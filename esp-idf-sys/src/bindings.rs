/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.0.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 0;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_USE_LONG_TIME_T: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const XCHAL_HAVE_BE: u32 = 0;
pub const XCHAL_HAVE_WINDOWED: u32 = 1;
pub const XCHAL_NUM_AREGS: u32 = 64;
pub const XCHAL_NUM_AREGS_LOG2: u32 = 6;
pub const XCHAL_MAX_INSTRUCTION_SIZE: u32 = 3;
pub const XCHAL_HAVE_DEBUG: u32 = 1;
pub const XCHAL_HAVE_DENSITY: u32 = 1;
pub const XCHAL_HAVE_LOOPS: u32 = 1;
pub const XCHAL_LOOP_BUFFER_SIZE: u32 = 256;
pub const XCHAL_HAVE_NSA: u32 = 1;
pub const XCHAL_HAVE_MINMAX: u32 = 1;
pub const XCHAL_HAVE_SEXT: u32 = 1;
pub const XCHAL_HAVE_DEPBITS: u32 = 0;
pub const XCHAL_HAVE_CLAMPS: u32 = 1;
pub const XCHAL_HAVE_MUL16: u32 = 1;
pub const XCHAL_HAVE_MUL32: u32 = 1;
pub const XCHAL_HAVE_MUL32_HIGH: u32 = 1;
pub const XCHAL_HAVE_DIV32: u32 = 1;
pub const XCHAL_HAVE_L32R: u32 = 1;
pub const XCHAL_HAVE_ABSOLUTE_LITERALS: u32 = 0;
pub const XCHAL_HAVE_CONST16: u32 = 0;
pub const XCHAL_HAVE_ADDX: u32 = 1;
pub const XCHAL_HAVE_WIDE_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_PREDICTED_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_CALL4AND12: u32 = 1;
pub const XCHAL_HAVE_ABS: u32 = 1;
pub const XCHAL_HAVE_RELEASE_SYNC: u32 = 1;
pub const XCHAL_HAVE_S32C1I: u32 = 1;
pub const XCHAL_HAVE_SPECULATION: u32 = 0;
pub const XCHAL_HAVE_FULL_RESET: u32 = 1;
pub const XCHAL_NUM_CONTEXTS: u32 = 1;
pub const XCHAL_NUM_MISC_REGS: u32 = 4;
pub const XCHAL_HAVE_TAP_MASTER: u32 = 0;
pub const XCHAL_HAVE_PRID: u32 = 1;
pub const XCHAL_HAVE_EXTERN_REGS: u32 = 1;
pub const XCHAL_HAVE_MX: u32 = 0;
pub const XCHAL_HAVE_MP_INTERRUPTS: u32 = 0;
pub const XCHAL_HAVE_MP_RUNSTALL: u32 = 0;
pub const XCHAL_HAVE_PSO: u32 = 0;
pub const XCHAL_HAVE_PSO_CDM: u32 = 0;
pub const XCHAL_HAVE_PSO_FULL_RETENTION: u32 = 0;
pub const XCHAL_HAVE_THREADPTR: u32 = 1;
pub const XCHAL_HAVE_BOOLEANS: u32 = 1;
pub const XCHAL_HAVE_CP: u32 = 1;
pub const XCHAL_CP_MAXCFG: u32 = 8;
pub const XCHAL_HAVE_MAC16: u32 = 1;
pub const XCHAL_HAVE_FUSION: u32 = 0;
pub const XCHAL_HAVE_FUSION_FP: u32 = 0;
pub const XCHAL_HAVE_FUSION_LOW_POWER: u32 = 0;
pub const XCHAL_HAVE_FUSION_AES: u32 = 0;
pub const XCHAL_HAVE_FUSION_CONVENC: u32 = 0;
pub const XCHAL_HAVE_FUSION_LFSR_CRC: u32 = 0;
pub const XCHAL_HAVE_FUSION_BITOPS: u32 = 0;
pub const XCHAL_HAVE_FUSION_AVS: u32 = 0;
pub const XCHAL_HAVE_FUSION_16BIT_BASEBAND: u32 = 0;
pub const XCHAL_HAVE_FUSION_VITERBI: u32 = 0;
pub const XCHAL_HAVE_FUSION_SOFTDEMAP: u32 = 0;
pub const XCHAL_HAVE_HIFIPRO: u32 = 0;
pub const XCHAL_HAVE_HIFI4: u32 = 0;
pub const XCHAL_HAVE_HIFI4_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI3: u32 = 0;
pub const XCHAL_HAVE_HIFI3_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI2: u32 = 0;
pub const XCHAL_HAVE_HIFI2EP: u32 = 0;
pub const XCHAL_HAVE_HIFI_MINI: u32 = 0;
pub const XCHAL_HAVE_VECTORFPU2005: u32 = 0;
pub const XCHAL_HAVE_USER_DPFPU: u32 = 0;
pub const XCHAL_HAVE_USER_SPFPU: u32 = 0;
pub const XCHAL_HAVE_FP: u32 = 1;
pub const XCHAL_HAVE_FP_DIV: u32 = 1;
pub const XCHAL_HAVE_FP_RECIP: u32 = 1;
pub const XCHAL_HAVE_FP_SQRT: u32 = 1;
pub const XCHAL_HAVE_FP_RSQRT: u32 = 1;
pub const XCHAL_HAVE_DFP: u32 = 0;
pub const XCHAL_HAVE_DFP_DIV: u32 = 0;
pub const XCHAL_HAVE_DFP_RECIP: u32 = 0;
pub const XCHAL_HAVE_DFP_SQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_RSQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_ACCEL: u32 = 1;
pub const XCHAL_HAVE_DFP_accel: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_ONLY: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_DOUBLE: u32 = 0;
pub const XCHAL_HAVE_VECTRA1: u32 = 0;
pub const XCHAL_HAVE_VECTRALX: u32 = 0;
pub const XCHAL_HAVE_PDX4: u32 = 0;
pub const XCHAL_HAVE_CONNXD2: u32 = 0;
pub const XCHAL_HAVE_CONNXD2_DUALLSFLIX: u32 = 0;
pub const XCHAL_HAVE_BBE16: u32 = 0;
pub const XCHAL_HAVE_BBE16_RSQRT: u32 = 0;
pub const XCHAL_HAVE_BBE16_VECDIV: u32 = 0;
pub const XCHAL_HAVE_BBE16_DESPREAD: u32 = 0;
pub const XCHAL_HAVE_BBENEP: u32 = 0;
pub const XCHAL_HAVE_BSP3: u32 = 0;
pub const XCHAL_HAVE_BSP3_TRANSPOSE: u32 = 0;
pub const XCHAL_HAVE_SSP16: u32 = 0;
pub const XCHAL_HAVE_SSP16_VITERBI: u32 = 0;
pub const XCHAL_HAVE_TURBO16: u32 = 0;
pub const XCHAL_HAVE_BBP16: u32 = 0;
pub const XCHAL_HAVE_FLIX3: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP_HISTOGRAM: u32 = 0;
pub const XCHAL_NUM_LOADSTORE_UNITS: u32 = 1;
pub const XCHAL_NUM_WRITEBUFFER_ENTRIES: u32 = 4;
pub const XCHAL_INST_FETCH_WIDTH: u32 = 4;
pub const XCHAL_DATA_WIDTH: u32 = 4;
pub const XCHAL_DATA_PIPE_DELAY: u32 = 2;
pub const XCHAL_CLOCK_GATING_GLOBAL: u32 = 1;
pub const XCHAL_CLOCK_GATING_FUNCUNIT: u32 = 1;
pub const XCHAL_UNALIGNED_LOAD_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_STORE_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_LOAD_HW: u32 = 1;
pub const XCHAL_UNALIGNED_STORE_HW: u32 = 1;
pub const XCHAL_SW_VERSION: u32 = 1100003;
pub const XCHAL_CORE_ID: &'static [u8; 17usize] = b"esp32_v3_49_prod\0";
pub const XCHAL_BUILD_UNIQUE_ID: u32 = 392854;
pub const XCHAL_HW_CONFIGID0: u32 = 3267166206;
pub const XCHAL_HW_CONFIGID1: u32 = 482737814;
pub const XCHAL_HW_VERSION_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_HW_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_VERSION: u32 = 260003;
pub const XCHAL_HW_REL_LX6: u32 = 1;
pub const XCHAL_HW_REL_LX6_0: u32 = 1;
pub const XCHAL_HW_REL_LX6_0_3: u32 = 1;
pub const XCHAL_HW_CONFIGID_RELIABLE: u32 = 1;
pub const XCHAL_HW_MIN_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MIN_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MIN_VERSION: u32 = 260003;
pub const XCHAL_HW_MAX_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MAX_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MAX_VERSION: u32 = 260003;
pub const XCHAL_ICACHE_LINESIZE: u32 = 4;
pub const XCHAL_DCACHE_LINESIZE: u32 = 4;
pub const XCHAL_ICACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_DCACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_ICACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_IS_WRITEBACK: u32 = 0;
pub const XCHAL_DCACHE_IS_COHERENT: u32 = 0;
pub const XCHAL_HAVE_PREFETCH: u32 = 0;
pub const XCHAL_HAVE_PREFETCH_L1: u32 = 0;
pub const XCHAL_PREFETCH_CASTOUT_LINES: u32 = 0;
pub const XCHAL_PREFETCH_ENTRIES: u32 = 0;
pub const XCHAL_PREFETCH_BLOCK_ENTRIES: u32 = 0;
pub const XCHAL_HAVE_CACHE_BLOCKOPS: u32 = 0;
pub const XCHAL_HAVE_ICACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_DCACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_ICACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_DCACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_PIF: u32 = 1;
pub const XCHAL_HAVE_AXI: u32 = 0;
pub const XCHAL_HAVE_PIF_WR_RESP: u32 = 0;
pub const XCHAL_HAVE_PIF_REQ_ATTR: u32 = 0;
pub const XCHAL_ICACHE_SETWIDTH: u32 = 0;
pub const XCHAL_DCACHE_SETWIDTH: u32 = 0;
pub const XCHAL_ICACHE_WAYS: u32 = 1;
pub const XCHAL_DCACHE_WAYS: u32 = 1;
pub const XCHAL_ICACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_DCACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_ICACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_DCACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_ICACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_BANKS: u32 = 0;
pub const XCHAL_CA_BITS: u32 = 4;
pub const XCHAL_NUM_INSTROM: u32 = 1;
pub const XCHAL_NUM_INSTRAM: u32 = 2;
pub const XCHAL_NUM_DATAROM: u32 = 1;
pub const XCHAL_NUM_DATARAM: u32 = 2;
pub const XCHAL_NUM_URAM: u32 = 0;
pub const XCHAL_NUM_XLMI: u32 = 1;
pub const XCHAL_INSTROM0_VADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_PADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_SIZE: u32 = 4194304;
pub const XCHAL_DATAROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_SIZE: u32 = 524288;
pub const XCHAL_DATARAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_SIZE: u32 = 4194304;
pub const XCHAL_DATARAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM1_BANKS: u32 = 1;
pub const XCHAL_XLMI0_VADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_PADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_SIZE: u32 = 524288;
pub const XCHAL_XLMI0_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_IMEM_LOADSTORE: u32 = 1;
pub const XCHAL_HAVE_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_HIGHPRI_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_NMI: u32 = 1;
pub const XCHAL_HAVE_CCOUNT: u32 = 1;
pub const XCHAL_NUM_TIMERS: u32 = 3;
pub const XCHAL_NUM_INTERRUPTS: u32 = 32;
pub const XCHAL_NUM_INTERRUPTS_LOG2: u32 = 5;
pub const XCHAL_NUM_EXTINTERRUPTS: u32 = 26;
pub const XCHAL_NUM_INTLEVELS: u32 = 6;
pub const XCHAL_EXCM_LEVEL: u32 = 3;
pub const XCHAL_INTLEVEL1_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_MASK: u32 = 3670016;
pub const XCHAL_INTLEVEL3_MASK: u32 = 683706368;
pub const XCHAL_INTLEVEL4_MASK: u32 = 1392508928;
pub const XCHAL_INTLEVEL5_MASK: u32 = 2214658048;
pub const XCHAL_INTLEVEL6_MASK: u32 = 0;
pub const XCHAL_INTLEVEL7_MASK: u32 = 16384;
pub const XCHAL_INTLEVEL1_ANDBELOW_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_ANDBELOW_MASK: u32 = 4077567;
pub const XCHAL_INTLEVEL3_ANDBELOW_MASK: u32 = 687783935;
pub const XCHAL_INTLEVEL4_ANDBELOW_MASK: u32 = 2080292863;
pub const XCHAL_INTLEVEL5_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL6_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL7_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INT0_LEVEL: u32 = 1;
pub const XCHAL_INT1_LEVEL: u32 = 1;
pub const XCHAL_INT2_LEVEL: u32 = 1;
pub const XCHAL_INT3_LEVEL: u32 = 1;
pub const XCHAL_INT4_LEVEL: u32 = 1;
pub const XCHAL_INT5_LEVEL: u32 = 1;
pub const XCHAL_INT6_LEVEL: u32 = 1;
pub const XCHAL_INT7_LEVEL: u32 = 1;
pub const XCHAL_INT8_LEVEL: u32 = 1;
pub const XCHAL_INT9_LEVEL: u32 = 1;
pub const XCHAL_INT10_LEVEL: u32 = 1;
pub const XCHAL_INT11_LEVEL: u32 = 3;
pub const XCHAL_INT12_LEVEL: u32 = 1;
pub const XCHAL_INT13_LEVEL: u32 = 1;
pub const XCHAL_INT14_LEVEL: u32 = 7;
pub const XCHAL_INT15_LEVEL: u32 = 3;
pub const XCHAL_INT16_LEVEL: u32 = 5;
pub const XCHAL_INT17_LEVEL: u32 = 1;
pub const XCHAL_INT18_LEVEL: u32 = 1;
pub const XCHAL_INT19_LEVEL: u32 = 2;
pub const XCHAL_INT20_LEVEL: u32 = 2;
pub const XCHAL_INT21_LEVEL: u32 = 2;
pub const XCHAL_INT22_LEVEL: u32 = 3;
pub const XCHAL_INT23_LEVEL: u32 = 3;
pub const XCHAL_INT24_LEVEL: u32 = 4;
pub const XCHAL_INT25_LEVEL: u32 = 4;
pub const XCHAL_INT26_LEVEL: u32 = 5;
pub const XCHAL_INT27_LEVEL: u32 = 3;
pub const XCHAL_INT28_LEVEL: u32 = 4;
pub const XCHAL_INT29_LEVEL: u32 = 3;
pub const XCHAL_INT30_LEVEL: u32 = 4;
pub const XCHAL_INT31_LEVEL: u32 = 5;
pub const XCHAL_DEBUGLEVEL: u32 = 6;
pub const XCHAL_HAVE_DEBUG_EXTERN_INT: u32 = 1;
pub const XCHAL_NMILEVEL: u32 = 7;
pub const XCHAL_INTTYPE_MASK_UNCONFIGURED: u32 = 0;
pub const XCHAL_INTTYPE_MASK_SOFTWARE: u32 = 536871040;
pub const XCHAL_INTTYPE_MASK_EXTERN_EDGE: u32 = 1346372608;
pub const XCHAL_INTTYPE_MASK_EXTERN_LEVEL: u32 = 2411606847;
pub const XCHAL_INTTYPE_MASK_TIMER: u32 = 98368;
pub const XCHAL_INTTYPE_MASK_NMI: u32 = 16384;
pub const XCHAL_INTTYPE_MASK_WRITE_ERROR: u32 = 0;
pub const XCHAL_INTTYPE_MASK_PROFILING: u32 = 2048;
pub const XCHAL_TIMER0_INTERRUPT: u32 = 6;
pub const XCHAL_TIMER1_INTERRUPT: u32 = 15;
pub const XCHAL_TIMER2_INTERRUPT: u32 = 16;
pub const XCHAL_NMI_INTERRUPT: u32 = 14;
pub const XCHAL_PROFILING_INTERRUPT: u32 = 11;
pub const XCHAL_INTLEVEL7_NUM: u32 = 14;
pub const XCHAL_EXTINT0_NUM: u32 = 0;
pub const XCHAL_EXTINT1_NUM: u32 = 1;
pub const XCHAL_EXTINT2_NUM: u32 = 2;
pub const XCHAL_EXTINT3_NUM: u32 = 3;
pub const XCHAL_EXTINT4_NUM: u32 = 4;
pub const XCHAL_EXTINT5_NUM: u32 = 5;
pub const XCHAL_EXTINT6_NUM: u32 = 8;
pub const XCHAL_EXTINT7_NUM: u32 = 9;
pub const XCHAL_EXTINT8_NUM: u32 = 10;
pub const XCHAL_EXTINT9_NUM: u32 = 12;
pub const XCHAL_EXTINT10_NUM: u32 = 13;
pub const XCHAL_EXTINT11_NUM: u32 = 14;
pub const XCHAL_EXTINT12_NUM: u32 = 17;
pub const XCHAL_EXTINT13_NUM: u32 = 18;
pub const XCHAL_EXTINT14_NUM: u32 = 19;
pub const XCHAL_EXTINT15_NUM: u32 = 20;
pub const XCHAL_EXTINT16_NUM: u32 = 21;
pub const XCHAL_EXTINT17_NUM: u32 = 22;
pub const XCHAL_EXTINT18_NUM: u32 = 23;
pub const XCHAL_EXTINT19_NUM: u32 = 24;
pub const XCHAL_EXTINT20_NUM: u32 = 25;
pub const XCHAL_EXTINT21_NUM: u32 = 26;
pub const XCHAL_EXTINT22_NUM: u32 = 27;
pub const XCHAL_EXTINT23_NUM: u32 = 28;
pub const XCHAL_EXTINT24_NUM: u32 = 30;
pub const XCHAL_EXTINT25_NUM: u32 = 31;
pub const XCHAL_INT0_EXTNUM: u32 = 0;
pub const XCHAL_INT1_EXTNUM: u32 = 1;
pub const XCHAL_INT2_EXTNUM: u32 = 2;
pub const XCHAL_INT3_EXTNUM: u32 = 3;
pub const XCHAL_INT4_EXTNUM: u32 = 4;
pub const XCHAL_INT5_EXTNUM: u32 = 5;
pub const XCHAL_INT8_EXTNUM: u32 = 6;
pub const XCHAL_INT9_EXTNUM: u32 = 7;
pub const XCHAL_INT10_EXTNUM: u32 = 8;
pub const XCHAL_INT12_EXTNUM: u32 = 9;
pub const XCHAL_INT13_EXTNUM: u32 = 10;
pub const XCHAL_INT14_EXTNUM: u32 = 11;
pub const XCHAL_INT17_EXTNUM: u32 = 12;
pub const XCHAL_INT18_EXTNUM: u32 = 13;
pub const XCHAL_INT19_EXTNUM: u32 = 14;
pub const XCHAL_INT20_EXTNUM: u32 = 15;
pub const XCHAL_INT21_EXTNUM: u32 = 16;
pub const XCHAL_INT22_EXTNUM: u32 = 17;
pub const XCHAL_INT23_EXTNUM: u32 = 18;
pub const XCHAL_INT24_EXTNUM: u32 = 19;
pub const XCHAL_INT25_EXTNUM: u32 = 20;
pub const XCHAL_INT26_EXTNUM: u32 = 21;
pub const XCHAL_INT27_EXTNUM: u32 = 22;
pub const XCHAL_INT28_EXTNUM: u32 = 23;
pub const XCHAL_INT30_EXTNUM: u32 = 24;
pub const XCHAL_INT31_EXTNUM: u32 = 25;
pub const XCHAL_XEA_VERSION: u32 = 2;
pub const XCHAL_HAVE_XEA1: u32 = 0;
pub const XCHAL_HAVE_XEA2: u32 = 1;
pub const XCHAL_HAVE_XEAX: u32 = 0;
pub const XCHAL_HAVE_EXCEPTIONS: u32 = 1;
pub const XCHAL_HAVE_HALT: u32 = 0;
pub const XCHAL_HAVE_BOOTLOADER: u32 = 0;
pub const XCHAL_HAVE_MEM_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_VECTOR_SELECT: u32 = 1;
pub const XCHAL_HAVE_VECBASE: u32 = 1;
pub const XCHAL_VECBASE_RESET_VADDR: u32 = 1073741824;
pub const XCHAL_VECBASE_RESET_PADDR: u32 = 1073741824;
pub const XCHAL_RESET_VECBASE_OVERLAP: u32 = 0;
pub const XCHAL_RESET_VECTOR0_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR0_PADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR1_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR1_PADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XCHAL_USER_VECOFS: u32 = 832;
pub const XCHAL_USER_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USER_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_KERNEL_VECOFS: u32 = 768;
pub const XCHAL_KERNEL_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNEL_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_DOUBLEEXC_VECOFS: u32 = 960;
pub const XCHAL_DOUBLEEXC_VECTOR_VADDR: u32 = 1073742784;
pub const XCHAL_DOUBLEEXC_VECTOR_PADDR: u32 = 1073742784;
pub const XCHAL_WINDOW_OF4_VECOFS: u32 = 0;
pub const XCHAL_WINDOW_UF4_VECOFS: u32 = 64;
pub const XCHAL_WINDOW_OF8_VECOFS: u32 = 128;
pub const XCHAL_WINDOW_UF8_VECOFS: u32 = 192;
pub const XCHAL_WINDOW_OF12_VECOFS: u32 = 256;
pub const XCHAL_WINDOW_UF12_VECOFS: u32 = 320;
pub const XCHAL_WINDOW_VECTORS_VADDR: u32 = 1073741824;
pub const XCHAL_WINDOW_VECTORS_PADDR: u32 = 1073741824;
pub const XCHAL_INTLEVEL2_VECOFS: u32 = 384;
pub const XCHAL_INTLEVEL2_VECTOR_VADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL2_VECTOR_PADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL3_VECOFS: u32 = 448;
pub const XCHAL_INTLEVEL3_VECTOR_VADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL3_VECTOR_PADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL4_VECOFS: u32 = 512;
pub const XCHAL_INTLEVEL4_VECTOR_VADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL4_VECTOR_PADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL5_VECOFS: u32 = 576;
pub const XCHAL_INTLEVEL5_VECTOR_VADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL5_VECTOR_PADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL6_VECOFS: u32 = 640;
pub const XCHAL_INTLEVEL6_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_INTLEVEL6_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECOFS: u32 = 640;
pub const XCHAL_DEBUG_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_NMI_VECOFS: u32 = 704;
pub const XCHAL_NMI_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_NMI_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECOFS: u32 = 704;
pub const XCHAL_INTLEVEL7_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_HAVE_DEBUG_ERI: u32 = 1;
pub const XCHAL_HAVE_DEBUG_APB: u32 = 1;
pub const XCHAL_HAVE_DEBUG_JTAG: u32 = 1;
pub const XCHAL_HAVE_OCD: u32 = 1;
pub const XCHAL_NUM_IBREAK: u32 = 2;
pub const XCHAL_NUM_DBREAK: u32 = 2;
pub const XCHAL_HAVE_OCD_DIR_ARRAY: u32 = 0;
pub const XCHAL_HAVE_OCD_LS32DDR: u32 = 1;
pub const XCHAL_HAVE_TRAX: u32 = 1;
pub const XCHAL_TRAX_MEM_SIZE: u32 = 16384;
pub const XCHAL_TRAX_MEM_SHAREABLE: u32 = 1;
pub const XCHAL_TRAX_ATB_WIDTH: u32 = 32;
pub const XCHAL_TRAX_TIME_WIDTH: u32 = 0;
pub const XCHAL_NUM_PERF_COUNTERS: u32 = 2;
pub const XCHAL_HAVE_TLBS: u32 = 1;
pub const XCHAL_HAVE_SPANNING_WAY: u32 = 1;
pub const XCHAL_SPANNING_WAY: u32 = 0;
pub const XCHAL_HAVE_IDENTITY_MAP: u32 = 1;
pub const XCHAL_HAVE_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_MIMIC_CACHEATTR: u32 = 1;
pub const XCHAL_HAVE_XLT_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_PTP_MMU: u32 = 0;
pub const XCHAL_MMU_ASID_BITS: u32 = 0;
pub const XCHAL_MMU_RINGS: u32 = 1;
pub const XCHAL_MMU_RING_BITS: u32 = 0;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_MB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &'static [u8; 4usize] = b"40m\0";
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &'static [u8; 4usize] = b"2MB\0";
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_EMAC_L2_TO_L3_RX_BUF_MODE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_BTDM_CONTROLLER_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_BT_RESERVE_DRAM: u32 = 0;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_ESP32_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_MB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_EMAC_TASK_PRIORITY: u32 = 20;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TCP_MSS: u32 = 1436;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_BLE_MAX_CONN_EFF: u32 = 0;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ULP_COPROC_RESERVE_MEM: u32 = 0;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_ESPTOOLPY_BAUD: u32 = 115200;
pub const CONFIG_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_ADC_CAL_LUT_ENABLE: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_MBEDTLS_RC4_DISABLED: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_RTC_CLOCK_SOURCE_INTERNAL_RC: u32 = 1;
pub const CONFIG_ESPTOOLPY_BAUD_115200B: u32 = 1;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_FOUR_UNIVERSAL_MAC_ADDRESS: u32 = 1;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_MAX_CONTENT_LEN: u32 = 16384;
pub const CONFIG_NUMBER_OF_UNIVERSAL_MAC_ADDRESS: u32 = 4;
pub const CONFIG_ESPTOOLPY_FLASHSIZE_DETECT: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MB_SERIAL_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &'static [u8; 4usize] = b"dio\0";
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &'static [u8; 14usize] = b"default_reset\0";
pub const CONFIG_ADC2_DISABLE_DAC: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION: u32 = 1;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_MAKE_WARN_UNDEFINED_VARIABLES: u32 = 1;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_MDNS_MAX_SERVICES: u32 = 10;
pub const CONFIG_EMAC_CHECK_LINK_PERIOD_MS: u32 = 2000;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_LIBSODIUM_USE_MBEDTLS_SHA: u32 = 1;
pub const CONFIG_DMA_RX_BUF_NUM: u32 = 10;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_SYNC_CONN_EFF: u32 = 0;
pub const CONFIG_PYTHON: &'static [u8; 7usize] = b"python\0";
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_ESP32_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESPTOOLPY_COMPRESSED: u32 = 1;
pub const CONFIG_PARTITION_TABLE_FILENAME: &'static [u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_MB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_1: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_MB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_EMAC_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_MB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_ESP32_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_DHE_RSA: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_TP_ENABLE: u32 = 1;
pub const CONFIG_FREERTOS_ASSERT_FAIL_ABORT: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ: u32 = 40;
pub const CONFIG_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_MBEDTLS_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_MB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_ESPTOOLPY_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_ACL_CONN_EFF: u32 = 0;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_ESPTOOLPY_AFTER: &'static [u8; 11usize] = b"hard_reset\0";
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_DMA_TX_BUF_NUM: u32 = 10;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_ESP32_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_ESP32_DEBUG_STUBS_ENABLE: u32 = 1;
pub const CONFIG_TCPIP_LWIP: u32 = 1;
pub const CONFIG_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_FREERTOS_CORETIMER_0: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &'static [u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_VREF_ENABLE: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_OPENSSL_ASSERT_DO_NOTHING: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_MB_TIMER_INDEX: u32 = 0;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_MB_TIMER_GROUP: u32 = 0;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_MB_TIMER_PORT_ENABLED: u32 = 1;
pub const CONFIG_MONITOR_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_ESPTOOLPY_PORT: &'static [u8; 13usize] = b"/dev/ttyUSB0\0";
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const ESP_IDF_VERSION_MAJOR: u32 = 4;
pub const ESP_IDF_VERSION_MINOR: u32 = 1;
pub const ESP_IDF_VERSION_PATCH: u32 = 0;
pub const TWO_UNIVERSAL_MAC_ADDR: u32 = 2;
pub const FOUR_UNIVERSAL_MAC_ADDR: u32 = 4;
pub const LOG_LOCAL_LEVEL: u32 = 3;
pub const LOG_COLOR_BLACK: &'static [u8; 3usize] = b"30\0";
pub const LOG_COLOR_RED: &'static [u8; 3usize] = b"31\0";
pub const LOG_COLOR_GREEN: &'static [u8; 3usize] = b"32\0";
pub const LOG_COLOR_BROWN: &'static [u8; 3usize] = b"33\0";
pub const LOG_COLOR_BLUE: &'static [u8; 3usize] = b"34\0";
pub const LOG_COLOR_PURPLE: &'static [u8; 3usize] = b"35\0";
pub const LOG_COLOR_CYAN: &'static [u8; 3usize] = b"36\0";
pub const LOG_RESET_COLOR: &'static [u8; 5usize] = b"\x1B[0m\0";
pub const portNUM_PROCESSORS: u32 = 2;
pub const XT_USE_THREAD_SAFE_CLIB: u32 = 0;
pub const configASSERT_2: u32 = 0;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const configUSE_MUTEX: u32 = 1;
pub const XT_TIMER_INDEX: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const XTHAL_RELEASE_MAJOR: u32 = 12000;
pub const XTHAL_RELEASE_MINOR: u32 = 9;
pub const XTHAL_RELEASE_NAME: &'static [u8; 7usize] = b"12.0.9\0";
pub const XTHAL_REL_12: u32 = 1;
pub const XTHAL_REL_12_0: u32 = 1;
pub const XTHAL_REL_12_0_9: u32 = 1;
pub const XTHAL_MAJOR_REV: u32 = 12000;
pub const XTHAL_MINOR_REV: u32 = 9;
pub const XTHAL_MAYBE: i32 = -1;
pub const XTHAL_MAX_CPS: u32 = 8;
pub const XTHAL_LITTLEENDIAN: u32 = 0;
pub const XTHAL_BIGENDIAN: u32 = 1;
pub const XTHAL_PREFETCH_ENABLE: i32 = -1;
pub const XTHAL_PREFETCH_DISABLE: u32 = 4294901760;
pub const XTHAL_DCACHE_PREFETCH_L1_OFF: u32 = 2415919104;
pub const XTHAL_DCACHE_PREFETCH_L1: u32 = 2415923200;
pub const XTHAL_ICACHE_PREFETCH_L1_OFF: u32 = 2684354560;
pub const XTHAL_ICACHE_PREFETCH_L1: u32 = 2684362752;
pub const XTHAL_DISASM_BUFSIZE: u32 = 80;
pub const XTHAL_DISASM_OPT_ADDR: u32 = 1;
pub const XTHAL_DISASM_OPT_OPHEX: u32 = 2;
pub const XTHAL_DISASM_OPT_OPCODE: u32 = 4;
pub const XTHAL_DISASM_OPT_PARMS: u32 = 8;
pub const XTHAL_DISASM_OPT_ALL: u32 = 4095;
pub const XTHAL_MAX_INTERRUPTS: u32 = 32;
pub const XTHAL_MAX_INTLEVELS: u32 = 16;
pub const XTHAL_MAX_TIMERS: u32 = 4;
pub const XTHAL_INTTYPE_UNCONFIGURED: u32 = 0;
pub const XTHAL_INTTYPE_SOFTWARE: u32 = 1;
pub const XTHAL_INTTYPE_EXTERN_EDGE: u32 = 2;
pub const XTHAL_INTTYPE_EXTERN_LEVEL: u32 = 3;
pub const XTHAL_INTTYPE_TIMER: u32 = 4;
pub const XTHAL_INTTYPE_NMI: u32 = 5;
pub const XTHAL_INTTYPE_WRITE_ERROR: u32 = 6;
pub const XTHAL_INTTYPE_PROFILING: u32 = 7;
pub const XTHAL_INTTYPE_IDMA_DONE: u32 = 8;
pub const XTHAL_INTTYPE_IDMA_ERR: u32 = 9;
pub const XTHAL_INTTYPE_GS_ERR: u32 = 10;
pub const XTHAL_INTTYPE_SG_ERR: u32 = 10;
pub const XTHAL_MAX_INTTYPES: u32 = 11;
pub const XTHAL_TIMER_UNCONFIGURED: i32 = -1;
pub const XTHAL_TIMER_UNASSIGNED: i32 = -1;
pub const XTHAL_MEMEP_PARITY: u32 = 1;
pub const XTHAL_MEMEP_ECC: u32 = 2;
pub const XTHAL_MEMEP_F_LOCAL: u32 = 0;
pub const XTHAL_MEMEP_F_DCACHE_DATA: u32 = 4;
pub const XTHAL_MEMEP_F_DCACHE_TAG: u32 = 5;
pub const XTHAL_MEMEP_F_ICACHE_DATA: u32 = 6;
pub const XTHAL_MEMEP_F_ICACHE_TAG: u32 = 7;
pub const XTHAL_MEMEP_F_CORRECTABLE: u32 = 16;
pub const XTHAL_AMB_EXCEPTION: u32 = 0;
pub const XTHAL_AMB_HITCACHE: u32 = 1;
pub const XTHAL_AMB_ALLOCATE: u32 = 2;
pub const XTHAL_AMB_WRITETHRU: u32 = 3;
pub const XTHAL_AMB_ISOLATE: u32 = 4;
pub const XTHAL_AMB_GUARD: u32 = 5;
pub const XTHAL_AMB_COHERENT: u32 = 6;
pub const XTHAL_AM_EXCEPTION: u32 = 1;
pub const XTHAL_AM_HITCACHE: u32 = 2;
pub const XTHAL_AM_ALLOCATE: u32 = 4;
pub const XTHAL_AM_WRITETHRU: u32 = 8;
pub const XTHAL_AM_ISOLATE: u32 = 16;
pub const XTHAL_AM_GUARD: u32 = 32;
pub const XTHAL_AM_COHERENT: u32 = 64;
pub const XTHAL_FAM_EXCEPTION: u32 = 1;
pub const XTHAL_FAM_BYPASS: u32 = 0;
pub const XTHAL_FAM_CACHED: u32 = 6;
pub const XTHAL_LAM_EXCEPTION: u32 = 1;
pub const XTHAL_LAM_ISOLATE: u32 = 18;
pub const XTHAL_LAM_BYPASS: u32 = 0;
pub const XTHAL_LAM_BYPASSG: u32 = 32;
pub const XTHAL_LAM_CACHED_NOALLOC: u32 = 2;
pub const XTHAL_LAM_NACACHED: u32 = 2;
pub const XTHAL_LAM_NACACHEDG: u32 = 34;
pub const XTHAL_LAM_CACHED: u32 = 6;
pub const XTHAL_LAM_COHCACHED: u32 = 70;
pub const XTHAL_SAM_EXCEPTION: u32 = 1;
pub const XTHAL_SAM_ISOLATE: u32 = 50;
pub const XTHAL_SAM_BYPASS: u32 = 40;
pub const XTHAL_SAM_WRITETHRU: u32 = 42;
pub const XTHAL_SAM_WRITEBACK: u32 = 38;
pub const XTHAL_SAM_WRITEBACK_NOALLOC: u32 = 34;
pub const XTHAL_SAM_COHWRITEBACK: u32 = 102;
pub const XTHAL_PAM_BYPASS: u32 = 0;
pub const XTHAL_PAM_BYPASS_BUF: u32 = 16;
pub const XTHAL_PAM_CACHED_NOALLOC: u32 = 48;
pub const XTHAL_PAM_WRITETHRU: u32 = 176;
pub const XTHAL_PAM_WRITEBACK_NOALLOC: u32 = 240;
pub const XTHAL_PAM_WRITEBACK: u32 = 496;
pub const XTHAL_CAFLAG_EXPAND: u32 = 256;
pub const XTHAL_CAFLAG_EXACT: u32 = 512;
pub const XTHAL_CAFLAG_NO_PARTIAL: u32 = 1024;
pub const XTHAL_CAFLAG_NO_AUTO_WB: u32 = 2048;
pub const XTHAL_CAFLAG_NO_AUTO_INV: u32 = 4096;
pub const XTHAL_SUCCESS: u32 = 0;
pub const XTHAL_NO_REGIONS_COVERED: i32 = -1;
pub const XTHAL_INEXACT: i32 = -2;
pub const XTHAL_INVALID_ADDRESS: i32 = -3;
pub const XTHAL_UNSUPPORTED: i32 = -4;
pub const XTHAL_ADDRESS_MISALIGNED: i32 = -5;
pub const XTHAL_NO_MAPPING: i32 = -6;
pub const XTHAL_BAD_ACCESS_RIGHTS: i32 = -7;
pub const XTHAL_BAD_MEMORY_TYPE: i32 = -8;
pub const XTHAL_MAP_NOT_ALIGNED: i32 = -9;
pub const XTHAL_OUT_OF_ENTRIES: i32 = -10;
pub const XTHAL_OUT_OF_ORDER_MAP: i32 = -11;
pub const XTHAL_INVALID: i32 = -12;
pub const XTHAL_ZERO_SIZED_REGION: i32 = -13;
pub const XTHAL_INVALID_ADDRESS_RANGE: i32 = -14;
pub const XCHAL_SUCCESS: u32 = 0;
pub const XCHAL_ADDRESS_MISALIGNED: i32 = -5;
pub const XCHAL_INEXACT: i32 = -2;
pub const XCHAL_INVALID_ADDRESS: i32 = -3;
pub const XCHAL_UNSUPPORTED_ON_THIS_ARCH: i32 = -4;
pub const XCHAL_NO_PAGES_MAPPED: i32 = -1;
pub const XTHAL_AR_NONE: u32 = 0;
pub const XTHAL_AR_R: u32 = 4;
pub const XTHAL_AR_RX: u32 = 5;
pub const XTHAL_AR_RW: u32 = 6;
pub const XTHAL_AR_RWX: u32 = 7;
pub const XTHAL_AR_Ww: u32 = 8;
pub const XTHAL_AR_RWrwx: u32 = 9;
pub const XTHAL_AR_RWr: u32 = 10;
pub const XTHAL_AR_RWXrx: u32 = 11;
pub const XTHAL_AR_Rr: u32 = 12;
pub const XTHAL_AR_RXrx: u32 = 13;
pub const XTHAL_AR_RWrw: u32 = 14;
pub const XTHAL_AR_RWXrwx: u32 = 15;
pub const XTHAL_AR_WIDTH: u32 = 4;
pub const XTHAL_MPU_USE_EXISTING_ACCESS_RIGHTS: u32 = 8192;
pub const XTHAL_MPU_USE_EXISTING_MEMORY_TYPE: u32 = 16384;
pub const XTHAL_MEM_DEVICE: u32 = 32768;
pub const XTHAL_MEM_NON_CACHEABLE: u32 = 589824;
pub const XTHAL_MEM_WRITETHRU_NOALLOC: u32 = 524288;
pub const XTHAL_MEM_WRITETHRU: u32 = 262144;
pub const XTHAL_MEM_WRITETHRU_WRITEALLOC: u32 = 393216;
pub const XTHAL_MEM_WRITEBACK_NOALLOC: u32 = 327680;
pub const XTHAL_MEM_WRITEBACK: u32 = 458752;
pub const XTHAL_MEM_INTERRUPTIBLE: u32 = 134217728;
pub const XTHAL_MEM_BUFFERABLE: u32 = 16777216;
pub const XTHAL_MEM_NON_SHAREABLE: u32 = 0;
pub const XTHAL_MEM_INNER_SHAREABLE: u32 = 33554432;
pub const XTHAL_MEM_OUTER_SHAREABLE: u32 = 67108864;
pub const XTHAL_MEM_SYSTEM_SHAREABLE: u32 = 100663296;
pub const _XTHAL_SYSTEM_CACHE_BITS: u32 = 983040;
pub const _XTHAL_LOCAL_CACHE_BITS: u32 = 15728640;
pub const _XTHAL_MEM_SYSTEM_RWC_MASK: u32 = 458752;
pub const _XTHAL_MEM_LOCAL_RWC_MASK: u32 = 7340032;
pub const _XTHAL_SHIFT_RWC: u32 = 16;
pub const XTHAL_MEM_NON_CACHED: u32 = 589824;
pub const XTHAL_MEM_NON_SHARED: u32 = 0;
pub const XTHAL_MEM_INNER_SHARED: u32 = 33554432;
pub const XTHAL_MEM_OUTER_SHARED: u32 = 67108864;
pub const XTHAL_MEM_SYSTEM_SHARED: u32 = 100663296;
pub const XTHAL_MEM_SW_SHAREABLE: u32 = 0;
pub const XTENSA_HWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_HWCIDSCHEME_T1020_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_0: u32 = 2;
pub const XTENSA_HWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_HWCIDSCHEME_T1020_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_1: u32 = 3;
pub const XTENSA_HWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2: u32 = 4;
pub const XTENSA_HWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2B: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2B: u32 = 5;
pub const XTENSA_HWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_HWCIDSCHEME_T1020_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_3: u32 = 6;
pub const XTENSA_HWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_HWCIDSCHEME_T1020_4: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_4: u32 = 7;
pub const XTENSA_HWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_HWCIDSCHEME_T1030_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_0: u32 = 9;
pub const XTENSA_HWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_HWCIDSCHEME_T1030_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_1: u32 = 10;
pub const XTENSA_HWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_HWCIDSCHEME_T1030_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_2: u32 = 11;
pub const XTENSA_HWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_HWCIDSCHEME_T1030_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_3: u32 = 12;
pub const XTENSA_HWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_HWCIDSCHEME_T1040_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_0: u32 = 15;
pub const XTENSA_HWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_1: u32 = 32;
pub const XTENSA_HWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1P: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_1P: u32 = 16;
pub const XTENSA_HWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_HWCIDSCHEME_T1040_2: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_2: u32 = 33;
pub const XTENSA_HWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_HWCIDSCHEME_T1040_3: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_3: u32 = 34;
pub const XTENSA_HWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_HWCIDSCHEME_T1050_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_0: u32 = 1;
pub const XTENSA_HWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_HWCIDSCHEME_T1050_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_1: u32 = 2;
pub const XTENSA_HWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_HWCIDSCHEME_T1050_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_2: u32 = 4;
pub const XTENSA_HWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_HWCIDSCHEME_T1050_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_3: u32 = 6;
pub const XTENSA_HWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_HWCIDSCHEME_T1050_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_4: u32 = 7;
pub const XTENSA_HWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_HWCIDSCHEME_T1050_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_5: u32 = 8;
pub const XTENSA_HWVERSION_RA_2004_1: u32 = 210000;
pub const XTENSA_HWCIDSCHEME_RA_2004_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2004_1: u32 = 3;
pub const XTENSA_HWVERSION_RA_2005_1: u32 = 210001;
pub const XTENSA_HWCIDSCHEME_RA_2005_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_1: u32 = 20;
pub const XTENSA_HWVERSION_RA_2005_2: u32 = 210002;
pub const XTENSA_HWCIDSCHEME_RA_2005_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_2: u32 = 21;
pub const XTENSA_HWVERSION_RA_2005_3: u32 = 210003;
pub const XTENSA_HWCIDSCHEME_RA_2005_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_3: u32 = 22;
pub const XTENSA_HWVERSION_RA_2006_4: u32 = 210004;
pub const XTENSA_HWCIDSCHEME_RA_2006_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_4: u32 = 23;
pub const XTENSA_HWVERSION_RA_2006_5: u32 = 210005;
pub const XTENSA_HWCIDSCHEME_RA_2006_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_5: u32 = 24;
pub const XTENSA_HWVERSION_RA_2006_6: u32 = 210006;
pub const XTENSA_HWCIDSCHEME_RA_2006_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_6: u32 = 25;
pub const XTENSA_HWVERSION_RA_2007_7: u32 = 210007;
pub const XTENSA_HWCIDSCHEME_RA_2007_7: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2007_7: u32 = 26;
pub const XTENSA_HWVERSION_RA_2008_8: u32 = 210008;
pub const XTENSA_HWCIDSCHEME_RA_2008_8: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2008_8: u32 = 27;
pub const XTENSA_HWVERSION_RB_2006_0: u32 = 220000;
pub const XTENSA_HWCIDSCHEME_RB_2006_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2006_0: u32 = 48;
pub const XTENSA_HWVERSION_RB_2007_1: u32 = 220001;
pub const XTENSA_HWCIDSCHEME_RB_2007_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_1: u32 = 49;
pub const XTENSA_HWVERSION_RB_2007_2: u32 = 221000;
pub const XTENSA_HWCIDSCHEME_RB_2007_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2: u32 = 52;
pub const XTENSA_HWVERSION_RB_2008_3: u32 = 221001;
pub const XTENSA_HWCIDSCHEME_RB_2008_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_3: u32 = 53;
pub const XTENSA_HWVERSION_RB_2008_4: u32 = 221002;
pub const XTENSA_HWCIDSCHEME_RB_2008_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_4: u32 = 54;
pub const XTENSA_HWVERSION_RB_2009_5: u32 = 221003;
pub const XTENSA_HWCIDSCHEME_RB_2009_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2009_5: u32 = 55;
pub const XTENSA_HWVERSION_RB_2007_2_MP: u32 = 221100;
pub const XTENSA_HWCIDSCHEME_RB_2007_2_MP: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2_MP: u32 = 64;
pub const XTENSA_HWVERSION_RC_2009_0: u32 = 230000;
pub const XTENSA_HWCIDSCHEME_RC_2009_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2009_0: u32 = 65;
pub const XTENSA_HWVERSION_RC_2010_1: u32 = 230001;
pub const XTENSA_HWCIDSCHEME_RC_2010_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_1: u32 = 66;
pub const XTENSA_HWVERSION_RC_2010_2: u32 = 230002;
pub const XTENSA_HWCIDSCHEME_RC_2010_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_2: u32 = 67;
pub const XTENSA_HWVERSION_RC_2011_3: u32 = 230003;
pub const XTENSA_HWCIDSCHEME_RC_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2011_3: u32 = 68;
pub const XTENSA_HWVERSION_RD_2010_0: u32 = 240000;
pub const XTENSA_HWCIDSCHEME_RD_2010_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2010_0: u32 = 80;
pub const XTENSA_HWVERSION_RD_2011_1: u32 = 240001;
pub const XTENSA_HWCIDSCHEME_RD_2011_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_1: u32 = 81;
pub const XTENSA_HWVERSION_RD_2011_2: u32 = 240002;
pub const XTENSA_HWCIDSCHEME_RD_2011_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_2: u32 = 82;
pub const XTENSA_HWVERSION_RD_2011_3: u32 = 240003;
pub const XTENSA_HWCIDSCHEME_RD_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_3: u32 = 83;
pub const XTENSA_HWVERSION_RD_2012_4: u32 = 240004;
pub const XTENSA_HWCIDSCHEME_RD_2012_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_4: u32 = 84;
pub const XTENSA_HWVERSION_RD_2012_5: u32 = 240005;
pub const XTENSA_HWCIDSCHEME_RD_2012_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_5: u32 = 85;
pub const XTENSA_HWVERSION_RE_2012_0: u32 = 250000;
pub const XTENSA_HWCIDSCHEME_RE_2012_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_0: u32 = 96;
pub const XTENSA_HWVERSION_RE_2012_1: u32 = 250001;
pub const XTENSA_HWCIDSCHEME_RE_2012_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_1: u32 = 97;
pub const XTENSA_HWVERSION_RE_2013_2: u32 = 250002;
pub const XTENSA_HWCIDSCHEME_RE_2013_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_2: u32 = 98;
pub const XTENSA_HWVERSION_RE_2013_3: u32 = 250003;
pub const XTENSA_HWCIDSCHEME_RE_2013_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_3: u32 = 99;
pub const XTENSA_HWVERSION_RE_2013_4: u32 = 250004;
pub const XTENSA_HWCIDSCHEME_RE_2013_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_4: u32 = 100;
pub const XTENSA_HWVERSION_RE_2014_5: u32 = 250005;
pub const XTENSA_HWCIDSCHEME_RE_2014_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2014_5: u32 = 101;
pub const XTENSA_HWVERSION_RE_2015_6: u32 = 250006;
pub const XTENSA_HWCIDSCHEME_RE_2015_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2015_6: u32 = 102;
pub const XTENSA_HWVERSION_RF_2014_0: u32 = 260000;
pub const XTENSA_HWCIDSCHEME_RF_2014_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_0: u32 = 112;
pub const XTENSA_HWVERSION_RF_2014_1: u32 = 260001;
pub const XTENSA_HWCIDSCHEME_RF_2014_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_1: u32 = 113;
pub const XTENSA_HWVERSION_RF_2015_2: u32 = 260002;
pub const XTENSA_HWCIDSCHEME_RF_2015_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_2: u32 = 114;
pub const XTENSA_HWVERSION_RF_2015_3: u32 = 260003;
pub const XTENSA_HWCIDSCHEME_RF_2015_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_3: u32 = 115;
pub const XTENSA_HWVERSION_RF_2016_4: u32 = 260004;
pub const XTENSA_HWCIDSCHEME_RF_2016_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2016_4: u32 = 116;
pub const XTENSA_HWVERSION_RG_2015_0: u32 = 270000;
pub const XTENSA_HWCIDSCHEME_RG_2015_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_0: u32 = 128;
pub const XTENSA_HWVERSION_RG_2015_1: u32 = 270001;
pub const XTENSA_HWCIDSCHEME_RG_2015_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_1: u32 = 129;
pub const XTENSA_HWVERSION_RG_2015_2: u32 = 270002;
pub const XTENSA_HWCIDSCHEME_RG_2015_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_2: u32 = 130;
pub const XTENSA_HWVERSION_RG_2016_3: u32 = 270003;
pub const XTENSA_HWCIDSCHEME_RG_2016_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2016_3: u32 = 131;
pub const XTENSA_HWVERSION_RG_2016_4: u32 = 270004;
pub const XTENSA_HWCIDSCHEME_RG_2016_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2016_4: u32 = 132;
pub const XTENSA_HWVERSION_RG_2017_5: u32 = 270005;
pub const XTENSA_HWCIDSCHEME_RG_2017_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_5: u32 = 133;
pub const XTENSA_HWVERSION_RG_2017_6: u32 = 270006;
pub const XTENSA_HWCIDSCHEME_RG_2017_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_6: u32 = 134;
pub const XTENSA_HWVERSION_RG_2017_7: u32 = 270007;
pub const XTENSA_HWCIDSCHEME_RG_2017_7: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_7: u32 = 135;
pub const XTENSA_HWVERSION_RG_2017_8: u32 = 270008;
pub const XTENSA_HWCIDSCHEME_RG_2017_8: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_8: u32 = 136;
pub const XTENSA_HWVERSION_RG_2018_9: u32 = 270009;
pub const XTENSA_HWCIDSCHEME_RG_2018_9: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2018_9: u32 = 137;
pub const XTENSA_HWVERSION_RH_2016_0: u32 = 280000;
pub const XTENSA_HWCIDSCHEME_RH_2016_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RH_2016_0: u32 = 144;
pub const XTENSA_SWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_SWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_SWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_SWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_SWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_SWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_SWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_SWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_SWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_SWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_SWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_SWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_SWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_SWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_SWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_SWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_SWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_SWVERSION_RA_2004_1: u32 = 600000;
pub const XTENSA_SWVERSION_RA_2005_1: u32 = 600001;
pub const XTENSA_SWVERSION_RA_2005_2: u32 = 600002;
pub const XTENSA_SWVERSION_RA_2005_3: u32 = 600003;
pub const XTENSA_SWVERSION_RA_2006_4: u32 = 600004;
pub const XTENSA_SWVERSION_RA_2006_5: u32 = 600005;
pub const XTENSA_SWVERSION_RA_2006_6: u32 = 600006;
pub const XTENSA_SWVERSION_RA_2007_7: u32 = 600007;
pub const XTENSA_SWVERSION_RA_2008_8: u32 = 600008;
pub const XTENSA_SWVERSION_RB_2006_0: u32 = 700000;
pub const XTENSA_SWVERSION_RB_2007_1: u32 = 700001;
pub const XTENSA_SWVERSION_RB_2007_2: u32 = 701000;
pub const XTENSA_SWVERSION_RB_2008_3: u32 = 701001;
pub const XTENSA_SWVERSION_RB_2008_4: u32 = 701002;
pub const XTENSA_SWVERSION_RB_2009_5: u32 = 701003;
pub const XTENSA_SWVERSION_RB_2007_2_MP: u32 = 701100;
pub const XTENSA_SWVERSION_RC_2009_0: u32 = 800000;
pub const XTENSA_SWVERSION_RC_2010_1: u32 = 800001;
pub const XTENSA_SWVERSION_RC_2010_2: u32 = 800002;
pub const XTENSA_SWVERSION_RC_2011_3: u32 = 800003;
pub const XTENSA_SWVERSION_RD_2010_0: u32 = 900000;
pub const XTENSA_SWVERSION_RD_2011_1: u32 = 900001;
pub const XTENSA_SWVERSION_RD_2011_2: u32 = 900002;
pub const XTENSA_SWVERSION_RD_2011_3: u32 = 900003;
pub const XTENSA_SWVERSION_RD_2012_4: u32 = 900004;
pub const XTENSA_SWVERSION_RD_2012_5: u32 = 900005;
pub const XTENSA_SWVERSION_RE_2012_0: u32 = 1000000;
pub const XTENSA_SWVERSION_RE_2012_1: u32 = 1000001;
pub const XTENSA_SWVERSION_RE_2013_2: u32 = 1000002;
pub const XTENSA_SWVERSION_RE_2013_3: u32 = 1000003;
pub const XTENSA_SWVERSION_RE_2013_4: u32 = 1000004;
pub const XTENSA_SWVERSION_RE_2014_5: u32 = 1000005;
pub const XTENSA_SWVERSION_RE_2015_6: u32 = 1000006;
pub const XTENSA_SWVERSION_RF_2014_0: u32 = 1100000;
pub const XTENSA_SWVERSION_RF_2014_1: u32 = 1100001;
pub const XTENSA_SWVERSION_RF_2015_2: u32 = 1100002;
pub const XTENSA_SWVERSION_RF_2015_3: u32 = 1100003;
pub const XTENSA_SWVERSION_RF_2016_4: u32 = 1100004;
pub const XTENSA_SWVERSION_RG_2015_0: u32 = 1200000;
pub const XTENSA_SWVERSION_RG_2015_1: u32 = 1200001;
pub const XTENSA_SWVERSION_RG_2015_2: u32 = 1200002;
pub const XTENSA_SWVERSION_RG_2016_3: u32 = 1200003;
pub const XTENSA_SWVERSION_RG_2016_4: u32 = 1200004;
pub const XTENSA_SWVERSION_RG_2017_5: u32 = 1200005;
pub const XTENSA_SWVERSION_RG_2017_6: u32 = 1200006;
pub const XTENSA_SWVERSION_RG_2017_7: u32 = 1200007;
pub const XTENSA_SWVERSION_RG_2017_8: u32 = 1200008;
pub const XTENSA_SWVERSION_RG_2018_9: u32 = 1200009;
pub const XTENSA_SWVERSION_RH_2016_0: u32 = 1300000;
pub const XTENSA_SWVERSION_T1040_1_PREHOTFIX: u32 = 104001;
pub const XTENSA_SWVERSION_6_0_0: u32 = 600000;
pub const XTENSA_SWVERSION_6_0_1: u32 = 600001;
pub const XTENSA_SWVERSION_6_0_2: u32 = 600002;
pub const XTENSA_SWVERSION_6_0_3: u32 = 600003;
pub const XTENSA_SWVERSION_6_0_4: u32 = 600004;
pub const XTENSA_SWVERSION_6_0_5: u32 = 600005;
pub const XTENSA_SWVERSION_6_0_6: u32 = 600006;
pub const XTENSA_SWVERSION_6_0_7: u32 = 600007;
pub const XTENSA_SWVERSION_6_0_8: u32 = 600008;
pub const XTENSA_SWVERSION_7_0_0: u32 = 700000;
pub const XTENSA_SWVERSION_7_0_1: u32 = 700001;
pub const XTENSA_SWVERSION_7_1_0: u32 = 701000;
pub const XTENSA_SWVERSION_7_1_1: u32 = 701001;
pub const XTENSA_SWVERSION_7_1_2: u32 = 701002;
pub const XTENSA_SWVERSION_7_1_3: u32 = 701003;
pub const XTENSA_SWVERSION_7_1_8_MP: u32 = 701100;
pub const XTENSA_SWVERSION_8_0_0: u32 = 800000;
pub const XTENSA_SWVERSION_8_0_1: u32 = 800001;
pub const XTENSA_SWVERSION_8_0_2: u32 = 800002;
pub const XTENSA_SWVERSION_8_0_3: u32 = 800003;
pub const XTENSA_SWVERSION_9_0_0: u32 = 900000;
pub const XTENSA_SWVERSION_9_0_1: u32 = 900001;
pub const XTENSA_SWVERSION_9_0_2: u32 = 900002;
pub const XTENSA_SWVERSION_9_0_3: u32 = 900003;
pub const XTENSA_SWVERSION_9_0_4: u32 = 900004;
pub const XTENSA_SWVERSION_9_0_5: u32 = 900005;
pub const XTENSA_SWVERSION_10_0_0: u32 = 1000000;
pub const XTENSA_SWVERSION_10_0_1: u32 = 1000001;
pub const XTENSA_SWVERSION_10_0_2: u32 = 1000002;
pub const XTENSA_SWVERSION_10_0_3: u32 = 1000003;
pub const XTENSA_SWVERSION_10_0_4: u32 = 1000004;
pub const XTENSA_SWVERSION_10_0_5: u32 = 1000005;
pub const XTENSA_SWVERSION_10_0_6: u32 = 1000006;
pub const XTENSA_SWVERSION_11_0_0: u32 = 1100000;
pub const XTENSA_SWVERSION_11_0_1: u32 = 1100001;
pub const XTENSA_SWVERSION_11_0_2: u32 = 1100002;
pub const XTENSA_SWVERSION_11_0_3: u32 = 1100003;
pub const XTENSA_SWVERSION_11_0_4: u32 = 1100004;
pub const XTENSA_SWVERSION_12_0_0: u32 = 1200000;
pub const XTENSA_SWVERSION_12_0_1: u32 = 1200001;
pub const XTENSA_SWVERSION_12_0_2: u32 = 1200002;
pub const XTENSA_SWVERSION_12_0_3: u32 = 1200003;
pub const XTENSA_SWVERSION_12_0_4: u32 = 1200004;
pub const XTENSA_SWVERSION_12_0_5: u32 = 1200005;
pub const XTENSA_SWVERSION_12_0_6: u32 = 1200006;
pub const XTENSA_SWVERSION_12_0_7: u32 = 1200007;
pub const XTENSA_SWVERSION_12_0_8: u32 = 1200008;
pub const XTENSA_SWVERSION_12_0_9: u32 = 1200009;
pub const XTENSA_SWVERSION_13_0_0: u32 = 1300000;
pub const XTENSA_RELEASE_NAME: &'static [u8; 10usize] = b"RG-2018.9\0";
pub const XTENSA_RELEASE_CANONICAL_NAME: &'static [u8; 10usize] = b"RG-2018.9\0";
pub const XTENSA_SWVERSION: u32 = 1200009;
pub const XTENSA_SWVERSION_NAME: &'static [u8; 7usize] = b"12.0.9\0";
pub const XTENSA_SWVERSION_CANONICAL_NAME: &'static [u8; 7usize] = b"12.0.9\0";
pub const XTENSA_SWVERSION_MAJORMID_NAME: &'static [u8; 5usize] = b"12.0\0";
pub const XTENSA_SWVERSION_MAJOR_NAME: &'static [u8; 3usize] = b"12\0";
pub const XTENSA_SWVERSION_LICENSE_NAME: &'static [u8; 5usize] = b"12.0\0";
pub const XCHAL_CA_BYPASS: u32 = 2;
pub const XCHAL_CA_BYPASSBUF: u32 = 6;
pub const XCHAL_CA_WRITETHRU: u32 = 2;
pub const XCHAL_CA_WRITEBACK: u32 = 2;
pub const XCHAL_HAVE_CA_WRITEBACK_NOALLOC: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC: u32 = 2;
pub const XCHAL_CA_BYPASS_RW: u32 = 0;
pub const XCHAL_CA_WRITETHRU_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC_RW: u32 = 0;
pub const XCHAL_CA_ILLEGAL: u32 = 15;
pub const XCHAL_CA_ISOLATE: u32 = 0;
pub const XCHAL_MMU_ASID_INVALID: u32 = 0;
pub const XCHAL_MMU_ASID_KERNEL: u32 = 0;
pub const XCHAL_MMU_SR_BITS: u32 = 0;
pub const XCHAL_MMU_CA_BITS: u32 = 4;
pub const XCHAL_MMU_MAX_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_MMU_MIN_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_ITLB_WAY_BITS: u32 = 0;
pub const XCHAL_ITLB_WAYS: u32 = 1;
pub const XCHAL_ITLB_ARF_WAYS: u32 = 0;
pub const XCHAL_ITLB_SETS: u32 = 1;
pub const XCHAL_ITLB_WAY0_SET: u32 = 0;
pub const XCHAL_ITLB_ARF_SETS: u32 = 0;
pub const XCHAL_ITLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_ITLB_SET0_WAY: u32 = 0;
pub const XCHAL_ITLB_SET0_WAYS: u32 = 1;
pub const XCHAL_ITLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_ITLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_ITLB_SET0_ARF: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_ITLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_ITLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_ITLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_WAY_BITS: u32 = 0;
pub const XCHAL_DTLB_WAYS: u32 = 1;
pub const XCHAL_DTLB_ARF_WAYS: u32 = 0;
pub const XCHAL_DTLB_SETS: u32 = 1;
pub const XCHAL_DTLB_WAY0_SET: u32 = 0;
pub const XCHAL_DTLB_ARF_SETS: u32 = 0;
pub const XCHAL_DTLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_DTLB_SET0_WAY: u32 = 0;
pub const XCHAL_DTLB_SET0_WAYS: u32 = 1;
pub const XCHAL_DTLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_DTLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_DTLB_SET0_ARF: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_DTLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_DTLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_DTLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_CP_NUM: u32 = 1;
pub const XCHAL_CP_MAX: u32 = 1;
pub const XCHAL_CP_MASK: u32 = 1;
pub const XCHAL_CP_PORT_MASK: u32 = 0;
pub const XCHAL_CP0_NAME: &'static [u8; 4usize] = b"FPU\0";
pub const XCHAL_CP0_SA_SIZE: u32 = 72;
pub const XCHAL_CP0_SA_ALIGN: u32 = 4;
pub const XCHAL_CP_ID_FPU: u32 = 0;
pub const XCHAL_CP1_SA_SIZE: u32 = 0;
pub const XCHAL_CP1_SA_ALIGN: u32 = 1;
pub const XCHAL_CP2_SA_SIZE: u32 = 0;
pub const XCHAL_CP2_SA_ALIGN: u32 = 1;
pub const XCHAL_CP3_SA_SIZE: u32 = 0;
pub const XCHAL_CP3_SA_ALIGN: u32 = 1;
pub const XCHAL_CP4_SA_SIZE: u32 = 0;
pub const XCHAL_CP4_SA_ALIGN: u32 = 1;
pub const XCHAL_CP5_SA_SIZE: u32 = 0;
pub const XCHAL_CP5_SA_ALIGN: u32 = 1;
pub const XCHAL_CP6_SA_SIZE: u32 = 0;
pub const XCHAL_CP6_SA_ALIGN: u32 = 1;
pub const XCHAL_CP7_SA_SIZE: u32 = 0;
pub const XCHAL_CP7_SA_ALIGN: u32 = 1;
pub const XCHAL_NCP_SA_SIZE: u32 = 48;
pub const XCHAL_NCP_SA_ALIGN: u32 = 4;
pub const XCHAL_TOTAL_SA_SIZE: u32 = 128;
pub const XCHAL_TOTAL_SA_ALIGN: u32 = 4;
pub const XCHAL_NCP_SA_NUM: u32 = 12;
pub const XCHAL_CP0_SA_NUM: u32 = 18;
pub const XCHAL_CP1_SA_NUM: u32 = 0;
pub const XCHAL_CP2_SA_NUM: u32 = 0;
pub const XCHAL_CP3_SA_NUM: u32 = 0;
pub const XCHAL_CP4_SA_NUM: u32 = 0;
pub const XCHAL_CP5_SA_NUM: u32 = 0;
pub const XCHAL_CP6_SA_NUM: u32 = 0;
pub const XCHAL_CP7_SA_NUM: u32 = 0;
pub const XCHAL_HAVE_LE: u32 = 1;
pub const XCHAL_MEMORY_ORDER: u32 = 0;
pub const XCHAL_HAVE_HIGHLEVEL_INTERRUPTS: u32 = 1;
pub const XCHAL_NUM_LOWPRI_LEVELS: u32 = 1;
pub const XCHAL_FIRST_HIGHPRI_LEVEL: u32 = 2;
pub const XCHAL_INTLEVEL0_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_MASK: u32 = 0;
pub const XCHAL_INTLEVEL9_MASK: u32 = 0;
pub const XCHAL_INTLEVEL10_MASK: u32 = 0;
pub const XCHAL_INTLEVEL11_MASK: u32 = 0;
pub const XCHAL_INTLEVEL12_MASK: u32 = 0;
pub const XCHAL_INTLEVEL13_MASK: u32 = 0;
pub const XCHAL_INTLEVEL14_MASK: u32 = 0;
pub const XCHAL_INTLEVEL15_MASK: u32 = 0;
pub const XCHAL_INTLEVEL0_ANDBELOW_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL9_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL10_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL11_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL12_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL13_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL14_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL15_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_LOWPRI_MASK: u32 = 407551;
pub const XCHAL_INTCLEARABLE_MASK: u32 = 1883243648;
pub const XCHAL_INTSETTABLE_MASK: u32 = 536871040;
pub const XCHAL_EXTINT0_MASK: u32 = 1;
pub const XCHAL_EXTINT1_MASK: u32 = 2;
pub const XCHAL_EXTINT2_MASK: u32 = 4;
pub const XCHAL_EXTINT3_MASK: u32 = 8;
pub const XCHAL_EXTINT4_MASK: u32 = 16;
pub const XCHAL_EXTINT5_MASK: u32 = 32;
pub const XCHAL_EXTINT6_MASK: u32 = 256;
pub const XCHAL_EXTINT7_MASK: u32 = 512;
pub const XCHAL_EXTINT8_MASK: u32 = 1024;
pub const XCHAL_EXTINT9_MASK: u32 = 4096;
pub const XCHAL_EXTINT10_MASK: u32 = 8192;
pub const XCHAL_EXTINT11_MASK: u32 = 16384;
pub const XCHAL_EXTINT12_MASK: u32 = 131072;
pub const XCHAL_EXTINT13_MASK: u32 = 262144;
pub const XCHAL_EXTINT14_MASK: u32 = 524288;
pub const XCHAL_EXTINT15_MASK: u32 = 1048576;
pub const XCHAL_EXTINT16_MASK: u32 = 2097152;
pub const XCHAL_EXTINT17_MASK: u32 = 4194304;
pub const XCHAL_EXTINT18_MASK: u32 = 8388608;
pub const XCHAL_EXTINT19_MASK: u32 = 16777216;
pub const XCHAL_EXTINT20_MASK: u32 = 33554432;
pub const XCHAL_EXTINT21_MASK: u32 = 67108864;
pub const XCHAL_EXTINT22_MASK: u32 = 134217728;
pub const XCHAL_EXTINT23_MASK: u32 = 268435456;
pub const XCHAL_EXTINT24_MASK: u32 = 1073741824;
pub const XCHAL_EXTINT25_MASK: u32 = 2147483648;
pub const XCHAL_HAVE_OLD_EXC_ARCH: u32 = 0;
pub const XCHAL_HAVE_EXCM: u32 = 1;
pub const XCHAL_PROGRAMEXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_PROGRAMEXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_STACKEDEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_STACKEDEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION: u32 = 0;
pub const XCHAL_EXCCAUSE_SYSTEM_CALL: u32 = 1;
pub const XCHAL_EXCCAUSE_INSTRUCTION_FETCH_ERROR: u32 = 2;
pub const XCHAL_EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const XCHAL_EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const XCHAL_EXCCAUSE_ALLOCA: u32 = 5;
pub const XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO: u32 = 6;
pub const XCHAL_EXCCAUSE_SPECULATION: u32 = 7;
pub const XCHAL_EXCCAUSE_PRIVILEGED: u32 = 8;
pub const XCHAL_EXCCAUSE_UNALIGNED: u32 = 9;
pub const XCHAL_EXCCAUSE_ITLB_MISS: u32 = 16;
pub const XCHAL_EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const XCHAL_EXCCAUSE_ITLB_PRIVILEGE: u32 = 18;
pub const XCHAL_EXCCAUSE_ITLB_SIZE_RESTRICTION: u32 = 19;
pub const XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE: u32 = 20;
pub const XCHAL_EXCCAUSE_DTLB_MISS: u32 = 24;
pub const XCHAL_EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const XCHAL_EXCCAUSE_DTLB_PRIVILEGE: u32 = 26;
pub const XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION: u32 = 27;
pub const XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE: u32 = 28;
pub const XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE: u32 = 29;
pub const XCHAL_EXCCAUSE_COPROCESSOR0_DISABLED: u32 = 32;
pub const XCHAL_EXCCAUSE_COPROCESSOR1_DISABLED: u32 = 33;
pub const XCHAL_EXCCAUSE_COPROCESSOR2_DISABLED: u32 = 34;
pub const XCHAL_EXCCAUSE_COPROCESSOR3_DISABLED: u32 = 35;
pub const XCHAL_EXCCAUSE_COPROCESSOR4_DISABLED: u32 = 36;
pub const XCHAL_EXCCAUSE_COPROCESSOR5_DISABLED: u32 = 37;
pub const XCHAL_EXCCAUSE_COPROCESSOR6_DISABLED: u32 = 38;
pub const XCHAL_EXCCAUSE_COPROCESSOR7_DISABLED: u32 = 39;
pub const XCHAL_DBREAKC_VALIDMASK: u32 = 3221225535;
pub const XCHAL_DBREAKC_MASK_BITS: u32 = 6;
pub const XCHAL_DBREAKC_MASK_NUM: u32 = 64;
pub const XCHAL_DBREAKC_MASK_SHIFT: u32 = 0;
pub const XCHAL_DBREAKC_MASK_MASK: u32 = 63;
pub const XCHAL_DBREAKC_LOADBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_LOADBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const XCHAL_DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const XCHAL_DBREAKC_STOREBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_STOREBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const XCHAL_DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const XCHAL_PS_VALIDMASK: u32 = 462655;
pub const XCHAL_PS_INTLEVEL_BITS: u32 = 4;
pub const XCHAL_PS_INTLEVEL_NUM: u32 = 16;
pub const XCHAL_PS_INTLEVEL_SHIFT: u32 = 0;
pub const XCHAL_PS_INTLEVEL_MASK: u32 = 15;
pub const XCHAL_PS_EXCM_BITS: u32 = 1;
pub const XCHAL_PS_EXCM_NUM: u32 = 2;
pub const XCHAL_PS_EXCM_SHIFT: u32 = 4;
pub const XCHAL_PS_EXCM_MASK: u32 = 16;
pub const XCHAL_PS_UM_BITS: u32 = 1;
pub const XCHAL_PS_UM_NUM: u32 = 2;
pub const XCHAL_PS_UM_SHIFT: u32 = 5;
pub const XCHAL_PS_UM_MASK: u32 = 32;
pub const XCHAL_PS_RING_BITS: u32 = 2;
pub const XCHAL_PS_RING_NUM: u32 = 4;
pub const XCHAL_PS_RING_SHIFT: u32 = 6;
pub const XCHAL_PS_RING_MASK: u32 = 192;
pub const XCHAL_PS_OWB_BITS: u32 = 4;
pub const XCHAL_PS_OWB_NUM: u32 = 16;
pub const XCHAL_PS_OWB_SHIFT: u32 = 8;
pub const XCHAL_PS_OWB_MASK: u32 = 3840;
pub const XCHAL_PS_CALLINC_BITS: u32 = 2;
pub const XCHAL_PS_CALLINC_NUM: u32 = 4;
pub const XCHAL_PS_CALLINC_SHIFT: u32 = 16;
pub const XCHAL_PS_CALLINC_MASK: u32 = 196608;
pub const XCHAL_PS_WOE_BITS: u32 = 1;
pub const XCHAL_PS_WOE_NUM: u32 = 2;
pub const XCHAL_PS_WOE_SHIFT: u32 = 18;
pub const XCHAL_PS_WOE_MASK: u32 = 262144;
pub const XCHAL_EXCCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_EXCCAUSE_BITS: u32 = 6;
pub const XCHAL_EXCCAUSE_NUM: u32 = 64;
pub const XCHAL_EXCCAUSE_SHIFT: u32 = 0;
pub const XCHAL_EXCCAUSE_MASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_ICOUNT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_ICOUNT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const XCHAL_DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const XCHAL_DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const XCHAL_DEBUGCAUSE_BREAKN_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAKN_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const XCHAL_NUM_IROM: u32 = 1;
pub const XCHAL_NUM_IRAM: u32 = 2;
pub const XCHAL_NUM_DROM: u32 = 1;
pub const XCHAL_NUM_DRAM: u32 = 2;
pub const XCHAL_IROM0_VADDR: u32 = 1082130432;
pub const XCHAL_IROM0_PADDR: u32 = 1082130432;
pub const XCHAL_IROM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_SIZE: u32 = 4194304;
pub const XCHAL_DROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DROM0_SIZE: u32 = 4194304;
pub const XCHAL_DRAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_SIZE: u32 = 524288;
pub const XCHAL_DRAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_SIZE: u32 = 4194304;
pub const XCHAL_CACHE_PREFCTL_DEFAULT: u32 = 4164;
pub const XCHAL_CACHE_LINEWIDTH_MAX: u32 = 2;
pub const XCHAL_CACHE_LINESIZE_MAX: u32 = 4;
pub const XCHAL_ICACHE_SETSIZE: u32 = 1;
pub const XCHAL_DCACHE_SETSIZE: u32 = 1;
pub const XCHAL_CACHE_SETWIDTH_MAX: u32 = 0;
pub const XCHAL_CACHE_SETSIZE_MAX: u32 = 1;
pub const XCHAL_ICACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_V: u32 = 1;
pub const XCHAL_ICACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_F: u32 = 0;
pub const XCHAL_ICACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_L: u32 = 0;
pub const XCHAL_DCACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_V: u32 = 1;
pub const XCHAL_DCACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_F: u32 = 0;
pub const XCHAL_DCACHE_TAG_D_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_D: u32 = 0;
pub const XCHAL_DCACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_L: u32 = 0;
pub const XCHAL_CACHE_MEMCTL_DEFAULT: u32 = 0;
pub const _MEMCTL_SNOOP_EN: u32 = 0;
pub const _MEMCTL_L0IBUF_EN: u32 = 1;
pub const XCHAL_SNOOP_LB_MEMCTL_DEFAULT: u32 = 1;
pub const XCHAL_ALIGN_MAX: u32 = 4;
pub const XCHAL_HW_RELEASE_MAJOR: u32 = 2600;
pub const XCHAL_HW_RELEASE_MINOR: u32 = 3;
pub const XCHAL_HW_RELEASE_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_EXTRA_SA_SIZE: u32 = 48;
pub const XCHAL_EXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CPEXTRA_SA_SIZE: u32 = 128;
pub const XCHAL_CPEXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CP1_NAME: u32 = 0;
pub const XCHAL_CP1_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP2_NAME: u32 = 0;
pub const XCHAL_CP2_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP3_NAME: u32 = 0;
pub const XCHAL_CP3_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP4_NAME: u32 = 0;
pub const XCHAL_CP4_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP5_NAME: u32 = 0;
pub const XCHAL_CP5_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP6_NAME: u32 = 0;
pub const XCHAL_CP6_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP7_NAME: u32 = 0;
pub const XCHAL_CP7_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CPEXTRA_SA_SIZE_TOR2: u32 = 128;
pub const XCHAL_INST_ILLN: u32 = 61549;
pub const XCHAL_INST_ILLN_BYTE0: u32 = 109;
pub const XCHAL_INST_ILLN_BYTE1: u32 = 240;
pub const XTHAL_INST_ILL: u32 = 0;
pub const XCHAL_ERRATUM_453: u32 = 0;
pub const XCHAL_ERRATUM_497: u32 = 0;
pub const XCHAL_ERRATUM_572: u32 = 1;
pub const XSHAL_USE_ABSOLUTE_LITERALS: u32 = 0;
pub const XSHAL_HAVE_TEXT_SECTION_LITERALS: u32 = 1;
pub const XTHAL_ABI_WINDOWED: u32 = 0;
pub const XTHAL_ABI_CALL0: u32 = 1;
pub const XTHAL_CLIB_NEWLIB: u32 = 0;
pub const XTHAL_CLIB_UCLIBC: u32 = 1;
pub const XTHAL_CLIB_XCLIB: u32 = 2;
pub const XSHAL_USE_FLOATING_POINT: u32 = 1;
pub const XSHAL_FLOATING_POINT_ABI: u32 = 0;
pub const XSHAL_IOBLOCK_CACHED_VADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_PADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_SIZE: u32 = 234881024;
pub const XSHAL_IOBLOCK_BYPASS_VADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_PADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_SIZE: u32 = 234881024;
pub const XSHAL_ROM_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_PADDR: u32 = 1342177280;
pub const XSHAL_ROM_SIZE: u32 = 16777216;
pub const XSHAL_ROM_AVAIL_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_AVAIL_VSIZE: u32 = 16777216;
pub const XSHAL_RAM_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_PADDR: u32 = 1610612736;
pub const XSHAL_RAM_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_PSIZE: u32 = 536870912;
pub const XSHAL_RAM_SIZE: u32 = 536870912;
pub const XSHAL_RAM_AVAIL_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_AVAIL_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_BYPASS_VADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PSIZE: u32 = 536870912;
pub const XSHAL_SIMIO_CACHED_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_BYPASS_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_PADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_SIZE: u32 = 536870912;
pub const XSHAL_MAGIC_EXIT: u32 = 0;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEBACK: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEALLOC: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITETHRU: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_BYPASS: u32 = 572662306;
pub const XSHAL_ALLVALID_CACHEATTR_DEFAULT: u32 = 572657938;
pub const XSHAL_STRICT_CACHEATTR_WRITEBACK: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITEALLOC: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITETHRU: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_BYPASS: u32 = 4294910511;
pub const XSHAL_STRICT_CACHEATTR_DEFAULT: u32 = 4294906143;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_TRAPNULL_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_ISS_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_PIPE_REGIONS: u32 = 0;
pub const XSHAL_ISS_SDRAM_REGIONS: u32 = 0;
pub const XSHAL_XT2000_CACHEATTR_WRITEBACK: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITEALLOC: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITETHRU: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_BYPASS: u32 = 4280427055;
pub const XSHAL_XT2000_CACHEATTR_DEFAULT: u32 = 4280422687;
pub const XSHAL_XT2000_PIPE_REGIONS: u32 = 0;
pub const XSHAL_XT2000_SDRAM_REGIONS: u32 = 1088;
pub const XSHAL_VECTORS_PACKED: u32 = 0;
pub const XSHAL_STATIC_VECTOR_SELECT: u32 = 1;
pub const XSHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_SIZE: u32 = 768;
pub const XSHAL_RESET_VECTOR_ISROM: u32 = 0;
pub const XSHAL_USER_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USER_VECTOR_ISROM: u32 = 0;
pub const XSHAL_PROGRAMEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USEREXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_ISROM: u32 = 0;
pub const XSHAL_STACKEDEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNELEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DOUBLEEXC_VECTOR_SIZE: u32 = 64;
pub const XSHAL_DOUBLEEXC_VECTOR_ISROM: u32 = 0;
pub const XSHAL_WINDOW_VECTORS_SIZE: u32 = 376;
pub const XSHAL_WINDOW_VECTORS_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL2_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL2_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL3_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL3_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL4_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL4_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL5_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL5_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL6_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL6_VECTOR_ISROM: u32 = 0;
pub const XSHAL_DEBUG_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DEBUG_VECTOR_ISROM: u32 = 0;
pub const XSHAL_NMI_VECTOR_SIZE: u32 = 56;
pub const XSHAL_NMI_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL7_VECTOR_SIZE: u32 = 56;
pub const EXCCAUSE_EXCCAUSE_SHIFT: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_MASK: u32 = 63;
pub const EXCCAUSE_ILLEGAL: u32 = 0;
pub const EXCCAUSE_SYSCALL: u32 = 1;
pub const EXCCAUSE_INSTR_ERROR: u32 = 2;
pub const EXCCAUSE_IFETCHERROR: u32 = 2;
pub const EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const EXCCAUSE_LOADSTOREERROR: u32 = 3;
pub const EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const EXCCAUSE_LEVEL1INTERRUPT: u32 = 4;
pub const EXCCAUSE_ALLOCA: u32 = 5;
pub const EXCCAUSE_DIVIDE_BY_ZERO: u32 = 6;
pub const EXCCAUSE_SPECULATION: u32 = 7;
pub const EXCCAUSE_PC_ERROR: u32 = 7;
pub const EXCCAUSE_PRIVILEGED: u32 = 8;
pub const EXCCAUSE_UNALIGNED: u32 = 9;
pub const EXCCAUSE_EXTREG_PRIVILEGE: u32 = 10;
pub const EXCCAUSE_EXCLUSIVE_ERROR: u32 = 11;
pub const EXCCAUSE_INSTR_DATA_ERROR: u32 = 12;
pub const EXCCAUSE_LOAD_STORE_DATA_ERROR: u32 = 13;
pub const EXCCAUSE_INSTR_ADDR_ERROR: u32 = 14;
pub const EXCCAUSE_LOAD_STORE_ADDR_ERROR: u32 = 15;
pub const EXCCAUSE_ITLB_MISS: u32 = 16;
pub const EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const EXCCAUSE_INSTR_RING: u32 = 18;
pub const EXCCAUSE_INSTR_PROHIBITED: u32 = 20;
pub const EXCCAUSE_DTLB_MISS: u32 = 24;
pub const EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const EXCCAUSE_LOAD_STORE_RING: u32 = 26;
pub const EXCCAUSE_LOAD_PROHIBITED: u32 = 28;
pub const EXCCAUSE_STORE_PROHIBITED: u32 = 29;
pub const EXCCAUSE_CP0_DISABLED: u32 = 32;
pub const EXCCAUSE_CP1_DISABLED: u32 = 33;
pub const EXCCAUSE_CP2_DISABLED: u32 = 34;
pub const EXCCAUSE_CP3_DISABLED: u32 = 35;
pub const EXCCAUSE_CP4_DISABLED: u32 = 36;
pub const EXCCAUSE_CP5_DISABLED: u32 = 37;
pub const EXCCAUSE_CP6_DISABLED: u32 = 38;
pub const EXCCAUSE_CP7_DISABLED: u32 = 39;
pub const PS_WOE_SHIFT: u32 = 18;
pub const PS_WOE_MASK: u32 = 262144;
pub const PS_WOE: u32 = 262144;
pub const PS_CALLINC_SHIFT: u32 = 16;
pub const PS_CALLINC_MASK: u32 = 196608;
pub const PS_OWB_SHIFT: u32 = 8;
pub const PS_OWB_MASK: u32 = 3840;
pub const PS_RING_SHIFT: u32 = 6;
pub const PS_RING_MASK: u32 = 192;
pub const PS_UM_SHIFT: u32 = 5;
pub const PS_UM_MASK: u32 = 32;
pub const PS_UM: u32 = 32;
pub const PS_EXCM_SHIFT: u32 = 4;
pub const PS_EXCM_MASK: u32 = 16;
pub const PS_EXCM: u32 = 16;
pub const PS_INTLEVEL_SHIFT: u32 = 0;
pub const PS_INTLEVEL_MASK: u32 = 15;
pub const PS_WOE_ABI: u32 = 262144;
pub const PS_PROGSTACK_SHIFT: u32 = 5;
pub const PS_PROGSTACK_MASK: u32 = 32;
pub const PS_PROG_SHIFT: u32 = 5;
pub const PS_PROG_MASK: u32 = 32;
pub const PS_PROG: u32 = 32;
pub const DBREAKC_MASK_SHIFT: u32 = 0;
pub const DBREAKC_MASK_MASK: u32 = 63;
pub const DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const MESR_MEME: u32 = 1;
pub const MESR_MEME_SHIFT: u32 = 0;
pub const MESR_DME: u32 = 2;
pub const MESR_DME_SHIFT: u32 = 1;
pub const MESR_RCE: u32 = 16;
pub const MESR_RCE_SHIFT: u32 = 4;
pub const MESR_ERRENAB: u32 = 256;
pub const MESR_ERRENAB_SHIFT: u32 = 8;
pub const MESR_ERRTEST: u32 = 512;
pub const MESR_ERRTEST_SHIFT: u32 = 9;
pub const MESR_DATEXC: u32 = 1024;
pub const MESR_DATEXC_SHIFT: u32 = 10;
pub const MESR_INSEXC: u32 = 2048;
pub const MESR_INSEXC_SHIFT: u32 = 11;
pub const MESR_WAYNUM_SHIFT: u32 = 16;
pub const MESR_ACCTYPE_SHIFT: u32 = 20;
pub const MESR_MEMTYPE_SHIFT: u32 = 24;
pub const MESR_ERRTYPE_SHIFT: u32 = 30;
pub const MEMCTL_SNOOP_EN_SHIFT: u32 = 1;
pub const MEMCTL_SNOOP_EN: u32 = 2;
pub const MEMCTL_L0IBUF_EN_SHIFT: u32 = 0;
pub const MEMCTL_L0IBUF_EN: u32 = 1;
pub const MEMCTL_INV_EN_SHIFT: u32 = 23;
pub const MEMCTL_INV_EN: u32 = 8388608;
pub const MEMCTL_DCWU_SHIFT: u32 = 8;
pub const MEMCTL_DCWU_BITS: u32 = 5;
pub const MEMCTL_DCWA_SHIFT: u32 = 13;
pub const MEMCTL_DCWA_BITS: u32 = 5;
pub const MEMCTL_ICWU_SHIFT: u32 = 18;
pub const MEMCTL_ICWU_BITS: u32 = 5;
pub const MEMCTL_DCWU_MASK: u32 = 7936;
pub const MEMCTL_DCWA_MASK: u32 = 253952;
pub const MEMCTL_ICWU_MASK: u32 = 8126464;
pub const MEMCTL_DCWU_CLR_MASK: i32 = -7937;
pub const MEMCTL_DCWA_CLR_MASK: i32 = -253953;
pub const MEMCTL_ICWU_CLR_MASK: i32 = -8126465;
pub const MEMCTL_DCW_CLR_MASK: i32 = -1;
pub const MEMCTL_IDCW_CLR_MASK: i32 = -1;
pub const CALL0_ABI: u32 = 0;
pub const ALIGNPAD: u32 = 2;
pub const KERNELSTACKSIZE: u32 = 1024;
pub const XT_CP0_SA: u32 = 0;
pub const XT_CPENABLE: u32 = 0;
pub const XT_CPSTORED: u32 = 2;
pub const XT_CP_CS_ST: u32 = 4;
pub const XT_CP_ASA: u32 = 8;
pub const CORE_ID_REGVAL_PRO: u32 = 52685;
pub const CORE_ID_REGVAL_APP: u32 = 43947;
pub const CORE_ID_PRO: u32 = 52685;
pub const CORE_ID_APP: u32 = 43947;
pub const STK_INTEXC_EXTRA: u32 = 0;
pub const XT_CLIB_CONTEXT_AREA_SIZE: u32 = 0;
pub const XT_USER_SIZE: u32 = 1024;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 1;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configTICK_RATE_HZ: u32 = 100;
pub const configMAX_PRIORITIES: u32 = 25;
pub const configMINIMAL_STACK_SIZE: u32 = 768;
pub const configIDLE_TASK_STACK_SIZE: u32 = 1536;
pub const configISR_STACK_SIZE: u32 = 1536;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_TRACE_FACILITY_2: u32 = 0;
pub const configBENCHMARK: u32 = 0;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 0;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_pcTaskGetTaskName: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_pxTaskGetStackStart: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 1;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 3;
pub const configUSE_NEWLIB_REENTRANT: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configUSE_TIMERS: u32 = 1;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 1;
pub const configXT_BOARD: u32 = 1;
pub const configXT_SIMULATOR: u32 = 0;
pub const configENABLE_TASK_SNAPSHOT: u32 = 1;
pub const configCHECK_MUTEX_GIVEN_BY_OWNER: u32 = 0;
pub const ESP_TASK_PRIO_MAX: u32 = 25;
pub const ESP_TASK_PRIO_MIN: u32 = 0;
pub const ESP_TASK_BT_CONTROLLER_PRIO: u32 = 23;
pub const TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const BT_TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const ESP_TASK_BT_CONTROLLER_STACK: u32 = 4096;
pub const ESP_TASK_TIMER_PRIO: u32 = 22;
pub const ESP_TASKD_EVENT_PRIO: u32 = 20;
pub const ESP_TASK_TCPIP_PRIO: u32 = 18;
pub const ESP_TASK_MAIN_PRIO: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const LBEG: u32 = 0;
pub const LEND: u32 = 1;
pub const LCOUNT: u32 = 2;
pub const SAR: u32 = 3;
pub const BR: u32 = 4;
pub const SCOMPARE1: u32 = 12;
pub const ACCLO: u32 = 16;
pub const ACCHI: u32 = 17;
pub const MR_0: u32 = 32;
pub const MR_1: u32 = 33;
pub const MR_2: u32 = 34;
pub const MR_3: u32 = 35;
pub const WINDOWBASE: u32 = 72;
pub const WINDOWSTART: u32 = 73;
pub const IBREAKENABLE: u32 = 96;
pub const MEMCTL: u32 = 97;
pub const ATOMCTL: u32 = 99;
pub const DDR: u32 = 104;
pub const IBREAKA_0: u32 = 128;
pub const IBREAKA_1: u32 = 129;
pub const DBREAKA_0: u32 = 144;
pub const DBREAKA_1: u32 = 145;
pub const DBREAKC_0: u32 = 160;
pub const DBREAKC_1: u32 = 161;
pub const EPC_1: u32 = 177;
pub const EPC_2: u32 = 178;
pub const EPC_3: u32 = 179;
pub const EPC_4: u32 = 180;
pub const EPC_5: u32 = 181;
pub const EPC_6: u32 = 182;
pub const EPC_7: u32 = 183;
pub const DEPC: u32 = 192;
pub const EPS_2: u32 = 194;
pub const EPS_3: u32 = 195;
pub const EPS_4: u32 = 196;
pub const EPS_5: u32 = 197;
pub const EPS_6: u32 = 198;
pub const EPS_7: u32 = 199;
pub const EXCSAVE_1: u32 = 209;
pub const EXCSAVE_2: u32 = 210;
pub const EXCSAVE_3: u32 = 211;
pub const EXCSAVE_4: u32 = 212;
pub const EXCSAVE_5: u32 = 213;
pub const EXCSAVE_6: u32 = 214;
pub const EXCSAVE_7: u32 = 215;
pub const CPENABLE: u32 = 224;
pub const INTERRUPT: u32 = 226;
pub const INTENABLE: u32 = 228;
pub const PS: u32 = 230;
pub const VECBASE: u32 = 231;
pub const EXCCAUSE: u32 = 232;
pub const DEBUGCAUSE: u32 = 233;
pub const CCOUNT: u32 = 234;
pub const PRID: u32 = 235;
pub const ICOUNT: u32 = 236;
pub const ICOUNTLEVEL: u32 = 237;
pub const EXCVADDR: u32 = 238;
pub const CCOMPARE_0: u32 = 240;
pub const CCOMPARE_1: u32 = 241;
pub const CCOMPARE_2: u32 = 242;
pub const MISC_REG_0: u32 = 244;
pub const MISC_REG_1: u32 = 245;
pub const MISC_REG_2: u32 = 246;
pub const MISC_REG_3: u32 = 247;
pub const MR: u32 = 32;
pub const IBREAKA: u32 = 128;
pub const DBREAKA: u32 = 144;
pub const DBREAKC: u32 = 160;
pub const EPC: u32 = 176;
pub const EPS: u32 = 192;
pub const EXCSAVE: u32 = 208;
pub const CCOMPARE: u32 = 240;
pub const INTREAD: u32 = 226;
pub const INTSET: u32 = 226;
pub const INTCLEAR: u32 = 227;
pub const CORE_STATE_SIGNATURE: u32 = 2982522861;
pub const XTOS_KEEPON_MEM: u32 = 256;
pub const XTOS_KEEPON_MEM_SHIFT: u32 = 8;
pub const XTOS_KEEPON_DEBUG: u32 = 4096;
pub const XTOS_KEEPON_DEBUG_SHIFT: u32 = 12;
pub const XTOS_IDMA_NO_WAIT: u32 = 65536;
pub const XTOS_IDMA_WAIT_STANDBY: u32 = 131072;
pub const XTOS_COREF_PSO: u32 = 1;
pub const XTOS_COREF_PSO_SHIFT: u32 = 0;
pub const MALLOC_CAP_EXEC: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_PID2: u32 = 16;
pub const MALLOC_CAP_PID3: u32 = 32;
pub const MALLOC_CAP_PID4: u32 = 64;
pub const MALLOC_CAP_PID5: u32 = 128;
pub const MALLOC_CAP_PID6: u32 = 256;
pub const MALLOC_CAP_PID7: u32 = 512;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_DEFAULT: u32 = 4096;
pub const MALLOC_CAP_INVALID: u32 = 2147483648;
pub const portMUX_FREE_VAL: u32 = 3007315967;
pub const portMUX_NO_TIMEOUT: i32 = -1;
pub const portMUX_TRY_LOCK: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 1;
pub const portTcbMemoryCaps: u32 = 2052;
pub const portStackMemoryCaps: u32 = 2052;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 4;
pub const portBYTE_ALIGNMENT_MASK: u32 = 3;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const INCLUDE_xTimerGetTimerDaemonTaskHandle: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xEventGroupSetBitFromISR: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configTASKLIST_INCLUDE_COREID: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configESP32_PER_TASK_DATA: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const ARG_MAX: u32 = 4096;
pub const PATH_MAX: u32 = 1024;
pub const tskKERNEL_VERSION_NUMBER: &'static [u8; 7usize] = b"V8.2.0\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 8;
pub const tskKERNEL_VERSION_MINOR: u32 = 2;
pub const tskKERNEL_VERSION_BUILD: u32 = 0;
pub const ESP_ERR_FLASH_OP_FAIL: u32 = 24577;
pub const ESP_ERR_FLASH_OP_TIMEOUT: u32 = 24578;
pub const SPI_FLASH_SEC_SIZE: u32 = 4096;
pub const SPI_FLASH_MMU_PAGE_SIZE: u32 = 65536;
pub const ESP_EVENT_ANY_ID: i32 = -1;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 10;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_FILTER_MASK_DATA_MPDU: u32 = 16;
pub const WIFI_PROMIS_FILTER_MASK_DATA_AMPDU: u32 = 32;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const IPSTR: &'static [u8; 12usize] = b"%d.%d.%d.%d\0";
pub const IPV6STR: &'static [u8; 40usize] = b"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\0";
pub const ESP_IPADDR_TYPE_V4: u32 = 0;
pub const ESP_IPADDR_TYPE_V6: u32 = 6;
pub const ESP_IPADDR_TYPE_ANY: u32 = 46;
pub const ESP_ERR_ESP_NETIF_BASE: u32 = 20480;
pub const ESP_ERR_ESP_NETIF_INVALID_PARAMS: u32 = 20481;
pub const ESP_ERR_ESP_NETIF_IF_NOT_READY: u32 = 20482;
pub const ESP_ERR_ESP_NETIF_DHCPC_START_FAILED: u32 = 20483;
pub const ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED: u32 = 20484;
pub const ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED: u32 = 20485;
pub const ESP_ERR_ESP_NETIF_NO_MEM: u32 = 20486;
pub const ESP_ERR_ESP_NETIF_DHCP_NOT_STOPPED: u32 = 20487;
pub const ESP_ERR_ESP_NETIF_DRIVER_ATTACH_FAILED: u32 = 20488;
pub const ESP_ERR_ESP_NETIF_INIT_FAILED: u32 = 20489;
pub const ESP_ERR_ESP_NETIF_DNS_NOT_CONFIGURED: u32 = 20490;
pub const ESP_WIFI_CRYPTO_VERSION: u32 = 1;
pub const ESP_WIFI_OS_ADAPTER_VERSION: u32 = 4;
pub const ESP_WIFI_OS_ADAPTER_MAGIC: u32 = 3735928495;
pub const OSI_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const OSI_QUEUE_SEND_FRONT: u32 = 0;
pub const OSI_QUEUE_SEND_BACK: u32 = 1;
pub const OSI_QUEUE_SEND_OVERWRITE: u32 = 2;
pub const ESP_ERR_WIFI_NOT_INIT: u32 = 12289;
pub const ESP_ERR_WIFI_NOT_STARTED: u32 = 12290;
pub const ESP_ERR_WIFI_NOT_STOPPED: u32 = 12291;
pub const ESP_ERR_WIFI_IF: u32 = 12292;
pub const ESP_ERR_WIFI_MODE: u32 = 12293;
pub const ESP_ERR_WIFI_STATE: u32 = 12294;
pub const ESP_ERR_WIFI_CONN: u32 = 12295;
pub const ESP_ERR_WIFI_NVS: u32 = 12296;
pub const ESP_ERR_WIFI_MAC: u32 = 12297;
pub const ESP_ERR_WIFI_SSID: u32 = 12298;
pub const ESP_ERR_WIFI_PASSWORD: u32 = 12299;
pub const ESP_ERR_WIFI_TIMEOUT: u32 = 12300;
pub const ESP_ERR_WIFI_WAKE_FAIL: u32 = 12301;
pub const ESP_ERR_WIFI_WOULD_BLOCK: u32 = 12302;
pub const ESP_ERR_WIFI_NOT_CONNECT: u32 = 12303;
pub const ESP_ERR_WIFI_POST: u32 = 12306;
pub const ESP_ERR_WIFI_INIT_STATE: u32 = 12307;
pub const ESP_ERR_WIFI_STOP_STATE: u32 = 12308;
pub const WIFI_STATIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const WIFI_CSI_ENABLED: u32 = 0;
pub const WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const WIFI_NVS_ENABLED: u32 = 1;
pub const WIFI_NANO_FORMAT_ENABLED: u32 = 0;
pub const WIFI_INIT_CONFIG_MAGIC: u32 = 523190095;
pub const WIFI_DEFAULT_TX_BA_WIN: u32 = 6;
pub const WIFI_DEFAULT_RX_BA_WIN: u32 = 6;
pub const WIFI_TASK_CORE_ID: u32 = 0;
pub const WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_FEATURE_WPA3_SAE_BIT: u32 = 1;
pub const ETH_MAX_PAYLOAD_LEN: u32 = 1500;
pub const ETH_MIN_PAYLOAD_LEN: u32 = 46;
pub const ETH_HEADER_LEN: u32 = 14;
pub const ETH_CRC_LEN: u32 = 4;
pub const ETH_VLAN_TAG_LEN: u32 = 4;
pub const ETH_JUMBO_FRAME_PAYLOAD_LEN: u32 = 9000;
pub const ETH_MAX_PACKET_SIZE: u32 = 1522;
pub const ETH_MIN_PACKET_SIZE: u32 = 64;
pub const ETH_MAC_FLAG_WORK_WITH_CACHE_DISABLE: u32 = 1;
pub const ETH_MAC_FLAG_PIN_TO_CORE: u32 = 2;
pub const ESP_ETH_PHY_ADDR_AUTO: i32 = -1;
pub const ESP_INTR_FLAG_LEVEL1: u32 = 2;
pub const ESP_INTR_FLAG_LEVEL2: u32 = 4;
pub const ESP_INTR_FLAG_LEVEL3: u32 = 8;
pub const ESP_INTR_FLAG_LEVEL4: u32 = 16;
pub const ESP_INTR_FLAG_LEVEL5: u32 = 32;
pub const ESP_INTR_FLAG_LEVEL6: u32 = 64;
pub const ESP_INTR_FLAG_NMI: u32 = 128;
pub const ESP_INTR_FLAG_SHARED: u32 = 256;
pub const ESP_INTR_FLAG_EDGE: u32 = 512;
pub const ESP_INTR_FLAG_IRAM: u32 = 1024;
pub const ESP_INTR_FLAG_INTRDISABLED: u32 = 2048;
pub const ESP_INTR_FLAG_LOWMED: u32 = 14;
pub const ESP_INTR_FLAG_HIGH: u32 = 240;
pub const ESP_INTR_FLAG_LEVELMASK: u32 = 254;
pub const ETS_INTERNAL_TIMER0_INTR_SOURCE: i32 = -1;
pub const ETS_INTERNAL_TIMER1_INTR_SOURCE: i32 = -2;
pub const ETS_INTERNAL_TIMER2_INTR_SOURCE: i32 = -3;
pub const ETS_INTERNAL_SW0_INTR_SOURCE: i32 = -4;
pub const ETS_INTERNAL_SW1_INTR_SOURCE: i32 = -5;
pub const ETS_INTERNAL_PROFILING_INTR_SOURCE: i32 = -6;
pub const ETS_INTERNAL_INTR_SOURCE_OFF: u32 = 6;
pub const PRO_CPU_NUM: u32 = 0;
pub const APP_CPU_NUM: u32 = 1;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 4194304;
pub const DR_REG_DPORT_BASE: u32 = 1072693248;
pub const DR_REG_AES_BASE: u32 = 1072697344;
pub const DR_REG_RSA_BASE: u32 = 1072701440;
pub const DR_REG_SHA_BASE: u32 = 1072705536;
pub const DR_REG_FLASH_MMU_TABLE_PRO: u32 = 1072758784;
pub const DR_REG_FLASH_MMU_TABLE_APP: u32 = 1072766976;
pub const DR_REG_DPORT_END: u32 = 1072775164;
pub const DR_REG_UART_BASE: u32 = 1072955392;
pub const DR_REG_SPI1_BASE: u32 = 1072963584;
pub const DR_REG_SPI0_BASE: u32 = 1072967680;
pub const DR_REG_GPIO_BASE: u32 = 1072971776;
pub const DR_REG_GPIO_SD_BASE: u32 = 1072975616;
pub const DR_REG_FE2_BASE: u32 = 1072975872;
pub const DR_REG_FE_BASE: u32 = 1072979968;
pub const DR_REG_FRC_TIMER_BASE: u32 = 1072984064;
pub const DR_REG_RTCCNTL_BASE: u32 = 1072988160;
pub const DR_REG_RTCIO_BASE: u32 = 1072989184;
pub const DR_REG_SENS_BASE: u32 = 1072990208;
pub const DR_REG_RTC_I2C_BASE: u32 = 1072991232;
pub const DR_REG_IO_MUX_BASE: u32 = 1072992256;
pub const DR_REG_HINF_BASE: u32 = 1073000448;
pub const DR_REG_UHCI1_BASE: u32 = 1073004544;
pub const DR_REG_I2S_BASE: u32 = 1073016832;
pub const DR_REG_UART1_BASE: u32 = 1073020928;
pub const DR_REG_BT_BASE: u32 = 1073025024;
pub const DR_REG_I2C_EXT_BASE: u32 = 1073033216;
pub const DR_REG_UHCI0_BASE: u32 = 1073037312;
pub const DR_REG_SLCHOST_BASE: u32 = 1073041408;
pub const DR_REG_RMT_BASE: u32 = 1073045504;
pub const DR_REG_PCNT_BASE: u32 = 1073049600;
pub const DR_REG_SLC_BASE: u32 = 1073053696;
pub const DR_REG_LEDC_BASE: u32 = 1073057792;
pub const DR_REG_EFUSE_BASE: u32 = 1073061888;
pub const DR_REG_SPI_ENCRYPT_BASE: u32 = 1073065984;
pub const DR_REG_NRX_BASE: u32 = 1073073152;
pub const DR_REG_BB_BASE: u32 = 1073074176;
pub const DR_REG_PWM_BASE: u32 = 1073078272;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1073082368;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1073086464;
pub const DR_REG_RTCMEM0_BASE: u32 = 1073090560;
pub const DR_REG_RTCMEM1_BASE: u32 = 1073094656;
pub const DR_REG_RTCMEM2_BASE: u32 = 1073098752;
pub const DR_REG_SPI2_BASE: u32 = 1073102848;
pub const DR_REG_SPI3_BASE: u32 = 1073106944;
pub const DR_REG_SYSCON_BASE: u32 = 1073111040;
pub const DR_REG_APB_CTRL_BASE: u32 = 1073111040;
pub const DR_REG_I2C1_EXT_BASE: u32 = 1073115136;
pub const DR_REG_SDMMC_BASE: u32 = 1073119232;
pub const DR_REG_EMAC_BASE: u32 = 1073123328;
pub const DR_REG_CAN_BASE: u32 = 1073131520;
pub const DR_REG_PWM1_BASE: u32 = 1073135616;
pub const DR_REG_I2S1_BASE: u32 = 1073139712;
pub const DR_REG_UART2_BASE: u32 = 1073143808;
pub const DR_REG_PWM2_BASE: u32 = 1073147904;
pub const DR_REG_PWM3_BASE: u32 = 1073152000;
pub const PERIPHS_SPI_ENCRYPT_BASEADDR: u32 = 1073065984;
pub const APB_CLK_FREQ_ROM: u32 = 26000000;
pub const CPU_CLK_FREQ_ROM: u32 = 26000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const WDT_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 5000000;
pub const SPI_CLK_DIV: u32 = 4;
pub const TICKS_PER_US_ROM: u32 = 26;
pub const GPIO_MATRIX_DELAY_NS: u32 = 25;
pub const SOC_DROM_LOW: u32 = 1061158912;
pub const SOC_DROM_HIGH: u32 = 1065353216;
pub const SOC_DRAM_LOW: u32 = 1073405952;
pub const SOC_DRAM_HIGH: u32 = 1073741824;
pub const SOC_IROM_LOW: u32 = 1074593792;
pub const SOC_IROM_HIGH: u32 = 1077936128;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074155264;
pub const SOC_CACHE_PRO_LOW: u32 = 1074200576;
pub const SOC_CACHE_PRO_HIGH: u32 = 1074233344;
pub const SOC_CACHE_APP_LOW: u32 = 1074233344;
pub const SOC_CACHE_APP_HIGH: u32 = 1074266112;
pub const SOC_IRAM_LOW: u32 = 1074266112;
pub const SOC_IRAM_HIGH: u32 = 1074397184;
pub const SOC_RTC_IRAM_LOW: u32 = 1074528256;
pub const SOC_RTC_IRAM_HIGH: u32 = 1074536448;
pub const SOC_RTC_DRAM_LOW: u32 = 1073217536;
pub const SOC_RTC_DRAM_HIGH: u32 = 1073225728;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342185472;
pub const SOC_EXTRAM_DATA_LOW: u32 = 1065353216;
pub const SOC_EXTRAM_DATA_HIGH: u32 = 1069547520;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1074397184;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1074528256;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1073610752;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1073741824;
pub const SOC_DIRAM_INVERTED: u32 = 1;
pub const SOC_DMA_LOW: u32 = 1073405952;
pub const SOC_DMA_HIGH: u32 = 1073741824;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1073283072;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1073741824;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1073283072;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1074536448;
pub const SOC_ROM_STACK_START: u32 = 1073626912;
pub const ETS_WIFI_MAC_INTR_SOURCE: u32 = 0;
pub const ETS_WIFI_MAC_NMI_SOURCE: u32 = 1;
pub const ETS_WIFI_BB_INTR_SOURCE: u32 = 2;
pub const ETS_BT_MAC_INTR_SOURCE: u32 = 3;
pub const ETS_BT_BB_INTR_SOURCE: u32 = 4;
pub const ETS_BT_BB_NMI_SOURCE: u32 = 5;
pub const ETS_RWBT_INTR_SOURCE: u32 = 6;
pub const ETS_RWBLE_INTR_SOURCE: u32 = 7;
pub const ETS_RWBT_NMI_SOURCE: u32 = 8;
pub const ETS_RWBLE_NMI_SOURCE: u32 = 9;
pub const ETS_SLC0_INTR_SOURCE: u32 = 10;
pub const ETS_SLC1_INTR_SOURCE: u32 = 11;
pub const ETS_UHCI0_INTR_SOURCE: u32 = 12;
pub const ETS_UHCI1_INTR_SOURCE: u32 = 13;
pub const ETS_TG0_T0_LEVEL_INTR_SOURCE: u32 = 14;
pub const ETS_TG0_T1_LEVEL_INTR_SOURCE: u32 = 15;
pub const ETS_TG0_WDT_LEVEL_INTR_SOURCE: u32 = 16;
pub const ETS_TG0_LACT_LEVEL_INTR_SOURCE: u32 = 17;
pub const ETS_TG1_T0_LEVEL_INTR_SOURCE: u32 = 18;
pub const ETS_TG1_T1_LEVEL_INTR_SOURCE: u32 = 19;
pub const ETS_TG1_WDT_LEVEL_INTR_SOURCE: u32 = 20;
pub const ETS_TG1_LACT_LEVEL_INTR_SOURCE: u32 = 21;
pub const ETS_GPIO_INTR_SOURCE: u32 = 22;
pub const ETS_GPIO_NMI_SOURCE: u32 = 23;
pub const ETS_FROM_CPU_INTR0_SOURCE: u32 = 24;
pub const ETS_FROM_CPU_INTR1_SOURCE: u32 = 25;
pub const ETS_FROM_CPU_INTR2_SOURCE: u32 = 26;
pub const ETS_FROM_CPU_INTR3_SOURCE: u32 = 27;
pub const ETS_SPI0_INTR_SOURCE: u32 = 28;
pub const ETS_SPI1_INTR_SOURCE: u32 = 29;
pub const ETS_SPI2_INTR_SOURCE: u32 = 30;
pub const ETS_SPI3_INTR_SOURCE: u32 = 31;
pub const ETS_I2S0_INTR_SOURCE: u32 = 32;
pub const ETS_I2S1_INTR_SOURCE: u32 = 33;
pub const ETS_UART0_INTR_SOURCE: u32 = 34;
pub const ETS_UART1_INTR_SOURCE: u32 = 35;
pub const ETS_UART2_INTR_SOURCE: u32 = 36;
pub const ETS_SDIO_HOST_INTR_SOURCE: u32 = 37;
pub const ETS_ETH_MAC_INTR_SOURCE: u32 = 38;
pub const ETS_PWM0_INTR_SOURCE: u32 = 39;
pub const ETS_PWM1_INTR_SOURCE: u32 = 40;
pub const ETS_PWM2_INTR_SOURCE: u32 = 41;
pub const ETS_PWM3_INTR_SOURCE: u32 = 42;
pub const ETS_LEDC_INTR_SOURCE: u32 = 43;
pub const ETS_EFUSE_INTR_SOURCE: u32 = 44;
pub const ETS_CAN_INTR_SOURCE: u32 = 45;
pub const ETS_RTC_CORE_INTR_SOURCE: u32 = 46;
pub const ETS_RMT_INTR_SOURCE: u32 = 47;
pub const ETS_PCNT_INTR_SOURCE: u32 = 48;
pub const ETS_I2C_EXT0_INTR_SOURCE: u32 = 49;
pub const ETS_I2C_EXT1_INTR_SOURCE: u32 = 50;
pub const ETS_RSA_INTR_SOURCE: u32 = 51;
pub const ETS_SPI1_DMA_INTR_SOURCE: u32 = 52;
pub const ETS_SPI2_DMA_INTR_SOURCE: u32 = 53;
pub const ETS_SPI3_DMA_INTR_SOURCE: u32 = 54;
pub const ETS_WDT_INTR_SOURCE: u32 = 55;
pub const ETS_TIMER1_INTR_SOURCE: u32 = 56;
pub const ETS_TIMER2_INTR_SOURCE: u32 = 57;
pub const ETS_TG0_T0_EDGE_INTR_SOURCE: u32 = 58;
pub const ETS_TG0_T1_EDGE_INTR_SOURCE: u32 = 59;
pub const ETS_TG0_WDT_EDGE_INTR_SOURCE: u32 = 60;
pub const ETS_TG0_LACT_EDGE_INTR_SOURCE: u32 = 61;
pub const ETS_TG1_T0_EDGE_INTR_SOURCE: u32 = 62;
pub const ETS_TG1_T1_EDGE_INTR_SOURCE: u32 = 63;
pub const ETS_TG1_WDT_EDGE_INTR_SOURCE: u32 = 64;
pub const ETS_TG1_LACT_EDGE_INTR_SOURCE: u32 = 65;
pub const ETS_MMU_IA_INTR_SOURCE: u32 = 66;
pub const ETS_MPU_IA_INTR_SOURCE: u32 = 67;
pub const ETS_CACHE_IA_INTR_SOURCE: u32 = 68;
pub const ETS_MAX_INTR_SOURCE: u32 = 69;
pub const ETS_WMAC_INUM: u32 = 0;
pub const ETS_BT_HOST_INUM: u32 = 1;
pub const ETS_WBB_INUM: u32 = 4;
pub const ETS_TG0_T1_INUM: u32 = 10;
pub const ETS_FRC1_INUM: u32 = 22;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_DPORT_INUM: u32 = 28;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_INVALID_INUM: u32 = 6;
pub const SLP_OE_V: u32 = 1;
pub const SLP_OE_S: u32 = 0;
pub const SLP_SEL_V: u32 = 1;
pub const SLP_SEL_S: u32 = 1;
pub const SLP_PD_V: u32 = 1;
pub const SLP_PD_S: u32 = 2;
pub const SLP_PU_V: u32 = 1;
pub const SLP_PU_S: u32 = 3;
pub const SLP_IE_V: u32 = 1;
pub const SLP_IE_S: u32 = 4;
pub const SLP_DRV: u32 = 3;
pub const SLP_DRV_V: u32 = 3;
pub const SLP_DRV_S: u32 = 5;
pub const FUN_PD_V: u32 = 1;
pub const FUN_PD_S: u32 = 7;
pub const FUN_PU_V: u32 = 1;
pub const FUN_PU_S: u32 = 8;
pub const FUN_IE_V: u32 = 1;
pub const FUN_IE_S: u32 = 9;
pub const FUN_DRV: u32 = 3;
pub const FUN_DRV_V: u32 = 3;
pub const FUN_DRV_S: u32 = 10;
pub const MCU_SEL: u32 = 7;
pub const MCU_SEL_V: u32 = 7;
pub const MCU_SEL_S: u32 = 12;
pub const PIN_FUNC_GPIO: u32 = 2;
pub const SPI_CLK_GPIO_NUM: u32 = 6;
pub const SPI_CS0_GPIO_NUM: u32 = 11;
pub const SPI_Q_GPIO_NUM: u32 = 7;
pub const SPI_D_GPIO_NUM: u32 = 8;
pub const SPI_WP_GPIO_NUM: u32 = 10;
pub const SPI_HD_GPIO_NUM: u32 = 9;
pub const PIN_CTRL: u32 = 1072992256;
pub const CLK_OUT3: u32 = 15;
pub const CLK_OUT3_V: u32 = 15;
pub const CLK_OUT3_S: u32 = 8;
pub const CLK_OUT3_M: u32 = 3840;
pub const CLK_OUT2: u32 = 15;
pub const CLK_OUT2_V: u32 = 15;
pub const CLK_OUT2_S: u32 = 4;
pub const CLK_OUT2_M: u32 = 240;
pub const CLK_OUT1: u32 = 15;
pub const CLK_OUT1_V: u32 = 15;
pub const CLK_OUT1_S: u32 = 0;
pub const CLK_OUT1_M: u32 = 15;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1072992324;
pub const IO_MUX_GPIO0_REG: u32 = 1072992324;
pub const FUNC_GPIO0_EMAC_TX_CLK: u32 = 5;
pub const FUNC_GPIO0_GPIO0: u32 = 2;
pub const FUNC_GPIO0_CLK_OUT1: u32 = 1;
pub const FUNC_GPIO0_GPIO0_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1072992392;
pub const IO_MUX_GPIO1_REG: u32 = 1072992392;
pub const FUNC_U0TXD_EMAC_RXD2: u32 = 5;
pub const FUNC_U0TXD_GPIO1: u32 = 2;
pub const FUNC_U0TXD_CLK_OUT3: u32 = 1;
pub const FUNC_U0TXD_U0TXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1072992320;
pub const IO_MUX_GPIO2_REG: u32 = 1072992320;
pub const FUNC_GPIO2_SD_DATA0: u32 = 4;
pub const FUNC_GPIO2_HS2_DATA0: u32 = 3;
pub const FUNC_GPIO2_GPIO2: u32 = 2;
pub const FUNC_GPIO2_HSPIWP: u32 = 1;
pub const FUNC_GPIO2_GPIO2_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1072992388;
pub const IO_MUX_GPIO3_REG: u32 = 1072992388;
pub const FUNC_U0RXD_GPIO3: u32 = 2;
pub const FUNC_U0RXD_CLK_OUT2: u32 = 1;
pub const FUNC_U0RXD_U0RXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1072992328;
pub const IO_MUX_GPIO4_REG: u32 = 1072992328;
pub const FUNC_GPIO4_EMAC_TX_ER: u32 = 5;
pub const FUNC_GPIO4_SD_DATA1: u32 = 4;
pub const FUNC_GPIO4_HS2_DATA1: u32 = 3;
pub const FUNC_GPIO4_GPIO4: u32 = 2;
pub const FUNC_GPIO4_HSPIHD: u32 = 1;
pub const FUNC_GPIO4_GPIO4_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1072992364;
pub const IO_MUX_GPIO5_REG: u32 = 1072992364;
pub const FUNC_GPIO5_EMAC_RX_CLK: u32 = 5;
pub const FUNC_GPIO5_HS1_DATA6: u32 = 3;
pub const FUNC_GPIO5_GPIO5: u32 = 2;
pub const FUNC_GPIO5_VSPICS0: u32 = 1;
pub const FUNC_GPIO5_GPIO5_0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1072992352;
pub const IO_MUX_GPIO6_REG: u32 = 1072992352;
pub const FUNC_SD_CLK_U1CTS: u32 = 4;
pub const FUNC_SD_CLK_HS1_CLK: u32 = 3;
pub const FUNC_SD_CLK_GPIO6: u32 = 2;
pub const FUNC_SD_CLK_SPICLK: u32 = 1;
pub const FUNC_SD_CLK_SD_CLK: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1072992356;
pub const IO_MUX_GPIO7_REG: u32 = 1072992356;
pub const FUNC_SD_DATA0_U2RTS: u32 = 4;
pub const FUNC_SD_DATA0_HS1_DATA0: u32 = 3;
pub const FUNC_SD_DATA0_GPIO7: u32 = 2;
pub const FUNC_SD_DATA0_SPIQ: u32 = 1;
pub const FUNC_SD_DATA0_SD_DATA0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1072992360;
pub const IO_MUX_GPIO8_REG: u32 = 1072992360;
pub const FUNC_SD_DATA1_U2CTS: u32 = 4;
pub const FUNC_SD_DATA1_HS1_DATA1: u32 = 3;
pub const FUNC_SD_DATA1_GPIO8: u32 = 2;
pub const FUNC_SD_DATA1_SPID: u32 = 1;
pub const FUNC_SD_DATA1_SD_DATA1: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1072992340;
pub const IO_MUX_GPIO9_REG: u32 = 1072992340;
pub const FUNC_SD_DATA2_U1RXD: u32 = 4;
pub const FUNC_SD_DATA2_HS1_DATA2: u32 = 3;
pub const FUNC_SD_DATA2_GPIO9: u32 = 2;
pub const FUNC_SD_DATA2_SPIHD: u32 = 1;
pub const FUNC_SD_DATA2_SD_DATA2: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1072992344;
pub const IO_MUX_GPIO10_REG: u32 = 1072992344;
pub const FUNC_SD_DATA3_U1TXD: u32 = 4;
pub const FUNC_SD_DATA3_HS1_DATA3: u32 = 3;
pub const FUNC_SD_DATA3_GPIO10: u32 = 2;
pub const FUNC_SD_DATA3_SPIWP: u32 = 1;
pub const FUNC_SD_DATA3_SD_DATA3: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1072992348;
pub const IO_MUX_GPIO11_REG: u32 = 1072992348;
pub const FUNC_SD_CMD_U1RTS: u32 = 4;
pub const FUNC_SD_CMD_HS1_CMD: u32 = 3;
pub const FUNC_SD_CMD_GPIO11: u32 = 2;
pub const FUNC_SD_CMD_SPICS0: u32 = 1;
pub const FUNC_SD_CMD_SD_CMD: u32 = 0;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1072992308;
pub const IO_MUX_GPIO12_REG: u32 = 1072992308;
pub const FUNC_MTDI_EMAC_TXD3: u32 = 5;
pub const FUNC_MTDI_SD_DATA2: u32 = 4;
pub const FUNC_MTDI_HS2_DATA2: u32 = 3;
pub const FUNC_MTDI_GPIO12: u32 = 2;
pub const FUNC_MTDI_HSPIQ: u32 = 1;
pub const FUNC_MTDI_MTDI: u32 = 0;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1072992312;
pub const IO_MUX_GPIO13_REG: u32 = 1072992312;
pub const FUNC_MTCK_EMAC_RX_ER: u32 = 5;
pub const FUNC_MTCK_SD_DATA3: u32 = 4;
pub const FUNC_MTCK_HS2_DATA3: u32 = 3;
pub const FUNC_MTCK_GPIO13: u32 = 2;
pub const FUNC_MTCK_HSPID: u32 = 1;
pub const FUNC_MTCK_MTCK: u32 = 0;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1072992304;
pub const IO_MUX_GPIO14_REG: u32 = 1072992304;
pub const FUNC_MTMS_EMAC_TXD2: u32 = 5;
pub const FUNC_MTMS_SD_CLK: u32 = 4;
pub const FUNC_MTMS_HS2_CLK: u32 = 3;
pub const FUNC_MTMS_GPIO14: u32 = 2;
pub const FUNC_MTMS_HSPICLK: u32 = 1;
pub const FUNC_MTMS_MTMS: u32 = 0;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1072992316;
pub const IO_MUX_GPIO15_REG: u32 = 1072992316;
pub const FUNC_MTDO_EMAC_RXD3: u32 = 5;
pub const FUNC_MTDO_SD_CMD: u32 = 4;
pub const FUNC_MTDO_HS2_CMD: u32 = 3;
pub const FUNC_MTDO_GPIO15: u32 = 2;
pub const FUNC_MTDO_HSPICS0: u32 = 1;
pub const FUNC_MTDO_MTDO: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO16_U: u32 = 1072992332;
pub const IO_MUX_GPIO16_REG: u32 = 1072992332;
pub const FUNC_GPIO16_EMAC_CLK_OUT: u32 = 5;
pub const FUNC_GPIO16_U2RXD: u32 = 4;
pub const FUNC_GPIO16_HS1_DATA4: u32 = 3;
pub const FUNC_GPIO16_GPIO16: u32 = 2;
pub const FUNC_GPIO16_GPIO16_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO17_U: u32 = 1072992336;
pub const IO_MUX_GPIO17_REG: u32 = 1072992336;
pub const FUNC_GPIO17_EMAC_CLK_OUT_180: u32 = 5;
pub const FUNC_GPIO17_U2TXD: u32 = 4;
pub const FUNC_GPIO17_HS1_DATA5: u32 = 3;
pub const FUNC_GPIO17_GPIO17: u32 = 2;
pub const FUNC_GPIO17_GPIO17_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO18_U: u32 = 1072992368;
pub const IO_MUX_GPIO18_REG: u32 = 1072992368;
pub const FUNC_GPIO18_HS1_DATA7: u32 = 3;
pub const FUNC_GPIO18_GPIO18: u32 = 2;
pub const FUNC_GPIO18_VSPICLK: u32 = 1;
pub const FUNC_GPIO18_GPIO18_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO19_U: u32 = 1072992372;
pub const IO_MUX_GPIO19_REG: u32 = 1072992372;
pub const FUNC_GPIO19_EMAC_TXD0: u32 = 5;
pub const FUNC_GPIO19_U0CTS: u32 = 3;
pub const FUNC_GPIO19_GPIO19: u32 = 2;
pub const FUNC_GPIO19_VSPIQ: u32 = 1;
pub const FUNC_GPIO19_GPIO19_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO20_U: u32 = 1072992376;
pub const IO_MUX_GPIO20_REG: u32 = 1072992376;
pub const FUNC_GPIO20_GPIO20: u32 = 2;
pub const FUNC_GPIO20_GPIO20_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO21_U: u32 = 1072992380;
pub const IO_MUX_GPIO21_REG: u32 = 1072992380;
pub const FUNC_GPIO21_EMAC_TX_EN: u32 = 5;
pub const FUNC_GPIO21_GPIO21: u32 = 2;
pub const FUNC_GPIO21_VSPIHD: u32 = 1;
pub const FUNC_GPIO21_GPIO21_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO22_U: u32 = 1072992384;
pub const IO_MUX_GPIO22_REG: u32 = 1072992384;
pub const FUNC_GPIO22_EMAC_TXD1: u32 = 5;
pub const FUNC_GPIO22_U0RTS: u32 = 3;
pub const FUNC_GPIO22_GPIO22: u32 = 2;
pub const FUNC_GPIO22_VSPIWP: u32 = 1;
pub const FUNC_GPIO22_GPIO22_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO23_U: u32 = 1072992396;
pub const IO_MUX_GPIO23_REG: u32 = 1072992396;
pub const FUNC_GPIO23_HS1_STROBE: u32 = 3;
pub const FUNC_GPIO23_GPIO23: u32 = 2;
pub const FUNC_GPIO23_VSPID: u32 = 1;
pub const FUNC_GPIO23_GPIO23_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO24_U: u32 = 1072992400;
pub const IO_MUX_GPIO24_REG: u32 = 1072992400;
pub const FUNC_GPIO24_GPIO24: u32 = 2;
pub const FUNC_GPIO24_GPIO24_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO25_U: u32 = 1072992292;
pub const IO_MUX_GPIO25_REG: u32 = 1072992292;
pub const FUNC_GPIO25_EMAC_RXD0: u32 = 5;
pub const FUNC_GPIO25_GPIO25: u32 = 2;
pub const FUNC_GPIO25_GPIO25_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO26_U: u32 = 1072992296;
pub const IO_MUX_GPIO26_REG: u32 = 1072992296;
pub const FUNC_GPIO26_EMAC_RXD1: u32 = 5;
pub const FUNC_GPIO26_GPIO26: u32 = 2;
pub const FUNC_GPIO26_GPIO26_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO27_U: u32 = 1072992300;
pub const IO_MUX_GPIO27_REG: u32 = 1072992300;
pub const FUNC_GPIO27_EMAC_RX_DV: u32 = 5;
pub const FUNC_GPIO27_GPIO27: u32 = 2;
pub const FUNC_GPIO27_GPIO27_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO32_U: u32 = 1072992284;
pub const IO_MUX_GPIO32_REG: u32 = 1072992284;
pub const FUNC_GPIO32_GPIO32: u32 = 2;
pub const FUNC_GPIO32_GPIO32_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO33_U: u32 = 1072992288;
pub const IO_MUX_GPIO33_REG: u32 = 1072992288;
pub const FUNC_GPIO33_GPIO33: u32 = 2;
pub const FUNC_GPIO33_GPIO33_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO34_U: u32 = 1072992276;
pub const IO_MUX_GPIO34_REG: u32 = 1072992276;
pub const FUNC_GPIO34_GPIO34: u32 = 2;
pub const FUNC_GPIO34_GPIO34_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO35_U: u32 = 1072992280;
pub const IO_MUX_GPIO35_REG: u32 = 1072992280;
pub const FUNC_GPIO35_GPIO35: u32 = 2;
pub const FUNC_GPIO35_GPIO35_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO36_U: u32 = 1072992260;
pub const IO_MUX_GPIO36_REG: u32 = 1072992260;
pub const FUNC_GPIO36_GPIO36: u32 = 2;
pub const FUNC_GPIO36_GPIO36_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO37_U: u32 = 1072992264;
pub const IO_MUX_GPIO37_REG: u32 = 1072992264;
pub const FUNC_GPIO37_GPIO37: u32 = 2;
pub const FUNC_GPIO37_GPIO37_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO38_U: u32 = 1072992268;
pub const IO_MUX_GPIO38_REG: u32 = 1072992268;
pub const FUNC_GPIO38_GPIO38: u32 = 2;
pub const FUNC_GPIO38_GPIO38_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO39_U: u32 = 1072992272;
pub const IO_MUX_GPIO39_REG: u32 = 1072992272;
pub const FUNC_GPIO39_GPIO39: u32 = 2;
pub const FUNC_GPIO39_GPIO39_0: u32 = 0;
pub const GPIO_BT_SELECT_REG: u32 = 1072971776;
pub const GPIO_BT_SEL: u32 = 4294967295;
pub const GPIO_BT_SEL_V: u32 = 4294967295;
pub const GPIO_BT_SEL_S: u32 = 0;
pub const GPIO_OUT_REG: u32 = 1072971780;
pub const GPIO_OUT_DATA: u32 = 4294967295;
pub const GPIO_OUT_DATA_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_REG: u32 = 1072971784;
pub const GPIO_OUT_DATA_W1TS: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_REG: u32 = 1072971788;
pub const GPIO_OUT_DATA_W1TC: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_S: u32 = 0;
pub const GPIO_OUT1_REG: u32 = 1072971792;
pub const GPIO_OUT1_DATA: u32 = 255;
pub const GPIO_OUT1_DATA_V: u32 = 255;
pub const GPIO_OUT1_DATA_S: u32 = 0;
pub const GPIO_OUT1_W1TS_REG: u32 = 1072971796;
pub const GPIO_OUT1_DATA_W1TS: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT1_W1TC_REG: u32 = 1072971800;
pub const GPIO_OUT1_DATA_W1TC: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_S: u32 = 0;
pub const GPIO_SDIO_SELECT_REG: u32 = 1072971804;
pub const GPIO_SDIO_SEL: u32 = 255;
pub const GPIO_SDIO_SEL_V: u32 = 255;
pub const GPIO_SDIO_SEL_S: u32 = 0;
pub const GPIO_ENABLE_REG: u32 = 1072971808;
pub const GPIO_ENABLE_DATA: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_REG: u32 = 1072971812;
pub const GPIO_ENABLE_DATA_W1TS: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE_W1TC_REG: u32 = 1072971816;
pub const GPIO_ENABLE_DATA_W1TC: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_S: u32 = 0;
pub const GPIO_ENABLE1_REG: u32 = 1072971820;
pub const GPIO_ENABLE1_DATA: u32 = 255;
pub const GPIO_ENABLE1_DATA_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_S: u32 = 0;
pub const GPIO_ENABLE1_W1TS_REG: u32 = 1072971824;
pub const GPIO_ENABLE1_DATA_W1TS: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE1_W1TC_REG: u32 = 1072971828;
pub const GPIO_ENABLE1_DATA_W1TC: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_S: u32 = 0;
pub const GPIO_STRAP_REG: u32 = 1072971832;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_V: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 0;
pub const GPIO_IN_REG: u32 = 1072971836;
pub const GPIO_IN_DATA: u32 = 4294967295;
pub const GPIO_IN_DATA_V: u32 = 4294967295;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_IN1_REG: u32 = 1072971840;
pub const GPIO_IN1_DATA: u32 = 255;
pub const GPIO_IN1_DATA_V: u32 = 255;
pub const GPIO_IN1_DATA_S: u32 = 0;
pub const GPIO_STATUS_REG: u32 = 1072971844;
pub const GPIO_STATUS_INT: u32 = 4294967295;
pub const GPIO_STATUS_INT_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_REG: u32 = 1072971848;
pub const GPIO_STATUS_INT_W1TS: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_REG: u32 = 1072971852;
pub const GPIO_STATUS_INT_W1TC: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_S: u32 = 0;
pub const GPIO_STATUS1_REG: u32 = 1072971856;
pub const GPIO_STATUS1_INT: u32 = 255;
pub const GPIO_STATUS1_INT_V: u32 = 255;
pub const GPIO_STATUS1_INT_S: u32 = 0;
pub const GPIO_STATUS1_W1TS_REG: u32 = 1072971860;
pub const GPIO_STATUS1_INT_W1TS: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS1_W1TC_REG: u32 = 1072971864;
pub const GPIO_STATUS1_INT_W1TC: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_S: u32 = 0;
pub const GPIO_ACPU_INT_REG: u32 = 1072971872;
pub const GPIO_APPCPU_INT: u32 = 4294967295;
pub const GPIO_APPCPU_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_INT_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT_REG: u32 = 1072971876;
pub const GPIO_APPCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_S: u32 = 0;
pub const GPIO_PCPU_INT_REG: u32 = 1072971880;
pub const GPIO_PROCPU_INT: u32 = 4294967295;
pub const GPIO_PROCPU_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_INT_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT_REG: u32 = 1072971884;
pub const GPIO_PROCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_S: u32 = 0;
pub const GPIO_CPUSDIO_INT_REG: u32 = 1072971888;
pub const GPIO_SDIO_INT: u32 = 4294967295;
pub const GPIO_SDIO_INT_V: u32 = 4294967295;
pub const GPIO_SDIO_INT_S: u32 = 0;
pub const GPIO_ACPU_INT1_REG: u32 = 1072971892;
pub const GPIO_APPCPU_INT_H: u32 = 255;
pub const GPIO_APPCPU_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_INT_H_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT1_REG: u32 = 1072971896;
pub const GPIO_APPCPU_NMI_INT_H: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_PCPU_INT1_REG: u32 = 1072971900;
pub const GPIO_PROCPU_INT_H: u32 = 255;
pub const GPIO_PROCPU_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_INT_H_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT1_REG: u32 = 1072971904;
pub const GPIO_PROCPU_NMI_INT_H: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_CPUSDIO_INT1_REG: u32 = 1072971908;
pub const GPIO_SDIO_INT_H: u32 = 255;
pub const GPIO_SDIO_INT_H_V: u32 = 255;
pub const GPIO_SDIO_INT_H_S: u32 = 0;
pub const GPIO_PIN_INT_ENA: u32 = 31;
pub const GPIO_PIN_INT_ENA_V: u32 = 31;
pub const GPIO_PIN_INT_ENA_S: u32 = 13;
pub const GPIO_PIN_CONFIG: u32 = 3;
pub const GPIO_PIN_CONFIG_V: u32 = 3;
pub const GPIO_PIN_CONFIG_S: u32 = 11;
pub const GPIO_PIN_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN_INT_TYPE: u32 = 7;
pub const GPIO_PIN_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_REG: u32 = 1072971912;
pub const GPIO_PIN0_INT_ENA: u32 = 31;
pub const GPIO_PIN0_INT_ENA_V: u32 = 31;
pub const GPIO_PIN0_INT_ENA_S: u32 = 13;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_V: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_REG: u32 = 1072971916;
pub const GPIO_PIN1_INT_ENA: u32 = 31;
pub const GPIO_PIN1_INT_ENA_V: u32 = 31;
pub const GPIO_PIN1_INT_ENA_S: u32 = 13;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_V: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_REG: u32 = 1072971920;
pub const GPIO_PIN2_INT_ENA: u32 = 31;
pub const GPIO_PIN2_INT_ENA_V: u32 = 31;
pub const GPIO_PIN2_INT_ENA_S: u32 = 13;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_V: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_REG: u32 = 1072971924;
pub const GPIO_PIN3_INT_ENA: u32 = 31;
pub const GPIO_PIN3_INT_ENA_V: u32 = 31;
pub const GPIO_PIN3_INT_ENA_S: u32 = 13;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_V: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_REG: u32 = 1072971928;
pub const GPIO_PIN4_INT_ENA: u32 = 31;
pub const GPIO_PIN4_INT_ENA_V: u32 = 31;
pub const GPIO_PIN4_INT_ENA_S: u32 = 13;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_V: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_REG: u32 = 1072971932;
pub const GPIO_PIN5_INT_ENA: u32 = 31;
pub const GPIO_PIN5_INT_ENA_V: u32 = 31;
pub const GPIO_PIN5_INT_ENA_S: u32 = 13;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_V: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_REG: u32 = 1072971936;
pub const GPIO_PIN6_INT_ENA: u32 = 31;
pub const GPIO_PIN6_INT_ENA_V: u32 = 31;
pub const GPIO_PIN6_INT_ENA_S: u32 = 13;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_V: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_REG: u32 = 1072971940;
pub const GPIO_PIN7_INT_ENA: u32 = 31;
pub const GPIO_PIN7_INT_ENA_V: u32 = 31;
pub const GPIO_PIN7_INT_ENA_S: u32 = 13;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_V: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_REG: u32 = 1072971944;
pub const GPIO_PIN8_INT_ENA: u32 = 31;
pub const GPIO_PIN8_INT_ENA_V: u32 = 31;
pub const GPIO_PIN8_INT_ENA_S: u32 = 13;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_V: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_REG: u32 = 1072971948;
pub const GPIO_PIN9_INT_ENA: u32 = 31;
pub const GPIO_PIN9_INT_ENA_V: u32 = 31;
pub const GPIO_PIN9_INT_ENA_S: u32 = 13;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_V: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_REG: u32 = 1072971952;
pub const GPIO_PIN10_INT_ENA: u32 = 31;
pub const GPIO_PIN10_INT_ENA_V: u32 = 31;
pub const GPIO_PIN10_INT_ENA_S: u32 = 13;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_V: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_REG: u32 = 1072971956;
pub const GPIO_PIN11_INT_ENA: u32 = 31;
pub const GPIO_PIN11_INT_ENA_V: u32 = 31;
pub const GPIO_PIN11_INT_ENA_S: u32 = 13;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_V: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_REG: u32 = 1072971960;
pub const GPIO_PIN12_INT_ENA: u32 = 31;
pub const GPIO_PIN12_INT_ENA_V: u32 = 31;
pub const GPIO_PIN12_INT_ENA_S: u32 = 13;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_V: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_REG: u32 = 1072971964;
pub const GPIO_PIN13_INT_ENA: u32 = 31;
pub const GPIO_PIN13_INT_ENA_V: u32 = 31;
pub const GPIO_PIN13_INT_ENA_S: u32 = 13;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_V: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_REG: u32 = 1072971968;
pub const GPIO_PIN14_INT_ENA: u32 = 31;
pub const GPIO_PIN14_INT_ENA_V: u32 = 31;
pub const GPIO_PIN14_INT_ENA_S: u32 = 13;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_V: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_REG: u32 = 1072971972;
pub const GPIO_PIN15_INT_ENA: u32 = 31;
pub const GPIO_PIN15_INT_ENA_V: u32 = 31;
pub const GPIO_PIN15_INT_ENA_S: u32 = 13;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_V: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN16_REG: u32 = 1072971976;
pub const GPIO_PIN16_INT_ENA: u32 = 31;
pub const GPIO_PIN16_INT_ENA_V: u32 = 31;
pub const GPIO_PIN16_INT_ENA_S: u32 = 13;
pub const GPIO_PIN16_CONFIG: u32 = 3;
pub const GPIO_PIN16_CONFIG_V: u32 = 3;
pub const GPIO_PIN16_CONFIG_S: u32 = 11;
pub const GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN16_INT_TYPE: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN17_REG: u32 = 1072971980;
pub const GPIO_PIN17_INT_ENA: u32 = 31;
pub const GPIO_PIN17_INT_ENA_V: u32 = 31;
pub const GPIO_PIN17_INT_ENA_S: u32 = 13;
pub const GPIO_PIN17_CONFIG: u32 = 3;
pub const GPIO_PIN17_CONFIG_V: u32 = 3;
pub const GPIO_PIN17_CONFIG_S: u32 = 11;
pub const GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN17_INT_TYPE: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN18_REG: u32 = 1072971984;
pub const GPIO_PIN18_INT_ENA: u32 = 31;
pub const GPIO_PIN18_INT_ENA_V: u32 = 31;
pub const GPIO_PIN18_INT_ENA_S: u32 = 13;
pub const GPIO_PIN18_CONFIG: u32 = 3;
pub const GPIO_PIN18_CONFIG_V: u32 = 3;
pub const GPIO_PIN18_CONFIG_S: u32 = 11;
pub const GPIO_PIN18_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN18_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN18_INT_TYPE: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN18_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN18_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN19_REG: u32 = 1072971988;
pub const GPIO_PIN19_INT_ENA: u32 = 31;
pub const GPIO_PIN19_INT_ENA_V: u32 = 31;
pub const GPIO_PIN19_INT_ENA_S: u32 = 13;
pub const GPIO_PIN19_CONFIG: u32 = 3;
pub const GPIO_PIN19_CONFIG_V: u32 = 3;
pub const GPIO_PIN19_CONFIG_S: u32 = 11;
pub const GPIO_PIN19_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN19_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN19_INT_TYPE: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN19_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN19_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN20_REG: u32 = 1072971992;
pub const GPIO_PIN20_INT_ENA: u32 = 31;
pub const GPIO_PIN20_INT_ENA_V: u32 = 31;
pub const GPIO_PIN20_INT_ENA_S: u32 = 13;
pub const GPIO_PIN20_CONFIG: u32 = 3;
pub const GPIO_PIN20_CONFIG_V: u32 = 3;
pub const GPIO_PIN20_CONFIG_S: u32 = 11;
pub const GPIO_PIN20_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN20_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN20_INT_TYPE: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN20_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN20_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN21_REG: u32 = 1072971996;
pub const GPIO_PIN21_INT_ENA: u32 = 31;
pub const GPIO_PIN21_INT_ENA_V: u32 = 31;
pub const GPIO_PIN21_INT_ENA_S: u32 = 13;
pub const GPIO_PIN21_CONFIG: u32 = 3;
pub const GPIO_PIN21_CONFIG_V: u32 = 3;
pub const GPIO_PIN21_CONFIG_S: u32 = 11;
pub const GPIO_PIN21_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN21_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN21_INT_TYPE: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN21_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN21_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN22_REG: u32 = 1072972000;
pub const GPIO_PIN22_INT_ENA: u32 = 31;
pub const GPIO_PIN22_INT_ENA_V: u32 = 31;
pub const GPIO_PIN22_INT_ENA_S: u32 = 13;
pub const GPIO_PIN22_CONFIG: u32 = 3;
pub const GPIO_PIN22_CONFIG_V: u32 = 3;
pub const GPIO_PIN22_CONFIG_S: u32 = 11;
pub const GPIO_PIN22_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN22_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN22_INT_TYPE: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN22_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN22_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN23_REG: u32 = 1072972004;
pub const GPIO_PIN23_INT_ENA: u32 = 31;
pub const GPIO_PIN23_INT_ENA_V: u32 = 31;
pub const GPIO_PIN23_INT_ENA_S: u32 = 13;
pub const GPIO_PIN23_CONFIG: u32 = 3;
pub const GPIO_PIN23_CONFIG_V: u32 = 3;
pub const GPIO_PIN23_CONFIG_S: u32 = 11;
pub const GPIO_PIN23_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN23_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN23_INT_TYPE: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN23_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN23_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN24_REG: u32 = 1072972008;
pub const GPIO_PIN24_INT_ENA: u32 = 31;
pub const GPIO_PIN24_INT_ENA_V: u32 = 31;
pub const GPIO_PIN24_INT_ENA_S: u32 = 13;
pub const GPIO_PIN24_CONFIG: u32 = 3;
pub const GPIO_PIN24_CONFIG_V: u32 = 3;
pub const GPIO_PIN24_CONFIG_S: u32 = 11;
pub const GPIO_PIN24_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN24_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN24_INT_TYPE: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN24_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN24_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN25_REG: u32 = 1072972012;
pub const GPIO_PIN25_INT_ENA: u32 = 31;
pub const GPIO_PIN25_INT_ENA_V: u32 = 31;
pub const GPIO_PIN25_INT_ENA_S: u32 = 13;
pub const GPIO_PIN25_CONFIG: u32 = 3;
pub const GPIO_PIN25_CONFIG_V: u32 = 3;
pub const GPIO_PIN25_CONFIG_S: u32 = 11;
pub const GPIO_PIN25_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN25_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN25_INT_TYPE: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN25_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN25_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN26_REG: u32 = 1072972016;
pub const GPIO_PIN26_INT_ENA: u32 = 31;
pub const GPIO_PIN26_INT_ENA_V: u32 = 31;
pub const GPIO_PIN26_INT_ENA_S: u32 = 13;
pub const GPIO_PIN26_CONFIG: u32 = 3;
pub const GPIO_PIN26_CONFIG_V: u32 = 3;
pub const GPIO_PIN26_CONFIG_S: u32 = 11;
pub const GPIO_PIN26_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN26_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN26_INT_TYPE: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN26_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN26_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN27_REG: u32 = 1072972020;
pub const GPIO_PIN27_INT_ENA: u32 = 31;
pub const GPIO_PIN27_INT_ENA_V: u32 = 31;
pub const GPIO_PIN27_INT_ENA_S: u32 = 13;
pub const GPIO_PIN27_CONFIG: u32 = 3;
pub const GPIO_PIN27_CONFIG_V: u32 = 3;
pub const GPIO_PIN27_CONFIG_S: u32 = 11;
pub const GPIO_PIN27_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN27_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN27_INT_TYPE: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN27_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN27_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN28_REG: u32 = 1072972024;
pub const GPIO_PIN28_INT_ENA: u32 = 31;
pub const GPIO_PIN28_INT_ENA_V: u32 = 31;
pub const GPIO_PIN28_INT_ENA_S: u32 = 13;
pub const GPIO_PIN28_CONFIG: u32 = 3;
pub const GPIO_PIN28_CONFIG_V: u32 = 3;
pub const GPIO_PIN28_CONFIG_S: u32 = 11;
pub const GPIO_PIN28_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN28_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN28_INT_TYPE: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN28_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN28_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN29_REG: u32 = 1072972028;
pub const GPIO_PIN29_INT_ENA: u32 = 31;
pub const GPIO_PIN29_INT_ENA_V: u32 = 31;
pub const GPIO_PIN29_INT_ENA_S: u32 = 13;
pub const GPIO_PIN29_CONFIG: u32 = 3;
pub const GPIO_PIN29_CONFIG_V: u32 = 3;
pub const GPIO_PIN29_CONFIG_S: u32 = 11;
pub const GPIO_PIN29_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN29_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN29_INT_TYPE: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN29_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN29_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN30_REG: u32 = 1072972032;
pub const GPIO_PIN30_INT_ENA: u32 = 31;
pub const GPIO_PIN30_INT_ENA_V: u32 = 31;
pub const GPIO_PIN30_INT_ENA_S: u32 = 13;
pub const GPIO_PIN30_CONFIG: u32 = 3;
pub const GPIO_PIN30_CONFIG_V: u32 = 3;
pub const GPIO_PIN30_CONFIG_S: u32 = 11;
pub const GPIO_PIN30_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN30_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN30_INT_TYPE: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN30_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN30_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN31_REG: u32 = 1072972036;
pub const GPIO_PIN31_INT_ENA: u32 = 31;
pub const GPIO_PIN31_INT_ENA_V: u32 = 31;
pub const GPIO_PIN31_INT_ENA_S: u32 = 13;
pub const GPIO_PIN31_CONFIG: u32 = 3;
pub const GPIO_PIN31_CONFIG_V: u32 = 3;
pub const GPIO_PIN31_CONFIG_S: u32 = 11;
pub const GPIO_PIN31_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN31_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN31_INT_TYPE: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN31_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN31_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN32_REG: u32 = 1072972040;
pub const GPIO_PIN32_INT_ENA: u32 = 31;
pub const GPIO_PIN32_INT_ENA_V: u32 = 31;
pub const GPIO_PIN32_INT_ENA_S: u32 = 13;
pub const GPIO_PIN32_CONFIG: u32 = 3;
pub const GPIO_PIN32_CONFIG_V: u32 = 3;
pub const GPIO_PIN32_CONFIG_S: u32 = 11;
pub const GPIO_PIN32_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN32_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN32_INT_TYPE: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN32_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN32_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN33_REG: u32 = 1072972044;
pub const GPIO_PIN33_INT_ENA: u32 = 31;
pub const GPIO_PIN33_INT_ENA_V: u32 = 31;
pub const GPIO_PIN33_INT_ENA_S: u32 = 13;
pub const GPIO_PIN33_CONFIG: u32 = 3;
pub const GPIO_PIN33_CONFIG_V: u32 = 3;
pub const GPIO_PIN33_CONFIG_S: u32 = 11;
pub const GPIO_PIN33_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN33_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN33_INT_TYPE: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN33_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN33_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN34_REG: u32 = 1072972048;
pub const GPIO_PIN34_INT_ENA: u32 = 31;
pub const GPIO_PIN34_INT_ENA_V: u32 = 31;
pub const GPIO_PIN34_INT_ENA_S: u32 = 13;
pub const GPIO_PIN34_CONFIG: u32 = 3;
pub const GPIO_PIN34_CONFIG_V: u32 = 3;
pub const GPIO_PIN34_CONFIG_S: u32 = 11;
pub const GPIO_PIN34_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN34_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN34_INT_TYPE: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN34_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN34_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN35_REG: u32 = 1072972052;
pub const GPIO_PIN35_INT_ENA: u32 = 31;
pub const GPIO_PIN35_INT_ENA_V: u32 = 31;
pub const GPIO_PIN35_INT_ENA_S: u32 = 13;
pub const GPIO_PIN35_CONFIG: u32 = 3;
pub const GPIO_PIN35_CONFIG_V: u32 = 3;
pub const GPIO_PIN35_CONFIG_S: u32 = 11;
pub const GPIO_PIN35_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN35_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN35_INT_TYPE: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN35_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN35_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN36_REG: u32 = 1072972056;
pub const GPIO_PIN36_INT_ENA: u32 = 31;
pub const GPIO_PIN36_INT_ENA_V: u32 = 31;
pub const GPIO_PIN36_INT_ENA_S: u32 = 13;
pub const GPIO_PIN36_CONFIG: u32 = 3;
pub const GPIO_PIN36_CONFIG_V: u32 = 3;
pub const GPIO_PIN36_CONFIG_S: u32 = 11;
pub const GPIO_PIN36_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN36_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN36_INT_TYPE: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN36_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN36_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN37_REG: u32 = 1072972060;
pub const GPIO_PIN37_INT_ENA: u32 = 31;
pub const GPIO_PIN37_INT_ENA_V: u32 = 31;
pub const GPIO_PIN37_INT_ENA_S: u32 = 13;
pub const GPIO_PIN37_CONFIG: u32 = 3;
pub const GPIO_PIN37_CONFIG_V: u32 = 3;
pub const GPIO_PIN37_CONFIG_S: u32 = 11;
pub const GPIO_PIN37_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN37_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN37_INT_TYPE: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN37_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN37_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN38_REG: u32 = 1072972064;
pub const GPIO_PIN38_INT_ENA: u32 = 31;
pub const GPIO_PIN38_INT_ENA_V: u32 = 31;
pub const GPIO_PIN38_INT_ENA_S: u32 = 13;
pub const GPIO_PIN38_CONFIG: u32 = 3;
pub const GPIO_PIN38_CONFIG_V: u32 = 3;
pub const GPIO_PIN38_CONFIG_S: u32 = 11;
pub const GPIO_PIN38_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN38_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN38_INT_TYPE: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN38_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN38_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN39_REG: u32 = 1072972068;
pub const GPIO_PIN39_INT_ENA: u32 = 31;
pub const GPIO_PIN39_INT_ENA_V: u32 = 31;
pub const GPIO_PIN39_INT_ENA_S: u32 = 13;
pub const GPIO_PIN39_CONFIG: u32 = 3;
pub const GPIO_PIN39_CONFIG_V: u32 = 3;
pub const GPIO_PIN39_CONFIG_S: u32 = 11;
pub const GPIO_PIN39_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN39_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN39_INT_TYPE: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN39_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN39_PAD_DRIVER_S: u32 = 2;
pub const GPIO_cali_conf_REG: u32 = 1072972072;
pub const GPIO_CALI_START_V: u32 = 1;
pub const GPIO_CALI_START_S: u32 = 31;
pub const GPIO_CALI_RTC_MAX: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_V: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_S: u32 = 0;
pub const GPIO_cali_data_REG: u32 = 1072972076;
pub const GPIO_CALI_RDY_SYNC2_V: u32 = 1;
pub const GPIO_CALI_RDY_SYNC2_S: u32 = 31;
pub const GPIO_CALI_RDY_REAL_V: u32 = 1;
pub const GPIO_CALI_RDY_REAL_S: u32 = 30;
pub const GPIO_CALI_VALUE_SYNC2: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_V: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_S: u32 = 0;
pub const GPIO_FUNC0_IN_SEL_CFG_REG: u32 = 1072972080;
pub const GPIO_SIG0_IN_SEL_V: u32 = 1;
pub const GPIO_SIG0_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC0_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC0_IN_SEL: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC1_IN_SEL_CFG_REG: u32 = 1072972084;
pub const GPIO_SIG1_IN_SEL_V: u32 = 1;
pub const GPIO_SIG1_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC1_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC1_IN_SEL: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC2_IN_SEL_CFG_REG: u32 = 1072972088;
pub const GPIO_SIG2_IN_SEL_V: u32 = 1;
pub const GPIO_SIG2_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC2_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC2_IN_SEL: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC3_IN_SEL_CFG_REG: u32 = 1072972092;
pub const GPIO_SIG3_IN_SEL_V: u32 = 1;
pub const GPIO_SIG3_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC3_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC3_IN_SEL: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC4_IN_SEL_CFG_REG: u32 = 1072972096;
pub const GPIO_SIG4_IN_SEL_V: u32 = 1;
pub const GPIO_SIG4_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC4_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC4_IN_SEL: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC5_IN_SEL_CFG_REG: u32 = 1072972100;
pub const GPIO_SIG5_IN_SEL_V: u32 = 1;
pub const GPIO_SIG5_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC5_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC5_IN_SEL: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC6_IN_SEL_CFG_REG: u32 = 1072972104;
pub const GPIO_SIG6_IN_SEL_V: u32 = 1;
pub const GPIO_SIG6_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC6_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC6_IN_SEL: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC7_IN_SEL_CFG_REG: u32 = 1072972108;
pub const GPIO_SIG7_IN_SEL_V: u32 = 1;
pub const GPIO_SIG7_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC7_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC7_IN_SEL: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC8_IN_SEL_CFG_REG: u32 = 1072972112;
pub const GPIO_SIG8_IN_SEL_V: u32 = 1;
pub const GPIO_SIG8_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC8_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC8_IN_SEL: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC9_IN_SEL_CFG_REG: u32 = 1072972116;
pub const GPIO_SIG9_IN_SEL_V: u32 = 1;
pub const GPIO_SIG9_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC9_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC9_IN_SEL: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC10_IN_SEL_CFG_REG: u32 = 1072972120;
pub const GPIO_SIG10_IN_SEL_V: u32 = 1;
pub const GPIO_SIG10_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC10_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC10_IN_SEL: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC11_IN_SEL_CFG_REG: u32 = 1072972124;
pub const GPIO_SIG11_IN_SEL_V: u32 = 1;
pub const GPIO_SIG11_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC11_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC11_IN_SEL: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC12_IN_SEL_CFG_REG: u32 = 1072972128;
pub const GPIO_SIG12_IN_SEL_V: u32 = 1;
pub const GPIO_SIG12_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC12_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC12_IN_SEL: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC13_IN_SEL_CFG_REG: u32 = 1072972132;
pub const GPIO_SIG13_IN_SEL_V: u32 = 1;
pub const GPIO_SIG13_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC13_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC13_IN_SEL: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC14_IN_SEL_CFG_REG: u32 = 1072972136;
pub const GPIO_SIG14_IN_SEL_V: u32 = 1;
pub const GPIO_SIG14_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC14_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC14_IN_SEL: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC15_IN_SEL_CFG_REG: u32 = 1072972140;
pub const GPIO_SIG15_IN_SEL_V: u32 = 1;
pub const GPIO_SIG15_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC15_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC15_IN_SEL: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC16_IN_SEL_CFG_REG: u32 = 1072972144;
pub const GPIO_SIG16_IN_SEL_V: u32 = 1;
pub const GPIO_SIG16_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC16_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC16_IN_SEL: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC17_IN_SEL_CFG_REG: u32 = 1072972148;
pub const GPIO_SIG17_IN_SEL_V: u32 = 1;
pub const GPIO_SIG17_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC17_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC17_IN_SEL: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC18_IN_SEL_CFG_REG: u32 = 1072972152;
pub const GPIO_SIG18_IN_SEL_V: u32 = 1;
pub const GPIO_SIG18_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC18_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC18_IN_SEL: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC19_IN_SEL_CFG_REG: u32 = 1072972156;
pub const GPIO_SIG19_IN_SEL_V: u32 = 1;
pub const GPIO_SIG19_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC19_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC19_IN_SEL: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC20_IN_SEL_CFG_REG: u32 = 1072972160;
pub const GPIO_SIG20_IN_SEL_V: u32 = 1;
pub const GPIO_SIG20_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC20_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC20_IN_SEL: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC21_IN_SEL_CFG_REG: u32 = 1072972164;
pub const GPIO_SIG21_IN_SEL_V: u32 = 1;
pub const GPIO_SIG21_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC21_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC21_IN_SEL: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC22_IN_SEL_CFG_REG: u32 = 1072972168;
pub const GPIO_SIG22_IN_SEL_V: u32 = 1;
pub const GPIO_SIG22_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC22_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC22_IN_SEL: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC23_IN_SEL_CFG_REG: u32 = 1072972172;
pub const GPIO_SIG23_IN_SEL_V: u32 = 1;
pub const GPIO_SIG23_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC23_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC23_IN_SEL: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC24_IN_SEL_CFG_REG: u32 = 1072972176;
pub const GPIO_SIG24_IN_SEL_V: u32 = 1;
pub const GPIO_SIG24_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC24_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC24_IN_SEL: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC25_IN_SEL_CFG_REG: u32 = 1072972180;
pub const GPIO_SIG25_IN_SEL_V: u32 = 1;
pub const GPIO_SIG25_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC25_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC25_IN_SEL: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC26_IN_SEL_CFG_REG: u32 = 1072972184;
pub const GPIO_SIG26_IN_SEL_V: u32 = 1;
pub const GPIO_SIG26_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC26_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC26_IN_SEL: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC27_IN_SEL_CFG_REG: u32 = 1072972188;
pub const GPIO_SIG27_IN_SEL_V: u32 = 1;
pub const GPIO_SIG27_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC27_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC27_IN_SEL: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC28_IN_SEL_CFG_REG: u32 = 1072972192;
pub const GPIO_SIG28_IN_SEL_V: u32 = 1;
pub const GPIO_SIG28_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC28_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC28_IN_SEL: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC29_IN_SEL_CFG_REG: u32 = 1072972196;
pub const GPIO_SIG29_IN_SEL_V: u32 = 1;
pub const GPIO_SIG29_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC29_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC29_IN_SEL: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC30_IN_SEL_CFG_REG: u32 = 1072972200;
pub const GPIO_SIG30_IN_SEL_V: u32 = 1;
pub const GPIO_SIG30_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC30_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC30_IN_SEL: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC31_IN_SEL_CFG_REG: u32 = 1072972204;
pub const GPIO_SIG31_IN_SEL_V: u32 = 1;
pub const GPIO_SIG31_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC31_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC31_IN_SEL: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC32_IN_SEL_CFG_REG: u32 = 1072972208;
pub const GPIO_SIG32_IN_SEL_V: u32 = 1;
pub const GPIO_SIG32_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC32_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC32_IN_SEL: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC33_IN_SEL_CFG_REG: u32 = 1072972212;
pub const GPIO_SIG33_IN_SEL_V: u32 = 1;
pub const GPIO_SIG33_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC33_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC33_IN_SEL: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC34_IN_SEL_CFG_REG: u32 = 1072972216;
pub const GPIO_SIG34_IN_SEL_V: u32 = 1;
pub const GPIO_SIG34_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC34_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC34_IN_SEL: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC35_IN_SEL_CFG_REG: u32 = 1072972220;
pub const GPIO_SIG35_IN_SEL_V: u32 = 1;
pub const GPIO_SIG35_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC35_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC35_IN_SEL: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC36_IN_SEL_CFG_REG: u32 = 1072972224;
pub const GPIO_SIG36_IN_SEL_V: u32 = 1;
pub const GPIO_SIG36_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC36_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC36_IN_SEL: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC37_IN_SEL_CFG_REG: u32 = 1072972228;
pub const GPIO_SIG37_IN_SEL_V: u32 = 1;
pub const GPIO_SIG37_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC37_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC37_IN_SEL: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC38_IN_SEL_CFG_REG: u32 = 1072972232;
pub const GPIO_SIG38_IN_SEL_V: u32 = 1;
pub const GPIO_SIG38_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC38_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC38_IN_SEL: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC39_IN_SEL_CFG_REG: u32 = 1072972236;
pub const GPIO_SIG39_IN_SEL_V: u32 = 1;
pub const GPIO_SIG39_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC39_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC39_IN_SEL: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC40_IN_SEL_CFG_REG: u32 = 1072972240;
pub const GPIO_SIG40_IN_SEL_V: u32 = 1;
pub const GPIO_SIG40_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC40_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC40_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC40_IN_SEL: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC41_IN_SEL_CFG_REG: u32 = 1072972244;
pub const GPIO_SIG41_IN_SEL_V: u32 = 1;
pub const GPIO_SIG41_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC41_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC41_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC41_IN_SEL: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC42_IN_SEL_CFG_REG: u32 = 1072972248;
pub const GPIO_SIG42_IN_SEL_V: u32 = 1;
pub const GPIO_SIG42_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC42_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC42_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC42_IN_SEL: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC43_IN_SEL_CFG_REG: u32 = 1072972252;
pub const GPIO_SIG43_IN_SEL_V: u32 = 1;
pub const GPIO_SIG43_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC43_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC43_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC43_IN_SEL: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC44_IN_SEL_CFG_REG: u32 = 1072972256;
pub const GPIO_SIG44_IN_SEL_V: u32 = 1;
pub const GPIO_SIG44_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC44_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC44_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC44_IN_SEL: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC45_IN_SEL_CFG_REG: u32 = 1072972260;
pub const GPIO_SIG45_IN_SEL_V: u32 = 1;
pub const GPIO_SIG45_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC45_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC45_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC45_IN_SEL: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC46_IN_SEL_CFG_REG: u32 = 1072972264;
pub const GPIO_SIG46_IN_SEL_V: u32 = 1;
pub const GPIO_SIG46_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC46_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC46_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC46_IN_SEL: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC47_IN_SEL_CFG_REG: u32 = 1072972268;
pub const GPIO_SIG47_IN_SEL_V: u32 = 1;
pub const GPIO_SIG47_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC47_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC47_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC47_IN_SEL: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC48_IN_SEL_CFG_REG: u32 = 1072972272;
pub const GPIO_SIG48_IN_SEL_V: u32 = 1;
pub const GPIO_SIG48_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC48_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC48_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC48_IN_SEL: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC49_IN_SEL_CFG_REG: u32 = 1072972276;
pub const GPIO_SIG49_IN_SEL_V: u32 = 1;
pub const GPIO_SIG49_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC49_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC49_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC49_IN_SEL: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC50_IN_SEL_CFG_REG: u32 = 1072972280;
pub const GPIO_SIG50_IN_SEL_V: u32 = 1;
pub const GPIO_SIG50_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC50_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC50_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC50_IN_SEL: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC51_IN_SEL_CFG_REG: u32 = 1072972284;
pub const GPIO_SIG51_IN_SEL_V: u32 = 1;
pub const GPIO_SIG51_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC51_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC51_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC51_IN_SEL: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC52_IN_SEL_CFG_REG: u32 = 1072972288;
pub const GPIO_SIG52_IN_SEL_V: u32 = 1;
pub const GPIO_SIG52_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC52_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC52_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC52_IN_SEL: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC53_IN_SEL_CFG_REG: u32 = 1072972292;
pub const GPIO_SIG53_IN_SEL_V: u32 = 1;
pub const GPIO_SIG53_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC53_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC53_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC53_IN_SEL: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC54_IN_SEL_CFG_REG: u32 = 1072972296;
pub const GPIO_SIG54_IN_SEL_V: u32 = 1;
pub const GPIO_SIG54_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC54_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC54_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC54_IN_SEL: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC55_IN_SEL_CFG_REG: u32 = 1072972300;
pub const GPIO_SIG55_IN_SEL_V: u32 = 1;
pub const GPIO_SIG55_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC55_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC55_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC55_IN_SEL: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC56_IN_SEL_CFG_REG: u32 = 1072972304;
pub const GPIO_SIG56_IN_SEL_V: u32 = 1;
pub const GPIO_SIG56_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC56_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC56_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC56_IN_SEL: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC57_IN_SEL_CFG_REG: u32 = 1072972308;
pub const GPIO_SIG57_IN_SEL_V: u32 = 1;
pub const GPIO_SIG57_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC57_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC57_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC57_IN_SEL: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC58_IN_SEL_CFG_REG: u32 = 1072972312;
pub const GPIO_SIG58_IN_SEL_V: u32 = 1;
pub const GPIO_SIG58_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC58_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC58_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC58_IN_SEL: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC59_IN_SEL_CFG_REG: u32 = 1072972316;
pub const GPIO_SIG59_IN_SEL_V: u32 = 1;
pub const GPIO_SIG59_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC59_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC59_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC59_IN_SEL: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC60_IN_SEL_CFG_REG: u32 = 1072972320;
pub const GPIO_SIG60_IN_SEL_V: u32 = 1;
pub const GPIO_SIG60_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC60_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC60_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC60_IN_SEL: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC61_IN_SEL_CFG_REG: u32 = 1072972324;
pub const GPIO_SIG61_IN_SEL_V: u32 = 1;
pub const GPIO_SIG61_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC61_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC61_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC61_IN_SEL: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC62_IN_SEL_CFG_REG: u32 = 1072972328;
pub const GPIO_SIG62_IN_SEL_V: u32 = 1;
pub const GPIO_SIG62_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC62_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC62_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC62_IN_SEL: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC63_IN_SEL_CFG_REG: u32 = 1072972332;
pub const GPIO_SIG63_IN_SEL_V: u32 = 1;
pub const GPIO_SIG63_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC63_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC63_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC63_IN_SEL: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC64_IN_SEL_CFG_REG: u32 = 1072972336;
pub const GPIO_SIG64_IN_SEL_V: u32 = 1;
pub const GPIO_SIG64_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC64_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC64_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC64_IN_SEL: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC65_IN_SEL_CFG_REG: u32 = 1072972340;
pub const GPIO_SIG65_IN_SEL_V: u32 = 1;
pub const GPIO_SIG65_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC65_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC65_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC65_IN_SEL: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC66_IN_SEL_CFG_REG: u32 = 1072972344;
pub const GPIO_SIG66_IN_SEL_V: u32 = 1;
pub const GPIO_SIG66_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC66_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC66_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC66_IN_SEL: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC67_IN_SEL_CFG_REG: u32 = 1072972348;
pub const GPIO_SIG67_IN_SEL_V: u32 = 1;
pub const GPIO_SIG67_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC67_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC67_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC67_IN_SEL: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC68_IN_SEL_CFG_REG: u32 = 1072972352;
pub const GPIO_SIG68_IN_SEL_V: u32 = 1;
pub const GPIO_SIG68_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC68_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC68_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC68_IN_SEL: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC69_IN_SEL_CFG_REG: u32 = 1072972356;
pub const GPIO_SIG69_IN_SEL_V: u32 = 1;
pub const GPIO_SIG69_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC69_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC69_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC69_IN_SEL: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC70_IN_SEL_CFG_REG: u32 = 1072972360;
pub const GPIO_SIG70_IN_SEL_V: u32 = 1;
pub const GPIO_SIG70_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC70_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC70_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC70_IN_SEL: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC71_IN_SEL_CFG_REG: u32 = 1072972364;
pub const GPIO_SIG71_IN_SEL_V: u32 = 1;
pub const GPIO_SIG71_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC71_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC71_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC71_IN_SEL: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC72_IN_SEL_CFG_REG: u32 = 1072972368;
pub const GPIO_SIG72_IN_SEL_V: u32 = 1;
pub const GPIO_SIG72_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC72_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC72_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC72_IN_SEL: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC73_IN_SEL_CFG_REG: u32 = 1072972372;
pub const GPIO_SIG73_IN_SEL_V: u32 = 1;
pub const GPIO_SIG73_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC73_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC73_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC73_IN_SEL: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC74_IN_SEL_CFG_REG: u32 = 1072972376;
pub const GPIO_SIG74_IN_SEL_V: u32 = 1;
pub const GPIO_SIG74_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC74_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC74_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC74_IN_SEL: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC75_IN_SEL_CFG_REG: u32 = 1072972380;
pub const GPIO_SIG75_IN_SEL_V: u32 = 1;
pub const GPIO_SIG75_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC75_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC75_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC75_IN_SEL: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC76_IN_SEL_CFG_REG: u32 = 1072972384;
pub const GPIO_SIG76_IN_SEL_V: u32 = 1;
pub const GPIO_SIG76_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC76_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC76_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC76_IN_SEL: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC77_IN_SEL_CFG_REG: u32 = 1072972388;
pub const GPIO_SIG77_IN_SEL_V: u32 = 1;
pub const GPIO_SIG77_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC77_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC77_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC77_IN_SEL: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC78_IN_SEL_CFG_REG: u32 = 1072972392;
pub const GPIO_SIG78_IN_SEL_V: u32 = 1;
pub const GPIO_SIG78_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC78_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC78_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC78_IN_SEL: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC79_IN_SEL_CFG_REG: u32 = 1072972396;
pub const GPIO_SIG79_IN_SEL_V: u32 = 1;
pub const GPIO_SIG79_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC79_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC79_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC79_IN_SEL: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC80_IN_SEL_CFG_REG: u32 = 1072972400;
pub const GPIO_SIG80_IN_SEL_V: u32 = 1;
pub const GPIO_SIG80_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC80_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC80_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC80_IN_SEL: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC81_IN_SEL_CFG_REG: u32 = 1072972404;
pub const GPIO_SIG81_IN_SEL_V: u32 = 1;
pub const GPIO_SIG81_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC81_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC81_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC81_IN_SEL: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC82_IN_SEL_CFG_REG: u32 = 1072972408;
pub const GPIO_SIG82_IN_SEL_V: u32 = 1;
pub const GPIO_SIG82_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC82_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC82_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC82_IN_SEL: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC83_IN_SEL_CFG_REG: u32 = 1072972412;
pub const GPIO_SIG83_IN_SEL_V: u32 = 1;
pub const GPIO_SIG83_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC83_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC83_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC83_IN_SEL: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC84_IN_SEL_CFG_REG: u32 = 1072972416;
pub const GPIO_SIG84_IN_SEL_V: u32 = 1;
pub const GPIO_SIG84_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC84_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC84_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC84_IN_SEL: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC85_IN_SEL_CFG_REG: u32 = 1072972420;
pub const GPIO_SIG85_IN_SEL_V: u32 = 1;
pub const GPIO_SIG85_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC85_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC85_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC85_IN_SEL: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC86_IN_SEL_CFG_REG: u32 = 1072972424;
pub const GPIO_SIG86_IN_SEL_V: u32 = 1;
pub const GPIO_SIG86_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC86_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC86_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC86_IN_SEL: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC87_IN_SEL_CFG_REG: u32 = 1072972428;
pub const GPIO_SIG87_IN_SEL_V: u32 = 1;
pub const GPIO_SIG87_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC87_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC87_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC87_IN_SEL: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC88_IN_SEL_CFG_REG: u32 = 1072972432;
pub const GPIO_SIG88_IN_SEL_V: u32 = 1;
pub const GPIO_SIG88_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC88_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC88_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC88_IN_SEL: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC89_IN_SEL_CFG_REG: u32 = 1072972436;
pub const GPIO_SIG89_IN_SEL_V: u32 = 1;
pub const GPIO_SIG89_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC89_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC89_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC89_IN_SEL: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC90_IN_SEL_CFG_REG: u32 = 1072972440;
pub const GPIO_SIG90_IN_SEL_V: u32 = 1;
pub const GPIO_SIG90_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC90_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC90_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC90_IN_SEL: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC91_IN_SEL_CFG_REG: u32 = 1072972444;
pub const GPIO_SIG91_IN_SEL_V: u32 = 1;
pub const GPIO_SIG91_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC91_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC91_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC91_IN_SEL: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC92_IN_SEL_CFG_REG: u32 = 1072972448;
pub const GPIO_SIG92_IN_SEL_V: u32 = 1;
pub const GPIO_SIG92_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC92_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC92_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC92_IN_SEL: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC93_IN_SEL_CFG_REG: u32 = 1072972452;
pub const GPIO_SIG93_IN_SEL_V: u32 = 1;
pub const GPIO_SIG93_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC93_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC93_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC93_IN_SEL: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC94_IN_SEL_CFG_REG: u32 = 1072972456;
pub const GPIO_SIG94_IN_SEL_V: u32 = 1;
pub const GPIO_SIG94_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC94_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC94_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC94_IN_SEL: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC95_IN_SEL_CFG_REG: u32 = 1072972460;
pub const GPIO_SIG95_IN_SEL_V: u32 = 1;
pub const GPIO_SIG95_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC95_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC95_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC95_IN_SEL: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC96_IN_SEL_CFG_REG: u32 = 1072972464;
pub const GPIO_SIG96_IN_SEL_V: u32 = 1;
pub const GPIO_SIG96_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC96_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC96_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC96_IN_SEL: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC97_IN_SEL_CFG_REG: u32 = 1072972468;
pub const GPIO_SIG97_IN_SEL_V: u32 = 1;
pub const GPIO_SIG97_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC97_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC97_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC97_IN_SEL: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC98_IN_SEL_CFG_REG: u32 = 1072972472;
pub const GPIO_SIG98_IN_SEL_V: u32 = 1;
pub const GPIO_SIG98_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC98_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC98_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC98_IN_SEL: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC99_IN_SEL_CFG_REG: u32 = 1072972476;
pub const GPIO_SIG99_IN_SEL_V: u32 = 1;
pub const GPIO_SIG99_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC99_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC99_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC99_IN_SEL: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC100_IN_SEL_CFG_REG: u32 = 1072972480;
pub const GPIO_SIG100_IN_SEL_V: u32 = 1;
pub const GPIO_SIG100_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC100_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC100_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC100_IN_SEL: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC101_IN_SEL_CFG_REG: u32 = 1072972484;
pub const GPIO_SIG101_IN_SEL_V: u32 = 1;
pub const GPIO_SIG101_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC101_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC101_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC101_IN_SEL: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC102_IN_SEL_CFG_REG: u32 = 1072972488;
pub const GPIO_SIG102_IN_SEL_V: u32 = 1;
pub const GPIO_SIG102_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC102_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC102_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC102_IN_SEL: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC103_IN_SEL_CFG_REG: u32 = 1072972492;
pub const GPIO_SIG103_IN_SEL_V: u32 = 1;
pub const GPIO_SIG103_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC103_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC103_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC103_IN_SEL: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC104_IN_SEL_CFG_REG: u32 = 1072972496;
pub const GPIO_SIG104_IN_SEL_V: u32 = 1;
pub const GPIO_SIG104_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC104_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC104_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC104_IN_SEL: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC105_IN_SEL_CFG_REG: u32 = 1072972500;
pub const GPIO_SIG105_IN_SEL_V: u32 = 1;
pub const GPIO_SIG105_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC105_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC105_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC105_IN_SEL: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC106_IN_SEL_CFG_REG: u32 = 1072972504;
pub const GPIO_SIG106_IN_SEL_V: u32 = 1;
pub const GPIO_SIG106_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC106_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC106_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC106_IN_SEL: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC107_IN_SEL_CFG_REG: u32 = 1072972508;
pub const GPIO_SIG107_IN_SEL_V: u32 = 1;
pub const GPIO_SIG107_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC107_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC107_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC107_IN_SEL: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC108_IN_SEL_CFG_REG: u32 = 1072972512;
pub const GPIO_SIG108_IN_SEL_V: u32 = 1;
pub const GPIO_SIG108_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC108_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC108_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC108_IN_SEL: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC109_IN_SEL_CFG_REG: u32 = 1072972516;
pub const GPIO_SIG109_IN_SEL_V: u32 = 1;
pub const GPIO_SIG109_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC109_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC109_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC109_IN_SEL: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC110_IN_SEL_CFG_REG: u32 = 1072972520;
pub const GPIO_SIG110_IN_SEL_V: u32 = 1;
pub const GPIO_SIG110_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC110_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC110_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC110_IN_SEL: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC111_IN_SEL_CFG_REG: u32 = 1072972524;
pub const GPIO_SIG111_IN_SEL_V: u32 = 1;
pub const GPIO_SIG111_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC111_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC111_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC111_IN_SEL: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC112_IN_SEL_CFG_REG: u32 = 1072972528;
pub const GPIO_SIG112_IN_SEL_V: u32 = 1;
pub const GPIO_SIG112_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC112_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC112_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC112_IN_SEL: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC113_IN_SEL_CFG_REG: u32 = 1072972532;
pub const GPIO_SIG113_IN_SEL_V: u32 = 1;
pub const GPIO_SIG113_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC113_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC113_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC113_IN_SEL: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC114_IN_SEL_CFG_REG: u32 = 1072972536;
pub const GPIO_SIG114_IN_SEL_V: u32 = 1;
pub const GPIO_SIG114_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC114_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC114_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC114_IN_SEL: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC115_IN_SEL_CFG_REG: u32 = 1072972540;
pub const GPIO_SIG115_IN_SEL_V: u32 = 1;
pub const GPIO_SIG115_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC115_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC115_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC115_IN_SEL: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC116_IN_SEL_CFG_REG: u32 = 1072972544;
pub const GPIO_SIG116_IN_SEL_V: u32 = 1;
pub const GPIO_SIG116_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC116_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC116_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC116_IN_SEL: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC117_IN_SEL_CFG_REG: u32 = 1072972548;
pub const GPIO_SIG117_IN_SEL_V: u32 = 1;
pub const GPIO_SIG117_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC117_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC117_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC117_IN_SEL: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC118_IN_SEL_CFG_REG: u32 = 1072972552;
pub const GPIO_SIG118_IN_SEL_V: u32 = 1;
pub const GPIO_SIG118_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC118_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC118_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC118_IN_SEL: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC119_IN_SEL_CFG_REG: u32 = 1072972556;
pub const GPIO_SIG119_IN_SEL_V: u32 = 1;
pub const GPIO_SIG119_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC119_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC119_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC119_IN_SEL: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC120_IN_SEL_CFG_REG: u32 = 1072972560;
pub const GPIO_SIG120_IN_SEL_V: u32 = 1;
pub const GPIO_SIG120_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC120_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC120_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC120_IN_SEL: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC121_IN_SEL_CFG_REG: u32 = 1072972564;
pub const GPIO_SIG121_IN_SEL_V: u32 = 1;
pub const GPIO_SIG121_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC121_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC121_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC121_IN_SEL: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC122_IN_SEL_CFG_REG: u32 = 1072972568;
pub const GPIO_SIG122_IN_SEL_V: u32 = 1;
pub const GPIO_SIG122_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC122_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC122_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC122_IN_SEL: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC123_IN_SEL_CFG_REG: u32 = 1072972572;
pub const GPIO_SIG123_IN_SEL_V: u32 = 1;
pub const GPIO_SIG123_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC123_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC123_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC123_IN_SEL: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC124_IN_SEL_CFG_REG: u32 = 1072972576;
pub const GPIO_SIG124_IN_SEL_V: u32 = 1;
pub const GPIO_SIG124_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC124_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC124_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC124_IN_SEL: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC125_IN_SEL_CFG_REG: u32 = 1072972580;
pub const GPIO_SIG125_IN_SEL_V: u32 = 1;
pub const GPIO_SIG125_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC125_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC125_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC125_IN_SEL: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC126_IN_SEL_CFG_REG: u32 = 1072972584;
pub const GPIO_SIG126_IN_SEL_V: u32 = 1;
pub const GPIO_SIG126_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC126_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC126_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC126_IN_SEL: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC127_IN_SEL_CFG_REG: u32 = 1072972588;
pub const GPIO_SIG127_IN_SEL_V: u32 = 1;
pub const GPIO_SIG127_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC127_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC127_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC127_IN_SEL: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC128_IN_SEL_CFG_REG: u32 = 1072972592;
pub const GPIO_SIG128_IN_SEL_V: u32 = 1;
pub const GPIO_SIG128_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC128_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC128_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC128_IN_SEL: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC129_IN_SEL_CFG_REG: u32 = 1072972596;
pub const GPIO_SIG129_IN_SEL_V: u32 = 1;
pub const GPIO_SIG129_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC129_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC129_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC129_IN_SEL: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC130_IN_SEL_CFG_REG: u32 = 1072972600;
pub const GPIO_SIG130_IN_SEL_V: u32 = 1;
pub const GPIO_SIG130_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC130_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC130_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC130_IN_SEL: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC131_IN_SEL_CFG_REG: u32 = 1072972604;
pub const GPIO_SIG131_IN_SEL_V: u32 = 1;
pub const GPIO_SIG131_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC131_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC131_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC131_IN_SEL: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC132_IN_SEL_CFG_REG: u32 = 1072972608;
pub const GPIO_SIG132_IN_SEL_V: u32 = 1;
pub const GPIO_SIG132_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC132_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC132_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC132_IN_SEL: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC133_IN_SEL_CFG_REG: u32 = 1072972612;
pub const GPIO_SIG133_IN_SEL_V: u32 = 1;
pub const GPIO_SIG133_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC133_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC133_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC133_IN_SEL: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC134_IN_SEL_CFG_REG: u32 = 1072972616;
pub const GPIO_SIG134_IN_SEL_V: u32 = 1;
pub const GPIO_SIG134_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC134_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC134_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC134_IN_SEL: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC135_IN_SEL_CFG_REG: u32 = 1072972620;
pub const GPIO_SIG135_IN_SEL_V: u32 = 1;
pub const GPIO_SIG135_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC135_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC135_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC135_IN_SEL: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC136_IN_SEL_CFG_REG: u32 = 1072972624;
pub const GPIO_SIG136_IN_SEL_V: u32 = 1;
pub const GPIO_SIG136_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC136_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC136_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC136_IN_SEL: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC137_IN_SEL_CFG_REG: u32 = 1072972628;
pub const GPIO_SIG137_IN_SEL_V: u32 = 1;
pub const GPIO_SIG137_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC137_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC137_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC137_IN_SEL: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC138_IN_SEL_CFG_REG: u32 = 1072972632;
pub const GPIO_SIG138_IN_SEL_V: u32 = 1;
pub const GPIO_SIG138_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC138_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC138_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC138_IN_SEL: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC139_IN_SEL_CFG_REG: u32 = 1072972636;
pub const GPIO_SIG139_IN_SEL_V: u32 = 1;
pub const GPIO_SIG139_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC139_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC139_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC139_IN_SEL: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC140_IN_SEL_CFG_REG: u32 = 1072972640;
pub const GPIO_SIG140_IN_SEL_V: u32 = 1;
pub const GPIO_SIG140_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC140_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC140_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC140_IN_SEL: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC141_IN_SEL_CFG_REG: u32 = 1072972644;
pub const GPIO_SIG141_IN_SEL_V: u32 = 1;
pub const GPIO_SIG141_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC141_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC141_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC141_IN_SEL: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC142_IN_SEL_CFG_REG: u32 = 1072972648;
pub const GPIO_SIG142_IN_SEL_V: u32 = 1;
pub const GPIO_SIG142_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC142_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC142_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC142_IN_SEL: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC143_IN_SEL_CFG_REG: u32 = 1072972652;
pub const GPIO_SIG143_IN_SEL_V: u32 = 1;
pub const GPIO_SIG143_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC143_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC143_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC143_IN_SEL: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC144_IN_SEL_CFG_REG: u32 = 1072972656;
pub const GPIO_SIG144_IN_SEL_V: u32 = 1;
pub const GPIO_SIG144_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC144_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC144_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC144_IN_SEL: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC145_IN_SEL_CFG_REG: u32 = 1072972660;
pub const GPIO_SIG145_IN_SEL_V: u32 = 1;
pub const GPIO_SIG145_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC145_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC145_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC145_IN_SEL: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC146_IN_SEL_CFG_REG: u32 = 1072972664;
pub const GPIO_SIG146_IN_SEL_V: u32 = 1;
pub const GPIO_SIG146_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC146_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC146_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC146_IN_SEL: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC147_IN_SEL_CFG_REG: u32 = 1072972668;
pub const GPIO_SIG147_IN_SEL_V: u32 = 1;
pub const GPIO_SIG147_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC147_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC147_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC147_IN_SEL: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC148_IN_SEL_CFG_REG: u32 = 1072972672;
pub const GPIO_SIG148_IN_SEL_V: u32 = 1;
pub const GPIO_SIG148_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC148_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC148_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC148_IN_SEL: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC149_IN_SEL_CFG_REG: u32 = 1072972676;
pub const GPIO_SIG149_IN_SEL_V: u32 = 1;
pub const GPIO_SIG149_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC149_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC149_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC149_IN_SEL: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC150_IN_SEL_CFG_REG: u32 = 1072972680;
pub const GPIO_SIG150_IN_SEL_V: u32 = 1;
pub const GPIO_SIG150_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC150_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC150_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC150_IN_SEL: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC151_IN_SEL_CFG_REG: u32 = 1072972684;
pub const GPIO_SIG151_IN_SEL_V: u32 = 1;
pub const GPIO_SIG151_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC151_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC151_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC151_IN_SEL: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC152_IN_SEL_CFG_REG: u32 = 1072972688;
pub const GPIO_SIG152_IN_SEL_V: u32 = 1;
pub const GPIO_SIG152_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC152_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC152_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC152_IN_SEL: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC153_IN_SEL_CFG_REG: u32 = 1072972692;
pub const GPIO_SIG153_IN_SEL_V: u32 = 1;
pub const GPIO_SIG153_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC153_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC153_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC153_IN_SEL: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC154_IN_SEL_CFG_REG: u32 = 1072972696;
pub const GPIO_SIG154_IN_SEL_V: u32 = 1;
pub const GPIO_SIG154_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC154_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC154_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC154_IN_SEL: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC155_IN_SEL_CFG_REG: u32 = 1072972700;
pub const GPIO_SIG155_IN_SEL_V: u32 = 1;
pub const GPIO_SIG155_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC155_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC155_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC155_IN_SEL: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC156_IN_SEL_CFG_REG: u32 = 1072972704;
pub const GPIO_SIG156_IN_SEL_V: u32 = 1;
pub const GPIO_SIG156_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC156_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC156_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC156_IN_SEL: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC157_IN_SEL_CFG_REG: u32 = 1072972708;
pub const GPIO_SIG157_IN_SEL_V: u32 = 1;
pub const GPIO_SIG157_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC157_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC157_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC157_IN_SEL: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC158_IN_SEL_CFG_REG: u32 = 1072972712;
pub const GPIO_SIG158_IN_SEL_V: u32 = 1;
pub const GPIO_SIG158_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC158_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC158_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC158_IN_SEL: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC159_IN_SEL_CFG_REG: u32 = 1072972716;
pub const GPIO_SIG159_IN_SEL_V: u32 = 1;
pub const GPIO_SIG159_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC159_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC159_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC159_IN_SEL: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC160_IN_SEL_CFG_REG: u32 = 1072972720;
pub const GPIO_SIG160_IN_SEL_V: u32 = 1;
pub const GPIO_SIG160_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC160_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC160_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC160_IN_SEL: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC161_IN_SEL_CFG_REG: u32 = 1072972724;
pub const GPIO_SIG161_IN_SEL_V: u32 = 1;
pub const GPIO_SIG161_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC161_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC161_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC161_IN_SEL: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC162_IN_SEL_CFG_REG: u32 = 1072972728;
pub const GPIO_SIG162_IN_SEL_V: u32 = 1;
pub const GPIO_SIG162_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC162_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC162_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC162_IN_SEL: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC163_IN_SEL_CFG_REG: u32 = 1072972732;
pub const GPIO_SIG163_IN_SEL_V: u32 = 1;
pub const GPIO_SIG163_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC163_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC163_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC163_IN_SEL: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC164_IN_SEL_CFG_REG: u32 = 1072972736;
pub const GPIO_SIG164_IN_SEL_V: u32 = 1;
pub const GPIO_SIG164_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC164_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC164_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC164_IN_SEL: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC165_IN_SEL_CFG_REG: u32 = 1072972740;
pub const GPIO_SIG165_IN_SEL_V: u32 = 1;
pub const GPIO_SIG165_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC165_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC165_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC165_IN_SEL: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC166_IN_SEL_CFG_REG: u32 = 1072972744;
pub const GPIO_SIG166_IN_SEL_V: u32 = 1;
pub const GPIO_SIG166_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC166_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC166_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC166_IN_SEL: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC167_IN_SEL_CFG_REG: u32 = 1072972748;
pub const GPIO_SIG167_IN_SEL_V: u32 = 1;
pub const GPIO_SIG167_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC167_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC167_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC167_IN_SEL: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC168_IN_SEL_CFG_REG: u32 = 1072972752;
pub const GPIO_SIG168_IN_SEL_V: u32 = 1;
pub const GPIO_SIG168_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC168_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC168_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC168_IN_SEL: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC169_IN_SEL_CFG_REG: u32 = 1072972756;
pub const GPIO_SIG169_IN_SEL_V: u32 = 1;
pub const GPIO_SIG169_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC169_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC169_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC169_IN_SEL: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC170_IN_SEL_CFG_REG: u32 = 1072972760;
pub const GPIO_SIG170_IN_SEL_V: u32 = 1;
pub const GPIO_SIG170_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC170_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC170_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC170_IN_SEL: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC171_IN_SEL_CFG_REG: u32 = 1072972764;
pub const GPIO_SIG171_IN_SEL_V: u32 = 1;
pub const GPIO_SIG171_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC171_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC171_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC171_IN_SEL: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC172_IN_SEL_CFG_REG: u32 = 1072972768;
pub const GPIO_SIG172_IN_SEL_V: u32 = 1;
pub const GPIO_SIG172_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC172_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC172_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC172_IN_SEL: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC173_IN_SEL_CFG_REG: u32 = 1072972772;
pub const GPIO_SIG173_IN_SEL_V: u32 = 1;
pub const GPIO_SIG173_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC173_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC173_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC173_IN_SEL: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC174_IN_SEL_CFG_REG: u32 = 1072972776;
pub const GPIO_SIG174_IN_SEL_V: u32 = 1;
pub const GPIO_SIG174_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC174_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC174_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC174_IN_SEL: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC175_IN_SEL_CFG_REG: u32 = 1072972780;
pub const GPIO_SIG175_IN_SEL_V: u32 = 1;
pub const GPIO_SIG175_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC175_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC175_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC175_IN_SEL: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC176_IN_SEL_CFG_REG: u32 = 1072972784;
pub const GPIO_SIG176_IN_SEL_V: u32 = 1;
pub const GPIO_SIG176_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC176_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC176_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC176_IN_SEL: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC177_IN_SEL_CFG_REG: u32 = 1072972788;
pub const GPIO_SIG177_IN_SEL_V: u32 = 1;
pub const GPIO_SIG177_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC177_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC177_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC177_IN_SEL: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC178_IN_SEL_CFG_REG: u32 = 1072972792;
pub const GPIO_SIG178_IN_SEL_V: u32 = 1;
pub const GPIO_SIG178_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC178_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC178_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC178_IN_SEL: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC179_IN_SEL_CFG_REG: u32 = 1072972796;
pub const GPIO_SIG179_IN_SEL_V: u32 = 1;
pub const GPIO_SIG179_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC179_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC179_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC179_IN_SEL: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC180_IN_SEL_CFG_REG: u32 = 1072972800;
pub const GPIO_SIG180_IN_SEL_V: u32 = 1;
pub const GPIO_SIG180_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC180_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC180_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC180_IN_SEL: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC181_IN_SEL_CFG_REG: u32 = 1072972804;
pub const GPIO_SIG181_IN_SEL_V: u32 = 1;
pub const GPIO_SIG181_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC181_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC181_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC181_IN_SEL: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC182_IN_SEL_CFG_REG: u32 = 1072972808;
pub const GPIO_SIG182_IN_SEL_V: u32 = 1;
pub const GPIO_SIG182_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC182_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC182_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC182_IN_SEL: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC183_IN_SEL_CFG_REG: u32 = 1072972812;
pub const GPIO_SIG183_IN_SEL_V: u32 = 1;
pub const GPIO_SIG183_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC183_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC183_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC183_IN_SEL: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC184_IN_SEL_CFG_REG: u32 = 1072972816;
pub const GPIO_SIG184_IN_SEL_V: u32 = 1;
pub const GPIO_SIG184_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC184_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC184_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC184_IN_SEL: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC185_IN_SEL_CFG_REG: u32 = 1072972820;
pub const GPIO_SIG185_IN_SEL_V: u32 = 1;
pub const GPIO_SIG185_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC185_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC185_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC185_IN_SEL: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC186_IN_SEL_CFG_REG: u32 = 1072972824;
pub const GPIO_SIG186_IN_SEL_V: u32 = 1;
pub const GPIO_SIG186_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC186_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC186_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC186_IN_SEL: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC187_IN_SEL_CFG_REG: u32 = 1072972828;
pub const GPIO_SIG187_IN_SEL_V: u32 = 1;
pub const GPIO_SIG187_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC187_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC187_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC187_IN_SEL: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC188_IN_SEL_CFG_REG: u32 = 1072972832;
pub const GPIO_SIG188_IN_SEL_V: u32 = 1;
pub const GPIO_SIG188_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC188_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC188_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC188_IN_SEL: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC189_IN_SEL_CFG_REG: u32 = 1072972836;
pub const GPIO_SIG189_IN_SEL_V: u32 = 1;
pub const GPIO_SIG189_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC189_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC189_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC189_IN_SEL: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC190_IN_SEL_CFG_REG: u32 = 1072972840;
pub const GPIO_SIG190_IN_SEL_V: u32 = 1;
pub const GPIO_SIG190_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC190_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC190_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC190_IN_SEL: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC191_IN_SEL_CFG_REG: u32 = 1072972844;
pub const GPIO_SIG191_IN_SEL_V: u32 = 1;
pub const GPIO_SIG191_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC191_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC191_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC191_IN_SEL: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC192_IN_SEL_CFG_REG: u32 = 1072972848;
pub const GPIO_SIG192_IN_SEL_V: u32 = 1;
pub const GPIO_SIG192_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC192_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC192_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC192_IN_SEL: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC193_IN_SEL_CFG_REG: u32 = 1072972852;
pub const GPIO_SIG193_IN_SEL_V: u32 = 1;
pub const GPIO_SIG193_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC193_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC193_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC193_IN_SEL: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC194_IN_SEL_CFG_REG: u32 = 1072972856;
pub const GPIO_SIG194_IN_SEL_V: u32 = 1;
pub const GPIO_SIG194_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC194_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC194_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC194_IN_SEL: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC195_IN_SEL_CFG_REG: u32 = 1072972860;
pub const GPIO_SIG195_IN_SEL_V: u32 = 1;
pub const GPIO_SIG195_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC195_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC195_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC195_IN_SEL: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC196_IN_SEL_CFG_REG: u32 = 1072972864;
pub const GPIO_SIG196_IN_SEL_V: u32 = 1;
pub const GPIO_SIG196_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC196_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC196_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC196_IN_SEL: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC197_IN_SEL_CFG_REG: u32 = 1072972868;
pub const GPIO_SIG197_IN_SEL_V: u32 = 1;
pub const GPIO_SIG197_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC197_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC197_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC197_IN_SEL: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC198_IN_SEL_CFG_REG: u32 = 1072972872;
pub const GPIO_SIG198_IN_SEL_V: u32 = 1;
pub const GPIO_SIG198_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC198_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC198_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC198_IN_SEL: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC199_IN_SEL_CFG_REG: u32 = 1072972876;
pub const GPIO_SIG199_IN_SEL_V: u32 = 1;
pub const GPIO_SIG199_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC199_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC199_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC199_IN_SEL: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC200_IN_SEL_CFG_REG: u32 = 1072972880;
pub const GPIO_SIG200_IN_SEL_V: u32 = 1;
pub const GPIO_SIG200_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC200_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC200_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC200_IN_SEL: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC201_IN_SEL_CFG_REG: u32 = 1072972884;
pub const GPIO_SIG201_IN_SEL_V: u32 = 1;
pub const GPIO_SIG201_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC201_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC201_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC201_IN_SEL: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC202_IN_SEL_CFG_REG: u32 = 1072972888;
pub const GPIO_SIG202_IN_SEL_V: u32 = 1;
pub const GPIO_SIG202_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC202_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC202_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC202_IN_SEL: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC203_IN_SEL_CFG_REG: u32 = 1072972892;
pub const GPIO_SIG203_IN_SEL_V: u32 = 1;
pub const GPIO_SIG203_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC203_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC203_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC203_IN_SEL: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC204_IN_SEL_CFG_REG: u32 = 1072972896;
pub const GPIO_SIG204_IN_SEL_V: u32 = 1;
pub const GPIO_SIG204_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC204_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC204_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC204_IN_SEL: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC205_IN_SEL_CFG_REG: u32 = 1072972900;
pub const GPIO_SIG205_IN_SEL_V: u32 = 1;
pub const GPIO_SIG205_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC205_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC205_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC205_IN_SEL: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC206_IN_SEL_CFG_REG: u32 = 1072972904;
pub const GPIO_SIG206_IN_SEL_V: u32 = 1;
pub const GPIO_SIG206_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC206_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC206_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC206_IN_SEL: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC207_IN_SEL_CFG_REG: u32 = 1072972908;
pub const GPIO_SIG207_IN_SEL_V: u32 = 1;
pub const GPIO_SIG207_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC207_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC207_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC207_IN_SEL: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC208_IN_SEL_CFG_REG: u32 = 1072972912;
pub const GPIO_SIG208_IN_SEL_V: u32 = 1;
pub const GPIO_SIG208_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC208_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC208_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC208_IN_SEL: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC209_IN_SEL_CFG_REG: u32 = 1072972916;
pub const GPIO_SIG209_IN_SEL_V: u32 = 1;
pub const GPIO_SIG209_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC209_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC209_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC209_IN_SEL: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC210_IN_SEL_CFG_REG: u32 = 1072972920;
pub const GPIO_SIG210_IN_SEL_V: u32 = 1;
pub const GPIO_SIG210_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC210_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC210_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC210_IN_SEL: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC211_IN_SEL_CFG_REG: u32 = 1072972924;
pub const GPIO_SIG211_IN_SEL_V: u32 = 1;
pub const GPIO_SIG211_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC211_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC211_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC211_IN_SEL: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC212_IN_SEL_CFG_REG: u32 = 1072972928;
pub const GPIO_SIG212_IN_SEL_V: u32 = 1;
pub const GPIO_SIG212_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC212_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC212_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC212_IN_SEL: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC213_IN_SEL_CFG_REG: u32 = 1072972932;
pub const GPIO_SIG213_IN_SEL_V: u32 = 1;
pub const GPIO_SIG213_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC213_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC213_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC213_IN_SEL: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC214_IN_SEL_CFG_REG: u32 = 1072972936;
pub const GPIO_SIG214_IN_SEL_V: u32 = 1;
pub const GPIO_SIG214_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC214_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC214_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC214_IN_SEL: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC215_IN_SEL_CFG_REG: u32 = 1072972940;
pub const GPIO_SIG215_IN_SEL_V: u32 = 1;
pub const GPIO_SIG215_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC215_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC215_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC215_IN_SEL: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC216_IN_SEL_CFG_REG: u32 = 1072972944;
pub const GPIO_SIG216_IN_SEL_V: u32 = 1;
pub const GPIO_SIG216_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC216_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC216_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC216_IN_SEL: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC217_IN_SEL_CFG_REG: u32 = 1072972948;
pub const GPIO_SIG217_IN_SEL_V: u32 = 1;
pub const GPIO_SIG217_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC217_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC217_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC217_IN_SEL: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC218_IN_SEL_CFG_REG: u32 = 1072972952;
pub const GPIO_SIG218_IN_SEL_V: u32 = 1;
pub const GPIO_SIG218_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC218_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC218_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC218_IN_SEL: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC219_IN_SEL_CFG_REG: u32 = 1072972956;
pub const GPIO_SIG219_IN_SEL_V: u32 = 1;
pub const GPIO_SIG219_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC219_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC219_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC219_IN_SEL: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC220_IN_SEL_CFG_REG: u32 = 1072972960;
pub const GPIO_SIG220_IN_SEL_V: u32 = 1;
pub const GPIO_SIG220_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC220_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC220_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC220_IN_SEL: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC221_IN_SEL_CFG_REG: u32 = 1072972964;
pub const GPIO_SIG221_IN_SEL_V: u32 = 1;
pub const GPIO_SIG221_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC221_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC221_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC221_IN_SEL: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC222_IN_SEL_CFG_REG: u32 = 1072972968;
pub const GPIO_SIG222_IN_SEL_V: u32 = 1;
pub const GPIO_SIG222_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC222_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC222_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC222_IN_SEL: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC223_IN_SEL_CFG_REG: u32 = 1072972972;
pub const GPIO_SIG223_IN_SEL_V: u32 = 1;
pub const GPIO_SIG223_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC223_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC223_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC223_IN_SEL: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC224_IN_SEL_CFG_REG: u32 = 1072972976;
pub const GPIO_SIG224_IN_SEL_V: u32 = 1;
pub const GPIO_SIG224_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC224_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC224_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC224_IN_SEL: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC225_IN_SEL_CFG_REG: u32 = 1072972980;
pub const GPIO_SIG225_IN_SEL_V: u32 = 1;
pub const GPIO_SIG225_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC225_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC225_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC225_IN_SEL: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC226_IN_SEL_CFG_REG: u32 = 1072972984;
pub const GPIO_SIG226_IN_SEL_V: u32 = 1;
pub const GPIO_SIG226_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC226_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC226_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC226_IN_SEL: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC227_IN_SEL_CFG_REG: u32 = 1072972988;
pub const GPIO_SIG227_IN_SEL_V: u32 = 1;
pub const GPIO_SIG227_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC227_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC227_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC227_IN_SEL: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC228_IN_SEL_CFG_REG: u32 = 1072972992;
pub const GPIO_SIG228_IN_SEL_V: u32 = 1;
pub const GPIO_SIG228_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC228_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC228_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC228_IN_SEL: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC229_IN_SEL_CFG_REG: u32 = 1072972996;
pub const GPIO_SIG229_IN_SEL_V: u32 = 1;
pub const GPIO_SIG229_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC229_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC229_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC229_IN_SEL: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC230_IN_SEL_CFG_REG: u32 = 1072973000;
pub const GPIO_SIG230_IN_SEL_V: u32 = 1;
pub const GPIO_SIG230_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC230_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC230_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC230_IN_SEL: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC231_IN_SEL_CFG_REG: u32 = 1072973004;
pub const GPIO_SIG231_IN_SEL_V: u32 = 1;
pub const GPIO_SIG231_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC231_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC231_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC231_IN_SEL: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC232_IN_SEL_CFG_REG: u32 = 1072973008;
pub const GPIO_SIG232_IN_SEL_V: u32 = 1;
pub const GPIO_SIG232_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC232_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC232_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC232_IN_SEL: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC233_IN_SEL_CFG_REG: u32 = 1072973012;
pub const GPIO_SIG233_IN_SEL_V: u32 = 1;
pub const GPIO_SIG233_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC233_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC233_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC233_IN_SEL: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC234_IN_SEL_CFG_REG: u32 = 1072973016;
pub const GPIO_SIG234_IN_SEL_V: u32 = 1;
pub const GPIO_SIG234_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC234_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC234_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC234_IN_SEL: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC235_IN_SEL_CFG_REG: u32 = 1072973020;
pub const GPIO_SIG235_IN_SEL_V: u32 = 1;
pub const GPIO_SIG235_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC235_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC235_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC235_IN_SEL: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC236_IN_SEL_CFG_REG: u32 = 1072973024;
pub const GPIO_SIG236_IN_SEL_V: u32 = 1;
pub const GPIO_SIG236_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC236_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC236_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC236_IN_SEL: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC237_IN_SEL_CFG_REG: u32 = 1072973028;
pub const GPIO_SIG237_IN_SEL_V: u32 = 1;
pub const GPIO_SIG237_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC237_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC237_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC237_IN_SEL: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC238_IN_SEL_CFG_REG: u32 = 1072973032;
pub const GPIO_SIG238_IN_SEL_V: u32 = 1;
pub const GPIO_SIG238_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC238_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC238_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC238_IN_SEL: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC239_IN_SEL_CFG_REG: u32 = 1072973036;
pub const GPIO_SIG239_IN_SEL_V: u32 = 1;
pub const GPIO_SIG239_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC239_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC239_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC239_IN_SEL: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC240_IN_SEL_CFG_REG: u32 = 1072973040;
pub const GPIO_SIG240_IN_SEL_V: u32 = 1;
pub const GPIO_SIG240_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC240_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC240_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC240_IN_SEL: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC241_IN_SEL_CFG_REG: u32 = 1072973044;
pub const GPIO_SIG241_IN_SEL_V: u32 = 1;
pub const GPIO_SIG241_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC241_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC241_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC241_IN_SEL: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC242_IN_SEL_CFG_REG: u32 = 1072973048;
pub const GPIO_SIG242_IN_SEL_V: u32 = 1;
pub const GPIO_SIG242_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC242_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC242_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC242_IN_SEL: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC243_IN_SEL_CFG_REG: u32 = 1072973052;
pub const GPIO_SIG243_IN_SEL_V: u32 = 1;
pub const GPIO_SIG243_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC243_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC243_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC243_IN_SEL: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC244_IN_SEL_CFG_REG: u32 = 1072973056;
pub const GPIO_SIG244_IN_SEL_V: u32 = 1;
pub const GPIO_SIG244_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC244_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC244_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC244_IN_SEL: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC245_IN_SEL_CFG_REG: u32 = 1072973060;
pub const GPIO_SIG245_IN_SEL_V: u32 = 1;
pub const GPIO_SIG245_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC245_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC245_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC245_IN_SEL: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC246_IN_SEL_CFG_REG: u32 = 1072973064;
pub const GPIO_SIG246_IN_SEL_V: u32 = 1;
pub const GPIO_SIG246_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC246_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC246_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC246_IN_SEL: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC247_IN_SEL_CFG_REG: u32 = 1072973068;
pub const GPIO_SIG247_IN_SEL_V: u32 = 1;
pub const GPIO_SIG247_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC247_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC247_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC247_IN_SEL: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC248_IN_SEL_CFG_REG: u32 = 1072973072;
pub const GPIO_SIG248_IN_SEL_V: u32 = 1;
pub const GPIO_SIG248_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC248_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC248_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC248_IN_SEL: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC249_IN_SEL_CFG_REG: u32 = 1072973076;
pub const GPIO_SIG249_IN_SEL_V: u32 = 1;
pub const GPIO_SIG249_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC249_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC249_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC249_IN_SEL: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC250_IN_SEL_CFG_REG: u32 = 1072973080;
pub const GPIO_SIG250_IN_SEL_V: u32 = 1;
pub const GPIO_SIG250_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC250_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC250_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC250_IN_SEL: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC251_IN_SEL_CFG_REG: u32 = 1072973084;
pub const GPIO_SIG251_IN_SEL_V: u32 = 1;
pub const GPIO_SIG251_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC251_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC251_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC251_IN_SEL: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC252_IN_SEL_CFG_REG: u32 = 1072973088;
pub const GPIO_SIG252_IN_SEL_V: u32 = 1;
pub const GPIO_SIG252_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC252_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC252_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC252_IN_SEL: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC253_IN_SEL_CFG_REG: u32 = 1072973092;
pub const GPIO_SIG253_IN_SEL_V: u32 = 1;
pub const GPIO_SIG253_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC253_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC253_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC253_IN_SEL: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC254_IN_SEL_CFG_REG: u32 = 1072973096;
pub const GPIO_SIG254_IN_SEL_V: u32 = 1;
pub const GPIO_SIG254_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC254_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC254_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC254_IN_SEL: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC255_IN_SEL_CFG_REG: u32 = 1072973100;
pub const GPIO_SIG255_IN_SEL_V: u32 = 1;
pub const GPIO_SIG255_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC255_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC255_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC255_IN_SEL: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC0_OUT_SEL_CFG_REG: u32 = 1072973104;
pub const GPIO_FUNC0_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC0_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC0_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC0_OUT_SEL: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC1_OUT_SEL_CFG_REG: u32 = 1072973108;
pub const GPIO_FUNC1_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC1_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC1_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC1_OUT_SEL: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC2_OUT_SEL_CFG_REG: u32 = 1072973112;
pub const GPIO_FUNC2_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC2_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC2_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC2_OUT_SEL: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC3_OUT_SEL_CFG_REG: u32 = 1072973116;
pub const GPIO_FUNC3_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC3_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC3_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC3_OUT_SEL: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC4_OUT_SEL_CFG_REG: u32 = 1072973120;
pub const GPIO_FUNC4_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC4_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC4_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC4_OUT_SEL: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC5_OUT_SEL_CFG_REG: u32 = 1072973124;
pub const GPIO_FUNC5_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC5_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC5_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC5_OUT_SEL: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC6_OUT_SEL_CFG_REG: u32 = 1072973128;
pub const GPIO_FUNC6_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC6_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC6_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC6_OUT_SEL: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC7_OUT_SEL_CFG_REG: u32 = 1072973132;
pub const GPIO_FUNC7_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC7_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC7_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC7_OUT_SEL: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC8_OUT_SEL_CFG_REG: u32 = 1072973136;
pub const GPIO_FUNC8_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC8_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC8_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC8_OUT_SEL: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC9_OUT_SEL_CFG_REG: u32 = 1072973140;
pub const GPIO_FUNC9_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC9_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC9_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC9_OUT_SEL: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC10_OUT_SEL_CFG_REG: u32 = 1072973144;
pub const GPIO_FUNC10_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC10_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC10_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC10_OUT_SEL: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC11_OUT_SEL_CFG_REG: u32 = 1072973148;
pub const GPIO_FUNC11_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC11_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC11_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC11_OUT_SEL: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC12_OUT_SEL_CFG_REG: u32 = 1072973152;
pub const GPIO_FUNC12_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC12_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC12_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC12_OUT_SEL: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC13_OUT_SEL_CFG_REG: u32 = 1072973156;
pub const GPIO_FUNC13_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC13_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC13_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC13_OUT_SEL: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC14_OUT_SEL_CFG_REG: u32 = 1072973160;
pub const GPIO_FUNC14_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC14_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC14_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC14_OUT_SEL: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC15_OUT_SEL_CFG_REG: u32 = 1072973164;
pub const GPIO_FUNC15_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC15_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC15_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC15_OUT_SEL: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC16_OUT_SEL_CFG_REG: u32 = 1072973168;
pub const GPIO_FUNC16_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC16_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC16_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC16_OUT_SEL: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC17_OUT_SEL_CFG_REG: u32 = 1072973172;
pub const GPIO_FUNC17_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC17_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC17_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC17_OUT_SEL: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC18_OUT_SEL_CFG_REG: u32 = 1072973176;
pub const GPIO_FUNC18_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC18_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC18_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC18_OUT_SEL: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC19_OUT_SEL_CFG_REG: u32 = 1072973180;
pub const GPIO_FUNC19_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC19_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC19_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC19_OUT_SEL: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC20_OUT_SEL_CFG_REG: u32 = 1072973184;
pub const GPIO_FUNC20_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC20_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC20_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC20_OUT_SEL: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC21_OUT_SEL_CFG_REG: u32 = 1072973188;
pub const GPIO_FUNC21_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC21_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC21_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC21_OUT_SEL: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC22_OUT_SEL_CFG_REG: u32 = 1072973192;
pub const GPIO_FUNC22_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC22_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC22_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC22_OUT_SEL: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC23_OUT_SEL_CFG_REG: u32 = 1072973196;
pub const GPIO_FUNC23_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC23_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC23_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC23_OUT_SEL: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC24_OUT_SEL_CFG_REG: u32 = 1072973200;
pub const GPIO_FUNC24_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC24_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC24_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC24_OUT_SEL: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC25_OUT_SEL_CFG_REG: u32 = 1072973204;
pub const GPIO_FUNC25_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC25_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC25_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC25_OUT_SEL: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC26_OUT_SEL_CFG_REG: u32 = 1072973208;
pub const GPIO_FUNC26_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC26_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC26_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC26_OUT_SEL: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC27_OUT_SEL_CFG_REG: u32 = 1072973212;
pub const GPIO_FUNC27_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC27_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC27_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC27_OUT_SEL: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC28_OUT_SEL_CFG_REG: u32 = 1072973216;
pub const GPIO_FUNC28_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC28_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC28_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC28_OUT_SEL: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC29_OUT_SEL_CFG_REG: u32 = 1072973220;
pub const GPIO_FUNC29_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC29_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC29_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC29_OUT_SEL: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC30_OUT_SEL_CFG_REG: u32 = 1072973224;
pub const GPIO_FUNC30_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC30_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC30_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC30_OUT_SEL: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC31_OUT_SEL_CFG_REG: u32 = 1072973228;
pub const GPIO_FUNC31_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC31_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC31_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC31_OUT_SEL: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC32_OUT_SEL_CFG_REG: u32 = 1072973232;
pub const GPIO_FUNC32_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC32_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC32_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC32_OUT_SEL: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC33_OUT_SEL_CFG_REG: u32 = 1072973236;
pub const GPIO_FUNC33_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC33_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC33_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC33_OUT_SEL: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC34_OUT_SEL_CFG_REG: u32 = 1072973240;
pub const GPIO_FUNC34_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC34_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC34_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC34_OUT_SEL: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC35_OUT_SEL_CFG_REG: u32 = 1072973244;
pub const GPIO_FUNC35_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC35_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC35_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC35_OUT_SEL: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC36_OUT_SEL_CFG_REG: u32 = 1072973248;
pub const GPIO_FUNC36_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC36_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC36_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC36_OUT_SEL: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC37_OUT_SEL_CFG_REG: u32 = 1072973252;
pub const GPIO_FUNC37_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC37_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC37_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC37_OUT_SEL: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC38_OUT_SEL_CFG_REG: u32 = 1072973256;
pub const GPIO_FUNC38_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC38_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC38_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC38_OUT_SEL: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC39_OUT_SEL_CFG_REG: u32 = 1072973260;
pub const GPIO_FUNC39_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC39_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC39_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC39_OUT_SEL: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_S: u32 = 0;
pub const SOC_GPIO_PORT: u32 = 1;
pub const GPIO_PIN_COUNT: u32 = 40;
pub const GPIO_SUPPORTS_RTC_INDEPENDENT: u32 = 0;
pub const GPIO_SUPPORTS_FORCE_HOLD: u32 = 0;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_MODE_DEF_INPUT: u32 = 1;
pub const GPIO_MODE_DEF_OUTPUT: u32 = 2;
pub const GPIO_MODE_DEF_OD: u32 = 4;
pub const SPICLK_IN_IDX: u32 = 0;
pub const SPICLK_OUT_IDX: u32 = 0;
pub const SPIQ_IN_IDX: u32 = 1;
pub const SPIQ_OUT_IDX: u32 = 1;
pub const SPID_IN_IDX: u32 = 2;
pub const SPID_OUT_IDX: u32 = 2;
pub const SPIHD_IN_IDX: u32 = 3;
pub const SPIHD_OUT_IDX: u32 = 3;
pub const SPIWP_IN_IDX: u32 = 4;
pub const SPIWP_OUT_IDX: u32 = 4;
pub const SPICS0_IN_IDX: u32 = 5;
pub const SPICS0_OUT_IDX: u32 = 5;
pub const SPICS1_IN_IDX: u32 = 6;
pub const SPICS1_OUT_IDX: u32 = 6;
pub const SPICS2_IN_IDX: u32 = 7;
pub const SPICS2_OUT_IDX: u32 = 7;
pub const HSPICLK_IN_IDX: u32 = 8;
pub const HSPICLK_OUT_IDX: u32 = 8;
pub const HSPIQ_IN_IDX: u32 = 9;
pub const HSPIQ_OUT_IDX: u32 = 9;
pub const HSPID_IN_IDX: u32 = 10;
pub const HSPID_OUT_IDX: u32 = 10;
pub const HSPICS0_IN_IDX: u32 = 11;
pub const HSPICS0_OUT_IDX: u32 = 11;
pub const HSPIHD_IN_IDX: u32 = 12;
pub const HSPIHD_OUT_IDX: u32 = 12;
pub const HSPIWP_IN_IDX: u32 = 13;
pub const HSPIWP_OUT_IDX: u32 = 13;
pub const U0RXD_IN_IDX: u32 = 14;
pub const U0TXD_OUT_IDX: u32 = 14;
pub const U0CTS_IN_IDX: u32 = 15;
pub const U0RTS_OUT_IDX: u32 = 15;
pub const U0DSR_IN_IDX: u32 = 16;
pub const U0DTR_OUT_IDX: u32 = 16;
pub const U1RXD_IN_IDX: u32 = 17;
pub const U1TXD_OUT_IDX: u32 = 17;
pub const U1CTS_IN_IDX: u32 = 18;
pub const U1RTS_OUT_IDX: u32 = 18;
pub const I2CM_SCL_O_IDX: u32 = 19;
pub const I2CM_SDA_I_IDX: u32 = 20;
pub const I2CM_SDA_O_IDX: u32 = 20;
pub const EXT_I2C_SCL_O_IDX: u32 = 21;
pub const EXT_I2C_SDA_O_IDX: u32 = 22;
pub const EXT_I2C_SDA_I_IDX: u32 = 22;
pub const I2S0O_BCK_IN_IDX: u32 = 23;
pub const I2S0O_BCK_OUT_IDX: u32 = 23;
pub const I2S1O_BCK_IN_IDX: u32 = 24;
pub const I2S1O_BCK_OUT_IDX: u32 = 24;
pub const I2S0O_WS_IN_IDX: u32 = 25;
pub const I2S0O_WS_OUT_IDX: u32 = 25;
pub const I2S1O_WS_IN_IDX: u32 = 26;
pub const I2S1O_WS_OUT_IDX: u32 = 26;
pub const I2S0I_BCK_IN_IDX: u32 = 27;
pub const I2S0I_BCK_OUT_IDX: u32 = 27;
pub const I2S0I_WS_IN_IDX: u32 = 28;
pub const I2S0I_WS_OUT_IDX: u32 = 28;
pub const I2CEXT0_SCL_IN_IDX: u32 = 29;
pub const I2CEXT0_SCL_OUT_IDX: u32 = 29;
pub const I2CEXT0_SDA_IN_IDX: u32 = 30;
pub const I2CEXT0_SDA_OUT_IDX: u32 = 30;
pub const PWM0_SYNC0_IN_IDX: u32 = 31;
pub const SDIO_TOHOST_INT_OUT_IDX: u32 = 31;
pub const PWM0_SYNC1_IN_IDX: u32 = 32;
pub const PWM0_OUT0A_IDX: u32 = 32;
pub const PWM0_SYNC2_IN_IDX: u32 = 33;
pub const PWM0_OUT0B_IDX: u32 = 33;
pub const PWM0_F0_IN_IDX: u32 = 34;
pub const PWM0_OUT1A_IDX: u32 = 34;
pub const PWM0_F1_IN_IDX: u32 = 35;
pub const PWM0_OUT1B_IDX: u32 = 35;
pub const PWM0_F2_IN_IDX: u32 = 36;
pub const PWM0_OUT2A_IDX: u32 = 36;
pub const GPIO_BT_ACTIVE_IDX: u32 = 37;
pub const PWM0_OUT2B_IDX: u32 = 37;
pub const GPIO_BT_PRIORITY_IDX: u32 = 38;
pub const PCNT_SIG_CH0_IN0_IDX: u32 = 39;
pub const PCNT_SIG_CH1_IN0_IDX: u32 = 40;
pub const GPIO_WLAN_ACTIVE_IDX: u32 = 40;
pub const PCNT_CTRL_CH0_IN0_IDX: u32 = 41;
pub const BB_DIAG0_IDX: u32 = 41;
pub const PCNT_CTRL_CH1_IN0_IDX: u32 = 42;
pub const BB_DIAG1_IDX: u32 = 42;
pub const PCNT_SIG_CH0_IN1_IDX: u32 = 43;
pub const BB_DIAG2_IDX: u32 = 43;
pub const PCNT_SIG_CH1_IN1_IDX: u32 = 44;
pub const BB_DIAG3_IDX: u32 = 44;
pub const PCNT_CTRL_CH0_IN1_IDX: u32 = 45;
pub const BB_DIAG4_IDX: u32 = 45;
pub const PCNT_CTRL_CH1_IN1_IDX: u32 = 46;
pub const BB_DIAG5_IDX: u32 = 46;
pub const PCNT_SIG_CH0_IN2_IDX: u32 = 47;
pub const BB_DIAG6_IDX: u32 = 47;
pub const PCNT_SIG_CH1_IN2_IDX: u32 = 48;
pub const BB_DIAG7_IDX: u32 = 48;
pub const PCNT_CTRL_CH0_IN2_IDX: u32 = 49;
pub const BB_DIAG8_IDX: u32 = 49;
pub const PCNT_CTRL_CH1_IN2_IDX: u32 = 50;
pub const BB_DIAG9_IDX: u32 = 50;
pub const PCNT_SIG_CH0_IN3_IDX: u32 = 51;
pub const BB_DIAG10_IDX: u32 = 51;
pub const PCNT_SIG_CH1_IN3_IDX: u32 = 52;
pub const BB_DIAG11_IDX: u32 = 52;
pub const PCNT_CTRL_CH0_IN3_IDX: u32 = 53;
pub const BB_DIAG12_IDX: u32 = 53;
pub const PCNT_CTRL_CH1_IN3_IDX: u32 = 54;
pub const BB_DIAG13_IDX: u32 = 54;
pub const PCNT_SIG_CH0_IN4_IDX: u32 = 55;
pub const BB_DIAG14_IDX: u32 = 55;
pub const PCNT_SIG_CH1_IN4_IDX: u32 = 56;
pub const BB_DIAG15_IDX: u32 = 56;
pub const PCNT_CTRL_CH0_IN4_IDX: u32 = 57;
pub const BB_DIAG16_IDX: u32 = 57;
pub const PCNT_CTRL_CH1_IN4_IDX: u32 = 58;
pub const BB_DIAG17_IDX: u32 = 58;
pub const BB_DIAG18_IDX: u32 = 59;
pub const BB_DIAG19_IDX: u32 = 60;
pub const HSPICS1_IN_IDX: u32 = 61;
pub const HSPICS1_OUT_IDX: u32 = 61;
pub const HSPICS2_IN_IDX: u32 = 62;
pub const HSPICS2_OUT_IDX: u32 = 62;
pub const VSPICLK_IN_IDX: u32 = 63;
pub const VSPICLK_OUT_IDX: u32 = 63;
pub const VSPIQ_IN_IDX: u32 = 64;
pub const VSPIQ_OUT_IDX: u32 = 64;
pub const VSPID_IN_IDX: u32 = 65;
pub const VSPID_OUT_IDX: u32 = 65;
pub const VSPIHD_IN_IDX: u32 = 66;
pub const VSPIHD_OUT_IDX: u32 = 66;
pub const VSPIWP_IN_IDX: u32 = 67;
pub const VSPIWP_OUT_IDX: u32 = 67;
pub const VSPICS0_IN_IDX: u32 = 68;
pub const VSPICS0_OUT_IDX: u32 = 68;
pub const VSPICS1_IN_IDX: u32 = 69;
pub const VSPICS1_OUT_IDX: u32 = 69;
pub const VSPICS2_IN_IDX: u32 = 70;
pub const VSPICS2_OUT_IDX: u32 = 70;
pub const PCNT_SIG_CH0_IN5_IDX: u32 = 71;
pub const LEDC_HS_SIG_OUT0_IDX: u32 = 71;
pub const PCNT_SIG_CH1_IN5_IDX: u32 = 72;
pub const LEDC_HS_SIG_OUT1_IDX: u32 = 72;
pub const PCNT_CTRL_CH0_IN5_IDX: u32 = 73;
pub const LEDC_HS_SIG_OUT2_IDX: u32 = 73;
pub const PCNT_CTRL_CH1_IN5_IDX: u32 = 74;
pub const LEDC_HS_SIG_OUT3_IDX: u32 = 74;
pub const PCNT_SIG_CH0_IN6_IDX: u32 = 75;
pub const LEDC_HS_SIG_OUT4_IDX: u32 = 75;
pub const PCNT_SIG_CH1_IN6_IDX: u32 = 76;
pub const LEDC_HS_SIG_OUT5_IDX: u32 = 76;
pub const PCNT_CTRL_CH0_IN6_IDX: u32 = 77;
pub const LEDC_HS_SIG_OUT6_IDX: u32 = 77;
pub const PCNT_CTRL_CH1_IN6_IDX: u32 = 78;
pub const LEDC_HS_SIG_OUT7_IDX: u32 = 78;
pub const PCNT_SIG_CH0_IN7_IDX: u32 = 79;
pub const LEDC_LS_SIG_OUT0_IDX: u32 = 79;
pub const PCNT_SIG_CH1_IN7_IDX: u32 = 80;
pub const LEDC_LS_SIG_OUT1_IDX: u32 = 80;
pub const PCNT_CTRL_CH0_IN7_IDX: u32 = 81;
pub const LEDC_LS_SIG_OUT2_IDX: u32 = 81;
pub const PCNT_CTRL_CH1_IN7_IDX: u32 = 82;
pub const LEDC_LS_SIG_OUT3_IDX: u32 = 82;
pub const RMT_SIG_IN0_IDX: u32 = 83;
pub const LEDC_LS_SIG_OUT4_IDX: u32 = 83;
pub const RMT_SIG_IN1_IDX: u32 = 84;
pub const LEDC_LS_SIG_OUT5_IDX: u32 = 84;
pub const RMT_SIG_IN2_IDX: u32 = 85;
pub const LEDC_LS_SIG_OUT6_IDX: u32 = 85;
pub const RMT_SIG_IN3_IDX: u32 = 86;
pub const LEDC_LS_SIG_OUT7_IDX: u32 = 86;
pub const RMT_SIG_IN4_IDX: u32 = 87;
pub const RMT_SIG_OUT0_IDX: u32 = 87;
pub const RMT_SIG_IN5_IDX: u32 = 88;
pub const RMT_SIG_OUT1_IDX: u32 = 88;
pub const RMT_SIG_IN6_IDX: u32 = 89;
pub const RMT_SIG_OUT2_IDX: u32 = 89;
pub const RMT_SIG_IN7_IDX: u32 = 90;
pub const RMT_SIG_OUT3_IDX: u32 = 90;
pub const RMT_SIG_OUT4_IDX: u32 = 91;
pub const RMT_SIG_OUT5_IDX: u32 = 92;
pub const EXT_ADC_START_IDX: u32 = 93;
pub const RMT_SIG_OUT6_IDX: u32 = 93;
pub const CAN_RX_IDX: u32 = 94;
pub const RMT_SIG_OUT7_IDX: u32 = 94;
pub const I2CEXT1_SCL_IN_IDX: u32 = 95;
pub const I2CEXT1_SCL_OUT_IDX: u32 = 95;
pub const I2CEXT1_SDA_IN_IDX: u32 = 96;
pub const I2CEXT1_SDA_OUT_IDX: u32 = 96;
pub const HOST_CARD_DETECT_N_1_IDX: u32 = 97;
pub const HOST_CCMD_OD_PULLUP_EN_N_IDX: u32 = 97;
pub const HOST_CARD_DETECT_N_2_IDX: u32 = 98;
pub const HOST_RST_N_1_IDX: u32 = 98;
pub const HOST_CARD_WRITE_PRT_1_IDX: u32 = 99;
pub const HOST_RST_N_2_IDX: u32 = 99;
pub const HOST_CARD_WRITE_PRT_2_IDX: u32 = 100;
pub const GPIO_SD0_OUT_IDX: u32 = 100;
pub const HOST_CARD_INT_N_1_IDX: u32 = 101;
pub const GPIO_SD1_OUT_IDX: u32 = 101;
pub const HOST_CARD_INT_N_2_IDX: u32 = 102;
pub const GPIO_SD2_OUT_IDX: u32 = 102;
pub const PWM1_SYNC0_IN_IDX: u32 = 103;
pub const GPIO_SD3_OUT_IDX: u32 = 103;
pub const PWM1_SYNC1_IN_IDX: u32 = 104;
pub const GPIO_SD4_OUT_IDX: u32 = 104;
pub const PWM1_SYNC2_IN_IDX: u32 = 105;
pub const GPIO_SD5_OUT_IDX: u32 = 105;
pub const PWM1_F0_IN_IDX: u32 = 106;
pub const GPIO_SD6_OUT_IDX: u32 = 106;
pub const PWM1_F1_IN_IDX: u32 = 107;
pub const GPIO_SD7_OUT_IDX: u32 = 107;
pub const PWM1_F2_IN_IDX: u32 = 108;
pub const PWM1_OUT0A_IDX: u32 = 108;
pub const PWM0_CAP0_IN_IDX: u32 = 109;
pub const PWM1_OUT0B_IDX: u32 = 109;
pub const PWM0_CAP1_IN_IDX: u32 = 110;
pub const PWM1_OUT1A_IDX: u32 = 110;
pub const PWM0_CAP2_IN_IDX: u32 = 111;
pub const PWM1_OUT1B_IDX: u32 = 111;
pub const PWM1_CAP0_IN_IDX: u32 = 112;
pub const PWM1_OUT2A_IDX: u32 = 112;
pub const PWM1_CAP1_IN_IDX: u32 = 113;
pub const PWM1_OUT2B_IDX: u32 = 113;
pub const PWM1_CAP2_IN_IDX: u32 = 114;
pub const PWM2_OUT1H_IDX: u32 = 114;
pub const PWM2_FLTA_IDX: u32 = 115;
pub const PWM2_OUT1L_IDX: u32 = 115;
pub const PWM2_FLTB_IDX: u32 = 116;
pub const PWM2_OUT2H_IDX: u32 = 116;
pub const PWM2_CAP1_IN_IDX: u32 = 117;
pub const PWM2_OUT2L_IDX: u32 = 117;
pub const PWM2_CAP2_IN_IDX: u32 = 118;
pub const PWM2_OUT3H_IDX: u32 = 118;
pub const PWM2_CAP3_IN_IDX: u32 = 119;
pub const PWM2_OUT3L_IDX: u32 = 119;
pub const PWM3_FLTA_IDX: u32 = 120;
pub const PWM2_OUT4H_IDX: u32 = 120;
pub const PWM3_FLTB_IDX: u32 = 121;
pub const PWM2_OUT4L_IDX: u32 = 121;
pub const PWM3_CAP1_IN_IDX: u32 = 122;
pub const PWM3_CAP2_IN_IDX: u32 = 123;
pub const CAN_TX_IDX: u32 = 123;
pub const PWM3_CAP3_IN_IDX: u32 = 124;
pub const CAN_BUS_OFF_ON_IDX: u32 = 124;
pub const CAN_CLKOUT_IDX: u32 = 125;
pub const SPID4_IN_IDX: u32 = 128;
pub const SPID4_OUT_IDX: u32 = 128;
pub const SPID5_IN_IDX: u32 = 129;
pub const SPID5_OUT_IDX: u32 = 129;
pub const SPID6_IN_IDX: u32 = 130;
pub const SPID6_OUT_IDX: u32 = 130;
pub const SPID7_IN_IDX: u32 = 131;
pub const SPID7_OUT_IDX: u32 = 131;
pub const HSPID4_IN_IDX: u32 = 132;
pub const HSPID4_OUT_IDX: u32 = 132;
pub const HSPID5_IN_IDX: u32 = 133;
pub const HSPID5_OUT_IDX: u32 = 133;
pub const HSPID6_IN_IDX: u32 = 134;
pub const HSPID6_OUT_IDX: u32 = 134;
pub const HSPID7_IN_IDX: u32 = 135;
pub const HSPID7_OUT_IDX: u32 = 135;
pub const VSPID4_IN_IDX: u32 = 136;
pub const VSPID4_OUT_IDX: u32 = 136;
pub const VSPID5_IN_IDX: u32 = 137;
pub const VSPID5_OUT_IDX: u32 = 137;
pub const VSPID6_IN_IDX: u32 = 138;
pub const VSPID6_OUT_IDX: u32 = 138;
pub const VSPID7_IN_IDX: u32 = 139;
pub const VSPID7_OUT_IDX: u32 = 139;
pub const I2S0I_DATA_IN0_IDX: u32 = 140;
pub const I2S0O_DATA_OUT0_IDX: u32 = 140;
pub const I2S0I_DATA_IN1_IDX: u32 = 141;
pub const I2S0O_DATA_OUT1_IDX: u32 = 141;
pub const I2S0I_DATA_IN2_IDX: u32 = 142;
pub const I2S0O_DATA_OUT2_IDX: u32 = 142;
pub const I2S0I_DATA_IN3_IDX: u32 = 143;
pub const I2S0O_DATA_OUT3_IDX: u32 = 143;
pub const I2S0I_DATA_IN4_IDX: u32 = 144;
pub const I2S0O_DATA_OUT4_IDX: u32 = 144;
pub const I2S0I_DATA_IN5_IDX: u32 = 145;
pub const I2S0O_DATA_OUT5_IDX: u32 = 145;
pub const I2S0I_DATA_IN6_IDX: u32 = 146;
pub const I2S0O_DATA_OUT6_IDX: u32 = 146;
pub const I2S0I_DATA_IN7_IDX: u32 = 147;
pub const I2S0O_DATA_OUT7_IDX: u32 = 147;
pub const I2S0I_DATA_IN8_IDX: u32 = 148;
pub const I2S0O_DATA_OUT8_IDX: u32 = 148;
pub const I2S0I_DATA_IN9_IDX: u32 = 149;
pub const I2S0O_DATA_OUT9_IDX: u32 = 149;
pub const I2S0I_DATA_IN10_IDX: u32 = 150;
pub const I2S0O_DATA_OUT10_IDX: u32 = 150;
pub const I2S0I_DATA_IN11_IDX: u32 = 151;
pub const I2S0O_DATA_OUT11_IDX: u32 = 151;
pub const I2S0I_DATA_IN12_IDX: u32 = 152;
pub const I2S0O_DATA_OUT12_IDX: u32 = 152;
pub const I2S0I_DATA_IN13_IDX: u32 = 153;
pub const I2S0O_DATA_OUT13_IDX: u32 = 153;
pub const I2S0I_DATA_IN14_IDX: u32 = 154;
pub const I2S0O_DATA_OUT14_IDX: u32 = 154;
pub const I2S0I_DATA_IN15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT16_IDX: u32 = 156;
pub const I2S0O_DATA_OUT17_IDX: u32 = 157;
pub const I2S0O_DATA_OUT18_IDX: u32 = 158;
pub const I2S0O_DATA_OUT19_IDX: u32 = 159;
pub const I2S0O_DATA_OUT20_IDX: u32 = 160;
pub const I2S0O_DATA_OUT21_IDX: u32 = 161;
pub const I2S0O_DATA_OUT22_IDX: u32 = 162;
pub const I2S0O_DATA_OUT23_IDX: u32 = 163;
pub const I2S1I_BCK_IN_IDX: u32 = 164;
pub const I2S1I_BCK_OUT_IDX: u32 = 164;
pub const I2S1I_WS_IN_IDX: u32 = 165;
pub const I2S1I_WS_OUT_IDX: u32 = 165;
pub const I2S1I_DATA_IN0_IDX: u32 = 166;
pub const I2S1O_DATA_OUT0_IDX: u32 = 166;
pub const I2S1I_DATA_IN1_IDX: u32 = 167;
pub const I2S1O_DATA_OUT1_IDX: u32 = 167;
pub const I2S1I_DATA_IN2_IDX: u32 = 168;
pub const I2S1O_DATA_OUT2_IDX: u32 = 168;
pub const I2S1I_DATA_IN3_IDX: u32 = 169;
pub const I2S1O_DATA_OUT3_IDX: u32 = 169;
pub const I2S1I_DATA_IN4_IDX: u32 = 170;
pub const I2S1O_DATA_OUT4_IDX: u32 = 170;
pub const I2S1I_DATA_IN5_IDX: u32 = 171;
pub const I2S1O_DATA_OUT5_IDX: u32 = 171;
pub const I2S1I_DATA_IN6_IDX: u32 = 172;
pub const I2S1O_DATA_OUT6_IDX: u32 = 172;
pub const I2S1I_DATA_IN7_IDX: u32 = 173;
pub const I2S1O_DATA_OUT7_IDX: u32 = 173;
pub const I2S1I_DATA_IN8_IDX: u32 = 174;
pub const I2S1O_DATA_OUT8_IDX: u32 = 174;
pub const I2S1I_DATA_IN9_IDX: u32 = 175;
pub const I2S1O_DATA_OUT9_IDX: u32 = 175;
pub const I2S1I_DATA_IN10_IDX: u32 = 176;
pub const I2S1O_DATA_OUT10_IDX: u32 = 176;
pub const I2S1I_DATA_IN11_IDX: u32 = 177;
pub const I2S1O_DATA_OUT11_IDX: u32 = 177;
pub const I2S1I_DATA_IN12_IDX: u32 = 178;
pub const I2S1O_DATA_OUT12_IDX: u32 = 178;
pub const I2S1I_DATA_IN13_IDX: u32 = 179;
pub const I2S1O_DATA_OUT13_IDX: u32 = 179;
pub const I2S1I_DATA_IN14_IDX: u32 = 180;
pub const I2S1O_DATA_OUT14_IDX: u32 = 180;
pub const I2S1I_DATA_IN15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT16_IDX: u32 = 182;
pub const I2S1O_DATA_OUT17_IDX: u32 = 183;
pub const I2S1O_DATA_OUT18_IDX: u32 = 184;
pub const I2S1O_DATA_OUT19_IDX: u32 = 185;
pub const I2S1O_DATA_OUT20_IDX: u32 = 186;
pub const I2S1O_DATA_OUT21_IDX: u32 = 187;
pub const I2S1O_DATA_OUT22_IDX: u32 = 188;
pub const I2S1O_DATA_OUT23_IDX: u32 = 189;
pub const I2S0I_H_SYNC_IDX: u32 = 190;
pub const PWM3_OUT1H_IDX: u32 = 190;
pub const I2S0I_V_SYNC_IDX: u32 = 191;
pub const PWM3_OUT1L_IDX: u32 = 191;
pub const I2S0I_H_ENABLE_IDX: u32 = 192;
pub const PWM3_OUT2H_IDX: u32 = 192;
pub const I2S1I_H_SYNC_IDX: u32 = 193;
pub const PWM3_OUT2L_IDX: u32 = 193;
pub const I2S1I_V_SYNC_IDX: u32 = 194;
pub const PWM3_OUT3H_IDX: u32 = 194;
pub const I2S1I_H_ENABLE_IDX: u32 = 195;
pub const PWM3_OUT3L_IDX: u32 = 195;
pub const PWM3_OUT4H_IDX: u32 = 196;
pub const PWM3_OUT4L_IDX: u32 = 197;
pub const U2RXD_IN_IDX: u32 = 198;
pub const U2TXD_OUT_IDX: u32 = 198;
pub const U2CTS_IN_IDX: u32 = 199;
pub const U2RTS_OUT_IDX: u32 = 199;
pub const EMAC_MDC_I_IDX: u32 = 200;
pub const EMAC_MDC_O_IDX: u32 = 200;
pub const EMAC_MDI_I_IDX: u32 = 201;
pub const EMAC_MDO_O_IDX: u32 = 201;
pub const EMAC_CRS_I_IDX: u32 = 202;
pub const EMAC_CRS_O_IDX: u32 = 202;
pub const EMAC_COL_I_IDX: u32 = 203;
pub const EMAC_COL_O_IDX: u32 = 203;
pub const PCMFSYNC_IN_IDX: u32 = 204;
pub const BT_AUDIO0_IRQ_IDX: u32 = 204;
pub const PCMCLK_IN_IDX: u32 = 205;
pub const BT_AUDIO1_IRQ_IDX: u32 = 205;
pub const PCMDIN_IDX: u32 = 206;
pub const BT_AUDIO2_IRQ_IDX: u32 = 206;
pub const BLE_AUDIO0_IRQ_IDX: u32 = 207;
pub const BLE_AUDIO1_IRQ_IDX: u32 = 208;
pub const BLE_AUDIO2_IRQ_IDX: u32 = 209;
pub const PCMFSYNC_OUT_IDX: u32 = 210;
pub const PCMCLK_OUT_IDX: u32 = 211;
pub const PCMDOUT_IDX: u32 = 212;
pub const BLE_AUDIO_SYNC0_P_IDX: u32 = 213;
pub const BLE_AUDIO_SYNC1_P_IDX: u32 = 214;
pub const BLE_AUDIO_SYNC2_P_IDX: u32 = 215;
pub const ANT_SEL0_IDX: u32 = 216;
pub const ANT_SEL1_IDX: u32 = 217;
pub const ANT_SEL2_IDX: u32 = 218;
pub const ANT_SEL3_IDX: u32 = 219;
pub const ANT_SEL4_IDX: u32 = 220;
pub const ANT_SEL5_IDX: u32 = 221;
pub const ANT_SEL6_IDX: u32 = 222;
pub const ANT_SEL7_IDX: u32 = 223;
pub const SIG_IN_FUNC224_IDX: u32 = 224;
pub const SIG_IN_FUNC225_IDX: u32 = 225;
pub const SIG_IN_FUNC226_IDX: u32 = 226;
pub const SIG_IN_FUNC227_IDX: u32 = 227;
pub const SIG_IN_FUNC228_IDX: u32 = 228;
pub const SIG_GPIO_OUT_IDX: u32 = 256;
pub const GPIO_PIN_REG_0: u32 = 1072992324;
pub const GPIO_PIN_REG_1: u32 = 1072992392;
pub const GPIO_PIN_REG_2: u32 = 1072992320;
pub const GPIO_PIN_REG_3: u32 = 1072992388;
pub const GPIO_PIN_REG_4: u32 = 1072992328;
pub const GPIO_PIN_REG_5: u32 = 1072992364;
pub const GPIO_PIN_REG_6: u32 = 1072992352;
pub const GPIO_PIN_REG_7: u32 = 1072992356;
pub const GPIO_PIN_REG_8: u32 = 1072992360;
pub const GPIO_PIN_REG_9: u32 = 1072992340;
pub const GPIO_PIN_REG_10: u32 = 1072992344;
pub const GPIO_PIN_REG_11: u32 = 1072992348;
pub const GPIO_PIN_REG_12: u32 = 1072992308;
pub const GPIO_PIN_REG_13: u32 = 1072992312;
pub const GPIO_PIN_REG_14: u32 = 1072992304;
pub const GPIO_PIN_REG_15: u32 = 1072992316;
pub const GPIO_PIN_REG_16: u32 = 1072992332;
pub const GPIO_PIN_REG_17: u32 = 1072992336;
pub const GPIO_PIN_REG_18: u32 = 1072992368;
pub const GPIO_PIN_REG_19: u32 = 1072992372;
pub const GPIO_PIN_REG_20: u32 = 1072992376;
pub const GPIO_PIN_REG_21: u32 = 1072992380;
pub const GPIO_PIN_REG_22: u32 = 1072992384;
pub const GPIO_PIN_REG_23: u32 = 1072992396;
pub const GPIO_PIN_REG_24: u32 = 1072992400;
pub const GPIO_PIN_REG_25: u32 = 1072992292;
pub const GPIO_PIN_REG_26: u32 = 1072992296;
pub const GPIO_PIN_REG_27: u32 = 1072992300;
pub const GPIO_PIN_REG_32: u32 = 1072992284;
pub const GPIO_PIN_REG_33: u32 = 1072992288;
pub const GPIO_PIN_REG_34: u32 = 1072992276;
pub const GPIO_PIN_REG_35: u32 = 1072992280;
pub const GPIO_PIN_REG_36: u32 = 1072992260;
pub const GPIO_PIN_REG_37: u32 = 1072992264;
pub const GPIO_PIN_REG_38: u32 = 1072992268;
pub const GPIO_PIN_REG_39: u32 = 1072992272;
pub const SENS_SAR_READ_CTRL_REG: u32 = 1072990208;
pub const SENS_SAR1_DATA_INV_V: u32 = 1;
pub const SENS_SAR1_DATA_INV_S: u32 = 28;
pub const SENS_SAR1_DIG_FORCE_V: u32 = 1;
pub const SENS_SAR1_DIG_FORCE_S: u32 = 27;
pub const SENS_SAR1_SAMPLE_NUM: u32 = 255;
pub const SENS_SAR1_SAMPLE_NUM_V: u32 = 255;
pub const SENS_SAR1_SAMPLE_NUM_S: u32 = 19;
pub const SENS_SAR1_CLK_GATED_V: u32 = 1;
pub const SENS_SAR1_CLK_GATED_S: u32 = 18;
pub const SENS_SAR1_SAMPLE_BIT: u32 = 3;
pub const SENS_SAR1_SAMPLE_BIT_V: u32 = 3;
pub const SENS_SAR1_SAMPLE_BIT_S: u32 = 16;
pub const SENS_SAR1_SAMPLE_CYCLE: u32 = 255;
pub const SENS_SAR1_SAMPLE_CYCLE_V: u32 = 255;
pub const SENS_SAR1_SAMPLE_CYCLE_S: u32 = 8;
pub const SENS_SAR1_CLK_DIV: u32 = 255;
pub const SENS_SAR1_CLK_DIV_V: u32 = 255;
pub const SENS_SAR1_CLK_DIV_S: u32 = 0;
pub const SENS_SAR_READ_STATUS1_REG: u32 = 1072990212;
pub const SENS_SAR1_READER_STATUS: u32 = 4294967295;
pub const SENS_SAR1_READER_STATUS_V: u32 = 4294967295;
pub const SENS_SAR1_READER_STATUS_S: u32 = 0;
pub const SENS_SAR_MEAS_WAIT1_REG: u32 = 1072990216;
pub const SENS_SAR_AMP_WAIT2: u32 = 65535;
pub const SENS_SAR_AMP_WAIT2_V: u32 = 65535;
pub const SENS_SAR_AMP_WAIT2_S: u32 = 16;
pub const SENS_SAR_AMP_WAIT1: u32 = 65535;
pub const SENS_SAR_AMP_WAIT1_V: u32 = 65535;
pub const SENS_SAR_AMP_WAIT1_S: u32 = 0;
pub const SENS_SAR_MEAS_WAIT2_REG: u32 = 1072990220;
pub const SENS_SAR2_RSTB_WAIT: u32 = 255;
pub const SENS_SAR2_RSTB_WAIT_V: u32 = 255;
pub const SENS_SAR2_RSTB_WAIT_S: u32 = 20;
pub const SENS_FORCE_XPD_SAR: u32 = 3;
pub const SENS_FORCE_XPD_SAR_V: u32 = 3;
pub const SENS_FORCE_XPD_SAR_S: u32 = 18;
pub const SENS_FORCE_XPD_SAR_SW_M: u32 = 2;
pub const SENS_FORCE_XPD_SAR_FSM: u32 = 0;
pub const SENS_FORCE_XPD_SAR_PD: u32 = 2;
pub const SENS_FORCE_XPD_SAR_PU: u32 = 3;
pub const SENS_FORCE_XPD_AMP: u32 = 3;
pub const SENS_FORCE_XPD_AMP_V: u32 = 3;
pub const SENS_FORCE_XPD_AMP_S: u32 = 16;
pub const SENS_FORCE_XPD_AMP_FSM: u32 = 0;
pub const SENS_FORCE_XPD_AMP_PD: u32 = 2;
pub const SENS_FORCE_XPD_AMP_PU: u32 = 3;
pub const SENS_SAR_AMP_WAIT3: u32 = 65535;
pub const SENS_SAR_AMP_WAIT3_V: u32 = 65535;
pub const SENS_SAR_AMP_WAIT3_S: u32 = 0;
pub const SENS_SAR_MEAS_CTRL_REG: u32 = 1072990224;
pub const SENS_SAR2_XPD_WAIT: u32 = 255;
pub const SENS_SAR2_XPD_WAIT_V: u32 = 255;
pub const SENS_SAR2_XPD_WAIT_S: u32 = 24;
pub const SENS_SAR_RSTB_FSM: u32 = 15;
pub const SENS_SAR_RSTB_FSM_V: u32 = 15;
pub const SENS_SAR_RSTB_FSM_S: u32 = 20;
pub const SENS_XPD_SAR_FSM: u32 = 15;
pub const SENS_XPD_SAR_FSM_V: u32 = 15;
pub const SENS_XPD_SAR_FSM_S: u32 = 16;
pub const SENS_AMP_SHORT_REF_GND_FSM: u32 = 15;
pub const SENS_AMP_SHORT_REF_GND_FSM_V: u32 = 15;
pub const SENS_AMP_SHORT_REF_GND_FSM_S: u32 = 12;
pub const SENS_AMP_SHORT_REF_FSM: u32 = 15;
pub const SENS_AMP_SHORT_REF_FSM_V: u32 = 15;
pub const SENS_AMP_SHORT_REF_FSM_S: u32 = 8;
pub const SENS_AMP_RST_FB_FSM: u32 = 15;
pub const SENS_AMP_RST_FB_FSM_V: u32 = 15;
pub const SENS_AMP_RST_FB_FSM_S: u32 = 4;
pub const SENS_XPD_SAR_AMP_FSM: u32 = 15;
pub const SENS_XPD_SAR_AMP_FSM_V: u32 = 15;
pub const SENS_XPD_SAR_AMP_FSM_S: u32 = 0;
pub const SENS_SAR_READ_STATUS2_REG: u32 = 1072990228;
pub const SENS_SAR2_READER_STATUS: u32 = 4294967295;
pub const SENS_SAR2_READER_STATUS_V: u32 = 4294967295;
pub const SENS_SAR2_READER_STATUS_S: u32 = 0;
pub const SENS_ULP_CP_SLEEP_CYC0_REG: u32 = 1072990232;
pub const SENS_SLEEP_CYCLES_S0: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S0_V: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S0_S: u32 = 0;
pub const SENS_ULP_CP_SLEEP_CYC1_REG: u32 = 1072990236;
pub const SENS_SLEEP_CYCLES_S1: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S1_V: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S1_S: u32 = 0;
pub const SENS_ULP_CP_SLEEP_CYC2_REG: u32 = 1072990240;
pub const SENS_SLEEP_CYCLES_S2: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S2_V: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S2_S: u32 = 0;
pub const SENS_ULP_CP_SLEEP_CYC3_REG: u32 = 1072990244;
pub const SENS_SLEEP_CYCLES_S3: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S3_V: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S3_S: u32 = 0;
pub const SENS_ULP_CP_SLEEP_CYC4_REG: u32 = 1072990248;
pub const SENS_SLEEP_CYCLES_S4: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S4_V: u32 = 4294967295;
pub const SENS_SLEEP_CYCLES_S4_S: u32 = 0;
pub const SENS_SAR_START_FORCE_REG: u32 = 1072990252;
pub const SENS_SAR2_PWDET_EN_V: u32 = 1;
pub const SENS_SAR2_PWDET_EN_S: u32 = 24;
pub const SENS_SAR1_STOP_V: u32 = 1;
pub const SENS_SAR1_STOP_S: u32 = 23;
pub const SENS_SAR2_STOP_V: u32 = 1;
pub const SENS_SAR2_STOP_S: u32 = 22;
pub const SENS_PC_INIT: u32 = 2047;
pub const SENS_PC_INIT_V: u32 = 2047;
pub const SENS_PC_INIT_S: u32 = 11;
pub const SENS_SARCLK_EN_V: u32 = 1;
pub const SENS_SARCLK_EN_S: u32 = 10;
pub const SENS_ULP_CP_START_TOP_V: u32 = 1;
pub const SENS_ULP_CP_START_TOP_S: u32 = 9;
pub const SENS_ULP_CP_FORCE_START_TOP_V: u32 = 1;
pub const SENS_ULP_CP_FORCE_START_TOP_S: u32 = 8;
pub const SENS_SAR2_PWDET_CCT: u32 = 7;
pub const SENS_SAR2_PWDET_CCT_V: u32 = 7;
pub const SENS_SAR2_PWDET_CCT_S: u32 = 5;
pub const SENS_SAR2_EN_TEST_V: u32 = 1;
pub const SENS_SAR2_EN_TEST_S: u32 = 4;
pub const SENS_SAR2_BIT_WIDTH: u32 = 3;
pub const SENS_SAR2_BIT_WIDTH_V: u32 = 3;
pub const SENS_SAR2_BIT_WIDTH_S: u32 = 2;
pub const SENS_SAR1_BIT_WIDTH: u32 = 3;
pub const SENS_SAR1_BIT_WIDTH_V: u32 = 3;
pub const SENS_SAR1_BIT_WIDTH_S: u32 = 0;
pub const SENS_SAR_MEM_WR_CTRL_REG: u32 = 1072990256;
pub const SENS_RTC_MEM_WR_OFFST_CLR_V: u32 = 1;
pub const SENS_RTC_MEM_WR_OFFST_CLR_S: u32 = 22;
pub const SENS_MEM_WR_ADDR_SIZE: u32 = 2047;
pub const SENS_MEM_WR_ADDR_SIZE_V: u32 = 2047;
pub const SENS_MEM_WR_ADDR_SIZE_S: u32 = 11;
pub const SENS_MEM_WR_ADDR_INIT: u32 = 2047;
pub const SENS_MEM_WR_ADDR_INIT_V: u32 = 2047;
pub const SENS_MEM_WR_ADDR_INIT_S: u32 = 0;
pub const SENS_SAR_ATTEN1_REG: u32 = 1072990260;
pub const SENS_SAR1_ATTEN: u32 = 4294967295;
pub const SENS_SAR1_ATTEN_V: u32 = 4294967295;
pub const SENS_SAR1_ATTEN_S: u32 = 0;
pub const SENS_SAR1_ATTEN_VAL_MASK: u32 = 3;
pub const SENS_SAR2_ATTEN_VAL_MASK: u32 = 3;
pub const SENS_SAR_ATTEN2_REG: u32 = 1072990264;
pub const SENS_SAR2_ATTEN: u32 = 4294967295;
pub const SENS_SAR2_ATTEN_V: u32 = 4294967295;
pub const SENS_SAR2_ATTEN_S: u32 = 0;
pub const SENS_SAR_SLAVE_ADDR1_REG: u32 = 1072990268;
pub const SENS_MEAS_STATUS: u32 = 255;
pub const SENS_MEAS_STATUS_V: u32 = 255;
pub const SENS_MEAS_STATUS_S: u32 = 22;
pub const SENS_I2C_SLAVE_ADDR0: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR0_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR0_S: u32 = 11;
pub const SENS_I2C_SLAVE_ADDR1: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR1_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR1_S: u32 = 0;
pub const SENS_SAR_SLAVE_ADDR2_REG: u32 = 1072990272;
pub const SENS_I2C_SLAVE_ADDR2: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR2_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR2_S: u32 = 11;
pub const SENS_I2C_SLAVE_ADDR3: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR3_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR3_S: u32 = 0;
pub const SENS_SAR_SLAVE_ADDR3_REG: u32 = 1072990276;
pub const SENS_TSENS_RDY_OUT_V: u32 = 1;
pub const SENS_TSENS_RDY_OUT_S: u32 = 30;
pub const SENS_TSENS_OUT: u32 = 255;
pub const SENS_TSENS_OUT_V: u32 = 255;
pub const SENS_TSENS_OUT_S: u32 = 22;
pub const SENS_I2C_SLAVE_ADDR4: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR4_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR4_S: u32 = 11;
pub const SENS_I2C_SLAVE_ADDR5: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR5_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR5_S: u32 = 0;
pub const SENS_SAR_SLAVE_ADDR4_REG: u32 = 1072990280;
pub const SENS_I2C_DONE_V: u32 = 1;
pub const SENS_I2C_DONE_S: u32 = 30;
pub const SENS_I2C_RDATA: u32 = 255;
pub const SENS_I2C_RDATA_V: u32 = 255;
pub const SENS_I2C_RDATA_S: u32 = 22;
pub const SENS_I2C_SLAVE_ADDR6: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR6_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR6_S: u32 = 11;
pub const SENS_I2C_SLAVE_ADDR7: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR7_V: u32 = 2047;
pub const SENS_I2C_SLAVE_ADDR7_S: u32 = 0;
pub const SENS_SAR_TSENS_CTRL_REG: u32 = 1072990284;
pub const SENS_TSENS_DUMP_OUT_V: u32 = 1;
pub const SENS_TSENS_DUMP_OUT_S: u32 = 26;
pub const SENS_TSENS_POWER_UP_FORCE_V: u32 = 1;
pub const SENS_TSENS_POWER_UP_FORCE_S: u32 = 25;
pub const SENS_TSENS_POWER_UP_V: u32 = 1;
pub const SENS_TSENS_POWER_UP_S: u32 = 24;
pub const SENS_TSENS_CLK_DIV: u32 = 255;
pub const SENS_TSENS_CLK_DIV_V: u32 = 255;
pub const SENS_TSENS_CLK_DIV_S: u32 = 16;
pub const SENS_TSENS_IN_INV_V: u32 = 1;
pub const SENS_TSENS_IN_INV_S: u32 = 15;
pub const SENS_TSENS_CLK_GATED_V: u32 = 1;
pub const SENS_TSENS_CLK_GATED_S: u32 = 14;
pub const SENS_TSENS_CLK_INV_V: u32 = 1;
pub const SENS_TSENS_CLK_INV_S: u32 = 13;
pub const SENS_TSENS_XPD_FORCE_V: u32 = 1;
pub const SENS_TSENS_XPD_FORCE_S: u32 = 12;
pub const SENS_TSENS_XPD_WAIT: u32 = 4095;
pub const SENS_TSENS_XPD_WAIT_V: u32 = 4095;
pub const SENS_TSENS_XPD_WAIT_S: u32 = 0;
pub const SENS_SAR_I2C_CTRL_REG: u32 = 1072990288;
pub const SENS_SAR_I2C_START_FORCE_V: u32 = 1;
pub const SENS_SAR_I2C_START_FORCE_S: u32 = 29;
pub const SENS_SAR_I2C_START_V: u32 = 1;
pub const SENS_SAR_I2C_START_S: u32 = 28;
pub const SENS_SAR_I2C_CTRL: u32 = 268435455;
pub const SENS_SAR_I2C_CTRL_V: u32 = 268435455;
pub const SENS_SAR_I2C_CTRL_S: u32 = 0;
pub const SENS_SAR_MEAS_START1_REG: u32 = 1072990292;
pub const SENS_SAR1_EN_PAD_FORCE_V: u32 = 1;
pub const SENS_SAR1_EN_PAD_FORCE_S: u32 = 31;
pub const SENS_SAR1_EN_PAD: u32 = 4095;
pub const SENS_SAR1_EN_PAD_V: u32 = 4095;
pub const SENS_SAR1_EN_PAD_S: u32 = 19;
pub const SENS_MEAS1_START_FORCE_V: u32 = 1;
pub const SENS_MEAS1_START_FORCE_S: u32 = 18;
pub const SENS_MEAS1_START_SAR_V: u32 = 1;
pub const SENS_MEAS1_START_SAR_S: u32 = 17;
pub const SENS_MEAS1_DONE_SAR_V: u32 = 1;
pub const SENS_MEAS1_DONE_SAR_S: u32 = 16;
pub const SENS_MEAS1_DATA_SAR: u32 = 65535;
pub const SENS_MEAS1_DATA_SAR_V: u32 = 65535;
pub const SENS_MEAS1_DATA_SAR_S: u32 = 0;
pub const SENS_SAR_TOUCH_CTRL1_REG: u32 = 1072990296;
pub const SENS_HALL_PHASE_FORCE_V: u32 = 1;
pub const SENS_HALL_PHASE_FORCE_S: u32 = 27;
pub const SENS_XPD_HALL_FORCE_V: u32 = 1;
pub const SENS_XPD_HALL_FORCE_S: u32 = 26;
pub const SENS_TOUCH_OUT_1EN_V: u32 = 1;
pub const SENS_TOUCH_OUT_1EN_S: u32 = 25;
pub const SENS_TOUCH_OUT_SEL_V: u32 = 1;
pub const SENS_TOUCH_OUT_SEL_S: u32 = 24;
pub const SENS_TOUCH_XPD_WAIT: u32 = 255;
pub const SENS_TOUCH_XPD_WAIT_V: u32 = 255;
pub const SENS_TOUCH_XPD_WAIT_S: u32 = 16;
pub const SENS_TOUCH_MEAS_DELAY: u32 = 65535;
pub const SENS_TOUCH_MEAS_DELAY_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_DELAY_S: u32 = 0;
pub const SENS_SAR_TOUCH_THRES1_REG: u32 = 1072990300;
pub const SENS_TOUCH_OUT_TH0: u32 = 65535;
pub const SENS_TOUCH_OUT_TH0_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH0_S: u32 = 16;
pub const SENS_TOUCH_OUT_TH1: u32 = 65535;
pub const SENS_TOUCH_OUT_TH1_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH1_S: u32 = 0;
pub const SENS_SAR_TOUCH_THRES2_REG: u32 = 1072990304;
pub const SENS_TOUCH_OUT_TH2: u32 = 65535;
pub const SENS_TOUCH_OUT_TH2_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH2_S: u32 = 16;
pub const SENS_TOUCH_OUT_TH3: u32 = 65535;
pub const SENS_TOUCH_OUT_TH3_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH3_S: u32 = 0;
pub const SENS_SAR_TOUCH_THRES3_REG: u32 = 1072990308;
pub const SENS_TOUCH_OUT_TH4: u32 = 65535;
pub const SENS_TOUCH_OUT_TH4_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH4_S: u32 = 16;
pub const SENS_TOUCH_OUT_TH5: u32 = 65535;
pub const SENS_TOUCH_OUT_TH5_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH5_S: u32 = 0;
pub const SENS_SAR_TOUCH_THRES4_REG: u32 = 1072990312;
pub const SENS_TOUCH_OUT_TH6: u32 = 65535;
pub const SENS_TOUCH_OUT_TH6_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH6_S: u32 = 16;
pub const SENS_TOUCH_OUT_TH7: u32 = 65535;
pub const SENS_TOUCH_OUT_TH7_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH7_S: u32 = 0;
pub const SENS_SAR_TOUCH_THRES5_REG: u32 = 1072990316;
pub const SENS_TOUCH_OUT_TH8: u32 = 65535;
pub const SENS_TOUCH_OUT_TH8_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH8_S: u32 = 16;
pub const SENS_TOUCH_OUT_TH9: u32 = 65535;
pub const SENS_TOUCH_OUT_TH9_V: u32 = 65535;
pub const SENS_TOUCH_OUT_TH9_S: u32 = 0;
pub const SENS_SAR_TOUCH_OUT1_REG: u32 = 1072990320;
pub const SENS_TOUCH_MEAS_OUT0: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT0_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT0_S: u32 = 16;
pub const SENS_TOUCH_MEAS_OUT1: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT1_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT1_S: u32 = 0;
pub const SENS_SAR_TOUCH_OUT2_REG: u32 = 1072990324;
pub const SENS_TOUCH_MEAS_OUT2: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT2_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT2_S: u32 = 16;
pub const SENS_TOUCH_MEAS_OUT3: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT3_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT3_S: u32 = 0;
pub const SENS_SAR_TOUCH_OUT3_REG: u32 = 1072990328;
pub const SENS_TOUCH_MEAS_OUT4: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT4_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT4_S: u32 = 16;
pub const SENS_TOUCH_MEAS_OUT5: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT5_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT5_S: u32 = 0;
pub const SENS_SAR_TOUCH_OUT4_REG: u32 = 1072990332;
pub const SENS_TOUCH_MEAS_OUT6: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT6_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT6_S: u32 = 16;
pub const SENS_TOUCH_MEAS_OUT7: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT7_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT7_S: u32 = 0;
pub const SENS_SAR_TOUCH_OUT5_REG: u32 = 1072990336;
pub const SENS_TOUCH_MEAS_OUT8: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT8_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT8_S: u32 = 16;
pub const SENS_TOUCH_MEAS_OUT9: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT9_V: u32 = 65535;
pub const SENS_TOUCH_MEAS_OUT9_S: u32 = 0;
pub const SENS_SAR_TOUCH_CTRL2_REG: u32 = 1072990340;
pub const SENS_TOUCH_MEAS_EN_CLR_V: u32 = 1;
pub const SENS_TOUCH_MEAS_EN_CLR_S: u32 = 30;
pub const SENS_TOUCH_SLEEP_CYCLES: u32 = 65535;
pub const SENS_TOUCH_SLEEP_CYCLES_V: u32 = 65535;
pub const SENS_TOUCH_SLEEP_CYCLES_S: u32 = 14;
pub const SENS_TOUCH_START_FORCE_V: u32 = 1;
pub const SENS_TOUCH_START_FORCE_S: u32 = 13;
pub const SENS_TOUCH_START_EN_V: u32 = 1;
pub const SENS_TOUCH_START_EN_S: u32 = 12;
pub const SENS_TOUCH_START_FSM_EN_V: u32 = 1;
pub const SENS_TOUCH_START_FSM_EN_S: u32 = 11;
pub const SENS_TOUCH_MEAS_DONE_V: u32 = 1;
pub const SENS_TOUCH_MEAS_DONE_S: u32 = 10;
pub const SENS_TOUCH_MEAS_EN: u32 = 1023;
pub const SENS_TOUCH_MEAS_EN_V: u32 = 1023;
pub const SENS_TOUCH_MEAS_EN_S: u32 = 0;
pub const SENS_SAR_TOUCH_ENABLE_REG: u32 = 1072990348;
pub const SENS_TOUCH_PAD_OUTEN1: u32 = 1023;
pub const SENS_TOUCH_PAD_OUTEN1_V: u32 = 1023;
pub const SENS_TOUCH_PAD_OUTEN1_S: u32 = 20;
pub const SENS_TOUCH_PAD_OUTEN2: u32 = 1023;
pub const SENS_TOUCH_PAD_OUTEN2_V: u32 = 1023;
pub const SENS_TOUCH_PAD_OUTEN2_S: u32 = 10;
pub const SENS_TOUCH_PAD_WORKEN: u32 = 1023;
pub const SENS_TOUCH_PAD_WORKEN_V: u32 = 1023;
pub const SENS_TOUCH_PAD_WORKEN_S: u32 = 0;
pub const SENS_SAR_READ_CTRL2_REG: u32 = 1072990352;
pub const SENS_SAR2_DATA_INV_V: u32 = 1;
pub const SENS_SAR2_DATA_INV_S: u32 = 29;
pub const SENS_SAR2_DIG_FORCE_V: u32 = 1;
pub const SENS_SAR2_DIG_FORCE_S: u32 = 28;
pub const SENS_SAR2_PWDET_FORCE_V: u32 = 1;
pub const SENS_SAR2_PWDET_FORCE_S: u32 = 27;
pub const SENS_SAR2_SAMPLE_NUM: u32 = 255;
pub const SENS_SAR2_SAMPLE_NUM_V: u32 = 255;
pub const SENS_SAR2_SAMPLE_NUM_S: u32 = 19;
pub const SENS_SAR2_CLK_GATED_V: u32 = 1;
pub const SENS_SAR2_CLK_GATED_S: u32 = 18;
pub const SENS_SAR2_SAMPLE_BIT: u32 = 3;
pub const SENS_SAR2_SAMPLE_BIT_V: u32 = 3;
pub const SENS_SAR2_SAMPLE_BIT_S: u32 = 16;
pub const SENS_SAR2_SAMPLE_CYCLE: u32 = 255;
pub const SENS_SAR2_SAMPLE_CYCLE_V: u32 = 255;
pub const SENS_SAR2_SAMPLE_CYCLE_S: u32 = 8;
pub const SENS_SAR2_CLK_DIV: u32 = 255;
pub const SENS_SAR2_CLK_DIV_V: u32 = 255;
pub const SENS_SAR2_CLK_DIV_S: u32 = 0;
pub const SENS_SAR_MEAS_START2_REG: u32 = 1072990356;
pub const SENS_SAR2_EN_PAD_FORCE_V: u32 = 1;
pub const SENS_SAR2_EN_PAD_FORCE_S: u32 = 31;
pub const SENS_SAR2_EN_PAD: u32 = 4095;
pub const SENS_SAR2_EN_PAD_V: u32 = 4095;
pub const SENS_SAR2_EN_PAD_S: u32 = 19;
pub const SENS_MEAS2_START_FORCE_V: u32 = 1;
pub const SENS_MEAS2_START_FORCE_S: u32 = 18;
pub const SENS_MEAS2_START_SAR_V: u32 = 1;
pub const SENS_MEAS2_START_SAR_S: u32 = 17;
pub const SENS_MEAS2_DONE_SAR_V: u32 = 1;
pub const SENS_MEAS2_DONE_SAR_S: u32 = 16;
pub const SENS_MEAS2_DATA_SAR: u32 = 65535;
pub const SENS_MEAS2_DATA_SAR_V: u32 = 65535;
pub const SENS_MEAS2_DATA_SAR_S: u32 = 0;
pub const SENS_SAR_DAC_CTRL1_REG: u32 = 1072990360;
pub const SENS_DAC_CLK_INV_V: u32 = 1;
pub const SENS_DAC_CLK_INV_S: u32 = 25;
pub const SENS_DAC_CLK_FORCE_HIGH_V: u32 = 1;
pub const SENS_DAC_CLK_FORCE_HIGH_S: u32 = 24;
pub const SENS_DAC_CLK_FORCE_LOW_V: u32 = 1;
pub const SENS_DAC_CLK_FORCE_LOW_S: u32 = 23;
pub const SENS_DAC_DIG_FORCE_V: u32 = 1;
pub const SENS_DAC_DIG_FORCE_S: u32 = 22;
pub const SENS_DEBUG_BIT_SEL: u32 = 31;
pub const SENS_DEBUG_BIT_SEL_V: u32 = 31;
pub const SENS_DEBUG_BIT_SEL_S: u32 = 17;
pub const SENS_SW_TONE_EN_V: u32 = 1;
pub const SENS_SW_TONE_EN_S: u32 = 16;
pub const SENS_SW_FSTEP: u32 = 65535;
pub const SENS_SW_FSTEP_V: u32 = 65535;
pub const SENS_SW_FSTEP_S: u32 = 0;
pub const SENS_SAR_DAC_CTRL2_REG: u32 = 1072990364;
pub const SENS_DAC_CW_EN2_V: u32 = 1;
pub const SENS_DAC_CW_EN2_S: u32 = 25;
pub const SENS_DAC_CW_EN1_V: u32 = 1;
pub const SENS_DAC_CW_EN1_S: u32 = 24;
pub const SENS_DAC_INV2: u32 = 3;
pub const SENS_DAC_INV2_V: u32 = 3;
pub const SENS_DAC_INV2_S: u32 = 22;
pub const SENS_DAC_INV1: u32 = 3;
pub const SENS_DAC_INV1_V: u32 = 3;
pub const SENS_DAC_INV1_S: u32 = 20;
pub const SENS_DAC_SCALE2: u32 = 3;
pub const SENS_DAC_SCALE2_V: u32 = 3;
pub const SENS_DAC_SCALE2_S: u32 = 18;
pub const SENS_DAC_SCALE1: u32 = 3;
pub const SENS_DAC_SCALE1_V: u32 = 3;
pub const SENS_DAC_SCALE1_S: u32 = 16;
pub const SENS_DAC_DC2: u32 = 255;
pub const SENS_DAC_DC2_V: u32 = 255;
pub const SENS_DAC_DC2_S: u32 = 8;
pub const SENS_DAC_DC1: u32 = 255;
pub const SENS_DAC_DC1_V: u32 = 255;
pub const SENS_DAC_DC1_S: u32 = 0;
pub const SENS_SAR_MEAS_CTRL2_REG: u32 = 1072990368;
pub const SENS_AMP_SHORT_REF_GND_FORCE: u32 = 3;
pub const SENS_AMP_SHORT_REF_GND_FORCE_V: u32 = 3;
pub const SENS_AMP_SHORT_REF_GND_FORCE_S: u32 = 17;
pub const SENS_AMP_SHORT_REF_GND_FORCE_FSM: u32 = 0;
pub const SENS_AMP_SHORT_REF_GND_FORCE_PD: u32 = 2;
pub const SENS_AMP_SHORT_REF_GND_FORCE_PU: u32 = 3;
pub const SENS_AMP_SHORT_REF_FORCE: u32 = 3;
pub const SENS_AMP_SHORT_REF_FORCE_V: u32 = 3;
pub const SENS_AMP_SHORT_REF_FORCE_S: u32 = 15;
pub const SENS_AMP_SHORT_REF_FORCE_FSM: u32 = 0;
pub const SENS_AMP_SHORT_REF_FORCE_PD: u32 = 2;
pub const SENS_AMP_SHORT_REF_FORCE_PU: u32 = 3;
pub const SENS_AMP_RST_FB_FORCE: u32 = 3;
pub const SENS_AMP_RST_FB_FORCE_V: u32 = 3;
pub const SENS_AMP_RST_FB_FORCE_S: u32 = 13;
pub const SENS_AMP_RST_FB_FORCE_FSM: u32 = 0;
pub const SENS_AMP_RST_FB_FORCE_PD: u32 = 2;
pub const SENS_AMP_RST_FB_FORCE_PU: u32 = 3;
pub const SENS_SAR2_RSTB_FORCE: u32 = 3;
pub const SENS_SAR2_RSTB_FORCE_V: u32 = 3;
pub const SENS_SAR2_RSTB_FORCE_S: u32 = 11;
pub const SENS_SAR2_RSTB_FORCE_FSM: u32 = 0;
pub const SENS_SAR2_RSTB_FORCE_PD: u32 = 2;
pub const SENS_SAR2_RSTB_FORCE_PU: u32 = 3;
pub const SENS_SAR_RSTB_FSM_IDLE_V: u32 = 1;
pub const SENS_SAR_RSTB_FSM_IDLE_S: u32 = 10;
pub const SENS_XPD_SAR_FSM_IDLE_V: u32 = 1;
pub const SENS_XPD_SAR_FSM_IDLE_S: u32 = 9;
pub const SENS_AMP_SHORT_REF_GND_FSM_IDLE_V: u32 = 1;
pub const SENS_AMP_SHORT_REF_GND_FSM_IDLE_S: u32 = 8;
pub const SENS_AMP_SHORT_REF_FSM_IDLE_V: u32 = 1;
pub const SENS_AMP_SHORT_REF_FSM_IDLE_S: u32 = 7;
pub const SENS_AMP_RST_FB_FSM_IDLE_V: u32 = 1;
pub const SENS_AMP_RST_FB_FSM_IDLE_S: u32 = 6;
pub const SENS_XPD_SAR_AMP_FSM_IDLE_V: u32 = 1;
pub const SENS_XPD_SAR_AMP_FSM_IDLE_S: u32 = 5;
pub const SENS_SAR1_DAC_XPD_FSM_IDLE_V: u32 = 1;
pub const SENS_SAR1_DAC_XPD_FSM_IDLE_S: u32 = 4;
pub const SENS_SAR1_DAC_XPD_FSM: u32 = 15;
pub const SENS_SAR1_DAC_XPD_FSM_V: u32 = 15;
pub const SENS_SAR1_DAC_XPD_FSM_S: u32 = 0;
pub const SENS_SAR_NOUSE_REG: u32 = 1072990456;
pub const SENS_SAR_NOUSE: u32 = 4294967295;
pub const SENS_SAR_NOUSE_V: u32 = 4294967295;
pub const SENS_SAR_NOUSE_S: u32 = 0;
pub const SENS_SARDATE_REG: u32 = 1072990460;
pub const SENS_SAR_DATE: u32 = 268435455;
pub const SENS_SAR_DATE_V: u32 = 268435455;
pub const SENS_SAR_DATE_S: u32 = 0;
pub const ADC1_CHANNEL_0_GPIO_NUM: u32 = 36;
pub const ADC1_CHANNEL_1_GPIO_NUM: u32 = 37;
pub const ADC1_CHANNEL_2_GPIO_NUM: u32 = 38;
pub const ADC1_CHANNEL_3_GPIO_NUM: u32 = 39;
pub const ADC1_CHANNEL_4_GPIO_NUM: u32 = 32;
pub const ADC1_CHANNEL_5_GPIO_NUM: u32 = 33;
pub const ADC1_CHANNEL_6_GPIO_NUM: u32 = 34;
pub const ADC1_CHANNEL_7_GPIO_NUM: u32 = 35;
pub const ADC2_CHANNEL_0_GPIO_NUM: u32 = 4;
pub const ADC2_CHANNEL_1_GPIO_NUM: u32 = 0;
pub const ADC2_CHANNEL_2_GPIO_NUM: u32 = 2;
pub const ADC2_CHANNEL_3_GPIO_NUM: u32 = 15;
pub const ADC2_CHANNEL_4_GPIO_NUM: u32 = 13;
pub const ADC2_CHANNEL_5_GPIO_NUM: u32 = 12;
pub const ADC2_CHANNEL_6_GPIO_NUM: u32 = 14;
pub const ADC2_CHANNEL_7_GPIO_NUM: u32 = 27;
pub const ADC2_CHANNEL_8_GPIO_NUM: u32 = 25;
pub const ADC2_CHANNEL_9_GPIO_NUM: u32 = 26;
pub const SOC_ADC_PERIPH_NUM: u32 = 2;
pub const SOC_ADC_PATT_LEN_MAX: u32 = 16;
pub const SOC_ADC_MAX_CHANNEL_NUM: u32 = 10;
pub const SOC_ADC1_DATA_INVERT_DEFAULT: u32 = 1;
pub const SOC_ADC2_DATA_INVERT_DEFAULT: u32 = 1;
pub const SOC_ADC_FSM_RSTB_WAIT_DEFAULT: u32 = 8;
pub const SOC_ADC_FSM_START_WAIT_DEFAULT: u32 = 5;
pub const SOC_ADC_FSM_STANDBY_WAIT_DEFAULT: u32 = 100;
pub const ADC_FSM_SAMPLE_CYCLE_DEFAULT: u32 = 2;
pub const SOC_ADC_PWDET_CCT_DEFAULT: u32 = 4;
pub const ESP_ERR_NVS_BASE: u32 = 4352;
pub const ESP_ERR_NVS_NOT_INITIALIZED: u32 = 4353;
pub const ESP_ERR_NVS_NOT_FOUND: u32 = 4354;
pub const ESP_ERR_NVS_TYPE_MISMATCH: u32 = 4355;
pub const ESP_ERR_NVS_READ_ONLY: u32 = 4356;
pub const ESP_ERR_NVS_NOT_ENOUGH_SPACE: u32 = 4357;
pub const ESP_ERR_NVS_INVALID_NAME: u32 = 4358;
pub const ESP_ERR_NVS_INVALID_HANDLE: u32 = 4359;
pub const ESP_ERR_NVS_REMOVE_FAILED: u32 = 4360;
pub const ESP_ERR_NVS_KEY_TOO_LONG: u32 = 4361;
pub const ESP_ERR_NVS_PAGE_FULL: u32 = 4362;
pub const ESP_ERR_NVS_INVALID_STATE: u32 = 4363;
pub const ESP_ERR_NVS_INVALID_LENGTH: u32 = 4364;
pub const ESP_ERR_NVS_NO_FREE_PAGES: u32 = 4365;
pub const ESP_ERR_NVS_VALUE_TOO_LONG: u32 = 4366;
pub const ESP_ERR_NVS_PART_NOT_FOUND: u32 = 4367;
pub const ESP_ERR_NVS_NEW_VERSION_FOUND: u32 = 4368;
pub const ESP_ERR_NVS_XTS_ENCR_FAILED: u32 = 4369;
pub const ESP_ERR_NVS_XTS_DECR_FAILED: u32 = 4370;
pub const ESP_ERR_NVS_XTS_CFG_FAILED: u32 = 4371;
pub const ESP_ERR_NVS_XTS_CFG_NOT_FOUND: u32 = 4372;
pub const ESP_ERR_NVS_ENCR_NOT_SUPPORTED: u32 = 4373;
pub const ESP_ERR_NVS_KEYS_NOT_INITIALIZED: u32 = 4374;
pub const ESP_ERR_NVS_CORRUPT_KEY_PART: u32 = 4375;
pub const ESP_ERR_NVS_CONTENT_DIFFERS: u32 = 4376;
pub const NVS_DEFAULT_PART_NAME: &'static [u8; 4usize] = b"nvs\0";
pub const NVS_PART_NAME_MAX_SIZE: u32 = 16;
pub const ESP_ERR_FLASH_NOT_INITIALISED: u32 = 24579;
pub const ESP_ERR_FLASH_UNSUPPORTED_HOST: u32 = 24580;
pub const ESP_ERR_FLASH_UNSUPPORTED_CHIP: u32 = 24581;
pub const ESP_ERR_FLASH_PROTECTED: u32 = 24582;
pub const NVS_KEY_SIZE: u32 = 32;
pub const LLDESC_TX_MBLK_SIZE: u32 = 268;
pub const LLDESC_RX_SMBLK_SIZE: u32 = 64;
pub const LLDESC_RX_MBLK_SIZE: u32 = 524;
pub const LLDESC_RX_AMPDU_ENTRY_MBLK_SIZE: u32 = 64;
pub const LLDESC_RX_AMPDU_LEN_MBLK_SIZE: u32 = 256;
pub const LLDESC_TX_MBLK_NUM: u32 = 10;
pub const LLDESC_RX_MBLK_NUM: u32 = 10;
pub const LLDESC_RX_AMPDU_ENTRY_MBLK_NUM: u32 = 4;
pub const LLDESC_RX_AMPDU_LEN_MLBK_NUM: u32 = 8;
pub const LLDESC_OWNER_MASK: u32 = 2147483648;
pub const LLDESC_OWNER_SHIFT: u32 = 31;
pub const LLDESC_SW_OWNED: u32 = 0;
pub const LLDESC_HW_OWNED: u32 = 1;
pub const LLDESC_EOF_MASK: u32 = 1073741824;
pub const LLDESC_EOF_SHIFT: u32 = 30;
pub const LLDESC_SOSF_MASK: u32 = 536870912;
pub const LLDESC_SOSF_SHIFT: u32 = 29;
pub const LLDESC_LENGTH_MASK: u32 = 16773120;
pub const LLDESC_LENGTH_SHIFT: u32 = 12;
pub const LLDESC_SIZE_MASK: u32 = 4095;
pub const LLDESC_SIZE_SHIFT: u32 = 0;
pub const LLDESC_ADDR_MASK: u32 = 1048575;
pub const SOC_MCPWM_SUPPORTED: u32 = 1;
pub const SOC_SDMMC_HOST_SUPPORTED: u32 = 1;
pub const SOC_BT_SUPPORTED: u32 = 1;
pub const SOC_SDIO_SLAVE_SUPPORTED: u32 = 1;
pub const SOC_CAN_SUPPORTED: u32 = 1;
pub const CAN_EXTD_ID_MASK: u32 = 536870911;
pub const CAN_STD_ID_MASK: u32 = 2047;
pub const CAN_FRAME_MAX_DLC: u32 = 8;
pub const CAN_FRAME_EXTD_ID_LEN_BYTES: u32 = 4;
pub const CAN_FRAME_STD_ID_LEN_BYTES: u32 = 2;
pub const CAN_ERR_PASS_THRESH: u32 = 128;
pub const CAN_MSG_FLAG_NONE: u32 = 0;
pub const CAN_MSG_FLAG_EXTD: u32 = 1;
pub const CAN_MSG_FLAG_RTR: u32 = 2;
pub const CAN_MSG_FLAG_SS: u32 = 4;
pub const CAN_MSG_FLAG_SELF: u32 = 8;
pub const CAN_MSG_FLAG_DLC_NON_COMP: u32 = 16;
pub const CAN_ALERT_TX_IDLE: u32 = 1;
pub const CAN_ALERT_TX_SUCCESS: u32 = 2;
pub const CAN_ALERT_BELOW_ERR_WARN: u32 = 4;
pub const CAN_ALERT_ERR_ACTIVE: u32 = 8;
pub const CAN_ALERT_RECOVERY_IN_PROGRESS: u32 = 16;
pub const CAN_ALERT_BUS_RECOVERED: u32 = 32;
pub const CAN_ALERT_ARB_LOST: u32 = 64;
pub const CAN_ALERT_ABOVE_ERR_WARN: u32 = 128;
pub const CAN_ALERT_BUS_ERROR: u32 = 256;
pub const CAN_ALERT_TX_FAILED: u32 = 512;
pub const CAN_ALERT_RX_QUEUE_FULL: u32 = 1024;
pub const CAN_ALERT_ERR_PASS: u32 = 2048;
pub const CAN_ALERT_BUS_OFF: u32 = 4096;
pub const CAN_ALERT_ALL: u32 = 8191;
pub const CAN_ALERT_NONE: u32 = 0;
pub const CAN_ALERT_AND_LOG: u32 = 8192;
pub const SOC_DAC_PERIPH_NUM: u32 = 2;
pub const SOC_DAC_RESOLUTION: u32 = 8;
pub const SOC_I2C_NUM: u32 = 2;
pub const SOC_I2C_FIFO_LEN: u32 = 32;
pub const I2C_INTR_MASK: u32 = 16383;
pub const I2C_SUPPORT_HW_FSM_RST: u32 = 0;
pub const I2C_SUPPORT_HW_CLR_BUS: u32 = 0;
pub const I2C_APB_CLK_FREQ: u32 = 80000000;
pub const I2C_NUM_0: u32 = 0;
pub const I2C_NUM_1: u32 = 1;
pub const I2C_NUM_MAX: u32 = 2;
pub const I2S_SIG_LOOPBACK_V: u32 = 1;
pub const I2S_SIG_LOOPBACK_S: u32 = 18;
pub const I2S_RX_MSB_RIGHT_V: u32 = 1;
pub const I2S_RX_MSB_RIGHT_S: u32 = 17;
pub const I2S_TX_MSB_RIGHT_V: u32 = 1;
pub const I2S_TX_MSB_RIGHT_S: u32 = 16;
pub const I2S_RX_MONO_V: u32 = 1;
pub const I2S_RX_MONO_S: u32 = 15;
pub const I2S_TX_MONO_V: u32 = 1;
pub const I2S_TX_MONO_S: u32 = 14;
pub const I2S_RX_SHORT_SYNC_V: u32 = 1;
pub const I2S_RX_SHORT_SYNC_S: u32 = 13;
pub const I2S_TX_SHORT_SYNC_V: u32 = 1;
pub const I2S_TX_SHORT_SYNC_S: u32 = 12;
pub const I2S_RX_MSB_SHIFT_V: u32 = 1;
pub const I2S_RX_MSB_SHIFT_S: u32 = 11;
pub const I2S_TX_MSB_SHIFT_V: u32 = 1;
pub const I2S_TX_MSB_SHIFT_S: u32 = 10;
pub const I2S_RX_RIGHT_FIRST_V: u32 = 1;
pub const I2S_RX_RIGHT_FIRST_S: u32 = 9;
pub const I2S_TX_RIGHT_FIRST_V: u32 = 1;
pub const I2S_TX_RIGHT_FIRST_S: u32 = 8;
pub const I2S_RX_SLAVE_MOD_V: u32 = 1;
pub const I2S_RX_SLAVE_MOD_S: u32 = 7;
pub const I2S_TX_SLAVE_MOD_V: u32 = 1;
pub const I2S_TX_SLAVE_MOD_S: u32 = 6;
pub const I2S_RX_START_V: u32 = 1;
pub const I2S_RX_START_S: u32 = 5;
pub const I2S_TX_START_V: u32 = 1;
pub const I2S_TX_START_S: u32 = 4;
pub const I2S_RX_FIFO_RESET_V: u32 = 1;
pub const I2S_RX_FIFO_RESET_S: u32 = 3;
pub const I2S_TX_FIFO_RESET_V: u32 = 1;
pub const I2S_TX_FIFO_RESET_S: u32 = 2;
pub const I2S_RX_RESET_V: u32 = 1;
pub const I2S_RX_RESET_S: u32 = 1;
pub const I2S_TX_RESET_V: u32 = 1;
pub const I2S_TX_RESET_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_RAW_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_RAW_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_RAW_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_RAW_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_RAW_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_RAW_S: u32 = 13;
pub const I2S_OUT_EOF_INT_RAW_V: u32 = 1;
pub const I2S_OUT_EOF_INT_RAW_S: u32 = 12;
pub const I2S_OUT_DONE_INT_RAW_V: u32 = 1;
pub const I2S_OUT_DONE_INT_RAW_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_RAW_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_RAW_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_RAW_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_RAW_S: u32 = 9;
pub const I2S_IN_DONE_INT_RAW_V: u32 = 1;
pub const I2S_IN_DONE_INT_RAW_S: u32 = 8;
pub const I2S_TX_HUNG_INT_RAW_V: u32 = 1;
pub const I2S_TX_HUNG_INT_RAW_S: u32 = 7;
pub const I2S_RX_HUNG_INT_RAW_V: u32 = 1;
pub const I2S_RX_HUNG_INT_RAW_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_RAW_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_RAW_S: u32 = 5;
pub const I2S_TX_WFULL_INT_RAW_V: u32 = 1;
pub const I2S_TX_WFULL_INT_RAW_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_RAW_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_RAW_S: u32 = 3;
pub const I2S_RX_WFULL_INT_RAW_V: u32 = 1;
pub const I2S_RX_WFULL_INT_RAW_S: u32 = 2;
pub const I2S_TX_PUT_DATA_INT_RAW_V: u32 = 1;
pub const I2S_TX_PUT_DATA_INT_RAW_S: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_RAW_V: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_RAW_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_ST_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_ST_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_ST_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_ST_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_ST_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_ST_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_ST_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_ST_S: u32 = 13;
pub const I2S_OUT_EOF_INT_ST_V: u32 = 1;
pub const I2S_OUT_EOF_INT_ST_S: u32 = 12;
pub const I2S_OUT_DONE_INT_ST_V: u32 = 1;
pub const I2S_OUT_DONE_INT_ST_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_ST_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_ST_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_ST_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_ST_S: u32 = 9;
pub const I2S_IN_DONE_INT_ST_V: u32 = 1;
pub const I2S_IN_DONE_INT_ST_S: u32 = 8;
pub const I2S_TX_HUNG_INT_ST_V: u32 = 1;
pub const I2S_TX_HUNG_INT_ST_S: u32 = 7;
pub const I2S_RX_HUNG_INT_ST_V: u32 = 1;
pub const I2S_RX_HUNG_INT_ST_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_ST_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_ST_S: u32 = 5;
pub const I2S_TX_WFULL_INT_ST_V: u32 = 1;
pub const I2S_TX_WFULL_INT_ST_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_ST_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_ST_S: u32 = 3;
pub const I2S_RX_WFULL_INT_ST_V: u32 = 1;
pub const I2S_RX_WFULL_INT_ST_S: u32 = 2;
pub const I2S_TX_PUT_DATA_INT_ST_V: u32 = 1;
pub const I2S_TX_PUT_DATA_INT_ST_S: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ST_V: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ST_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_ENA_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_ENA_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_ENA_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_ENA_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_ENA_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_ENA_S: u32 = 13;
pub const I2S_OUT_EOF_INT_ENA_V: u32 = 1;
pub const I2S_OUT_EOF_INT_ENA_S: u32 = 12;
pub const I2S_OUT_DONE_INT_ENA_V: u32 = 1;
pub const I2S_OUT_DONE_INT_ENA_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_ENA_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_ENA_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_ENA_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_ENA_S: u32 = 9;
pub const I2S_IN_DONE_INT_ENA_V: u32 = 1;
pub const I2S_IN_DONE_INT_ENA_S: u32 = 8;
pub const I2S_TX_HUNG_INT_ENA_V: u32 = 1;
pub const I2S_TX_HUNG_INT_ENA_S: u32 = 7;
pub const I2S_RX_HUNG_INT_ENA_V: u32 = 1;
pub const I2S_RX_HUNG_INT_ENA_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_ENA_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_ENA_S: u32 = 5;
pub const I2S_TX_WFULL_INT_ENA_V: u32 = 1;
pub const I2S_TX_WFULL_INT_ENA_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_ENA_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_ENA_S: u32 = 3;
pub const I2S_RX_WFULL_INT_ENA_V: u32 = 1;
pub const I2S_RX_WFULL_INT_ENA_S: u32 = 2;
pub const I2S_TX_PUT_DATA_INT_ENA_V: u32 = 1;
pub const I2S_TX_PUT_DATA_INT_ENA_S: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ENA_V: u32 = 1;
pub const I2S_RX_TAKE_DATA_INT_ENA_S: u32 = 0;
pub const I2S_OUT_TOTAL_EOF_INT_CLR_V: u32 = 1;
pub const I2S_OUT_TOTAL_EOF_INT_CLR_S: u32 = 16;
pub const I2S_IN_DSCR_EMPTY_INT_CLR_V: u32 = 1;
pub const I2S_IN_DSCR_EMPTY_INT_CLR_S: u32 = 15;
pub const I2S_OUT_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const I2S_OUT_DSCR_ERR_INT_CLR_S: u32 = 14;
pub const I2S_IN_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const I2S_IN_DSCR_ERR_INT_CLR_S: u32 = 13;
pub const I2S_OUT_EOF_INT_CLR_V: u32 = 1;
pub const I2S_OUT_EOF_INT_CLR_S: u32 = 12;
pub const I2S_OUT_DONE_INT_CLR_V: u32 = 1;
pub const I2S_OUT_DONE_INT_CLR_S: u32 = 11;
pub const I2S_IN_ERR_EOF_INT_CLR_V: u32 = 1;
pub const I2S_IN_ERR_EOF_INT_CLR_S: u32 = 10;
pub const I2S_IN_SUC_EOF_INT_CLR_V: u32 = 1;
pub const I2S_IN_SUC_EOF_INT_CLR_S: u32 = 9;
pub const I2S_IN_DONE_INT_CLR_V: u32 = 1;
pub const I2S_IN_DONE_INT_CLR_S: u32 = 8;
pub const I2S_TX_HUNG_INT_CLR_V: u32 = 1;
pub const I2S_TX_HUNG_INT_CLR_S: u32 = 7;
pub const I2S_RX_HUNG_INT_CLR_V: u32 = 1;
pub const I2S_RX_HUNG_INT_CLR_S: u32 = 6;
pub const I2S_TX_REMPTY_INT_CLR_V: u32 = 1;
pub const I2S_TX_REMPTY_INT_CLR_S: u32 = 5;
pub const I2S_TX_WFULL_INT_CLR_V: u32 = 1;
pub const I2S_TX_WFULL_INT_CLR_S: u32 = 4;
pub const I2S_RX_REMPTY_INT_CLR_V: u32 = 1;
pub const I2S_RX_REMPTY_INT_CLR_S: u32 = 3;
pub const I2S_RX_WFULL_INT_CLR_V: u32 = 1;
pub const I2S_RX_WFULL_INT_CLR_S: u32 = 2;
pub const I2S_PUT_DATA_INT_CLR_V: u32 = 1;
pub const I2S_PUT_DATA_INT_CLR_S: u32 = 1;
pub const I2S_TAKE_DATA_INT_CLR_V: u32 = 1;
pub const I2S_TAKE_DATA_INT_CLR_S: u32 = 0;
pub const I2S_TX_BCK_IN_INV_V: u32 = 1;
pub const I2S_TX_BCK_IN_INV_S: u32 = 24;
pub const I2S_DATA_ENABLE_DELAY: u32 = 3;
pub const I2S_DATA_ENABLE_DELAY_V: u32 = 3;
pub const I2S_DATA_ENABLE_DELAY_S: u32 = 22;
pub const I2S_RX_DSYNC_SW_V: u32 = 1;
pub const I2S_RX_DSYNC_SW_S: u32 = 21;
pub const I2S_TX_DSYNC_SW_V: u32 = 1;
pub const I2S_TX_DSYNC_SW_S: u32 = 20;
pub const I2S_RX_BCK_OUT_DELAY: u32 = 3;
pub const I2S_RX_BCK_OUT_DELAY_V: u32 = 3;
pub const I2S_RX_BCK_OUT_DELAY_S: u32 = 18;
pub const I2S_RX_WS_OUT_DELAY: u32 = 3;
pub const I2S_RX_WS_OUT_DELAY_V: u32 = 3;
pub const I2S_RX_WS_OUT_DELAY_S: u32 = 16;
pub const I2S_TX_SD_OUT_DELAY: u32 = 3;
pub const I2S_TX_SD_OUT_DELAY_V: u32 = 3;
pub const I2S_TX_SD_OUT_DELAY_S: u32 = 14;
pub const I2S_TX_WS_OUT_DELAY: u32 = 3;
pub const I2S_TX_WS_OUT_DELAY_V: u32 = 3;
pub const I2S_TX_WS_OUT_DELAY_S: u32 = 12;
pub const I2S_TX_BCK_OUT_DELAY: u32 = 3;
pub const I2S_TX_BCK_OUT_DELAY_V: u32 = 3;
pub const I2S_TX_BCK_OUT_DELAY_S: u32 = 10;
pub const I2S_RX_SD_IN_DELAY: u32 = 3;
pub const I2S_RX_SD_IN_DELAY_V: u32 = 3;
pub const I2S_RX_SD_IN_DELAY_S: u32 = 8;
pub const I2S_RX_WS_IN_DELAY: u32 = 3;
pub const I2S_RX_WS_IN_DELAY_V: u32 = 3;
pub const I2S_RX_WS_IN_DELAY_S: u32 = 6;
pub const I2S_RX_BCK_IN_DELAY: u32 = 3;
pub const I2S_RX_BCK_IN_DELAY_V: u32 = 3;
pub const I2S_RX_BCK_IN_DELAY_S: u32 = 4;
pub const I2S_TX_WS_IN_DELAY: u32 = 3;
pub const I2S_TX_WS_IN_DELAY_V: u32 = 3;
pub const I2S_TX_WS_IN_DELAY_S: u32 = 2;
pub const I2S_TX_BCK_IN_DELAY: u32 = 3;
pub const I2S_TX_BCK_IN_DELAY_V: u32 = 3;
pub const I2S_TX_BCK_IN_DELAY_S: u32 = 0;
pub const I2S_RX_FIFO_MOD_FORCE_EN_V: u32 = 1;
pub const I2S_RX_FIFO_MOD_FORCE_EN_S: u32 = 20;
pub const I2S_TX_FIFO_MOD_FORCE_EN_V: u32 = 1;
pub const I2S_TX_FIFO_MOD_FORCE_EN_S: u32 = 19;
pub const I2S_RX_FIFO_MOD: u32 = 7;
pub const I2S_RX_FIFO_MOD_V: u32 = 7;
pub const I2S_RX_FIFO_MOD_S: u32 = 16;
pub const I2S_TX_FIFO_MOD: u32 = 7;
pub const I2S_TX_FIFO_MOD_V: u32 = 7;
pub const I2S_TX_FIFO_MOD_S: u32 = 13;
pub const I2S_DSCR_EN_V: u32 = 1;
pub const I2S_DSCR_EN_S: u32 = 12;
pub const I2S_TX_DATA_NUM: u32 = 63;
pub const I2S_TX_DATA_NUM_V: u32 = 63;
pub const I2S_TX_DATA_NUM_S: u32 = 6;
pub const I2S_RX_DATA_NUM: u32 = 63;
pub const I2S_RX_DATA_NUM_V: u32 = 63;
pub const I2S_RX_DATA_NUM_S: u32 = 0;
pub const I2S_RX_EOF_NUM: u32 = 4294967295;
pub const I2S_RX_EOF_NUM_V: u32 = 4294967295;
pub const I2S_RX_EOF_NUM_S: u32 = 0;
pub const I2S_SIGLE_DATA: u32 = 4294967295;
pub const I2S_SIGLE_DATA_V: u32 = 4294967295;
pub const I2S_SIGLE_DATA_S: u32 = 0;
pub const I2S_RX_CHAN_MOD: u32 = 3;
pub const I2S_RX_CHAN_MOD_V: u32 = 3;
pub const I2S_RX_CHAN_MOD_S: u32 = 3;
pub const I2S_TX_CHAN_MOD: u32 = 7;
pub const I2S_TX_CHAN_MOD_V: u32 = 7;
pub const I2S_TX_CHAN_MOD_S: u32 = 0;
pub const I2S_OUTLINK_PARK_V: u32 = 1;
pub const I2S_OUTLINK_PARK_S: u32 = 31;
pub const I2S_OUTLINK_RESTART_V: u32 = 1;
pub const I2S_OUTLINK_RESTART_S: u32 = 30;
pub const I2S_OUTLINK_START_V: u32 = 1;
pub const I2S_OUTLINK_START_S: u32 = 29;
pub const I2S_OUTLINK_STOP_V: u32 = 1;
pub const I2S_OUTLINK_STOP_S: u32 = 28;
pub const I2S_OUTLINK_ADDR: u32 = 1048575;
pub const I2S_OUTLINK_ADDR_V: u32 = 1048575;
pub const I2S_OUTLINK_ADDR_S: u32 = 0;
pub const I2S_INLINK_PARK_V: u32 = 1;
pub const I2S_INLINK_PARK_S: u32 = 31;
pub const I2S_INLINK_RESTART_V: u32 = 1;
pub const I2S_INLINK_RESTART_S: u32 = 30;
pub const I2S_INLINK_START_V: u32 = 1;
pub const I2S_INLINK_START_S: u32 = 29;
pub const I2S_INLINK_STOP_V: u32 = 1;
pub const I2S_INLINK_STOP_S: u32 = 28;
pub const I2S_INLINK_ADDR: u32 = 1048575;
pub const I2S_INLINK_ADDR_V: u32 = 1048575;
pub const I2S_INLINK_ADDR_S: u32 = 0;
pub const I2S_OUT_EOF_DES_ADDR: u32 = 4294967295;
pub const I2S_OUT_EOF_DES_ADDR_V: u32 = 4294967295;
pub const I2S_OUT_EOF_DES_ADDR_S: u32 = 0;
pub const I2S_IN_SUC_EOF_DES_ADDR: u32 = 4294967295;
pub const I2S_IN_SUC_EOF_DES_ADDR_V: u32 = 4294967295;
pub const I2S_IN_SUC_EOF_DES_ADDR_S: u32 = 0;
pub const I2S_OUT_EOF_BFR_DES_ADDR: u32 = 4294967295;
pub const I2S_OUT_EOF_BFR_DES_ADDR_V: u32 = 4294967295;
pub const I2S_OUT_EOF_BFR_DES_ADDR_S: u32 = 0;
pub const I2S_AHB_TESTADDR: u32 = 3;
pub const I2S_AHB_TESTADDR_V: u32 = 3;
pub const I2S_AHB_TESTADDR_S: u32 = 4;
pub const I2S_AHB_TESTMODE: u32 = 7;
pub const I2S_AHB_TESTMODE_V: u32 = 7;
pub const I2S_AHB_TESTMODE_S: u32 = 0;
pub const I2S_INLINK_DSCR: u32 = 4294967295;
pub const I2S_INLINK_DSCR_V: u32 = 4294967295;
pub const I2S_INLINK_DSCR_S: u32 = 0;
pub const I2S_INLINK_DSCR_BF0: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF0_V: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF0_S: u32 = 0;
pub const I2S_INLINK_DSCR_BF1: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF1_V: u32 = 4294967295;
pub const I2S_INLINK_DSCR_BF1_S: u32 = 0;
pub const I2S_OUTLINK_DSCR: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_V: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_S: u32 = 0;
pub const I2S_OUTLINK_DSCR_BF0: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF0_V: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF0_S: u32 = 0;
pub const I2S_OUTLINK_DSCR_BF1: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF1_V: u32 = 4294967295;
pub const I2S_OUTLINK_DSCR_BF1_S: u32 = 0;
pub const I2S_MEM_TRANS_EN_V: u32 = 1;
pub const I2S_MEM_TRANS_EN_S: u32 = 13;
pub const I2S_CHECK_OWNER_V: u32 = 1;
pub const I2S_CHECK_OWNER_S: u32 = 12;
pub const I2S_OUT_DATA_BURST_EN_V: u32 = 1;
pub const I2S_OUT_DATA_BURST_EN_S: u32 = 11;
pub const I2S_INDSCR_BURST_EN_V: u32 = 1;
pub const I2S_INDSCR_BURST_EN_S: u32 = 10;
pub const I2S_OUTDSCR_BURST_EN_V: u32 = 1;
pub const I2S_OUTDSCR_BURST_EN_S: u32 = 9;
pub const I2S_OUT_EOF_MODE_V: u32 = 1;
pub const I2S_OUT_EOF_MODE_S: u32 = 8;
pub const I2S_OUT_NO_RESTART_CLR_V: u32 = 1;
pub const I2S_OUT_NO_RESTART_CLR_S: u32 = 7;
pub const I2S_OUT_AUTO_WRBACK_V: u32 = 1;
pub const I2S_OUT_AUTO_WRBACK_S: u32 = 6;
pub const I2S_IN_LOOP_TEST_V: u32 = 1;
pub const I2S_IN_LOOP_TEST_S: u32 = 5;
pub const I2S_OUT_LOOP_TEST_V: u32 = 1;
pub const I2S_OUT_LOOP_TEST_S: u32 = 4;
pub const I2S_AHBM_RST_V: u32 = 1;
pub const I2S_AHBM_RST_S: u32 = 3;
pub const I2S_AHBM_FIFO_RST_V: u32 = 1;
pub const I2S_AHBM_FIFO_RST_S: u32 = 2;
pub const I2S_OUT_RST_V: u32 = 1;
pub const I2S_OUT_RST_S: u32 = 1;
pub const I2S_IN_RST_V: u32 = 1;
pub const I2S_IN_RST_S: u32 = 0;
pub const I2S_OUTFIFO_PUSH_V: u32 = 1;
pub const I2S_OUTFIFO_PUSH_S: u32 = 16;
pub const I2S_OUTFIFO_WDATA: u32 = 511;
pub const I2S_OUTFIFO_WDATA_V: u32 = 511;
pub const I2S_OUTFIFO_WDATA_S: u32 = 0;
pub const I2S_INFIFO_POP_V: u32 = 1;
pub const I2S_INFIFO_POP_S: u32 = 16;
pub const I2S_INFIFO_RDATA: u32 = 4095;
pub const I2S_INFIFO_RDATA_V: u32 = 4095;
pub const I2S_INFIFO_RDATA_S: u32 = 0;
pub const I2S_LC_STATE0: u32 = 4294967295;
pub const I2S_LC_STATE0_V: u32 = 4294967295;
pub const I2S_LC_STATE0_S: u32 = 0;
pub const I2S_LC_STATE1: u32 = 4294967295;
pub const I2S_LC_STATE1_V: u32 = 4294967295;
pub const I2S_LC_STATE1_S: u32 = 0;
pub const I2S_LC_FIFO_TIMEOUT_ENA_V: u32 = 1;
pub const I2S_LC_FIFO_TIMEOUT_ENA_S: u32 = 11;
pub const I2S_LC_FIFO_TIMEOUT_SHIFT: u32 = 7;
pub const I2S_LC_FIFO_TIMEOUT_SHIFT_V: u32 = 7;
pub const I2S_LC_FIFO_TIMEOUT_SHIFT_S: u32 = 8;
pub const I2S_LC_FIFO_TIMEOUT: u32 = 255;
pub const I2S_LC_FIFO_TIMEOUT_V: u32 = 255;
pub const I2S_LC_FIFO_TIMEOUT_S: u32 = 0;
pub const I2S_CVSD_Y_MIN: u32 = 65535;
pub const I2S_CVSD_Y_MIN_V: u32 = 65535;
pub const I2S_CVSD_Y_MIN_S: u32 = 16;
pub const I2S_CVSD_Y_MAX: u32 = 65535;
pub const I2S_CVSD_Y_MAX_V: u32 = 65535;
pub const I2S_CVSD_Y_MAX_S: u32 = 0;
pub const I2S_CVSD_SIGMA_MIN: u32 = 65535;
pub const I2S_CVSD_SIGMA_MIN_V: u32 = 65535;
pub const I2S_CVSD_SIGMA_MIN_S: u32 = 16;
pub const I2S_CVSD_SIGMA_MAX: u32 = 65535;
pub const I2S_CVSD_SIGMA_MAX_V: u32 = 65535;
pub const I2S_CVSD_SIGMA_MAX_S: u32 = 0;
pub const I2S_CVSD_H: u32 = 7;
pub const I2S_CVSD_H_V: u32 = 7;
pub const I2S_CVSD_H_S: u32 = 16;
pub const I2S_CVSD_BETA: u32 = 1023;
pub const I2S_CVSD_BETA_V: u32 = 1023;
pub const I2S_CVSD_BETA_S: u32 = 6;
pub const I2S_CVSD_J: u32 = 7;
pub const I2S_CVSD_J_V: u32 = 7;
pub const I2S_CVSD_J_S: u32 = 3;
pub const I2S_CVSD_K: u32 = 7;
pub const I2S_CVSD_K_V: u32 = 7;
pub const I2S_CVSD_K_S: u32 = 0;
pub const I2S_N_MIN_ERR: u32 = 7;
pub const I2S_N_MIN_ERR_V: u32 = 7;
pub const I2S_N_MIN_ERR_S: u32 = 25;
pub const I2S_PACK_LEN_8K: u32 = 31;
pub const I2S_PACK_LEN_8K_V: u32 = 31;
pub const I2S_PACK_LEN_8K_S: u32 = 20;
pub const I2S_MAX_SLIDE_SAMPLE: u32 = 255;
pub const I2S_MAX_SLIDE_SAMPLE_V: u32 = 255;
pub const I2S_MAX_SLIDE_SAMPLE_S: u32 = 12;
pub const I2S_SHIFT_RATE: u32 = 7;
pub const I2S_SHIFT_RATE_V: u32 = 7;
pub const I2S_SHIFT_RATE_S: u32 = 9;
pub const I2S_N_ERR_SEG: u32 = 7;
pub const I2S_N_ERR_SEG_V: u32 = 7;
pub const I2S_N_ERR_SEG_S: u32 = 6;
pub const I2S_GOOD_PACK_MAX: u32 = 63;
pub const I2S_GOOD_PACK_MAX_V: u32 = 63;
pub const I2S_GOOD_PACK_MAX_S: u32 = 0;
pub const I2S_SLIDE_WIN_LEN: u32 = 255;
pub const I2S_SLIDE_WIN_LEN_V: u32 = 255;
pub const I2S_SLIDE_WIN_LEN_S: u32 = 24;
pub const I2S_BAD_OLA_WIN2_PARA: u32 = 255;
pub const I2S_BAD_OLA_WIN2_PARA_V: u32 = 255;
pub const I2S_BAD_OLA_WIN2_PARA_S: u32 = 16;
pub const I2S_BAD_OLA_WIN2_PARA_SHIFT: u32 = 15;
pub const I2S_BAD_OLA_WIN2_PARA_SHIFT_V: u32 = 15;
pub const I2S_BAD_OLA_WIN2_PARA_SHIFT_S: u32 = 12;
pub const I2S_BAD_CEF_ATTEN_PARA_SHIFT: u32 = 15;
pub const I2S_BAD_CEF_ATTEN_PARA_SHIFT_V: u32 = 15;
pub const I2S_BAD_CEF_ATTEN_PARA_SHIFT_S: u32 = 8;
pub const I2S_BAD_CEF_ATTEN_PARA: u32 = 255;
pub const I2S_BAD_CEF_ATTEN_PARA_V: u32 = 255;
pub const I2S_BAD_CEF_ATTEN_PARA_S: u32 = 0;
pub const I2S_MIN_PERIOD: u32 = 31;
pub const I2S_MIN_PERIOD_V: u32 = 31;
pub const I2S_MIN_PERIOD_S: u32 = 2;
pub const I2S_CVSD_SEG_MOD: u32 = 3;
pub const I2S_CVSD_SEG_MOD_V: u32 = 3;
pub const I2S_CVSD_SEG_MOD_S: u32 = 0;
pub const I2S_PLC2DMA_EN_V: u32 = 1;
pub const I2S_PLC2DMA_EN_S: u32 = 12;
pub const I2S_PLC_EN_V: u32 = 1;
pub const I2S_PLC_EN_S: u32 = 11;
pub const I2S_CVSD_DEC_RESET_V: u32 = 1;
pub const I2S_CVSD_DEC_RESET_S: u32 = 10;
pub const I2S_CVSD_DEC_START_V: u32 = 1;
pub const I2S_CVSD_DEC_START_S: u32 = 9;
pub const I2S_ESCO_CVSD_INF_EN_V: u32 = 1;
pub const I2S_ESCO_CVSD_INF_EN_S: u32 = 8;
pub const I2S_ESCO_CVSD_PACK_LEN_8K: u32 = 31;
pub const I2S_ESCO_CVSD_PACK_LEN_8K_V: u32 = 31;
pub const I2S_ESCO_CVSD_PACK_LEN_8K_S: u32 = 3;
pub const I2S_ESCO_CVSD_DEC_PACK_ERR_V: u32 = 1;
pub const I2S_ESCO_CVSD_DEC_PACK_ERR_S: u32 = 2;
pub const I2S_ESCO_CHAN_MOD_V: u32 = 1;
pub const I2S_ESCO_CHAN_MOD_S: u32 = 1;
pub const I2S_ESCO_EN_V: u32 = 1;
pub const I2S_ESCO_EN_S: u32 = 0;
pub const I2S_CVSD_ENC_RESET_V: u32 = 1;
pub const I2S_CVSD_ENC_RESET_S: u32 = 3;
pub const I2S_CVSD_ENC_START_V: u32 = 1;
pub const I2S_CVSD_ENC_START_S: u32 = 2;
pub const I2S_SCO_NO_I2S_EN_V: u32 = 1;
pub const I2S_SCO_NO_I2S_EN_S: u32 = 1;
pub const I2S_SCO_WITH_I2S_EN_V: u32 = 1;
pub const I2S_SCO_WITH_I2S_EN_S: u32 = 0;
pub const I2S_TX_ZEROS_RM_EN_V: u32 = 1;
pub const I2S_TX_ZEROS_RM_EN_S: u32 = 9;
pub const I2S_TX_STOP_EN_V: u32 = 1;
pub const I2S_TX_STOP_EN_S: u32 = 8;
pub const I2S_RX_PCM_BYPASS_V: u32 = 1;
pub const I2S_RX_PCM_BYPASS_S: u32 = 7;
pub const I2S_RX_PCM_CONF: u32 = 7;
pub const I2S_RX_PCM_CONF_V: u32 = 7;
pub const I2S_RX_PCM_CONF_S: u32 = 4;
pub const I2S_TX_PCM_BYPASS_V: u32 = 1;
pub const I2S_TX_PCM_BYPASS_S: u32 = 3;
pub const I2S_TX_PCM_CONF: u32 = 7;
pub const I2S_TX_PCM_CONF_V: u32 = 7;
pub const I2S_TX_PCM_CONF_S: u32 = 0;
pub const I2S_PLC_MEM_FORCE_PU_V: u32 = 1;
pub const I2S_PLC_MEM_FORCE_PU_S: u32 = 3;
pub const I2S_PLC_MEM_FORCE_PD_V: u32 = 1;
pub const I2S_PLC_MEM_FORCE_PD_S: u32 = 2;
pub const I2S_FIFO_FORCE_PU_V: u32 = 1;
pub const I2S_FIFO_FORCE_PU_S: u32 = 1;
pub const I2S_FIFO_FORCE_PD_V: u32 = 1;
pub const I2S_FIFO_FORCE_PD_S: u32 = 0;
pub const I2S_INTER_VALID_EN_V: u32 = 1;
pub const I2S_INTER_VALID_EN_S: u32 = 7;
pub const I2S_EXT_ADC_START_EN_V: u32 = 1;
pub const I2S_EXT_ADC_START_EN_S: u32 = 6;
pub const I2S_LCD_EN_V: u32 = 1;
pub const I2S_LCD_EN_S: u32 = 5;
pub const I2S_DATA_ENABLE_V: u32 = 1;
pub const I2S_DATA_ENABLE_S: u32 = 4;
pub const I2S_DATA_ENABLE_TEST_EN_V: u32 = 1;
pub const I2S_DATA_ENABLE_TEST_EN_S: u32 = 3;
pub const I2S_LCD_TX_SDX2_EN_V: u32 = 1;
pub const I2S_LCD_TX_SDX2_EN_S: u32 = 2;
pub const I2S_LCD_TX_WRX2_EN_V: u32 = 1;
pub const I2S_LCD_TX_WRX2_EN_S: u32 = 1;
pub const I2S_CAMERA_EN_V: u32 = 1;
pub const I2S_CAMERA_EN_S: u32 = 0;
pub const I2S_CLKA_ENA_V: u32 = 1;
pub const I2S_CLKA_ENA_S: u32 = 21;
pub const I2S_CLK_EN_V: u32 = 1;
pub const I2S_CLK_EN_S: u32 = 20;
pub const I2S_CLKM_DIV_A: u32 = 63;
pub const I2S_CLKM_DIV_A_V: u32 = 63;
pub const I2S_CLKM_DIV_A_S: u32 = 14;
pub const I2S_CLKM_DIV_B: u32 = 63;
pub const I2S_CLKM_DIV_B_V: u32 = 63;
pub const I2S_CLKM_DIV_B_S: u32 = 8;
pub const I2S_CLKM_DIV_NUM: u32 = 255;
pub const I2S_CLKM_DIV_NUM_V: u32 = 255;
pub const I2S_CLKM_DIV_NUM_S: u32 = 0;
pub const I2S_RX_BITS_MOD: u32 = 63;
pub const I2S_RX_BITS_MOD_V: u32 = 63;
pub const I2S_RX_BITS_MOD_S: u32 = 18;
pub const I2S_TX_BITS_MOD: u32 = 63;
pub const I2S_TX_BITS_MOD_V: u32 = 63;
pub const I2S_TX_BITS_MOD_S: u32 = 12;
pub const I2S_RX_BCK_DIV_NUM: u32 = 63;
pub const I2S_RX_BCK_DIV_NUM_V: u32 = 63;
pub const I2S_RX_BCK_DIV_NUM_S: u32 = 6;
pub const I2S_TX_BCK_DIV_NUM: u32 = 63;
pub const I2S_TX_BCK_DIV_NUM_V: u32 = 63;
pub const I2S_TX_BCK_DIV_NUM_S: u32 = 0;
pub const I2S_TX_PDM_HP_BYPASS_V: u32 = 1;
pub const I2S_TX_PDM_HP_BYPASS_S: u32 = 25;
pub const I2S_RX_PDM_SINC_DSR_16_EN_V: u32 = 1;
pub const I2S_RX_PDM_SINC_DSR_16_EN_S: u32 = 24;
pub const I2S_TX_PDM_SIGMADELTA_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_SIGMADELTA_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_SIGMADELTA_IN_SHIFT_S: u32 = 22;
pub const I2S_TX_PDM_SINC_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_SINC_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_SINC_IN_SHIFT_S: u32 = 20;
pub const I2S_TX_PDM_LP_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_LP_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_LP_IN_SHIFT_S: u32 = 18;
pub const I2S_TX_PDM_HP_IN_SHIFT: u32 = 3;
pub const I2S_TX_PDM_HP_IN_SHIFT_V: u32 = 3;
pub const I2S_TX_PDM_HP_IN_SHIFT_S: u32 = 16;
pub const I2S_TX_PDM_PRESCALE: u32 = 255;
pub const I2S_TX_PDM_PRESCALE_V: u32 = 255;
pub const I2S_TX_PDM_PRESCALE_S: u32 = 8;
pub const I2S_TX_PDM_SINC_OSR2: u32 = 15;
pub const I2S_TX_PDM_SINC_OSR2_V: u32 = 15;
pub const I2S_TX_PDM_SINC_OSR2_S: u32 = 4;
pub const I2S_PDM2PCM_CONV_EN_V: u32 = 1;
pub const I2S_PDM2PCM_CONV_EN_S: u32 = 3;
pub const I2S_PCM2PDM_CONV_EN_V: u32 = 1;
pub const I2S_PCM2PDM_CONV_EN_S: u32 = 2;
pub const I2S_RX_PDM_EN_V: u32 = 1;
pub const I2S_RX_PDM_EN_S: u32 = 1;
pub const I2S_TX_PDM_EN_V: u32 = 1;
pub const I2S_TX_PDM_EN_S: u32 = 0;
pub const I2S_TX_PDM_FP: u32 = 1023;
pub const I2S_TX_PDM_FP_V: u32 = 1023;
pub const I2S_TX_PDM_FP_S: u32 = 10;
pub const I2S_TX_PDM_FS: u32 = 1023;
pub const I2S_TX_PDM_FS_V: u32 = 1023;
pub const I2S_TX_PDM_FS_S: u32 = 0;
pub const I2S_RX_FIFO_RESET_BACK_V: u32 = 1;
pub const I2S_RX_FIFO_RESET_BACK_S: u32 = 2;
pub const I2S_TX_FIFO_RESET_BACK_V: u32 = 1;
pub const I2S_TX_FIFO_RESET_BACK_S: u32 = 1;
pub const I2S_TX_IDLE_V: u32 = 1;
pub const I2S_TX_IDLE_S: u32 = 0;
pub const I2S_I2SDATE: u32 = 4294967295;
pub const I2S_I2SDATE_V: u32 = 4294967295;
pub const I2S_I2SDATE_S: u32 = 0;
pub const APLL_MIN_FREQ: u32 = 250000000;
pub const APLL_MAX_FREQ: u32 = 500000000;
pub const APLL_I2S_MIN_RATE: u32 = 10675;
pub const I2S_AD_BCK_FACTOR: u32 = 2;
pub const I2S_PDM_BCK_FACTOR: u32 = 64;
pub const I2S_MAX_BUFFER_SIZE: u32 = 4194304;
pub const I2S_BASE_CLK: u32 = 160000000;
pub const I2S_NUM_0: u32 = 0;
pub const I2S_NUM_1: u32 = 1;
pub const I2S_NUM_MAX: u32 = 2;
pub const SOC_I2S_NUM: u32 = 2;
pub const SOC_I2S_SUPPORT_PDM: u32 = 1;
pub const SOC_RTC_IO_PIN_COUNT: u32 = 18;
pub const SOC_PIN_FUNC_RTC_IO: u32 = 0;
pub const RTC_GPIO_NUMBER: u32 = 18;
pub const RTCIO_GPIO36_CHANNEL: u32 = 0;
pub const RTCIO_CHANNEL_0_GPIO_NUM: u32 = 36;
pub const RTCIO_GPIO37_CHANNEL: u32 = 1;
pub const RTCIO_CHANNEL_1_GPIO_NUM: u32 = 37;
pub const RTCIO_GPIO38_CHANNEL: u32 = 2;
pub const RTCIO_CHANNEL_2_GPIO_NUM: u32 = 38;
pub const RTCIO_GPIO39_CHANNEL: u32 = 3;
pub const RTCIO_CHANNEL_3_GPIO_NUM: u32 = 39;
pub const RTCIO_GPIO34_CHANNEL: u32 = 4;
pub const RTCIO_CHANNEL_4_GPIO_NUM: u32 = 34;
pub const RTCIO_GPIO35_CHANNEL: u32 = 5;
pub const RTCIO_CHANNEL_5_GPIO_NUM: u32 = 35;
pub const RTCIO_GPIO25_CHANNEL: u32 = 6;
pub const RTCIO_CHANNEL_6_GPIO_NUM: u32 = 25;
pub const RTCIO_GPIO26_CHANNEL: u32 = 7;
pub const RTCIO_CHANNEL_7_GPIO_NUM: u32 = 26;
pub const RTCIO_GPIO33_CHANNEL: u32 = 8;
pub const RTCIO_CHANNEL_8_GPIO_NUM: u32 = 33;
pub const RTCIO_GPIO32_CHANNEL: u32 = 9;
pub const RTCIO_CHANNEL_9_GPIO_NUM: u32 = 32;
pub const RTCIO_GPIO4_CHANNEL: u32 = 10;
pub const RTCIO_CHANNEL_10_GPIO_NUM: u32 = 4;
pub const RTCIO_GPIO0_CHANNEL: u32 = 11;
pub const RTCIO_CHANNEL_11_GPIO_NUM: u32 = 0;
pub const RTCIO_GPIO2_CHANNEL: u32 = 12;
pub const RTCIO_CHANNEL_12_GPIO_NUM: u32 = 2;
pub const RTCIO_GPIO15_CHANNEL: u32 = 13;
pub const RTCIO_CHANNEL_13_GPIO_NUM: u32 = 15;
pub const RTCIO_GPIO13_CHANNEL: u32 = 14;
pub const RTCIO_CHANNEL_14_GPIO_NUM: u32 = 13;
pub const RTCIO_GPIO12_CHANNEL: u32 = 15;
pub const RTCIO_CHANNEL_15_GPIO_NUM: u32 = 12;
pub const RTCIO_GPIO14_CHANNEL: u32 = 16;
pub const RTCIO_CHANNEL_16_GPIO_NUM: u32 = 14;
pub const RTCIO_GPIO27_CHANNEL: u32 = 17;
pub const RTCIO_CHANNEL_17_GPIO_NUM: u32 = 27;
pub const RTC_GPIO_OUT_REG: u32 = 1072989184;
pub const RTC_GPIO_OUT_DATA: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_S: u32 = 14;
pub const RTC_GPIO_OUT_W1TS_REG: u32 = 1072989188;
pub const RTC_GPIO_OUT_DATA_W1TS: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TS_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TS_S: u32 = 14;
pub const RTC_GPIO_OUT_W1TC_REG: u32 = 1072989192;
pub const RTC_GPIO_OUT_DATA_W1TC: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TC_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TC_S: u32 = 14;
pub const RTC_GPIO_ENABLE_REG: u32 = 1072989196;
pub const RTC_GPIO_ENABLE: u32 = 262143;
pub const RTC_GPIO_ENABLE_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_S: u32 = 14;
pub const RTC_GPIO_ENABLE_W1TS_REG: u32 = 1072989200;
pub const RTC_GPIO_ENABLE_W1TS: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TS_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TS_S: u32 = 14;
pub const RTC_GPIO_ENABLE_W1TC_REG: u32 = 1072989204;
pub const RTC_GPIO_ENABLE_W1TC: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TC_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TC_S: u32 = 14;
pub const RTC_GPIO_STATUS_REG: u32 = 1072989208;
pub const RTC_GPIO_STATUS_INT: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_S: u32 = 14;
pub const RTC_GPIO_STATUS_W1TS_REG: u32 = 1072989212;
pub const RTC_GPIO_STATUS_INT_W1TS: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TS_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TS_S: u32 = 14;
pub const RTC_GPIO_STATUS_W1TC_REG: u32 = 1072989216;
pub const RTC_GPIO_STATUS_INT_W1TC: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TC_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TC_S: u32 = 14;
pub const RTC_GPIO_IN_REG: u32 = 1072989220;
pub const RTC_GPIO_IN_NEXT: u32 = 262143;
pub const RTC_GPIO_IN_NEXT_V: u32 = 262143;
pub const RTC_GPIO_IN_NEXT_S: u32 = 14;
pub const RTC_GPIO_PIN0_REG: u32 = 1072989224;
pub const RTC_GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN0_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN1_REG: u32 = 1072989228;
pub const RTC_GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN1_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN2_REG: u32 = 1072989232;
pub const RTC_GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN2_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN3_REG: u32 = 1072989236;
pub const RTC_GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN3_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN4_REG: u32 = 1072989240;
pub const RTC_GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN4_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN5_REG: u32 = 1072989244;
pub const RTC_GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN5_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN6_REG: u32 = 1072989248;
pub const RTC_GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN6_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN7_REG: u32 = 1072989252;
pub const RTC_GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN7_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN8_REG: u32 = 1072989256;
pub const RTC_GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN8_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN9_REG: u32 = 1072989260;
pub const RTC_GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN9_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN10_REG: u32 = 1072989264;
pub const RTC_GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN10_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN11_REG: u32 = 1072989268;
pub const RTC_GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN11_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN12_REG: u32 = 1072989272;
pub const RTC_GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN12_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN13_REG: u32 = 1072989276;
pub const RTC_GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN13_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN14_REG: u32 = 1072989280;
pub const RTC_GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN14_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN15_REG: u32 = 1072989284;
pub const RTC_GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN15_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN16_REG: u32 = 1072989288;
pub const RTC_GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN16_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN17_REG: u32 = 1072989292;
pub const RTC_GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN17_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const RTC_IO_RTC_DEBUG_SEL_REG: u32 = 1072989296;
pub const RTC_IO_DEBUG_12M_NO_GATING_V: u32 = 1;
pub const RTC_IO_DEBUG_12M_NO_GATING_S: u32 = 25;
pub const RTC_IO_DEBUG_SEL4: u32 = 31;
pub const RTC_IO_DEBUG_SEL4_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL4_S: u32 = 20;
pub const RTC_IO_DEBUG_SEL3: u32 = 31;
pub const RTC_IO_DEBUG_SEL3_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL3_S: u32 = 15;
pub const RTC_IO_DEBUG_SEL2: u32 = 31;
pub const RTC_IO_DEBUG_SEL2_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL2_S: u32 = 10;
pub const RTC_IO_DEBUG_SEL1: u32 = 31;
pub const RTC_IO_DEBUG_SEL1_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL1_S: u32 = 5;
pub const RTC_IO_DEBUG_SEL0: u32 = 31;
pub const RTC_IO_DEBUG_SEL0_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL0_S: u32 = 0;
pub const RTC_IO_DEBUG_SEL0_8M: u32 = 1;
pub const RTC_IO_DEBUG_SEL0_32K_XTAL: u32 = 4;
pub const RTC_IO_DEBUG_SEL0_150K_OSC: u32 = 5;
pub const RTC_IO_DIG_PAD_HOLD_REG: u32 = 1072989300;
pub const RTC_IO_DIG_PAD_HOLD: u32 = 4294967295;
pub const RTC_IO_DIG_PAD_HOLD_V: u32 = 4294967295;
pub const RTC_IO_DIG_PAD_HOLD_S: u32 = 0;
pub const RTC_IO_HALL_SENS_REG: u32 = 1072989304;
pub const RTC_IO_XPD_HALL_V: u32 = 1;
pub const RTC_IO_XPD_HALL_S: u32 = 31;
pub const RTC_IO_HALL_PHASE_V: u32 = 1;
pub const RTC_IO_HALL_PHASE_S: u32 = 30;
pub const RTC_IO_SENSOR_PADS_REG: u32 = 1072989308;
pub const RTC_IO_SENSE1_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE1_HOLD_S: u32 = 31;
pub const RTC_IO_SENSE2_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE2_HOLD_S: u32 = 30;
pub const RTC_IO_SENSE3_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE3_HOLD_S: u32 = 29;
pub const RTC_IO_SENSE4_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE4_HOLD_S: u32 = 28;
pub const RTC_IO_SENSE1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE1_MUX_SEL_S: u32 = 27;
pub const RTC_IO_SENSE2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE2_MUX_SEL_S: u32 = 26;
pub const RTC_IO_SENSE3_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE3_MUX_SEL_S: u32 = 25;
pub const RTC_IO_SENSE4_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE4_MUX_SEL_S: u32 = 24;
pub const RTC_IO_SENSE1_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE1_FUN_SEL_S: u32 = 22;
pub const RTC_IO_SENSE1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE1_SLP_SEL_S: u32 = 21;
pub const RTC_IO_SENSE1_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE1_SLP_IE_S: u32 = 20;
pub const RTC_IO_SENSE1_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE1_FUN_IE_S: u32 = 19;
pub const RTC_IO_SENSE2_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE2_FUN_SEL_S: u32 = 17;
pub const RTC_IO_SENSE2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE2_SLP_SEL_S: u32 = 16;
pub const RTC_IO_SENSE2_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE2_SLP_IE_S: u32 = 15;
pub const RTC_IO_SENSE2_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE2_FUN_IE_S: u32 = 14;
pub const RTC_IO_SENSE3_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE3_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE3_FUN_SEL_S: u32 = 12;
pub const RTC_IO_SENSE3_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE3_SLP_SEL_S: u32 = 11;
pub const RTC_IO_SENSE3_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE3_SLP_IE_S: u32 = 10;
pub const RTC_IO_SENSE3_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE3_FUN_IE_S: u32 = 9;
pub const RTC_IO_SENSE4_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE4_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE4_FUN_SEL_S: u32 = 7;
pub const RTC_IO_SENSE4_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE4_SLP_SEL_S: u32 = 6;
pub const RTC_IO_SENSE4_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE4_SLP_IE_S: u32 = 5;
pub const RTC_IO_SENSE4_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE4_FUN_IE_S: u32 = 4;
pub const RTC_IO_ADC_PAD_REG: u32 = 1072989312;
pub const RTC_IO_ADC1_HOLD_V: u32 = 1;
pub const RTC_IO_ADC1_HOLD_S: u32 = 31;
pub const RTC_IO_ADC2_HOLD_V: u32 = 1;
pub const RTC_IO_ADC2_HOLD_S: u32 = 30;
pub const RTC_IO_ADC1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_ADC1_MUX_SEL_S: u32 = 29;
pub const RTC_IO_ADC2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_ADC2_MUX_SEL_S: u32 = 28;
pub const RTC_IO_ADC1_FUN_SEL: u32 = 3;
pub const RTC_IO_ADC1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_ADC1_FUN_SEL_S: u32 = 26;
pub const RTC_IO_ADC1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_ADC1_SLP_SEL_S: u32 = 25;
pub const RTC_IO_ADC1_SLP_IE_V: u32 = 1;
pub const RTC_IO_ADC1_SLP_IE_S: u32 = 24;
pub const RTC_IO_ADC1_FUN_IE_V: u32 = 1;
pub const RTC_IO_ADC1_FUN_IE_S: u32 = 23;
pub const RTC_IO_ADC2_FUN_SEL: u32 = 3;
pub const RTC_IO_ADC2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_ADC2_FUN_SEL_S: u32 = 21;
pub const RTC_IO_ADC2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_ADC2_SLP_SEL_S: u32 = 20;
pub const RTC_IO_ADC2_SLP_IE_V: u32 = 1;
pub const RTC_IO_ADC2_SLP_IE_S: u32 = 19;
pub const RTC_IO_ADC2_FUN_IE_V: u32 = 1;
pub const RTC_IO_ADC2_FUN_IE_S: u32 = 18;
pub const RTC_IO_PAD_DAC1_REG: u32 = 1072989316;
pub const RTC_IO_PDAC1_DRV: u32 = 3;
pub const RTC_IO_PDAC1_DRV_V: u32 = 3;
pub const RTC_IO_PDAC1_DRV_S: u32 = 30;
pub const RTC_IO_PDAC1_HOLD_V: u32 = 1;
pub const RTC_IO_PDAC1_HOLD_S: u32 = 29;
pub const RTC_IO_PDAC1_RDE_V: u32 = 1;
pub const RTC_IO_PDAC1_RDE_S: u32 = 28;
pub const RTC_IO_PDAC1_RUE_V: u32 = 1;
pub const RTC_IO_PDAC1_RUE_S: u32 = 27;
pub const RTC_IO_PDAC1_DAC: u32 = 255;
pub const RTC_IO_PDAC1_DAC_V: u32 = 255;
pub const RTC_IO_PDAC1_DAC_S: u32 = 19;
pub const RTC_IO_PDAC1_XPD_DAC_V: u32 = 1;
pub const RTC_IO_PDAC1_XPD_DAC_S: u32 = 18;
pub const RTC_IO_PDAC1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_PDAC1_MUX_SEL_S: u32 = 17;
pub const RTC_IO_PDAC1_FUN_SEL: u32 = 3;
pub const RTC_IO_PDAC1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_PDAC1_FUN_SEL_S: u32 = 15;
pub const RTC_IO_PDAC1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_SEL_S: u32 = 14;
pub const RTC_IO_PDAC1_SLP_IE_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_IE_S: u32 = 13;
pub const RTC_IO_PDAC1_SLP_OE_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_OE_S: u32 = 12;
pub const RTC_IO_PDAC1_FUN_IE_V: u32 = 1;
pub const RTC_IO_PDAC1_FUN_IE_S: u32 = 11;
pub const RTC_IO_PDAC1_DAC_XPD_FORCE_V: u32 = 1;
pub const RTC_IO_PDAC1_DAC_XPD_FORCE_S: u32 = 10;
pub const RTC_IO_PAD_DAC2_REG: u32 = 1072989320;
pub const RTC_IO_PDAC2_DRV: u32 = 3;
pub const RTC_IO_PDAC2_DRV_V: u32 = 3;
pub const RTC_IO_PDAC2_DRV_S: u32 = 30;
pub const RTC_IO_PDAC2_HOLD_V: u32 = 1;
pub const RTC_IO_PDAC2_HOLD_S: u32 = 29;
pub const RTC_IO_PDAC2_RDE_V: u32 = 1;
pub const RTC_IO_PDAC2_RDE_S: u32 = 28;
pub const RTC_IO_PDAC2_RUE_V: u32 = 1;
pub const RTC_IO_PDAC2_RUE_S: u32 = 27;
pub const RTC_IO_PDAC2_DAC: u32 = 255;
pub const RTC_IO_PDAC2_DAC_V: u32 = 255;
pub const RTC_IO_PDAC2_DAC_S: u32 = 19;
pub const RTC_IO_PDAC2_XPD_DAC_V: u32 = 1;
pub const RTC_IO_PDAC2_XPD_DAC_S: u32 = 18;
pub const RTC_IO_PDAC2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_PDAC2_MUX_SEL_S: u32 = 17;
pub const RTC_IO_PDAC2_FUN_SEL: u32 = 3;
pub const RTC_IO_PDAC2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_PDAC2_FUN_SEL_S: u32 = 15;
pub const RTC_IO_PDAC2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_SEL_S: u32 = 14;
pub const RTC_IO_PDAC2_SLP_IE_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_IE_S: u32 = 13;
pub const RTC_IO_PDAC2_SLP_OE_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_OE_S: u32 = 12;
pub const RTC_IO_PDAC2_FUN_IE_V: u32 = 1;
pub const RTC_IO_PDAC2_FUN_IE_S: u32 = 11;
pub const RTC_IO_PDAC2_DAC_XPD_FORCE_V: u32 = 1;
pub const RTC_IO_PDAC2_DAC_XPD_FORCE_S: u32 = 10;
pub const RTC_IO_XTAL_32K_PAD_REG: u32 = 1072989324;
pub const RTC_IO_X32N_DRV: u32 = 3;
pub const RTC_IO_X32N_DRV_V: u32 = 3;
pub const RTC_IO_X32N_DRV_S: u32 = 30;
pub const RTC_IO_X32N_HOLD_V: u32 = 1;
pub const RTC_IO_X32N_HOLD_S: u32 = 29;
pub const RTC_IO_X32N_RDE_V: u32 = 1;
pub const RTC_IO_X32N_RDE_S: u32 = 28;
pub const RTC_IO_X32N_RUE_V: u32 = 1;
pub const RTC_IO_X32N_RUE_S: u32 = 27;
pub const RTC_IO_X32P_DRV: u32 = 3;
pub const RTC_IO_X32P_DRV_V: u32 = 3;
pub const RTC_IO_X32P_DRV_S: u32 = 25;
pub const RTC_IO_X32P_HOLD_V: u32 = 1;
pub const RTC_IO_X32P_HOLD_S: u32 = 24;
pub const RTC_IO_X32P_RDE_V: u32 = 1;
pub const RTC_IO_X32P_RDE_S: u32 = 23;
pub const RTC_IO_X32P_RUE_V: u32 = 1;
pub const RTC_IO_X32P_RUE_S: u32 = 22;
pub const RTC_IO_DAC_XTAL_32K: u32 = 3;
pub const RTC_IO_DAC_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DAC_XTAL_32K_S: u32 = 20;
pub const RTC_IO_XPD_XTAL_32K_V: u32 = 1;
pub const RTC_IO_XPD_XTAL_32K_S: u32 = 19;
pub const RTC_IO_X32N_MUX_SEL_V: u32 = 1;
pub const RTC_IO_X32N_MUX_SEL_S: u32 = 18;
pub const RTC_IO_X32P_MUX_SEL_V: u32 = 1;
pub const RTC_IO_X32P_MUX_SEL_S: u32 = 17;
pub const RTC_IO_X32N_FUN_SEL: u32 = 3;
pub const RTC_IO_X32N_FUN_SEL_V: u32 = 3;
pub const RTC_IO_X32N_FUN_SEL_S: u32 = 15;
pub const RTC_IO_X32N_SLP_SEL_V: u32 = 1;
pub const RTC_IO_X32N_SLP_SEL_S: u32 = 14;
pub const RTC_IO_X32N_SLP_IE_V: u32 = 1;
pub const RTC_IO_X32N_SLP_IE_S: u32 = 13;
pub const RTC_IO_X32N_SLP_OE_V: u32 = 1;
pub const RTC_IO_X32N_SLP_OE_S: u32 = 12;
pub const RTC_IO_X32N_FUN_IE_V: u32 = 1;
pub const RTC_IO_X32N_FUN_IE_S: u32 = 11;
pub const RTC_IO_X32P_FUN_SEL: u32 = 3;
pub const RTC_IO_X32P_FUN_SEL_V: u32 = 3;
pub const RTC_IO_X32P_FUN_SEL_S: u32 = 9;
pub const RTC_IO_X32P_SLP_SEL_V: u32 = 1;
pub const RTC_IO_X32P_SLP_SEL_S: u32 = 8;
pub const RTC_IO_X32P_SLP_IE_V: u32 = 1;
pub const RTC_IO_X32P_SLP_IE_S: u32 = 7;
pub const RTC_IO_X32P_SLP_OE_V: u32 = 1;
pub const RTC_IO_X32P_SLP_OE_S: u32 = 6;
pub const RTC_IO_X32P_FUN_IE_V: u32 = 1;
pub const RTC_IO_X32P_FUN_IE_S: u32 = 5;
pub const RTC_IO_DRES_XTAL_32K: u32 = 3;
pub const RTC_IO_DRES_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DRES_XTAL_32K_S: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K_S: u32 = 1;
pub const RTC_IO_TOUCH_CFG_REG: u32 = 1072989328;
pub const RTC_IO_TOUCH_XPD_BIAS_V: u32 = 1;
pub const RTC_IO_TOUCH_XPD_BIAS_S: u32 = 31;
pub const RTC_IO_TOUCH_DREFH: u32 = 3;
pub const RTC_IO_TOUCH_DREFH_V: u32 = 3;
pub const RTC_IO_TOUCH_DREFH_S: u32 = 29;
pub const RTC_IO_TOUCH_DREFL: u32 = 3;
pub const RTC_IO_TOUCH_DREFL_V: u32 = 3;
pub const RTC_IO_TOUCH_DREFL_S: u32 = 27;
pub const RTC_IO_TOUCH_DRANGE: u32 = 3;
pub const RTC_IO_TOUCH_DRANGE_V: u32 = 3;
pub const RTC_IO_TOUCH_DRANGE_S: u32 = 25;
pub const RTC_IO_TOUCH_DCUR: u32 = 3;
pub const RTC_IO_TOUCH_DCUR_V: u32 = 3;
pub const RTC_IO_TOUCH_DCUR_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD0_REG: u32 = 1072989332;
pub const RTC_IO_TOUCH_PAD0_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD0_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD0_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD0_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD0_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD0_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD0_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD0_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD0_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD0_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD0_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD0_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD0_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD0_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD0_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD0_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD1_REG: u32 = 1072989336;
pub const RTC_IO_TOUCH_PAD1_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD1_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD1_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD1_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD1_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD1_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD1_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD1_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD1_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD1_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD1_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD1_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD1_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD1_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD2_REG: u32 = 1072989340;
pub const RTC_IO_TOUCH_PAD2_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD2_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD2_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD2_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD2_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD2_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD2_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD2_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD2_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD2_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD2_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD2_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD2_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD2_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD3_REG: u32 = 1072989344;
pub const RTC_IO_TOUCH_PAD3_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD3_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD3_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD3_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD3_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD3_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD3_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD3_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD3_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD3_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD3_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD3_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD3_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD3_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD3_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD3_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD4_REG: u32 = 1072989348;
pub const RTC_IO_TOUCH_PAD4_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD4_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD4_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD4_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD4_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD4_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD4_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD4_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD4_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD4_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD4_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD4_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD4_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD4_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD4_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD4_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD5_REG: u32 = 1072989352;
pub const RTC_IO_TOUCH_PAD5_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD5_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD5_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD5_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD5_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD5_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD5_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD5_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD5_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD5_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD5_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD5_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD5_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD5_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD5_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD5_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD6_REG: u32 = 1072989356;
pub const RTC_IO_TOUCH_PAD6_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD6_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD6_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD6_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD6_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD6_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD6_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD6_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD6_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD6_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD6_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD6_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD6_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD6_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD6_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD6_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD7_REG: u32 = 1072989360;
pub const RTC_IO_TOUCH_PAD7_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD7_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD7_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD7_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD7_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD7_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD7_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD7_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD7_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD7_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD7_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD7_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD7_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD7_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD7_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD7_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD8_REG: u32 = 1072989364;
pub const RTC_IO_TOUCH_PAD8_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD8_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD8_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD8_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD8_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD8_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD8_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_TO_GPIO_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD9_REG: u32 = 1072989368;
pub const RTC_IO_TOUCH_PAD9_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD9_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD9_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD9_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD9_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD9_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD9_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_TO_GPIO_S: u32 = 19;
pub const RTC_IO_EXT_WAKEUP0_REG: u32 = 1072989372;
pub const RTC_IO_EXT_WAKEUP0_SEL: u32 = 31;
pub const RTC_IO_EXT_WAKEUP0_SEL_V: u32 = 31;
pub const RTC_IO_EXT_WAKEUP0_SEL_S: u32 = 27;
pub const RTC_IO_XTL_EXT_CTR_REG: u32 = 1072989376;
pub const RTC_IO_XTL_EXT_CTR_SEL: u32 = 31;
pub const RTC_IO_XTL_EXT_CTR_SEL_V: u32 = 31;
pub const RTC_IO_XTL_EXT_CTR_SEL_S: u32 = 27;
pub const RTC_IO_SAR_I2C_IO_REG: u32 = 1072989380;
pub const RTC_IO_SAR_I2C_SDA_SEL: u32 = 3;
pub const RTC_IO_SAR_I2C_SDA_SEL_V: u32 = 3;
pub const RTC_IO_SAR_I2C_SDA_SEL_S: u32 = 30;
pub const RTC_IO_SAR_I2C_SCL_SEL: u32 = 3;
pub const RTC_IO_SAR_I2C_SCL_SEL_V: u32 = 3;
pub const RTC_IO_SAR_I2C_SCL_SEL_S: u32 = 28;
pub const RTC_IO_SAR_DEBUG_BIT_SEL: u32 = 31;
pub const RTC_IO_SAR_DEBUG_BIT_SEL_V: u32 = 31;
pub const RTC_IO_SAR_DEBUG_BIT_SEL_S: u32 = 23;
pub const RTC_IO_DATE_REG: u32 = 1072989384;
pub const RTC_IO_IO_DATE: u32 = 268435455;
pub const RTC_IO_IO_DATE_V: u32 = 268435455;
pub const RTC_IO_IO_DATE_S: u32 = 0;
pub const RTC_IO_RTC_IO_DATE_VERSION: u32 = 24129888;
pub const RTC_CNTL_WDT_WKEY_VALUE: u32 = 1356348065;
pub const RTC_CNTL_OPTIONS0_REG: u32 = 1072988160;
pub const RTC_CNTL_SW_SYS_RST_V: u32 = 1;
pub const RTC_CNTL_SW_SYS_RST_S: u32 = 31;
pub const RTC_CNTL_DG_WRAP_FORCE_NORST_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_NORST_S: u32 = 30;
pub const RTC_CNTL_DG_WRAP_FORCE_RST_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_RST_S: u32 = 29;
pub const RTC_CNTL_ANALOG_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_ANALOG_FORCE_NOISO_S: u32 = 28;
pub const RTC_CNTL_PLL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_PLL_FORCE_NOISO_S: u32 = 27;
pub const RTC_CNTL_XTL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_NOISO_S: u32 = 26;
pub const RTC_CNTL_ANALOG_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_ANALOG_FORCE_ISO_S: u32 = 25;
pub const RTC_CNTL_PLL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_PLL_FORCE_ISO_S: u32 = 24;
pub const RTC_CNTL_XTL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_ISO_S: u32 = 23;
pub const RTC_CNTL_BIAS_CORE_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BIAS_CORE_FORCE_PU_S: u32 = 22;
pub const RTC_CNTL_BIAS_CORE_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BIAS_CORE_FORCE_PD_S: u32 = 21;
pub const RTC_CNTL_BIAS_CORE_FOLW_8M_V: u32 = 1;
pub const RTC_CNTL_BIAS_CORE_FOLW_8M_S: u32 = 20;
pub const RTC_CNTL_BIAS_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BIAS_I2C_FORCE_PU_S: u32 = 19;
pub const RTC_CNTL_BIAS_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BIAS_I2C_FORCE_PD_S: u32 = 18;
pub const RTC_CNTL_BIAS_I2C_FOLW_8M_V: u32 = 1;
pub const RTC_CNTL_BIAS_I2C_FOLW_8M_S: u32 = 17;
pub const RTC_CNTL_BIAS_FORCE_NOSLEEP_V: u32 = 1;
pub const RTC_CNTL_BIAS_FORCE_NOSLEEP_S: u32 = 16;
pub const RTC_CNTL_BIAS_FORCE_SLEEP_V: u32 = 1;
pub const RTC_CNTL_BIAS_FORCE_SLEEP_S: u32 = 15;
pub const RTC_CNTL_BIAS_SLEEP_FOLW_8M_V: u32 = 1;
pub const RTC_CNTL_BIAS_SLEEP_FOLW_8M_S: u32 = 14;
pub const RTC_CNTL_XTL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_PU_S: u32 = 13;
pub const RTC_CNTL_XTL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_XTL_FORCE_PD_S: u32 = 12;
pub const RTC_CNTL_BBPLL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BBPLL_FORCE_PU_S: u32 = 11;
pub const RTC_CNTL_BBPLL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BBPLL_FORCE_PD_S: u32 = 10;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PU_S: u32 = 9;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BBPLL_I2C_FORCE_PD_S: u32 = 8;
pub const RTC_CNTL_BB_I2C_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_BB_I2C_FORCE_PU_S: u32 = 7;
pub const RTC_CNTL_BB_I2C_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_BB_I2C_FORCE_PD_S: u32 = 6;
pub const RTC_CNTL_SW_PROCPU_RST_V: u32 = 1;
pub const RTC_CNTL_SW_PROCPU_RST_S: u32 = 5;
pub const RTC_CNTL_SW_APPCPU_RST_V: u32 = 1;
pub const RTC_CNTL_SW_APPCPU_RST_S: u32 = 4;
pub const RTC_CNTL_SW_STALL_PROCPU_C0: u32 = 3;
pub const RTC_CNTL_SW_STALL_PROCPU_C0_V: u32 = 3;
pub const RTC_CNTL_SW_STALL_PROCPU_C0_S: u32 = 2;
pub const RTC_CNTL_SW_STALL_APPCPU_C0: u32 = 3;
pub const RTC_CNTL_SW_STALL_APPCPU_C0_V: u32 = 3;
pub const RTC_CNTL_SW_STALL_APPCPU_C0_S: u32 = 0;
pub const RTC_CNTL_SLP_TIMER0_REG: u32 = 1072988164;
pub const RTC_CNTL_SLP_VAL_LO: u32 = 4294967295;
pub const RTC_CNTL_SLP_VAL_LO_V: u32 = 4294967295;
pub const RTC_CNTL_SLP_VAL_LO_S: u32 = 0;
pub const RTC_CNTL_SLP_TIMER1_REG: u32 = 1072988168;
pub const RTC_CNTL_MAIN_TIMER_ALARM_EN_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_ALARM_EN_S: u32 = 16;
pub const RTC_CNTL_SLP_VAL_HI: u32 = 65535;
pub const RTC_CNTL_SLP_VAL_HI_V: u32 = 65535;
pub const RTC_CNTL_SLP_VAL_HI_S: u32 = 0;
pub const RTC_CNTL_TIME_UPDATE_REG: u32 = 1072988172;
pub const RTC_CNTL_TIME_UPDATE_V: u32 = 1;
pub const RTC_CNTL_TIME_UPDATE_S: u32 = 31;
pub const RTC_CNTL_TIME_VALID_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_S: u32 = 30;
pub const RTC_CNTL_TIME0_REG: u32 = 1072988176;
pub const RTC_CNTL_TIME_LO: u32 = 4294967295;
pub const RTC_CNTL_TIME_LO_V: u32 = 4294967295;
pub const RTC_CNTL_TIME_LO_S: u32 = 0;
pub const RTC_CNTL_TIME1_REG: u32 = 1072988180;
pub const RTC_CNTL_TIME_HI: u32 = 65535;
pub const RTC_CNTL_TIME_HI_V: u32 = 65535;
pub const RTC_CNTL_TIME_HI_S: u32 = 0;
pub const RTC_CNTL_STATE0_REG: u32 = 1072988184;
pub const RTC_CNTL_SLEEP_EN_V: u32 = 1;
pub const RTC_CNTL_SLEEP_EN_S: u32 = 31;
pub const RTC_CNTL_SLP_REJECT_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_S: u32 = 30;
pub const RTC_CNTL_SLP_WAKEUP_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_S: u32 = 29;
pub const RTC_CNTL_SDIO_ACTIVE_IND_V: u32 = 1;
pub const RTC_CNTL_SDIO_ACTIVE_IND_S: u32 = 28;
pub const RTC_CNTL_ULP_CP_SLP_TIMER_EN_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_SLP_TIMER_EN_S: u32 = 24;
pub const RTC_CNTL_TOUCH_SLP_TIMER_EN_V: u32 = 1;
pub const RTC_CNTL_TOUCH_SLP_TIMER_EN_S: u32 = 23;
pub const RTC_CNTL_APB2RTC_BRIDGE_SEL_V: u32 = 1;
pub const RTC_CNTL_APB2RTC_BRIDGE_SEL_S: u32 = 22;
pub const RTC_CNTL_ULP_CP_WAKEUP_FORCE_EN_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_WAKEUP_FORCE_EN_S: u32 = 21;
pub const RTC_CNTL_TOUCH_WAKEUP_FORCE_EN_V: u32 = 1;
pub const RTC_CNTL_TOUCH_WAKEUP_FORCE_EN_S: u32 = 20;
pub const RTC_CNTL_TIMER1_REG: u32 = 1072988188;
pub const RTC_CNTL_PLL_BUF_WAIT: u32 = 255;
pub const RTC_CNTL_PLL_BUF_WAIT_V: u32 = 255;
pub const RTC_CNTL_PLL_BUF_WAIT_S: u32 = 24;
pub const RTC_CNTL_PLL_BUF_WAIT_DEFAULT: u32 = 20;
pub const RTC_CNTL_XTL_BUF_WAIT: u32 = 1023;
pub const RTC_CNTL_XTL_BUF_WAIT_V: u32 = 1023;
pub const RTC_CNTL_XTL_BUF_WAIT_S: u32 = 14;
pub const RTC_CNTL_XTL_BUF_WAIT_DEFAULT: u32 = 20;
pub const RTC_CNTL_CK8M_WAIT: u32 = 255;
pub const RTC_CNTL_CK8M_WAIT_V: u32 = 255;
pub const RTC_CNTL_CK8M_WAIT_S: u32 = 6;
pub const RTC_CNTL_CK8M_WAIT_DEFAULT: u32 = 20;
pub const RTC_CNTL_CPU_STALL_WAIT: u32 = 31;
pub const RTC_CNTL_CPU_STALL_WAIT_V: u32 = 31;
pub const RTC_CNTL_CPU_STALL_WAIT_S: u32 = 1;
pub const RTC_CNTL_CPU_STALL_EN_V: u32 = 1;
pub const RTC_CNTL_CPU_STALL_EN_S: u32 = 0;
pub const RTC_CNTL_TIMER2_REG: u32 = 1072988192;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF: u32 = 255;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF_V: u32 = 255;
pub const RTC_CNTL_MIN_TIME_CK8M_OFF_S: u32 = 24;
pub const RTC_CNTL_ULPCP_TOUCH_START_WAIT: u32 = 511;
pub const RTC_CNTL_ULPCP_TOUCH_START_WAIT_V: u32 = 511;
pub const RTC_CNTL_ULPCP_TOUCH_START_WAIT_S: u32 = 15;
pub const RTC_CNTL_TIMER3_REG: u32 = 1072988196;
pub const RTC_CNTL_ROM_RAM_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_ROM_RAM_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_ROM_RAM_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_ROM_RAM_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_ROM_RAM_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_ROM_RAM_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_WIFI_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_WIFI_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_WIFI_POWERUP_TIMER_S: u32 = 9;
pub const RTC_CNTL_WIFI_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_WIFI_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_WIFI_WAIT_TIMER_S: u32 = 0;
pub const RTC_CNTL_TIMER4_REG: u32 = 1072988200;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_DG_WRAP_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_DG_WRAP_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_POWERUP_TIMER_S: u32 = 9;
pub const RTC_CNTL_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_WAIT_TIMER_S: u32 = 0;
pub const RTC_CNTL_TIMER5_REG: u32 = 1072988204;
pub const RTC_CNTL_RTCMEM_POWERUP_TIMER: u32 = 127;
pub const RTC_CNTL_RTCMEM_POWERUP_TIMER_V: u32 = 127;
pub const RTC_CNTL_RTCMEM_POWERUP_TIMER_S: u32 = 25;
pub const RTC_CNTL_RTCMEM_WAIT_TIMER: u32 = 511;
pub const RTC_CNTL_RTCMEM_WAIT_TIMER_V: u32 = 511;
pub const RTC_CNTL_RTCMEM_WAIT_TIMER_S: u32 = 16;
pub const RTC_CNTL_MIN_SLP_VAL: u32 = 255;
pub const RTC_CNTL_MIN_SLP_VAL_V: u32 = 255;
pub const RTC_CNTL_MIN_SLP_VAL_S: u32 = 8;
pub const RTC_CNTL_MIN_SLP_VAL_MIN: u32 = 2;
pub const RTC_CNTL_ULP_CP_SUBTIMER_PREDIV: u32 = 255;
pub const RTC_CNTL_ULP_CP_SUBTIMER_PREDIV_V: u32 = 255;
pub const RTC_CNTL_ULP_CP_SUBTIMER_PREDIV_S: u32 = 0;
pub const RTC_CNTL_ANA_CONF_REG: u32 = 1072988208;
pub const RTC_CNTL_PLL_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_PLL_I2C_PU_S: u32 = 31;
pub const RTC_CNTL_CKGEN_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_CKGEN_I2C_PU_S: u32 = 30;
pub const RTC_CNTL_RFRX_PBUS_PU_V: u32 = 1;
pub const RTC_CNTL_RFRX_PBUS_PU_S: u32 = 28;
pub const RTC_CNTL_TXRF_I2C_PU_V: u32 = 1;
pub const RTC_CNTL_TXRF_I2C_PU_S: u32 = 27;
pub const RTC_CNTL_PVTMON_PU_V: u32 = 1;
pub const RTC_CNTL_PVTMON_PU_S: u32 = 26;
pub const RTC_CNTL_BBPLL_CAL_SLP_START_V: u32 = 1;
pub const RTC_CNTL_BBPLL_CAL_SLP_START_S: u32 = 25;
pub const RTC_CNTL_PLLA_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_PLLA_FORCE_PU_S: u32 = 24;
pub const RTC_CNTL_PLLA_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_PLLA_FORCE_PD_S: u32 = 23;
pub const RTC_CNTL_RESET_STATE_REG: u32 = 1072988212;
pub const RTC_CNTL_PROCPU_STAT_VECTOR_SEL_V: u32 = 1;
pub const RTC_CNTL_PROCPU_STAT_VECTOR_SEL_S: u32 = 13;
pub const RTC_CNTL_APPCPU_STAT_VECTOR_SEL_V: u32 = 1;
pub const RTC_CNTL_APPCPU_STAT_VECTOR_SEL_S: u32 = 12;
pub const RTC_CNTL_RESET_CAUSE_APPCPU: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_APPCPU_V: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_APPCPU_S: u32 = 6;
pub const RTC_CNTL_RESET_CAUSE_PROCPU: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_PROCPU_V: u32 = 63;
pub const RTC_CNTL_RESET_CAUSE_PROCPU_S: u32 = 0;
pub const RTC_CNTL_WAKEUP_STATE_REG: u32 = 1072988216;
pub const RTC_CNTL_GPIO_WAKEUP_FILTER_V: u32 = 1;
pub const RTC_CNTL_GPIO_WAKEUP_FILTER_S: u32 = 22;
pub const RTC_CNTL_WAKEUP_ENA: u32 = 2047;
pub const RTC_CNTL_WAKEUP_ENA_V: u32 = 2047;
pub const RTC_CNTL_WAKEUP_ENA_S: u32 = 11;
pub const RTC_CNTL_WAKEUP_CAUSE: u32 = 2047;
pub const RTC_CNTL_WAKEUP_CAUSE_V: u32 = 2047;
pub const RTC_CNTL_WAKEUP_CAUSE_S: u32 = 0;
pub const RTC_CNTL_INT_ENA_REG: u32 = 1072988220;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ENA_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ENA_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_ENA_S: u32 = 6;
pub const RTC_CNTL_ULP_CP_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_INT_ENA_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_ENA_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ENA_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_ENA_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ENA_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ENA_S: u32 = 0;
pub const RTC_CNTL_INT_RAW_REG: u32 = 1072988224;
pub const RTC_CNTL_MAIN_TIMER_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_RAW_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_RAW_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_RAW_S: u32 = 6;
pub const RTC_CNTL_ULP_CP_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_ULP_CP_INT_RAW_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_RAW_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_RAW_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_RAW_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_RAW_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_RAW_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_RAW_S: u32 = 0;
pub const RTC_CNTL_INT_ST_REG: u32 = 1072988228;
pub const RTC_CNTL_MAIN_TIMER_INT_ST_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_ST_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_ST_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_ST_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_ST_S: u32 = 6;
pub const RTC_CNTL_SAR_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SAR_INT_ST_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_ST_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_ST_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_ST_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_ST_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_ST_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ST_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_ST_S: u32 = 0;
pub const RTC_CNTL_INT_CLR_REG: u32 = 1072988232;
pub const RTC_CNTL_MAIN_TIMER_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_MAIN_TIMER_INT_CLR_S: u32 = 8;
pub const RTC_CNTL_BROWN_OUT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_INT_CLR_S: u32 = 7;
pub const RTC_CNTL_TOUCH_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_TOUCH_INT_CLR_S: u32 = 6;
pub const RTC_CNTL_SAR_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SAR_INT_CLR_S: u32 = 5;
pub const RTC_CNTL_TIME_VALID_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_TIME_VALID_INT_CLR_S: u32 = 4;
pub const RTC_CNTL_WDT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_WDT_INT_CLR_S: u32 = 3;
pub const RTC_CNTL_SDIO_IDLE_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SDIO_IDLE_INT_CLR_S: u32 = 2;
pub const RTC_CNTL_SLP_REJECT_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SLP_REJECT_INT_CLR_S: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_CLR_V: u32 = 1;
pub const RTC_CNTL_SLP_WAKEUP_INT_CLR_S: u32 = 0;
pub const RTC_CNTL_STORE0_REG: u32 = 1072988236;
pub const RTC_CNTL_SCRATCH0: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH0_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH0_S: u32 = 0;
pub const RTC_CNTL_STORE1_REG: u32 = 1072988240;
pub const RTC_CNTL_SCRATCH1: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH1_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH1_S: u32 = 0;
pub const RTC_CNTL_STORE2_REG: u32 = 1072988244;
pub const RTC_CNTL_SCRATCH2: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH2_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH2_S: u32 = 0;
pub const RTC_CNTL_STORE3_REG: u32 = 1072988248;
pub const RTC_CNTL_SCRATCH3: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH3_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH3_S: u32 = 0;
pub const RTC_CNTL_EXT_XTL_CONF_REG: u32 = 1072988252;
pub const RTC_CNTL_XTL_EXT_CTR_EN_V: u32 = 1;
pub const RTC_CNTL_XTL_EXT_CTR_EN_S: u32 = 31;
pub const RTC_CNTL_XTL_EXT_CTR_LV_V: u32 = 1;
pub const RTC_CNTL_XTL_EXT_CTR_LV_S: u32 = 30;
pub const RTC_CNTL_EXT_WAKEUP_CONF_REG: u32 = 1072988256;
pub const RTC_CNTL_EXT_WAKEUP1_LV_V: u32 = 1;
pub const RTC_CNTL_EXT_WAKEUP1_LV_S: u32 = 31;
pub const RTC_CNTL_EXT_WAKEUP0_LV_V: u32 = 1;
pub const RTC_CNTL_EXT_WAKEUP0_LV_S: u32 = 30;
pub const RTC_CNTL_SLP_REJECT_CONF_REG: u32 = 1072988260;
pub const RTC_CNTL_REJECT_CAUSE: u32 = 15;
pub const RTC_CNTL_REJECT_CAUSE_V: u32 = 15;
pub const RTC_CNTL_REJECT_CAUSE_S: u32 = 28;
pub const RTC_CNTL_DEEP_SLP_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_DEEP_SLP_REJECT_EN_S: u32 = 27;
pub const RTC_CNTL_LIGHT_SLP_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_LIGHT_SLP_REJECT_EN_S: u32 = 26;
pub const RTC_CNTL_SDIO_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_SDIO_REJECT_EN_S: u32 = 25;
pub const RTC_CNTL_GPIO_REJECT_EN_V: u32 = 1;
pub const RTC_CNTL_GPIO_REJECT_EN_S: u32 = 24;
pub const RTC_CNTL_CPU_PERIOD_CONF_REG: u32 = 1072988264;
pub const RTC_CNTL_CPUPERIOD_SEL: u32 = 3;
pub const RTC_CNTL_CPUPERIOD_SEL_V: u32 = 3;
pub const RTC_CNTL_CPUPERIOD_SEL_S: u32 = 30;
pub const RTC_CNTL_CPUSEL_CONF_V: u32 = 1;
pub const RTC_CNTL_CPUSEL_CONF_S: u32 = 29;
pub const RTC_CNTL_SDIO_ACT_CONF_REG: u32 = 1072988268;
pub const RTC_CNTL_SDIO_ACT_DNUM: u32 = 1023;
pub const RTC_CNTL_SDIO_ACT_DNUM_V: u32 = 1023;
pub const RTC_CNTL_SDIO_ACT_DNUM_S: u32 = 22;
pub const RTC_CNTL_CLK_CONF_REG: u32 = 1072988272;
pub const RTC_CNTL_ANA_CLK_RTC_SEL: u32 = 3;
pub const RTC_CNTL_ANA_CLK_RTC_SEL_V: u32 = 3;
pub const RTC_CNTL_ANA_CLK_RTC_SEL_S: u32 = 30;
pub const RTC_CNTL_FAST_CLK_RTC_SEL_V: u32 = 1;
pub const RTC_CNTL_FAST_CLK_RTC_SEL_S: u32 = 29;
pub const RTC_CNTL_SOC_CLK_SEL: u32 = 3;
pub const RTC_CNTL_SOC_CLK_SEL_V: u32 = 3;
pub const RTC_CNTL_SOC_CLK_SEL_S: u32 = 27;
pub const RTC_CNTL_SOC_CLK_SEL_XTL: u32 = 0;
pub const RTC_CNTL_SOC_CLK_SEL_PLL: u32 = 1;
pub const RTC_CNTL_SOC_CLK_SEL_8M: u32 = 2;
pub const RTC_CNTL_SOC_CLK_SEL_APLL: u32 = 3;
pub const RTC_CNTL_CK8M_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_PU_S: u32 = 26;
pub const RTC_CNTL_CK8M_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_PD_S: u32 = 25;
pub const RTC_CNTL_CK8M_DFREQ: u32 = 255;
pub const RTC_CNTL_CK8M_DFREQ_V: u32 = 255;
pub const RTC_CNTL_CK8M_DFREQ_S: u32 = 17;
pub const RTC_CNTL_CK8M_DFREQ_DEFAULT: u32 = 172;
pub const RTC_CNTL_CK8M_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_CK8M_FORCE_NOGATING_S: u32 = 16;
pub const RTC_CNTL_XTAL_FORCE_NOGATING_V: u32 = 1;
pub const RTC_CNTL_XTAL_FORCE_NOGATING_S: u32 = 15;
pub const RTC_CNTL_CK8M_DIV_SEL: u32 = 7;
pub const RTC_CNTL_CK8M_DIV_SEL_V: u32 = 7;
pub const RTC_CNTL_CK8M_DIV_SEL_S: u32 = 12;
pub const RTC_CNTL_CK8M_DFREQ_FORCE_V: u32 = 1;
pub const RTC_CNTL_CK8M_DFREQ_FORCE_S: u32 = 11;
pub const RTC_CNTL_DIG_CLK8M_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_CLK8M_EN_S: u32 = 10;
pub const RTC_CNTL_DIG_CLK8M_D256_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_CLK8M_D256_EN_S: u32 = 9;
pub const RTC_CNTL_DIG_XTAL32K_EN_V: u32 = 1;
pub const RTC_CNTL_DIG_XTAL32K_EN_S: u32 = 8;
pub const RTC_CNTL_ENB_CK8M_DIV_V: u32 = 1;
pub const RTC_CNTL_ENB_CK8M_DIV_S: u32 = 7;
pub const RTC_CNTL_ENB_CK8M_V: u32 = 1;
pub const RTC_CNTL_ENB_CK8M_S: u32 = 6;
pub const RTC_CNTL_CK8M_DIV: u32 = 3;
pub const RTC_CNTL_CK8M_DIV_V: u32 = 3;
pub const RTC_CNTL_CK8M_DIV_S: u32 = 4;
pub const RTC_CNTL_SDIO_CONF_REG: u32 = 1072988276;
pub const RTC_CNTL_XPD_SDIO_REG_V: u32 = 1;
pub const RTC_CNTL_XPD_SDIO_REG_S: u32 = 31;
pub const RTC_CNTL_DREFH_SDIO: u32 = 3;
pub const RTC_CNTL_DREFH_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFH_SDIO_S: u32 = 29;
pub const RTC_CNTL_DREFM_SDIO: u32 = 3;
pub const RTC_CNTL_DREFM_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFM_SDIO_S: u32 = 27;
pub const RTC_CNTL_DREFL_SDIO: u32 = 3;
pub const RTC_CNTL_DREFL_SDIO_V: u32 = 3;
pub const RTC_CNTL_DREFL_SDIO_S: u32 = 25;
pub const RTC_CNTL_REG1P8_READY_V: u32 = 1;
pub const RTC_CNTL_REG1P8_READY_S: u32 = 24;
pub const RTC_CNTL_SDIO_TIEH_V: u32 = 1;
pub const RTC_CNTL_SDIO_TIEH_S: u32 = 23;
pub const RTC_CNTL_SDIO_FORCE_V: u32 = 1;
pub const RTC_CNTL_SDIO_FORCE_S: u32 = 22;
pub const RTC_CNTL_SDIO_PD_EN_V: u32 = 1;
pub const RTC_CNTL_SDIO_PD_EN_S: u32 = 21;
pub const RTC_CNTL_BIAS_CONF_REG: u32 = 1072988280;
pub const RTC_CNTL_RST_BIAS_I2C_V: u32 = 1;
pub const RTC_CNTL_RST_BIAS_I2C_S: u32 = 31;
pub const RTC_CNTL_DEC_HEARTBEAT_WIDTH_V: u32 = 1;
pub const RTC_CNTL_DEC_HEARTBEAT_WIDTH_S: u32 = 30;
pub const RTC_CNTL_INC_HEARTBEAT_PERIOD_V: u32 = 1;
pub const RTC_CNTL_INC_HEARTBEAT_PERIOD_S: u32 = 29;
pub const RTC_CNTL_DEC_HEARTBEAT_PERIOD_V: u32 = 1;
pub const RTC_CNTL_DEC_HEARTBEAT_PERIOD_S: u32 = 28;
pub const RTC_CNTL_INC_HEARTBEAT_REFRESH_V: u32 = 1;
pub const RTC_CNTL_INC_HEARTBEAT_REFRESH_S: u32 = 27;
pub const RTC_CNTL_ENB_SCK_XTAL_V: u32 = 1;
pub const RTC_CNTL_ENB_SCK_XTAL_S: u32 = 26;
pub const RTC_CNTL_DBG_ATTEN: u32 = 3;
pub const RTC_CNTL_DBG_ATTEN_V: u32 = 3;
pub const RTC_CNTL_DBG_ATTEN_S: u32 = 24;
pub const RTC_CNTL_DBG_ATTEN_DEFAULT: u32 = 3;
pub const RTC_CNTL_REG: u32 = 1072988284;
pub const RTC_CNTL_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_FORCE_PU_S: u32 = 31;
pub const RTC_CNTL_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_FORCE_PD_S: u32 = 30;
pub const RTC_CNTL_DBOOST_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_DBOOST_FORCE_PU_S: u32 = 29;
pub const RTC_CNTL_DBOOST_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_DBOOST_FORCE_PD_S: u32 = 28;
pub const RTC_CNTL_DBIAS_WAK: u32 = 7;
pub const RTC_CNTL_DBIAS_WAK_V: u32 = 7;
pub const RTC_CNTL_DBIAS_WAK_S: u32 = 25;
pub const RTC_CNTL_DBIAS_SLP: u32 = 7;
pub const RTC_CNTL_DBIAS_SLP_V: u32 = 7;
pub const RTC_CNTL_DBIAS_SLP_S: u32 = 22;
pub const RTC_CNTL_SCK_DCAP: u32 = 255;
pub const RTC_CNTL_SCK_DCAP_V: u32 = 255;
pub const RTC_CNTL_SCK_DCAP_S: u32 = 14;
pub const RTC_CNTL_SCK_DCAP_DEFAULT: u32 = 255;
pub const RTC_CNTL_DIG_DBIAS_WAK: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_WAK_V: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_WAK_S: u32 = 11;
pub const RTC_CNTL_DIG_DBIAS_SLP: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_SLP_V: u32 = 7;
pub const RTC_CNTL_DIG_DBIAS_SLP_S: u32 = 8;
pub const RTC_CNTL_SCK_DCAP_FORCE_V: u32 = 1;
pub const RTC_CNTL_SCK_DCAP_FORCE_S: u32 = 7;
pub const RTC_CNTL_DBIAS_0V90: u32 = 0;
pub const RTC_CNTL_DBIAS_0V95: u32 = 1;
pub const RTC_CNTL_DBIAS_1V00: u32 = 2;
pub const RTC_CNTL_DBIAS_1V05: u32 = 3;
pub const RTC_CNTL_DBIAS_1V10: u32 = 4;
pub const RTC_CNTL_DBIAS_1V15: u32 = 5;
pub const RTC_CNTL_DBIAS_1V20: u32 = 6;
pub const RTC_CNTL_DBIAS_1V25: u32 = 7;
pub const RTC_CNTL_PWC_REG: u32 = 1072988288;
pub const RTC_CNTL_PD_EN_V: u32 = 1;
pub const RTC_CNTL_PD_EN_S: u32 = 20;
pub const RTC_CNTL_PWC_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_PWC_FORCE_PU_S: u32 = 19;
pub const RTC_CNTL_PWC_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_PWC_FORCE_PD_S: u32 = 18;
pub const RTC_CNTL_SLOWMEM_PD_EN_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_PD_EN_S: u32 = 17;
pub const RTC_CNTL_SLOWMEM_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_PU_S: u32 = 16;
pub const RTC_CNTL_SLOWMEM_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_PD_S: u32 = 15;
pub const RTC_CNTL_FASTMEM_PD_EN_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_PD_EN_S: u32 = 14;
pub const RTC_CNTL_FASTMEM_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_PU_S: u32 = 13;
pub const RTC_CNTL_FASTMEM_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_PD_S: u32 = 12;
pub const RTC_CNTL_SLOWMEM_FORCE_LPU_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_LPU_S: u32 = 11;
pub const RTC_CNTL_SLOWMEM_FORCE_LPD_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_LPD_S: u32 = 10;
pub const RTC_CNTL_SLOWMEM_FOLW_CPU_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FOLW_CPU_S: u32 = 9;
pub const RTC_CNTL_FASTMEM_FORCE_LPU_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_LPU_S: u32 = 8;
pub const RTC_CNTL_FASTMEM_FORCE_LPD_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_LPD_S: u32 = 7;
pub const RTC_CNTL_FASTMEM_FOLW_CPU_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FOLW_CPU_S: u32 = 6;
pub const RTC_CNTL_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_FORCE_NOISO_S: u32 = 5;
pub const RTC_CNTL_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_FORCE_ISO_S: u32 = 4;
pub const RTC_CNTL_SLOWMEM_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_ISO_S: u32 = 3;
pub const RTC_CNTL_SLOWMEM_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_SLOWMEM_FORCE_NOISO_S: u32 = 2;
pub const RTC_CNTL_FASTMEM_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_ISO_S: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_FASTMEM_FORCE_NOISO_S: u32 = 0;
pub const RTC_CNTL_DIG_PWC_REG: u32 = 1072988292;
pub const RTC_CNTL_DG_WRAP_PD_EN_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_PD_EN_S: u32 = 31;
pub const RTC_CNTL_WIFI_PD_EN_V: u32 = 1;
pub const RTC_CNTL_WIFI_PD_EN_S: u32 = 30;
pub const RTC_CNTL_INTER_RAM4_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_PD_EN_S: u32 = 29;
pub const RTC_CNTL_INTER_RAM3_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_PD_EN_S: u32 = 28;
pub const RTC_CNTL_INTER_RAM2_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_PD_EN_S: u32 = 27;
pub const RTC_CNTL_INTER_RAM1_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_PD_EN_S: u32 = 26;
pub const RTC_CNTL_INTER_RAM0_PD_EN_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_PD_EN_S: u32 = 25;
pub const RTC_CNTL_ROM0_PD_EN_V: u32 = 1;
pub const RTC_CNTL_ROM0_PD_EN_S: u32 = 24;
pub const RTC_CNTL_DG_WRAP_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_PU_S: u32 = 20;
pub const RTC_CNTL_DG_WRAP_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_PD_S: u32 = 19;
pub const RTC_CNTL_WIFI_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_PU_S: u32 = 18;
pub const RTC_CNTL_WIFI_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_PD_S: u32 = 17;
pub const RTC_CNTL_INTER_RAM4_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_PU_S: u32 = 16;
pub const RTC_CNTL_INTER_RAM4_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_PD_S: u32 = 15;
pub const RTC_CNTL_INTER_RAM3_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_PU_S: u32 = 14;
pub const RTC_CNTL_INTER_RAM3_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_PD_S: u32 = 13;
pub const RTC_CNTL_INTER_RAM2_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_PU_S: u32 = 12;
pub const RTC_CNTL_INTER_RAM2_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_PD_S: u32 = 11;
pub const RTC_CNTL_INTER_RAM1_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_PU_S: u32 = 10;
pub const RTC_CNTL_INTER_RAM1_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_PD_S: u32 = 9;
pub const RTC_CNTL_INTER_RAM0_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_PU_S: u32 = 8;
pub const RTC_CNTL_INTER_RAM0_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_PD_S: u32 = 7;
pub const RTC_CNTL_ROM0_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_PU_S: u32 = 6;
pub const RTC_CNTL_ROM0_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_PD_S: u32 = 5;
pub const RTC_CNTL_LSLP_MEM_FORCE_PU_V: u32 = 1;
pub const RTC_CNTL_LSLP_MEM_FORCE_PU_S: u32 = 4;
pub const RTC_CNTL_LSLP_MEM_FORCE_PD_V: u32 = 1;
pub const RTC_CNTL_LSLP_MEM_FORCE_PD_S: u32 = 3;
pub const RTC_CNTL_DIG_ISO_REG: u32 = 1072988296;
pub const RTC_CNTL_DG_WRAP_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_NOISO_S: u32 = 31;
pub const RTC_CNTL_DG_WRAP_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_DG_WRAP_FORCE_ISO_S: u32 = 30;
pub const RTC_CNTL_WIFI_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_NOISO_S: u32 = 29;
pub const RTC_CNTL_WIFI_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_WIFI_FORCE_ISO_S: u32 = 28;
pub const RTC_CNTL_INTER_RAM4_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_NOISO_S: u32 = 27;
pub const RTC_CNTL_INTER_RAM4_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM4_FORCE_ISO_S: u32 = 26;
pub const RTC_CNTL_INTER_RAM3_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_NOISO_S: u32 = 25;
pub const RTC_CNTL_INTER_RAM3_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM3_FORCE_ISO_S: u32 = 24;
pub const RTC_CNTL_INTER_RAM2_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_NOISO_S: u32 = 23;
pub const RTC_CNTL_INTER_RAM2_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM2_FORCE_ISO_S: u32 = 22;
pub const RTC_CNTL_INTER_RAM1_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_NOISO_S: u32 = 21;
pub const RTC_CNTL_INTER_RAM1_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM1_FORCE_ISO_S: u32 = 20;
pub const RTC_CNTL_INTER_RAM0_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_NOISO_S: u32 = 19;
pub const RTC_CNTL_INTER_RAM0_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_INTER_RAM0_FORCE_ISO_S: u32 = 18;
pub const RTC_CNTL_ROM0_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_NOISO_S: u32 = 17;
pub const RTC_CNTL_ROM0_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_ROM0_FORCE_ISO_S: u32 = 16;
pub const RTC_CNTL_DG_PAD_FORCE_HOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_HOLD_S: u32 = 15;
pub const RTC_CNTL_DG_PAD_FORCE_UNHOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_UNHOLD_S: u32 = 14;
pub const RTC_CNTL_DG_PAD_FORCE_ISO_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_ISO_S: u32 = 13;
pub const RTC_CNTL_DG_PAD_FORCE_NOISO_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_FORCE_NOISO_S: u32 = 12;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_EN_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_EN_S: u32 = 11;
pub const RTC_CNTL_CLR_DG_PAD_AUTOHOLD_V: u32 = 1;
pub const RTC_CNTL_CLR_DG_PAD_AUTOHOLD_S: u32 = 10;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_V: u32 = 1;
pub const RTC_CNTL_DG_PAD_AUTOHOLD_S: u32 = 9;
pub const RTC_CNTL_DIG_ISO_FORCE_ON_V: u32 = 1;
pub const RTC_CNTL_DIG_ISO_FORCE_ON_S: u32 = 8;
pub const RTC_CNTL_DIG_ISO_FORCE_OFF_V: u32 = 1;
pub const RTC_CNTL_DIG_ISO_FORCE_OFF_S: u32 = 7;
pub const RTC_CNTL_WDTCONFIG0_REG: u32 = 1072988300;
pub const RTC_CNTL_WDT_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_EN_S: u32 = 31;
pub const RTC_CNTL_WDT_STG0: u32 = 7;
pub const RTC_CNTL_WDT_STG0_V: u32 = 7;
pub const RTC_CNTL_WDT_STG0_S: u32 = 28;
pub const RTC_CNTL_WDT_STG1: u32 = 7;
pub const RTC_CNTL_WDT_STG1_V: u32 = 7;
pub const RTC_CNTL_WDT_STG1_S: u32 = 25;
pub const RTC_CNTL_WDT_STG2: u32 = 7;
pub const RTC_CNTL_WDT_STG2_V: u32 = 7;
pub const RTC_CNTL_WDT_STG2_S: u32 = 22;
pub const RTC_CNTL_WDT_STG3: u32 = 7;
pub const RTC_CNTL_WDT_STG3_V: u32 = 7;
pub const RTC_CNTL_WDT_STG3_S: u32 = 19;
pub const RTC_CNTL_WDT_EDGE_INT_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_EDGE_INT_EN_S: u32 = 18;
pub const RTC_CNTL_WDT_LEVEL_INT_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_LEVEL_INT_EN_S: u32 = 17;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH: u32 = 7;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH_V: u32 = 7;
pub const RTC_CNTL_WDT_CPU_RESET_LENGTH_S: u32 = 14;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH: u32 = 7;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH_V: u32 = 7;
pub const RTC_CNTL_WDT_SYS_RESET_LENGTH_S: u32 = 11;
pub const RTC_CNTL_WDT_FLASHBOOT_MOD_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_FLASHBOOT_MOD_EN_S: u32 = 10;
pub const RTC_CNTL_WDT_PROCPU_RESET_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_PROCPU_RESET_EN_S: u32 = 9;
pub const RTC_CNTL_WDT_APPCPU_RESET_EN_V: u32 = 1;
pub const RTC_CNTL_WDT_APPCPU_RESET_EN_S: u32 = 8;
pub const RTC_CNTL_WDT_PAUSE_IN_SLP_V: u32 = 1;
pub const RTC_CNTL_WDT_PAUSE_IN_SLP_S: u32 = 7;
pub const RTC_WDT_STG_SEL_OFF: u32 = 0;
pub const RTC_WDT_STG_SEL_INT: u32 = 1;
pub const RTC_WDT_STG_SEL_RESET_CPU: u32 = 2;
pub const RTC_WDT_STG_SEL_RESET_SYSTEM: u32 = 3;
pub const RTC_WDT_STG_SEL_RESET_RTC: u32 = 4;
pub const RTC_CNTL_WDTCONFIG1_REG: u32 = 1072988304;
pub const RTC_CNTL_WDT_STG0_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG0_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG0_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG2_REG: u32 = 1072988308;
pub const RTC_CNTL_WDT_STG1_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG1_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG1_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG3_REG: u32 = 1072988312;
pub const RTC_CNTL_WDT_STG2_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG2_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG2_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTCONFIG4_REG: u32 = 1072988316;
pub const RTC_CNTL_WDT_STG3_HOLD: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG3_HOLD_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_STG3_HOLD_S: u32 = 0;
pub const RTC_CNTL_WDTFEED_REG: u32 = 1072988320;
pub const RTC_CNTL_WDT_FEED_V: u32 = 1;
pub const RTC_CNTL_WDT_FEED_S: u32 = 31;
pub const RTC_CNTL_WDTWPROTECT_REG: u32 = 1072988324;
pub const RTC_CNTL_WDT_WKEY: u32 = 4294967295;
pub const RTC_CNTL_WDT_WKEY_V: u32 = 4294967295;
pub const RTC_CNTL_WDT_WKEY_S: u32 = 0;
pub const RTC_CNTL_TEST_MUX_REG: u32 = 1072988328;
pub const RTC_CNTL_DTEST_RTC: u32 = 3;
pub const RTC_CNTL_DTEST_RTC_V: u32 = 3;
pub const RTC_CNTL_DTEST_RTC_S: u32 = 30;
pub const RTC_CNTL_ENT_RTC_V: u32 = 1;
pub const RTC_CNTL_ENT_RTC_S: u32 = 29;
pub const RTC_CNTL_SW_CPU_STALL_REG: u32 = 1072988332;
pub const RTC_CNTL_SW_STALL_PROCPU_C1: u32 = 63;
pub const RTC_CNTL_SW_STALL_PROCPU_C1_V: u32 = 63;
pub const RTC_CNTL_SW_STALL_PROCPU_C1_S: u32 = 26;
pub const RTC_CNTL_SW_STALL_APPCPU_C1: u32 = 63;
pub const RTC_CNTL_SW_STALL_APPCPU_C1_V: u32 = 63;
pub const RTC_CNTL_SW_STALL_APPCPU_C1_S: u32 = 20;
pub const RTC_CNTL_STORE4_REG: u32 = 1072988336;
pub const RTC_CNTL_SCRATCH4: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH4_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH4_S: u32 = 0;
pub const RTC_CNTL_STORE5_REG: u32 = 1072988340;
pub const RTC_CNTL_SCRATCH5: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH5_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH5_S: u32 = 0;
pub const RTC_CNTL_STORE6_REG: u32 = 1072988344;
pub const RTC_CNTL_SCRATCH6: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH6_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH6_S: u32 = 0;
pub const RTC_CNTL_STORE7_REG: u32 = 1072988348;
pub const RTC_CNTL_SCRATCH7: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH7_V: u32 = 4294967295;
pub const RTC_CNTL_SCRATCH7_S: u32 = 0;
pub const RTC_CNTL_LOW_POWER_ST_REG: u32 = 1072988352;
pub const RTC_CNTL_RDY_FOR_WAKEUP_V: u32 = 1;
pub const RTC_CNTL_RDY_FOR_WAKEUP_S: u32 = 19;
pub const RTC_CNTL_DIAG0_REG: u32 = 1072988352;
pub const RTC_CNTL_LOW_POWER_DIAG0: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG0_V: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG0_S: u32 = 0;
pub const RTC_CNTL_DIAG1_REG: u32 = 1072988356;
pub const RTC_CNTL_LOW_POWER_DIAG1: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG1_V: u32 = 4294967295;
pub const RTC_CNTL_LOW_POWER_DIAG1_S: u32 = 0;
pub const RTC_CNTL_HOLD_FORCE_REG: u32 = 1072988360;
pub const RTC_CNTL_X32N_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_X32N_HOLD_FORCE_S: u32 = 17;
pub const RTC_CNTL_X32P_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_X32P_HOLD_FORCE_S: u32 = 16;
pub const RTC_CNTL_TOUCH_PAD7_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD7_HOLD_FORCE_S: u32 = 15;
pub const RTC_CNTL_TOUCH_PAD6_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD6_HOLD_FORCE_S: u32 = 14;
pub const RTC_CNTL_TOUCH_PAD5_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD5_HOLD_FORCE_S: u32 = 13;
pub const RTC_CNTL_TOUCH_PAD4_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD4_HOLD_FORCE_S: u32 = 12;
pub const RTC_CNTL_TOUCH_PAD3_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD3_HOLD_FORCE_S: u32 = 11;
pub const RTC_CNTL_TOUCH_PAD2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD2_HOLD_FORCE_S: u32 = 10;
pub const RTC_CNTL_TOUCH_PAD1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD1_HOLD_FORCE_S: u32 = 9;
pub const RTC_CNTL_TOUCH_PAD0_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_TOUCH_PAD0_HOLD_FORCE_S: u32 = 8;
pub const RTC_CNTL_SENSE4_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE4_HOLD_FORCE_S: u32 = 7;
pub const RTC_CNTL_SENSE3_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE3_HOLD_FORCE_S: u32 = 6;
pub const RTC_CNTL_SENSE2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE2_HOLD_FORCE_S: u32 = 5;
pub const RTC_CNTL_SENSE1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_SENSE1_HOLD_FORCE_S: u32 = 4;
pub const RTC_CNTL_PDAC2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_PDAC2_HOLD_FORCE_S: u32 = 3;
pub const RTC_CNTL_PDAC1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_PDAC1_HOLD_FORCE_S: u32 = 2;
pub const RTC_CNTL_ADC2_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_ADC2_HOLD_FORCE_S: u32 = 1;
pub const RTC_CNTL_ADC1_HOLD_FORCE_V: u32 = 1;
pub const RTC_CNTL_ADC1_HOLD_FORCE_S: u32 = 0;
pub const RTC_CNTL_EXT_WAKEUP1_REG: u32 = 1072988364;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_V: u32 = 1;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_CLR_S: u32 = 18;
pub const RTC_CNTL_EXT_WAKEUP1_SEL: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_SEL_V: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_SEL_S: u32 = 0;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_REG: u32 = 1072988368;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_V: u32 = 262143;
pub const RTC_CNTL_EXT_WAKEUP1_STATUS_S: u32 = 0;
pub const RTC_CNTL_BROWN_OUT_REG: u32 = 1072988372;
pub const RTC_CNTL_BROWN_OUT_DET_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_DET_S: u32 = 31;
pub const RTC_CNTL_BROWN_OUT_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_ENA_S: u32 = 30;
pub const RTC_CNTL_DBROWN_OUT_THRES: u32 = 7;
pub const RTC_CNTL_DBROWN_OUT_THRES_V: u32 = 7;
pub const RTC_CNTL_DBROWN_OUT_THRES_S: u32 = 27;
pub const RTC_CNTL_BROWN_OUT_RST_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_RST_ENA_S: u32 = 26;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT_V: u32 = 1023;
pub const RTC_CNTL_BROWN_OUT_RST_WAIT_S: u32 = 16;
pub const RTC_CNTL_BROWN_OUT_PD_RF_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_PD_RF_ENA_S: u32 = 15;
pub const RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_V: u32 = 1;
pub const RTC_CNTL_BROWN_OUT_CLOSE_FLASH_ENA_S: u32 = 14;
pub const RTC_MEM_CONF: u32 = 1072988416;
pub const RTC_MEM_CRC_FINISH_V: u32 = 1;
pub const RTC_MEM_CRC_FINISH_S: u32 = 31;
pub const RTC_MEM_CRC_LEN: u32 = 2047;
pub const RTC_MEM_CRC_LEN_V: u32 = 2047;
pub const RTC_MEM_CRC_LEN_S: u32 = 20;
pub const RTC_MEM_CRC_ADDR: u32 = 2047;
pub const RTC_MEM_CRC_ADDR_V: u32 = 2047;
pub const RTC_MEM_CRC_ADDR_S: u32 = 9;
pub const RTC_MEM_CRC_START_V: u32 = 1;
pub const RTC_MEM_CRC_START_S: u32 = 8;
pub const RTC_MEM_PID_CONF: u32 = 255;
pub const RTC_MEM_PID_CONF_M: u32 = 255;
pub const RTC_MEM_PID_CONF_V: u32 = 255;
pub const RTC_MEM_PID_CONF_S: u32 = 0;
pub const RTC_MEM_CRC_RES: u32 = 1072988420;
pub const RTC_CNTL_DATE_REG: u32 = 1072988476;
pub const RTC_CNTL_CNTL_DATE: u32 = 268435455;
pub const RTC_CNTL_CNTL_DATE_V: u32 = 268435455;
pub const RTC_CNTL_CNTL_DATE_S: u32 = 0;
pub const RTC_CNTL_RTC_CNTL_DATE_VERSION: u32 = 23085696;
pub const I2S_PIN_NO_CHANGE: i32 = -1;
pub const SOC_LEDC_SUPPORT_HS_MODE: u32 = 1;
pub const LEDC_APB_CLK_HZ: u32 = 80000000;
pub const LEDC_REF_CLK_HZ: u32 = 1000000;
pub const LEDC_ERR_DUTY: u32 = 4294967295;
pub const LEDC_ERR_VAL: i32 = -1;
pub const SOC_MCPWM_PERIPH_NUM: u32 = 2;
pub const SOC_MCPWM_TIMER_NUM: u32 = 3;
pub const SOC_MCPWM_OP_NUM: u32 = 3;
pub const SOC_MCPWM_COMPARATOR_NUM: u32 = 2;
pub const SOC_MCPWM_GENERATOR_NUM: u32 = 2;
pub const SOC_MCPWM_FAULT_SIG_NUM: u32 = 3;
pub const PCNT_U0_CONF0_REG: u32 = 1073049600;
pub const PCNT_CH1_LCTRL_MODE_U0: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U0_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U0_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U0: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U0_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U0_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U0: u32 = 3;
pub const PCNT_CH1_POS_MODE_U0_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U0_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U0: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U0_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U0_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U0: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U0_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U0_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U0: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U0_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U0_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U0: u32 = 3;
pub const PCNT_CH0_POS_MODE_U0_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U0_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U0: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U0_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U0_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U0_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U0_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U0_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U0_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U0_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U0_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U0_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U0_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U0_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U0_S: u32 = 11;
pub const PCNT_FILTER_EN_U0_V: u32 = 1;
pub const PCNT_FILTER_EN_U0_S: u32 = 10;
pub const PCNT_FILTER_THRES_U0: u32 = 1023;
pub const PCNT_FILTER_THRES_U0_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U0_S: u32 = 0;
pub const PCNT_U0_CONF1_REG: u32 = 1073049604;
pub const PCNT_CNT_THRES1_U0: u32 = 65535;
pub const PCNT_CNT_THRES1_U0_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U0_S: u32 = 16;
pub const PCNT_CNT_THRES0_U0: u32 = 65535;
pub const PCNT_CNT_THRES0_U0_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U0_S: u32 = 0;
pub const PCNT_U0_CONF2_REG: u32 = 1073049608;
pub const PCNT_CNT_L_LIM_U0: u32 = 65535;
pub const PCNT_CNT_L_LIM_U0_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U0_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U0: u32 = 65535;
pub const PCNT_CNT_H_LIM_U0_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U0_S: u32 = 0;
pub const PCNT_U1_CONF0_REG: u32 = 1073049612;
pub const PCNT_CH1_LCTRL_MODE_U1: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U1_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U1_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U1: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U1_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U1_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U1: u32 = 3;
pub const PCNT_CH1_POS_MODE_U1_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U1_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U1: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U1_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U1_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U1: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U1_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U1_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U1: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U1_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U1_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U1: u32 = 3;
pub const PCNT_CH0_POS_MODE_U1_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U1_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U1: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U1_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U1_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U1_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U1_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U1_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U1_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U1_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U1_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U1_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U1_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U1_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U1_S: u32 = 11;
pub const PCNT_FILTER_EN_U1_V: u32 = 1;
pub const PCNT_FILTER_EN_U1_S: u32 = 10;
pub const PCNT_FILTER_THRES_U1: u32 = 1023;
pub const PCNT_FILTER_THRES_U1_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U1_S: u32 = 0;
pub const PCNT_U1_CONF1_REG: u32 = 1073049616;
pub const PCNT_CNT_THRES1_U1: u32 = 65535;
pub const PCNT_CNT_THRES1_U1_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U1_S: u32 = 16;
pub const PCNT_CNT_THRES0_U1: u32 = 65535;
pub const PCNT_CNT_THRES0_U1_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U1_S: u32 = 0;
pub const PCNT_U1_CONF2_REG: u32 = 1073049620;
pub const PCNT_CNT_L_LIM_U1: u32 = 65535;
pub const PCNT_CNT_L_LIM_U1_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U1_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U1: u32 = 65535;
pub const PCNT_CNT_H_LIM_U1_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U1_S: u32 = 0;
pub const PCNT_U2_CONF0_REG: u32 = 1073049624;
pub const PCNT_CH1_LCTRL_MODE_U2: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U2_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U2_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U2: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U2_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U2_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U2: u32 = 3;
pub const PCNT_CH1_POS_MODE_U2_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U2_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U2: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U2_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U2_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U2: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U2_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U2_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U2: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U2_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U2_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U2: u32 = 3;
pub const PCNT_CH0_POS_MODE_U2_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U2_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U2: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U2_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U2_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U2_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U2_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U2_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U2_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U2_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U2_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U2_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U2_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U2_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U2_S: u32 = 11;
pub const PCNT_FILTER_EN_U2_V: u32 = 1;
pub const PCNT_FILTER_EN_U2_S: u32 = 10;
pub const PCNT_FILTER_THRES_U2: u32 = 1023;
pub const PCNT_FILTER_THRES_U2_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U2_S: u32 = 0;
pub const PCNT_U2_CONF1_REG: u32 = 1073049628;
pub const PCNT_CNT_THRES1_U2: u32 = 65535;
pub const PCNT_CNT_THRES1_U2_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U2_S: u32 = 16;
pub const PCNT_CNT_THRES0_U2: u32 = 65535;
pub const PCNT_CNT_THRES0_U2_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U2_S: u32 = 0;
pub const PCNT_U2_CONF2_REG: u32 = 1073049632;
pub const PCNT_CNT_L_LIM_U2: u32 = 65535;
pub const PCNT_CNT_L_LIM_U2_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U2_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U2: u32 = 65535;
pub const PCNT_CNT_H_LIM_U2_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U2_S: u32 = 0;
pub const PCNT_U3_CONF0_REG: u32 = 1073049636;
pub const PCNT_CH1_LCTRL_MODE_U3: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U3_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U3_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U3: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U3_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U3_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U3: u32 = 3;
pub const PCNT_CH1_POS_MODE_U3_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U3_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U3: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U3_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U3_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U3: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U3_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U3_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U3: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U3_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U3_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U3: u32 = 3;
pub const PCNT_CH0_POS_MODE_U3_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U3_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U3: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U3_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U3_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U3_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U3_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U3_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U3_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U3_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U3_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U3_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U3_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U3_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U3_S: u32 = 11;
pub const PCNT_FILTER_EN_U3_V: u32 = 1;
pub const PCNT_FILTER_EN_U3_S: u32 = 10;
pub const PCNT_FILTER_THRES_U3: u32 = 1023;
pub const PCNT_FILTER_THRES_U3_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U3_S: u32 = 0;
pub const PCNT_U3_CONF1_REG: u32 = 1073049640;
pub const PCNT_CNT_THRES1_U3: u32 = 65535;
pub const PCNT_CNT_THRES1_U3_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U3_S: u32 = 16;
pub const PCNT_CNT_THRES0_U3: u32 = 65535;
pub const PCNT_CNT_THRES0_U3_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U3_S: u32 = 0;
pub const PCNT_U3_CONF2_REG: u32 = 1073049644;
pub const PCNT_CNT_L_LIM_U3: u32 = 65535;
pub const PCNT_CNT_L_LIM_U3_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U3_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U3: u32 = 65535;
pub const PCNT_CNT_H_LIM_U3_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U3_S: u32 = 0;
pub const PCNT_U4_CONF0_REG: u32 = 1073049648;
pub const PCNT_CH1_LCTRL_MODE_U4: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U4_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U4_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U4: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U4_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U4_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U4: u32 = 3;
pub const PCNT_CH1_POS_MODE_U4_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U4_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U4: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U4_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U4_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U4: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U4_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U4_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U4: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U4_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U4_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U4: u32 = 3;
pub const PCNT_CH0_POS_MODE_U4_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U4_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U4: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U4_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U4_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U4_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U4_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U4_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U4_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U4_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U4_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U4_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U4_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U4_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U4_S: u32 = 11;
pub const PCNT_FILTER_EN_U4_V: u32 = 1;
pub const PCNT_FILTER_EN_U4_S: u32 = 10;
pub const PCNT_FILTER_THRES_U4: u32 = 1023;
pub const PCNT_FILTER_THRES_U4_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U4_S: u32 = 0;
pub const PCNT_U4_CONF1_REG: u32 = 1073049652;
pub const PCNT_CNT_THRES1_U4: u32 = 65535;
pub const PCNT_CNT_THRES1_U4_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U4_S: u32 = 16;
pub const PCNT_CNT_THRES0_U4: u32 = 65535;
pub const PCNT_CNT_THRES0_U4_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U4_S: u32 = 0;
pub const PCNT_U4_CONF2_REG: u32 = 1073049656;
pub const PCNT_CNT_L_LIM_U4: u32 = 65535;
pub const PCNT_CNT_L_LIM_U4_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U4_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U4: u32 = 65535;
pub const PCNT_CNT_H_LIM_U4_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U4_S: u32 = 0;
pub const PCNT_U5_CONF0_REG: u32 = 1073049660;
pub const PCNT_CH1_LCTRL_MODE_U5: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U5_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U5_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U5: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U5_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U5_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U5: u32 = 3;
pub const PCNT_CH1_POS_MODE_U5_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U5_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U5: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U5_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U5_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U5: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U5_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U5_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U5: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U5_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U5_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U5: u32 = 3;
pub const PCNT_CH0_POS_MODE_U5_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U5_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U5: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U5_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U5_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U5_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U5_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U5_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U5_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U5_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U5_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U5_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U5_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U5_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U5_S: u32 = 11;
pub const PCNT_FILTER_EN_U5_V: u32 = 1;
pub const PCNT_FILTER_EN_U5_S: u32 = 10;
pub const PCNT_FILTER_THRES_U5: u32 = 1023;
pub const PCNT_FILTER_THRES_U5_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U5_S: u32 = 0;
pub const PCNT_U5_CONF1_REG: u32 = 1073049664;
pub const PCNT_CNT_THRES1_U5: u32 = 65535;
pub const PCNT_CNT_THRES1_U5_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U5_S: u32 = 16;
pub const PCNT_CNT_THRES0_U5: u32 = 65535;
pub const PCNT_CNT_THRES0_U5_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U5_S: u32 = 0;
pub const PCNT_U5_CONF2_REG: u32 = 1073049668;
pub const PCNT_CNT_L_LIM_U5: u32 = 65535;
pub const PCNT_CNT_L_LIM_U5_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U5_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U5: u32 = 65535;
pub const PCNT_CNT_H_LIM_U5_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U5_S: u32 = 0;
pub const PCNT_U6_CONF0_REG: u32 = 1073049672;
pub const PCNT_CH1_LCTRL_MODE_U6: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U6_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U6_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U6: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U6_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U6_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U6: u32 = 3;
pub const PCNT_CH1_POS_MODE_U6_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U6_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U6: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U6_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U6_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U6: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U6_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U6_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U6: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U6_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U6_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U6: u32 = 3;
pub const PCNT_CH0_POS_MODE_U6_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U6_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U6: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U6_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U6_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U6_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U6_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U6_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U6_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U6_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U6_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U6_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U6_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U6_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U6_S: u32 = 11;
pub const PCNT_FILTER_EN_U6_V: u32 = 1;
pub const PCNT_FILTER_EN_U6_S: u32 = 10;
pub const PCNT_FILTER_THRES_U6: u32 = 1023;
pub const PCNT_FILTER_THRES_U6_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U6_S: u32 = 0;
pub const PCNT_U6_CONF1_REG: u32 = 1073049676;
pub const PCNT_CNT_THRES1_U6: u32 = 65535;
pub const PCNT_CNT_THRES1_U6_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U6_S: u32 = 16;
pub const PCNT_CNT_THRES0_U6: u32 = 65535;
pub const PCNT_CNT_THRES0_U6_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U6_S: u32 = 0;
pub const PCNT_U6_CONF2_REG: u32 = 1073049680;
pub const PCNT_CNT_L_LIM_U6: u32 = 65535;
pub const PCNT_CNT_L_LIM_U6_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U6_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U6: u32 = 65535;
pub const PCNT_CNT_H_LIM_U6_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U6_S: u32 = 0;
pub const PCNT_U7_CONF0_REG: u32 = 1073049684;
pub const PCNT_CH1_LCTRL_MODE_U7: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U7_V: u32 = 3;
pub const PCNT_CH1_LCTRL_MODE_U7_S: u32 = 30;
pub const PCNT_CH1_HCTRL_MODE_U7: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U7_V: u32 = 3;
pub const PCNT_CH1_HCTRL_MODE_U7_S: u32 = 28;
pub const PCNT_CH1_POS_MODE_U7: u32 = 3;
pub const PCNT_CH1_POS_MODE_U7_V: u32 = 3;
pub const PCNT_CH1_POS_MODE_U7_S: u32 = 26;
pub const PCNT_CH1_NEG_MODE_U7: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U7_V: u32 = 3;
pub const PCNT_CH1_NEG_MODE_U7_S: u32 = 24;
pub const PCNT_CH0_LCTRL_MODE_U7: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U7_V: u32 = 3;
pub const PCNT_CH0_LCTRL_MODE_U7_S: u32 = 22;
pub const PCNT_CH0_HCTRL_MODE_U7: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U7_V: u32 = 3;
pub const PCNT_CH0_HCTRL_MODE_U7_S: u32 = 20;
pub const PCNT_CH0_POS_MODE_U7: u32 = 3;
pub const PCNT_CH0_POS_MODE_U7_V: u32 = 3;
pub const PCNT_CH0_POS_MODE_U7_S: u32 = 18;
pub const PCNT_CH0_NEG_MODE_U7: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U7_V: u32 = 3;
pub const PCNT_CH0_NEG_MODE_U7_S: u32 = 16;
pub const PCNT_THR_THRES1_EN_U7_V: u32 = 1;
pub const PCNT_THR_THRES1_EN_U7_S: u32 = 15;
pub const PCNT_THR_THRES0_EN_U7_V: u32 = 1;
pub const PCNT_THR_THRES0_EN_U7_S: u32 = 14;
pub const PCNT_THR_L_LIM_EN_U7_V: u32 = 1;
pub const PCNT_THR_L_LIM_EN_U7_S: u32 = 13;
pub const PCNT_THR_H_LIM_EN_U7_V: u32 = 1;
pub const PCNT_THR_H_LIM_EN_U7_S: u32 = 12;
pub const PCNT_THR_ZERO_EN_U7_V: u32 = 1;
pub const PCNT_THR_ZERO_EN_U7_S: u32 = 11;
pub const PCNT_FILTER_EN_U7_V: u32 = 1;
pub const PCNT_FILTER_EN_U7_S: u32 = 10;
pub const PCNT_FILTER_THRES_U7: u32 = 1023;
pub const PCNT_FILTER_THRES_U7_V: u32 = 1023;
pub const PCNT_FILTER_THRES_U7_S: u32 = 0;
pub const PCNT_U7_CONF1_REG: u32 = 1073049688;
pub const PCNT_CNT_THRES1_U7: u32 = 65535;
pub const PCNT_CNT_THRES1_U7_V: u32 = 65535;
pub const PCNT_CNT_THRES1_U7_S: u32 = 16;
pub const PCNT_CNT_THRES0_U7: u32 = 65535;
pub const PCNT_CNT_THRES0_U7_V: u32 = 65535;
pub const PCNT_CNT_THRES0_U7_S: u32 = 0;
pub const PCNT_U7_CONF2_REG: u32 = 1073049692;
pub const PCNT_CNT_L_LIM_U7: u32 = 65535;
pub const PCNT_CNT_L_LIM_U7_V: u32 = 65535;
pub const PCNT_CNT_L_LIM_U7_S: u32 = 16;
pub const PCNT_CNT_H_LIM_U7: u32 = 65535;
pub const PCNT_CNT_H_LIM_U7_V: u32 = 65535;
pub const PCNT_CNT_H_LIM_U7_S: u32 = 0;
pub const PCNT_U0_CNT_REG: u32 = 1073049696;
pub const PCNT_PLUS_CNT_U0: u32 = 65535;
pub const PCNT_PLUS_CNT_U0_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U0_S: u32 = 0;
pub const PCNT_U1_CNT_REG: u32 = 1073049700;
pub const PCNT_PLUS_CNT_U1: u32 = 65535;
pub const PCNT_PLUS_CNT_U1_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U1_S: u32 = 0;
pub const PCNT_U2_CNT_REG: u32 = 1073049704;
pub const PCNT_PLUS_CNT_U2: u32 = 65535;
pub const PCNT_PLUS_CNT_U2_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U2_S: u32 = 0;
pub const PCNT_U3_CNT_REG: u32 = 1073049708;
pub const PCNT_PLUS_CNT_U3: u32 = 65535;
pub const PCNT_PLUS_CNT_U3_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U3_S: u32 = 0;
pub const PCNT_U4_CNT_REG: u32 = 1073049712;
pub const PCNT_PLUS_CNT_U4: u32 = 65535;
pub const PCNT_PLUS_CNT_U4_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U4_S: u32 = 0;
pub const PCNT_U5_CNT_REG: u32 = 1073049716;
pub const PCNT_PLUS_CNT_U5: u32 = 65535;
pub const PCNT_PLUS_CNT_U5_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U5_S: u32 = 0;
pub const PCNT_U6_CNT_REG: u32 = 1073049720;
pub const PCNT_PLUS_CNT_U6: u32 = 65535;
pub const PCNT_PLUS_CNT_U6_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U6_S: u32 = 0;
pub const PCNT_U7_CNT_REG: u32 = 1073049724;
pub const PCNT_PLUS_CNT_U7: u32 = 65535;
pub const PCNT_PLUS_CNT_U7_V: u32 = 65535;
pub const PCNT_PLUS_CNT_U7_S: u32 = 0;
pub const PCNT_INT_RAW_REG: u32 = 1073049728;
pub const PCNT_CNT_THR_EVENT_U7_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U7_INT_RAW_S: u32 = 7;
pub const PCNT_CNT_THR_EVENT_U6_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U6_INT_RAW_S: u32 = 6;
pub const PCNT_CNT_THR_EVENT_U5_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U5_INT_RAW_S: u32 = 5;
pub const PCNT_CNT_THR_EVENT_U4_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U4_INT_RAW_S: u32 = 4;
pub const PCNT_CNT_THR_EVENT_U3_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U3_INT_RAW_S: u32 = 3;
pub const PCNT_CNT_THR_EVENT_U2_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U2_INT_RAW_S: u32 = 2;
pub const PCNT_CNT_THR_EVENT_U1_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U1_INT_RAW_S: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_RAW_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_RAW_S: u32 = 0;
pub const PCNT_INT_ST_REG: u32 = 1073049732;
pub const PCNT_CNT_THR_EVENT_U7_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U7_INT_ST_S: u32 = 7;
pub const PCNT_CNT_THR_EVENT_U6_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U6_INT_ST_S: u32 = 6;
pub const PCNT_CNT_THR_EVENT_U5_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U5_INT_ST_S: u32 = 5;
pub const PCNT_CNT_THR_EVENT_U4_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U4_INT_ST_S: u32 = 4;
pub const PCNT_CNT_THR_EVENT_U3_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U3_INT_ST_S: u32 = 3;
pub const PCNT_CNT_THR_EVENT_U2_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U2_INT_ST_S: u32 = 2;
pub const PCNT_CNT_THR_EVENT_U1_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U1_INT_ST_S: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_ST_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_ST_S: u32 = 0;
pub const PCNT_INT_ENA_REG: u32 = 1073049736;
pub const PCNT_CNT_THR_EVENT_U7_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U7_INT_ENA_S: u32 = 7;
pub const PCNT_CNT_THR_EVENT_U6_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U6_INT_ENA_S: u32 = 6;
pub const PCNT_CNT_THR_EVENT_U5_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U5_INT_ENA_S: u32 = 5;
pub const PCNT_CNT_THR_EVENT_U4_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U4_INT_ENA_S: u32 = 4;
pub const PCNT_CNT_THR_EVENT_U3_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U3_INT_ENA_S: u32 = 3;
pub const PCNT_CNT_THR_EVENT_U2_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U2_INT_ENA_S: u32 = 2;
pub const PCNT_CNT_THR_EVENT_U1_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U1_INT_ENA_S: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_ENA_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_ENA_S: u32 = 0;
pub const PCNT_INT_CLR_REG: u32 = 1073049740;
pub const PCNT_CNT_THR_EVENT_U7_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U7_INT_CLR_S: u32 = 7;
pub const PCNT_CNT_THR_EVENT_U6_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U6_INT_CLR_S: u32 = 6;
pub const PCNT_CNT_THR_EVENT_U5_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U5_INT_CLR_S: u32 = 5;
pub const PCNT_CNT_THR_EVENT_U4_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U4_INT_CLR_S: u32 = 4;
pub const PCNT_CNT_THR_EVENT_U3_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U3_INT_CLR_S: u32 = 3;
pub const PCNT_CNT_THR_EVENT_U2_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U2_INT_CLR_S: u32 = 2;
pub const PCNT_CNT_THR_EVENT_U1_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U1_INT_CLR_S: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_CLR_V: u32 = 1;
pub const PCNT_CNT_THR_EVENT_U0_INT_CLR_S: u32 = 0;
pub const PCNT_U0_STATUS_REG: u32 = 1073049744;
pub const PCNT_CORE_STATUS_U0: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U0_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U0_S: u32 = 0;
pub const PCNT_STATUS_CNT_MODE: u32 = 3;
pub const PCNT_STATUS_CNT_MODE_V: u32 = 3;
pub const PCNT_STATUS_CNT_MODE_S: u32 = 0;
pub const PCNT_STATUS_THRES1_V: u32 = 1;
pub const PCNT_STATUS_THRES1_S: u32 = 2;
pub const PCNT_STATUS_THRES0_V: u32 = 1;
pub const PCNT_STATUS_THRES0_S: u32 = 3;
pub const PCNT_STATUS_L_LIM_V: u32 = 1;
pub const PCNT_STATUS_L_LIM_S: u32 = 4;
pub const PCNT_STATUS_H_LIM_V: u32 = 1;
pub const PCNT_STATUS_H_LIM_S: u32 = 5;
pub const PCNT_STATUS_ZERO_V: u32 = 1;
pub const PCNT_STATUS_ZERO_S: u32 = 6;
pub const PCNT_U1_STATUS_REG: u32 = 1073049748;
pub const PCNT_CORE_STATUS_U1: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U1_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U1_S: u32 = 0;
pub const PCNT_U2_STATUS_REG: u32 = 1073049752;
pub const PCNT_CORE_STATUS_U2: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U2_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U2_S: u32 = 0;
pub const PCNT_U3_STATUS_REG: u32 = 1073049756;
pub const PCNT_CORE_STATUS_U3: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U3_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U3_S: u32 = 0;
pub const PCNT_U4_STATUS_REG: u32 = 1073049760;
pub const PCNT_CORE_STATUS_U4: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U4_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U4_S: u32 = 0;
pub const PCNT_U5_STATUS_REG: u32 = 1073049764;
pub const PCNT_CORE_STATUS_U5: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U5_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U5_S: u32 = 0;
pub const PCNT_U6_STATUS_REG: u32 = 1073049768;
pub const PCNT_CORE_STATUS_U6: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U6_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U6_S: u32 = 0;
pub const PCNT_U7_STATUS_REG: u32 = 1073049772;
pub const PCNT_CORE_STATUS_U7: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U7_V: u32 = 4294967295;
pub const PCNT_CORE_STATUS_U7_S: u32 = 0;
pub const PCNT_CTRL_REG: u32 = 1073049776;
pub const PCNT_CLK_EN_V: u32 = 1;
pub const PCNT_CLK_EN_S: u32 = 16;
pub const PCNT_CNT_PAUSE_U7_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U7_S: u32 = 15;
pub const PCNT_PLUS_CNT_RST_U7_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U7_S: u32 = 14;
pub const PCNT_CNT_PAUSE_U6_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U6_S: u32 = 13;
pub const PCNT_PLUS_CNT_RST_U6_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U6_S: u32 = 12;
pub const PCNT_CNT_PAUSE_U5_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U5_S: u32 = 11;
pub const PCNT_PLUS_CNT_RST_U5_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U5_S: u32 = 10;
pub const PCNT_CNT_PAUSE_U4_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U4_S: u32 = 9;
pub const PCNT_PLUS_CNT_RST_U4_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U4_S: u32 = 8;
pub const PCNT_CNT_PAUSE_U3_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U3_S: u32 = 7;
pub const PCNT_PLUS_CNT_RST_U3_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U3_S: u32 = 6;
pub const PCNT_CNT_PAUSE_U2_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U2_S: u32 = 5;
pub const PCNT_PLUS_CNT_RST_U2_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U2_S: u32 = 4;
pub const PCNT_CNT_PAUSE_U1_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U1_S: u32 = 3;
pub const PCNT_PLUS_CNT_RST_U1_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U1_S: u32 = 2;
pub const PCNT_CNT_PAUSE_U0_V: u32 = 1;
pub const PCNT_CNT_PAUSE_U0_S: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U0_V: u32 = 1;
pub const PCNT_PLUS_CNT_RST_U0_S: u32 = 0;
pub const PCNT_DATE_REG: u32 = 1073049852;
pub const PCNT_DATE: u32 = 4294967295;
pub const PCNT_DATE_V: u32 = 4294967295;
pub const PCNT_DATE_S: u32 = 0;
pub const PCNT_PORT_0: u32 = 0;
pub const PCNT_PORT_MAX: u32 = 1;
pub const SOC_PCNT_NUM: u32 = 1;
pub const PCNT_PIN_NOT_USED: i32 = -1;
pub const PCNT_UNIT_0: u32 = 0;
pub const PCNT_UNIT_1: u32 = 1;
pub const PCNT_UNIT_2: u32 = 2;
pub const PCNT_UNIT_3: u32 = 3;
pub const PCNT_UNIT_4: u32 = 4;
pub const PCNT_UNIT_5: u32 = 5;
pub const PCNT_UNIT_6: u32 = 6;
pub const PCNT_UNIT_7: u32 = 7;
pub const PCNT_UNIT_MAX: u32 = 8;
pub const RMT_CHANNEL_MEM_WORDS: u32 = 64;
pub const RMT_MEM_ITEM_NUM: u32 = 64;
pub const SDIO_SLAVE_SLOT0_IOMUX_PIN_NUM_CLK: u32 = 6;
pub const SDIO_SLAVE_SLOT0_IOMUX_PIN_NUM_CMD: u32 = 11;
pub const SDIO_SLAVE_SLOT0_IOMUX_PIN_NUM_D0: u32 = 7;
pub const SDIO_SLAVE_SLOT0_IOMUX_PIN_NUM_D1: u32 = 8;
pub const SDIO_SLAVE_SLOT0_IOMUX_PIN_NUM_D2: u32 = 9;
pub const SDIO_SLAVE_SLOT0_IOMUX_PIN_NUM_D3: u32 = 10;
pub const SDIO_SLAVE_SLOT0_FUNC: u32 = 0;
pub const SDIO_SLAVE_SLOT1_IOMUX_PIN_NUM_CLK: u32 = 14;
pub const SDIO_SLAVE_SLOT1_IOMUX_PIN_NUM_CMD: u32 = 15;
pub const SDIO_SLAVE_SLOT1_IOMUX_PIN_NUM_D0: u32 = 2;
pub const SDIO_SLAVE_SLOT1_IOMUX_PIN_NUM_D1: u32 = 4;
pub const SDIO_SLAVE_SLOT1_IOMUX_PIN_NUM_D2: u32 = 12;
pub const SDIO_SLAVE_SLOT1_IOMUX_PIN_NUM_D3: u32 = 13;
pub const SDIO_SLAVE_SLOT1_FUNC: u32 = 4;
pub const SLC_CONF0_REG: u32 = 1073053696;
pub const SLC_SLC1_TOKEN_SEL_V: u32 = 1;
pub const SLC_SLC1_TOKEN_SEL_S: u32 = 31;
pub const SLC_SLC1_TOKEN_AUTO_CLR_V: u32 = 1;
pub const SLC_SLC1_TOKEN_AUTO_CLR_S: u32 = 30;
pub const SLC_SLC1_TXDATA_BURST_EN_V: u32 = 1;
pub const SLC_SLC1_TXDATA_BURST_EN_S: u32 = 29;
pub const SLC_SLC1_TXDSCR_BURST_EN_V: u32 = 1;
pub const SLC_SLC1_TXDSCR_BURST_EN_S: u32 = 28;
pub const SLC_SLC1_TXLINK_AUTO_RET_V: u32 = 1;
pub const SLC_SLC1_TXLINK_AUTO_RET_S: u32 = 27;
pub const SLC_SLC1_RXLINK_AUTO_RET_V: u32 = 1;
pub const SLC_SLC1_RXLINK_AUTO_RET_S: u32 = 26;
pub const SLC_SLC1_RXDATA_BURST_EN_V: u32 = 1;
pub const SLC_SLC1_RXDATA_BURST_EN_S: u32 = 25;
pub const SLC_SLC1_RXDSCR_BURST_EN_V: u32 = 1;
pub const SLC_SLC1_RXDSCR_BURST_EN_S: u32 = 24;
pub const SLC_SLC1_RX_NO_RESTART_CLR_V: u32 = 1;
pub const SLC_SLC1_RX_NO_RESTART_CLR_S: u32 = 23;
pub const SLC_SLC1_RX_AUTO_WRBACK_V: u32 = 1;
pub const SLC_SLC1_RX_AUTO_WRBACK_S: u32 = 22;
pub const SLC_SLC1_RX_LOOP_TEST_V: u32 = 1;
pub const SLC_SLC1_RX_LOOP_TEST_S: u32 = 21;
pub const SLC_SLC1_TX_LOOP_TEST_V: u32 = 1;
pub const SLC_SLC1_TX_LOOP_TEST_S: u32 = 20;
pub const SLC_SLC1_WR_RETRY_MASK_EN_V: u32 = 1;
pub const SLC_SLC1_WR_RETRY_MASK_EN_S: u32 = 19;
pub const SLC_SLC0_WR_RETRY_MASK_EN_V: u32 = 1;
pub const SLC_SLC0_WR_RETRY_MASK_EN_S: u32 = 18;
pub const SLC_SLC1_RX_RST_V: u32 = 1;
pub const SLC_SLC1_RX_RST_S: u32 = 17;
pub const SLC_SLC1_TX_RST_V: u32 = 1;
pub const SLC_SLC1_TX_RST_S: u32 = 16;
pub const SLC_SLC0_TOKEN_SEL_V: u32 = 1;
pub const SLC_SLC0_TOKEN_SEL_S: u32 = 15;
pub const SLC_SLC0_TOKEN_AUTO_CLR_V: u32 = 1;
pub const SLC_SLC0_TOKEN_AUTO_CLR_S: u32 = 14;
pub const SLC_SLC0_TXDATA_BURST_EN_V: u32 = 1;
pub const SLC_SLC0_TXDATA_BURST_EN_S: u32 = 13;
pub const SLC_SLC0_TXDSCR_BURST_EN_V: u32 = 1;
pub const SLC_SLC0_TXDSCR_BURST_EN_S: u32 = 12;
pub const SLC_SLC0_TXLINK_AUTO_RET_V: u32 = 1;
pub const SLC_SLC0_TXLINK_AUTO_RET_S: u32 = 11;
pub const SLC_SLC0_RXLINK_AUTO_RET_V: u32 = 1;
pub const SLC_SLC0_RXLINK_AUTO_RET_S: u32 = 10;
pub const SLC_SLC0_RXDATA_BURST_EN_V: u32 = 1;
pub const SLC_SLC0_RXDATA_BURST_EN_S: u32 = 9;
pub const SLC_SLC0_RXDSCR_BURST_EN_V: u32 = 1;
pub const SLC_SLC0_RXDSCR_BURST_EN_S: u32 = 8;
pub const SLC_SLC0_RX_NO_RESTART_CLR_V: u32 = 1;
pub const SLC_SLC0_RX_NO_RESTART_CLR_S: u32 = 7;
pub const SLC_SLC0_RX_AUTO_WRBACK_V: u32 = 1;
pub const SLC_SLC0_RX_AUTO_WRBACK_S: u32 = 6;
pub const SLC_SLC0_RX_LOOP_TEST_V: u32 = 1;
pub const SLC_SLC0_RX_LOOP_TEST_S: u32 = 5;
pub const SLC_SLC0_TX_LOOP_TEST_V: u32 = 1;
pub const SLC_SLC0_TX_LOOP_TEST_S: u32 = 4;
pub const SLC_AHBM_RST_V: u32 = 1;
pub const SLC_AHBM_RST_S: u32 = 3;
pub const SLC_AHBM_FIFO_RST_V: u32 = 1;
pub const SLC_AHBM_FIFO_RST_S: u32 = 2;
pub const SLC_SLC0_RX_RST_V: u32 = 1;
pub const SLC_SLC0_RX_RST_S: u32 = 1;
pub const SLC_SLC0_TX_RST_V: u32 = 1;
pub const SLC_SLC0_TX_RST_S: u32 = 0;
pub const SLC_0INT_RAW_REG: u32 = 1073053700;
pub const SLC_SLC0_RX_QUICK_EOF_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_RX_QUICK_EOF_INT_RAW_S: u32 = 26;
pub const SLC_CMD_DTC_INT_RAW_V: u32 = 1;
pub const SLC_CMD_DTC_INT_RAW_S: u32 = 25;
pub const SLC_SLC0_TX_ERR_EOF_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TX_ERR_EOF_INT_RAW_S: u32 = 24;
pub const SLC_SLC0_WR_RETRY_DONE_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_WR_RETRY_DONE_INT_RAW_S: u32 = 23;
pub const SLC_SLC0_HOST_RD_ACK_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_HOST_RD_ACK_INT_RAW_S: u32 = 22;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_RAW_S: u32 = 21;
pub const SLC_SLC0_RX_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_RX_DSCR_ERR_INT_RAW_S: u32 = 20;
pub const SLC_SLC0_TX_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_ERR_INT_RAW_S: u32 = 19;
pub const SLC_SLC0_TOHOST_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TOHOST_INT_RAW_S: u32 = 18;
pub const SLC_SLC0_RX_EOF_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_RX_EOF_INT_RAW_S: u32 = 17;
pub const SLC_SLC0_RX_DONE_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_RX_DONE_INT_RAW_S: u32 = 16;
pub const SLC_SLC0_TX_SUC_EOF_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TX_SUC_EOF_INT_RAW_S: u32 = 15;
pub const SLC_SLC0_TX_DONE_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TX_DONE_INT_RAW_S: u32 = 14;
pub const SLC_SLC0_TOKEN1_1TO0_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_1TO0_INT_RAW_S: u32 = 13;
pub const SLC_SLC0_TOKEN0_1TO0_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_1TO0_INT_RAW_S: u32 = 12;
pub const SLC_SLC0_TX_OVF_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TX_OVF_INT_RAW_S: u32 = 11;
pub const SLC_SLC0_RX_UDF_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_RX_UDF_INT_RAW_S: u32 = 10;
pub const SLC_SLC0_TX_START_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_TX_START_INT_RAW_S: u32 = 9;
pub const SLC_SLC0_RX_START_INT_RAW_V: u32 = 1;
pub const SLC_SLC0_RX_START_INT_RAW_S: u32 = 8;
pub const SLC_FRHOST_BIT7_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT7_INT_RAW_S: u32 = 7;
pub const SLC_FRHOST_BIT6_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT6_INT_RAW_S: u32 = 6;
pub const SLC_FRHOST_BIT5_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT5_INT_RAW_S: u32 = 5;
pub const SLC_FRHOST_BIT4_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT4_INT_RAW_S: u32 = 4;
pub const SLC_FRHOST_BIT3_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT3_INT_RAW_S: u32 = 3;
pub const SLC_FRHOST_BIT2_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT2_INT_RAW_S: u32 = 2;
pub const SLC_FRHOST_BIT1_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT1_INT_RAW_S: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_RAW_S: u32 = 0;
pub const SLC_0INT_ST_REG: u32 = 1073053704;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ST_V: u32 = 1;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ST_S: u32 = 26;
pub const SLC_CMD_DTC_INT_ST_V: u32 = 1;
pub const SLC_CMD_DTC_INT_ST_S: u32 = 25;
pub const SLC_SLC0_TX_ERR_EOF_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TX_ERR_EOF_INT_ST_S: u32 = 24;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ST_V: u32 = 1;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ST_S: u32 = 23;
pub const SLC_SLC0_HOST_RD_ACK_INT_ST_V: u32 = 1;
pub const SLC_SLC0_HOST_RD_ACK_INT_ST_S: u32 = 22;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ST_S: u32 = 21;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ST_V: u32 = 1;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ST_S: u32 = 20;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ST_S: u32 = 19;
pub const SLC_SLC0_TOHOST_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TOHOST_INT_ST_S: u32 = 18;
pub const SLC_SLC0_RX_EOF_INT_ST_V: u32 = 1;
pub const SLC_SLC0_RX_EOF_INT_ST_S: u32 = 17;
pub const SLC_SLC0_RX_DONE_INT_ST_V: u32 = 1;
pub const SLC_SLC0_RX_DONE_INT_ST_S: u32 = 16;
pub const SLC_SLC0_TX_SUC_EOF_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TX_SUC_EOF_INT_ST_S: u32 = 15;
pub const SLC_SLC0_TX_DONE_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TX_DONE_INT_ST_S: u32 = 14;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ST_S: u32 = 13;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ST_S: u32 = 12;
pub const SLC_SLC0_TX_OVF_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TX_OVF_INT_ST_S: u32 = 11;
pub const SLC_SLC0_RX_UDF_INT_ST_V: u32 = 1;
pub const SLC_SLC0_RX_UDF_INT_ST_S: u32 = 10;
pub const SLC_SLC0_TX_START_INT_ST_V: u32 = 1;
pub const SLC_SLC0_TX_START_INT_ST_S: u32 = 9;
pub const SLC_SLC0_RX_START_INT_ST_V: u32 = 1;
pub const SLC_SLC0_RX_START_INT_ST_S: u32 = 8;
pub const SLC_FRHOST_BIT7_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT7_INT_ST_S: u32 = 7;
pub const SLC_FRHOST_BIT6_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT6_INT_ST_S: u32 = 6;
pub const SLC_FRHOST_BIT5_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT5_INT_ST_S: u32 = 5;
pub const SLC_FRHOST_BIT4_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT4_INT_ST_S: u32 = 4;
pub const SLC_FRHOST_BIT3_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT3_INT_ST_S: u32 = 3;
pub const SLC_FRHOST_BIT2_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT2_INT_ST_S: u32 = 2;
pub const SLC_FRHOST_BIT1_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT1_INT_ST_S: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ST_S: u32 = 0;
pub const SLC_0INT_ENA_REG: u32 = 1073053708;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ENA_S: u32 = 26;
pub const SLC_CMD_DTC_INT_ENA_V: u32 = 1;
pub const SLC_CMD_DTC_INT_ENA_S: u32 = 25;
pub const SLC_SLC0_TX_ERR_EOF_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TX_ERR_EOF_INT_ENA_S: u32 = 24;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ENA_S: u32 = 23;
pub const SLC_SLC0_HOST_RD_ACK_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_HOST_RD_ACK_INT_ENA_S: u32 = 22;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ENA_S: u32 = 21;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ENA_S: u32 = 20;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ENA_S: u32 = 19;
pub const SLC_SLC0_TOHOST_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TOHOST_INT_ENA_S: u32 = 18;
pub const SLC_SLC0_RX_EOF_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_RX_EOF_INT_ENA_S: u32 = 17;
pub const SLC_SLC0_RX_DONE_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_RX_DONE_INT_ENA_S: u32 = 16;
pub const SLC_SLC0_TX_SUC_EOF_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TX_SUC_EOF_INT_ENA_S: u32 = 15;
pub const SLC_SLC0_TX_DONE_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TX_DONE_INT_ENA_S: u32 = 14;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ENA_S: u32 = 13;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ENA_S: u32 = 12;
pub const SLC_SLC0_TX_OVF_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TX_OVF_INT_ENA_S: u32 = 11;
pub const SLC_SLC0_RX_UDF_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_RX_UDF_INT_ENA_S: u32 = 10;
pub const SLC_SLC0_TX_START_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_TX_START_INT_ENA_S: u32 = 9;
pub const SLC_SLC0_RX_START_INT_ENA_V: u32 = 1;
pub const SLC_SLC0_RX_START_INT_ENA_S: u32 = 8;
pub const SLC_FRHOST_BIT7_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT7_INT_ENA_S: u32 = 7;
pub const SLC_FRHOST_BIT6_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT6_INT_ENA_S: u32 = 6;
pub const SLC_FRHOST_BIT5_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT5_INT_ENA_S: u32 = 5;
pub const SLC_FRHOST_BIT4_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT4_INT_ENA_S: u32 = 4;
pub const SLC_FRHOST_BIT3_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT3_INT_ENA_S: u32 = 3;
pub const SLC_FRHOST_BIT2_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT2_INT_ENA_S: u32 = 2;
pub const SLC_FRHOST_BIT1_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT1_INT_ENA_S: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ENA_S: u32 = 0;
pub const SLC_0INT_CLR_REG: u32 = 1073053712;
pub const SLC_SLC0_RX_QUICK_EOF_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_RX_QUICK_EOF_INT_CLR_S: u32 = 26;
pub const SLC_CMD_DTC_INT_CLR_V: u32 = 1;
pub const SLC_CMD_DTC_INT_CLR_S: u32 = 25;
pub const SLC_SLC0_TX_ERR_EOF_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TX_ERR_EOF_INT_CLR_S: u32 = 24;
pub const SLC_SLC0_WR_RETRY_DONE_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_WR_RETRY_DONE_INT_CLR_S: u32 = 23;
pub const SLC_SLC0_HOST_RD_ACK_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_HOST_RD_ACK_INT_CLR_S: u32 = 22;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_CLR_S: u32 = 21;
pub const SLC_SLC0_RX_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_RX_DSCR_ERR_INT_CLR_S: u32 = 20;
pub const SLC_SLC0_TX_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_ERR_INT_CLR_S: u32 = 19;
pub const SLC_SLC0_TOHOST_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TOHOST_INT_CLR_S: u32 = 18;
pub const SLC_SLC0_RX_EOF_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_RX_EOF_INT_CLR_S: u32 = 17;
pub const SLC_SLC0_RX_DONE_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_RX_DONE_INT_CLR_S: u32 = 16;
pub const SLC_SLC0_TX_SUC_EOF_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TX_SUC_EOF_INT_CLR_S: u32 = 15;
pub const SLC_SLC0_TX_DONE_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TX_DONE_INT_CLR_S: u32 = 14;
pub const SLC_SLC0_TOKEN1_1TO0_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_1TO0_INT_CLR_S: u32 = 13;
pub const SLC_SLC0_TOKEN0_1TO0_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_1TO0_INT_CLR_S: u32 = 12;
pub const SLC_SLC0_TX_OVF_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TX_OVF_INT_CLR_S: u32 = 11;
pub const SLC_SLC0_RX_UDF_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_RX_UDF_INT_CLR_S: u32 = 10;
pub const SLC_SLC0_TX_START_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_TX_START_INT_CLR_S: u32 = 9;
pub const SLC_SLC0_RX_START_INT_CLR_V: u32 = 1;
pub const SLC_SLC0_RX_START_INT_CLR_S: u32 = 8;
pub const SLC_FRHOST_BIT7_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT7_INT_CLR_S: u32 = 7;
pub const SLC_FRHOST_BIT6_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT6_INT_CLR_S: u32 = 6;
pub const SLC_FRHOST_BIT5_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT5_INT_CLR_S: u32 = 5;
pub const SLC_FRHOST_BIT4_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT4_INT_CLR_S: u32 = 4;
pub const SLC_FRHOST_BIT3_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT3_INT_CLR_S: u32 = 3;
pub const SLC_FRHOST_BIT2_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT2_INT_CLR_S: u32 = 2;
pub const SLC_FRHOST_BIT1_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT1_INT_CLR_S: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_CLR_S: u32 = 0;
pub const SLC_1INT_RAW_REG: u32 = 1073053716;
pub const SLC_SLC1_TX_ERR_EOF_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TX_ERR_EOF_INT_RAW_S: u32 = 24;
pub const SLC_SLC1_WR_RETRY_DONE_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_WR_RETRY_DONE_INT_RAW_S: u32 = 23;
pub const SLC_SLC1_HOST_RD_ACK_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_HOST_RD_ACK_INT_RAW_S: u32 = 22;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_RAW_S: u32 = 21;
pub const SLC_SLC1_RX_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_RX_DSCR_ERR_INT_RAW_S: u32 = 20;
pub const SLC_SLC1_TX_DSCR_ERR_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_ERR_INT_RAW_S: u32 = 19;
pub const SLC_SLC1_TOHOST_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TOHOST_INT_RAW_S: u32 = 18;
pub const SLC_SLC1_RX_EOF_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_RX_EOF_INT_RAW_S: u32 = 17;
pub const SLC_SLC1_RX_DONE_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_RX_DONE_INT_RAW_S: u32 = 16;
pub const SLC_SLC1_TX_SUC_EOF_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TX_SUC_EOF_INT_RAW_S: u32 = 15;
pub const SLC_SLC1_TX_DONE_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TX_DONE_INT_RAW_S: u32 = 14;
pub const SLC_SLC1_TOKEN1_1TO0_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_1TO0_INT_RAW_S: u32 = 13;
pub const SLC_SLC1_TOKEN0_1TO0_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_1TO0_INT_RAW_S: u32 = 12;
pub const SLC_SLC1_TX_OVF_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TX_OVF_INT_RAW_S: u32 = 11;
pub const SLC_SLC1_RX_UDF_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_RX_UDF_INT_RAW_S: u32 = 10;
pub const SLC_SLC1_TX_START_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_TX_START_INT_RAW_S: u32 = 9;
pub const SLC_SLC1_RX_START_INT_RAW_V: u32 = 1;
pub const SLC_SLC1_RX_START_INT_RAW_S: u32 = 8;
pub const SLC_FRHOST_BIT15_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT15_INT_RAW_S: u32 = 7;
pub const SLC_FRHOST_BIT14_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT14_INT_RAW_S: u32 = 6;
pub const SLC_FRHOST_BIT13_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT13_INT_RAW_S: u32 = 5;
pub const SLC_FRHOST_BIT12_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT12_INT_RAW_S: u32 = 4;
pub const SLC_FRHOST_BIT11_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT11_INT_RAW_S: u32 = 3;
pub const SLC_FRHOST_BIT10_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT10_INT_RAW_S: u32 = 2;
pub const SLC_FRHOST_BIT9_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT9_INT_RAW_S: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_RAW_V: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_RAW_S: u32 = 0;
pub const SLC_1INT_ST_REG: u32 = 1073053720;
pub const SLC_SLC1_TX_ERR_EOF_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TX_ERR_EOF_INT_ST_S: u32 = 24;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ST_V: u32 = 1;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ST_S: u32 = 23;
pub const SLC_SLC1_HOST_RD_ACK_INT_ST_V: u32 = 1;
pub const SLC_SLC1_HOST_RD_ACK_INT_ST_S: u32 = 22;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ST_S: u32 = 21;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ST_V: u32 = 1;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ST_S: u32 = 20;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ST_S: u32 = 19;
pub const SLC_SLC1_TOHOST_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TOHOST_INT_ST_S: u32 = 18;
pub const SLC_SLC1_RX_EOF_INT_ST_V: u32 = 1;
pub const SLC_SLC1_RX_EOF_INT_ST_S: u32 = 17;
pub const SLC_SLC1_RX_DONE_INT_ST_V: u32 = 1;
pub const SLC_SLC1_RX_DONE_INT_ST_S: u32 = 16;
pub const SLC_SLC1_TX_SUC_EOF_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TX_SUC_EOF_INT_ST_S: u32 = 15;
pub const SLC_SLC1_TX_DONE_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TX_DONE_INT_ST_S: u32 = 14;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ST_S: u32 = 13;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ST_S: u32 = 12;
pub const SLC_SLC1_TX_OVF_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TX_OVF_INT_ST_S: u32 = 11;
pub const SLC_SLC1_RX_UDF_INT_ST_V: u32 = 1;
pub const SLC_SLC1_RX_UDF_INT_ST_S: u32 = 10;
pub const SLC_SLC1_TX_START_INT_ST_V: u32 = 1;
pub const SLC_SLC1_TX_START_INT_ST_S: u32 = 9;
pub const SLC_SLC1_RX_START_INT_ST_V: u32 = 1;
pub const SLC_SLC1_RX_START_INT_ST_S: u32 = 8;
pub const SLC_FRHOST_BIT15_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT15_INT_ST_S: u32 = 7;
pub const SLC_FRHOST_BIT14_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT14_INT_ST_S: u32 = 6;
pub const SLC_FRHOST_BIT13_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT13_INT_ST_S: u32 = 5;
pub const SLC_FRHOST_BIT12_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT12_INT_ST_S: u32 = 4;
pub const SLC_FRHOST_BIT11_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT11_INT_ST_S: u32 = 3;
pub const SLC_FRHOST_BIT10_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT10_INT_ST_S: u32 = 2;
pub const SLC_FRHOST_BIT9_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT9_INT_ST_S: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ST_V: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ST_S: u32 = 0;
pub const SLC_1INT_ENA_REG: u32 = 1073053724;
pub const SLC_SLC1_TX_ERR_EOF_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TX_ERR_EOF_INT_ENA_S: u32 = 24;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ENA_S: u32 = 23;
pub const SLC_SLC1_HOST_RD_ACK_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_HOST_RD_ACK_INT_ENA_S: u32 = 22;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ENA_S: u32 = 21;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ENA_S: u32 = 20;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ENA_S: u32 = 19;
pub const SLC_SLC1_TOHOST_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TOHOST_INT_ENA_S: u32 = 18;
pub const SLC_SLC1_RX_EOF_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_RX_EOF_INT_ENA_S: u32 = 17;
pub const SLC_SLC1_RX_DONE_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_RX_DONE_INT_ENA_S: u32 = 16;
pub const SLC_SLC1_TX_SUC_EOF_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TX_SUC_EOF_INT_ENA_S: u32 = 15;
pub const SLC_SLC1_TX_DONE_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TX_DONE_INT_ENA_S: u32 = 14;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ENA_S: u32 = 13;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ENA_S: u32 = 12;
pub const SLC_SLC1_TX_OVF_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TX_OVF_INT_ENA_S: u32 = 11;
pub const SLC_SLC1_RX_UDF_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_RX_UDF_INT_ENA_S: u32 = 10;
pub const SLC_SLC1_TX_START_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_TX_START_INT_ENA_S: u32 = 9;
pub const SLC_SLC1_RX_START_INT_ENA_V: u32 = 1;
pub const SLC_SLC1_RX_START_INT_ENA_S: u32 = 8;
pub const SLC_FRHOST_BIT15_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT15_INT_ENA_S: u32 = 7;
pub const SLC_FRHOST_BIT14_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT14_INT_ENA_S: u32 = 6;
pub const SLC_FRHOST_BIT13_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT13_INT_ENA_S: u32 = 5;
pub const SLC_FRHOST_BIT12_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT12_INT_ENA_S: u32 = 4;
pub const SLC_FRHOST_BIT11_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT11_INT_ENA_S: u32 = 3;
pub const SLC_FRHOST_BIT10_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT10_INT_ENA_S: u32 = 2;
pub const SLC_FRHOST_BIT9_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT9_INT_ENA_S: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ENA_V: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ENA_S: u32 = 0;
pub const SLC_1INT_CLR_REG: u32 = 1073053728;
pub const SLC_SLC1_TX_ERR_EOF_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TX_ERR_EOF_INT_CLR_S: u32 = 24;
pub const SLC_SLC1_WR_RETRY_DONE_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_WR_RETRY_DONE_INT_CLR_S: u32 = 23;
pub const SLC_SLC1_HOST_RD_ACK_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_HOST_RD_ACK_INT_CLR_S: u32 = 22;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_CLR_S: u32 = 21;
pub const SLC_SLC1_RX_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_RX_DSCR_ERR_INT_CLR_S: u32 = 20;
pub const SLC_SLC1_TX_DSCR_ERR_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_ERR_INT_CLR_S: u32 = 19;
pub const SLC_SLC1_TOHOST_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TOHOST_INT_CLR_S: u32 = 18;
pub const SLC_SLC1_RX_EOF_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_RX_EOF_INT_CLR_S: u32 = 17;
pub const SLC_SLC1_RX_DONE_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_RX_DONE_INT_CLR_S: u32 = 16;
pub const SLC_SLC1_TX_SUC_EOF_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TX_SUC_EOF_INT_CLR_S: u32 = 15;
pub const SLC_SLC1_TX_DONE_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TX_DONE_INT_CLR_S: u32 = 14;
pub const SLC_SLC1_TOKEN1_1TO0_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_1TO0_INT_CLR_S: u32 = 13;
pub const SLC_SLC1_TOKEN0_1TO0_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_1TO0_INT_CLR_S: u32 = 12;
pub const SLC_SLC1_TX_OVF_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TX_OVF_INT_CLR_S: u32 = 11;
pub const SLC_SLC1_RX_UDF_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_RX_UDF_INT_CLR_S: u32 = 10;
pub const SLC_SLC1_TX_START_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_TX_START_INT_CLR_S: u32 = 9;
pub const SLC_SLC1_RX_START_INT_CLR_V: u32 = 1;
pub const SLC_SLC1_RX_START_INT_CLR_S: u32 = 8;
pub const SLC_FRHOST_BIT15_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT15_INT_CLR_S: u32 = 7;
pub const SLC_FRHOST_BIT14_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT14_INT_CLR_S: u32 = 6;
pub const SLC_FRHOST_BIT13_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT13_INT_CLR_S: u32 = 5;
pub const SLC_FRHOST_BIT12_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT12_INT_CLR_S: u32 = 4;
pub const SLC_FRHOST_BIT11_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT11_INT_CLR_S: u32 = 3;
pub const SLC_FRHOST_BIT10_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT10_INT_CLR_S: u32 = 2;
pub const SLC_FRHOST_BIT9_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT9_INT_CLR_S: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_CLR_V: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_CLR_S: u32 = 0;
pub const SLC_RX_STATUS_REG: u32 = 1073053732;
pub const SLC_SLC1_RX_EMPTY_V: u32 = 1;
pub const SLC_SLC1_RX_EMPTY_S: u32 = 17;
pub const SLC_SLC1_RX_FULL_V: u32 = 1;
pub const SLC_SLC1_RX_FULL_S: u32 = 16;
pub const SLC_SLC0_RX_EMPTY_V: u32 = 1;
pub const SLC_SLC0_RX_EMPTY_S: u32 = 1;
pub const SLC_SLC0_RX_FULL_V: u32 = 1;
pub const SLC_SLC0_RX_FULL_S: u32 = 0;
pub const SLC_0RXFIFO_PUSH_REG: u32 = 1073053736;
pub const SLC_SLC0_RXFIFO_PUSH_V: u32 = 1;
pub const SLC_SLC0_RXFIFO_PUSH_S: u32 = 16;
pub const SLC_SLC0_RXFIFO_WDATA: u32 = 511;
pub const SLC_SLC0_RXFIFO_WDATA_V: u32 = 511;
pub const SLC_SLC0_RXFIFO_WDATA_S: u32 = 0;
pub const SLC_1RXFIFO_PUSH_REG: u32 = 1073053740;
pub const SLC_SLC1_RXFIFO_PUSH_V: u32 = 1;
pub const SLC_SLC1_RXFIFO_PUSH_S: u32 = 16;
pub const SLC_SLC1_RXFIFO_WDATA: u32 = 511;
pub const SLC_SLC1_RXFIFO_WDATA_V: u32 = 511;
pub const SLC_SLC1_RXFIFO_WDATA_S: u32 = 0;
pub const SLC_TX_STATUS_REG: u32 = 1073053744;
pub const SLC_SLC1_TX_EMPTY_V: u32 = 1;
pub const SLC_SLC1_TX_EMPTY_S: u32 = 17;
pub const SLC_SLC1_TX_FULL_V: u32 = 1;
pub const SLC_SLC1_TX_FULL_S: u32 = 16;
pub const SLC_SLC0_TX_EMPTY_V: u32 = 1;
pub const SLC_SLC0_TX_EMPTY_S: u32 = 1;
pub const SLC_SLC0_TX_FULL_V: u32 = 1;
pub const SLC_SLC0_TX_FULL_S: u32 = 0;
pub const SLC_0TXFIFO_POP_REG: u32 = 1073053748;
pub const SLC_SLC0_TXFIFO_POP_V: u32 = 1;
pub const SLC_SLC0_TXFIFO_POP_S: u32 = 16;
pub const SLC_SLC0_TXFIFO_RDATA: u32 = 2047;
pub const SLC_SLC0_TXFIFO_RDATA_V: u32 = 2047;
pub const SLC_SLC0_TXFIFO_RDATA_S: u32 = 0;
pub const SLC_1TXFIFO_POP_REG: u32 = 1073053752;
pub const SLC_SLC1_TXFIFO_POP_V: u32 = 1;
pub const SLC_SLC1_TXFIFO_POP_S: u32 = 16;
pub const SLC_SLC1_TXFIFO_RDATA: u32 = 2047;
pub const SLC_SLC1_TXFIFO_RDATA_V: u32 = 2047;
pub const SLC_SLC1_TXFIFO_RDATA_S: u32 = 0;
pub const SLC_0RX_LINK_REG: u32 = 1073053756;
pub const SLC_SLC0_RXLINK_PARK_V: u32 = 1;
pub const SLC_SLC0_RXLINK_PARK_S: u32 = 31;
pub const SLC_SLC0_RXLINK_RESTART_V: u32 = 1;
pub const SLC_SLC0_RXLINK_RESTART_S: u32 = 30;
pub const SLC_SLC0_RXLINK_START_V: u32 = 1;
pub const SLC_SLC0_RXLINK_START_S: u32 = 29;
pub const SLC_SLC0_RXLINK_STOP_V: u32 = 1;
pub const SLC_SLC0_RXLINK_STOP_S: u32 = 28;
pub const SLC_SLC0_RXLINK_ADDR: u32 = 1048575;
pub const SLC_SLC0_RXLINK_ADDR_V: u32 = 1048575;
pub const SLC_SLC0_RXLINK_ADDR_S: u32 = 0;
pub const SLC_0TX_LINK_REG: u32 = 1073053760;
pub const SLC_SLC0_TXLINK_PARK_V: u32 = 1;
pub const SLC_SLC0_TXLINK_PARK_S: u32 = 31;
pub const SLC_SLC0_TXLINK_RESTART_V: u32 = 1;
pub const SLC_SLC0_TXLINK_RESTART_S: u32 = 30;
pub const SLC_SLC0_TXLINK_START_V: u32 = 1;
pub const SLC_SLC0_TXLINK_START_S: u32 = 29;
pub const SLC_SLC0_TXLINK_STOP_V: u32 = 1;
pub const SLC_SLC0_TXLINK_STOP_S: u32 = 28;
pub const SLC_SLC0_TXLINK_ADDR: u32 = 1048575;
pub const SLC_SLC0_TXLINK_ADDR_V: u32 = 1048575;
pub const SLC_SLC0_TXLINK_ADDR_S: u32 = 0;
pub const SLC_1RX_LINK_REG: u32 = 1073053764;
pub const SLC_SLC1_RXLINK_PARK_V: u32 = 1;
pub const SLC_SLC1_RXLINK_PARK_S: u32 = 31;
pub const SLC_SLC1_RXLINK_RESTART_V: u32 = 1;
pub const SLC_SLC1_RXLINK_RESTART_S: u32 = 30;
pub const SLC_SLC1_RXLINK_START_V: u32 = 1;
pub const SLC_SLC1_RXLINK_START_S: u32 = 29;
pub const SLC_SLC1_RXLINK_STOP_V: u32 = 1;
pub const SLC_SLC1_RXLINK_STOP_S: u32 = 28;
pub const SLC_SLC1_BT_PACKET_V: u32 = 1;
pub const SLC_SLC1_BT_PACKET_S: u32 = 20;
pub const SLC_SLC1_RXLINK_ADDR: u32 = 1048575;
pub const SLC_SLC1_RXLINK_ADDR_V: u32 = 1048575;
pub const SLC_SLC1_RXLINK_ADDR_S: u32 = 0;
pub const SLC_1TX_LINK_REG: u32 = 1073053768;
pub const SLC_SLC1_TXLINK_PARK_V: u32 = 1;
pub const SLC_SLC1_TXLINK_PARK_S: u32 = 31;
pub const SLC_SLC1_TXLINK_RESTART_V: u32 = 1;
pub const SLC_SLC1_TXLINK_RESTART_S: u32 = 30;
pub const SLC_SLC1_TXLINK_START_V: u32 = 1;
pub const SLC_SLC1_TXLINK_START_S: u32 = 29;
pub const SLC_SLC1_TXLINK_STOP_V: u32 = 1;
pub const SLC_SLC1_TXLINK_STOP_S: u32 = 28;
pub const SLC_SLC1_TXLINK_ADDR: u32 = 1048575;
pub const SLC_SLC1_TXLINK_ADDR_V: u32 = 1048575;
pub const SLC_SLC1_TXLINK_ADDR_S: u32 = 0;
pub const SLC_INTVEC_TOHOST_REG: u32 = 1073053772;
pub const SLC_SLC1_TOHOST_INTVEC: u32 = 255;
pub const SLC_SLC1_TOHOST_INTVEC_V: u32 = 255;
pub const SLC_SLC1_TOHOST_INTVEC_S: u32 = 16;
pub const SLC_SLC0_TOHOST_INTVEC: u32 = 255;
pub const SLC_SLC0_TOHOST_INTVEC_V: u32 = 255;
pub const SLC_SLC0_TOHOST_INTVEC_S: u32 = 0;
pub const SLC_0TOKEN0_REG: u32 = 1073053776;
pub const SLC_SLC0_TOKEN0: u32 = 4095;
pub const SLC_SLC0_TOKEN0_V: u32 = 4095;
pub const SLC_SLC0_TOKEN0_S: u32 = 16;
pub const SLC_SLC0_TOKEN0_INC_MORE_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_INC_MORE_S: u32 = 14;
pub const SLC_SLC0_TOKEN0_INC_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_INC_S: u32 = 13;
pub const SLC_SLC0_TOKEN0_WR_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_WR_S: u32 = 12;
pub const SLC_SLC0_TOKEN0_WDATA: u32 = 4095;
pub const SLC_SLC0_TOKEN0_WDATA_V: u32 = 4095;
pub const SLC_SLC0_TOKEN0_WDATA_S: u32 = 0;
pub const SLC_0TOKEN1_REG: u32 = 1073053780;
pub const SLC_SLC0_TOKEN1: u32 = 4095;
pub const SLC_SLC0_TOKEN1_V: u32 = 4095;
pub const SLC_SLC0_TOKEN1_S: u32 = 16;
pub const SLC_SLC0_TOKEN1_INC_MORE_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_INC_MORE_S: u32 = 14;
pub const SLC_SLC0_TOKEN1_INC_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_INC_S: u32 = 13;
pub const SLC_SLC0_TOKEN1_WR_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_WR_S: u32 = 12;
pub const SLC_SLC0_TOKEN1_WDATA: u32 = 4095;
pub const SLC_SLC0_TOKEN1_WDATA_V: u32 = 4095;
pub const SLC_SLC0_TOKEN1_WDATA_S: u32 = 0;
pub const SLC_1TOKEN0_REG: u32 = 1073053784;
pub const SLC_SLC1_TOKEN0: u32 = 4095;
pub const SLC_SLC1_TOKEN0_V: u32 = 4095;
pub const SLC_SLC1_TOKEN0_S: u32 = 16;
pub const SLC_SLC1_TOKEN0_INC_MORE_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_INC_MORE_S: u32 = 14;
pub const SLC_SLC1_TOKEN0_INC_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_INC_S: u32 = 13;
pub const SLC_SLC1_TOKEN0_WR_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_WR_S: u32 = 12;
pub const SLC_SLC1_TOKEN0_WDATA: u32 = 4095;
pub const SLC_SLC1_TOKEN0_WDATA_V: u32 = 4095;
pub const SLC_SLC1_TOKEN0_WDATA_S: u32 = 0;
pub const SLC_1TOKEN1_REG: u32 = 1073053788;
pub const SLC_SLC1_TOKEN1: u32 = 4095;
pub const SLC_SLC1_TOKEN1_V: u32 = 4095;
pub const SLC_SLC1_TOKEN1_S: u32 = 16;
pub const SLC_SLC1_TOKEN1_INC_MORE_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_INC_MORE_S: u32 = 14;
pub const SLC_SLC1_TOKEN1_INC_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_INC_S: u32 = 13;
pub const SLC_SLC1_TOKEN1_WR_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_WR_S: u32 = 12;
pub const SLC_SLC1_TOKEN1_WDATA: u32 = 4095;
pub const SLC_SLC1_TOKEN1_WDATA_V: u32 = 4095;
pub const SLC_SLC1_TOKEN1_WDATA_S: u32 = 0;
pub const SLC_CONF1_REG: u32 = 1073053792;
pub const SLC_CLK_EN_V: u32 = 1;
pub const SLC_CLK_EN_S: u32 = 22;
pub const SLC_SLC1_RX_STITCH_EN_V: u32 = 1;
pub const SLC_SLC1_RX_STITCH_EN_S: u32 = 21;
pub const SLC_SLC1_TX_STITCH_EN_V: u32 = 1;
pub const SLC_SLC1_TX_STITCH_EN_S: u32 = 20;
pub const SLC_HOST_INT_LEVEL_SEL_V: u32 = 1;
pub const SLC_HOST_INT_LEVEL_SEL_S: u32 = 19;
pub const SLC_SLC1_RX_CHECK_SUM_EN_V: u32 = 1;
pub const SLC_SLC1_RX_CHECK_SUM_EN_S: u32 = 18;
pub const SLC_SLC1_TX_CHECK_SUM_EN_V: u32 = 1;
pub const SLC_SLC1_TX_CHECK_SUM_EN_S: u32 = 17;
pub const SLC_SLC1_CHECK_OWNER_V: u32 = 1;
pub const SLC_SLC1_CHECK_OWNER_S: u32 = 16;
pub const SLC_SLC0_RX_STITCH_EN_V: u32 = 1;
pub const SLC_SLC0_RX_STITCH_EN_S: u32 = 6;
pub const SLC_SLC0_TX_STITCH_EN_V: u32 = 1;
pub const SLC_SLC0_TX_STITCH_EN_S: u32 = 5;
pub const SLC_SLC0_LEN_AUTO_CLR_V: u32 = 1;
pub const SLC_SLC0_LEN_AUTO_CLR_S: u32 = 4;
pub const SLC_CMD_HOLD_EN_V: u32 = 1;
pub const SLC_CMD_HOLD_EN_S: u32 = 3;
pub const SLC_SLC0_RX_CHECK_SUM_EN_V: u32 = 1;
pub const SLC_SLC0_RX_CHECK_SUM_EN_S: u32 = 2;
pub const SLC_SLC0_TX_CHECK_SUM_EN_V: u32 = 1;
pub const SLC_SLC0_TX_CHECK_SUM_EN_S: u32 = 1;
pub const SLC_SLC0_CHECK_OWNER_V: u32 = 1;
pub const SLC_SLC0_CHECK_OWNER_S: u32 = 0;
pub const SLC_0_STATE0_REG: u32 = 1073053796;
pub const SLC_SLC0_STATE0: u32 = 4294967295;
pub const SLC_SLC0_STATE0_V: u32 = 4294967295;
pub const SLC_SLC0_STATE0_S: u32 = 0;
pub const SLC_0_STATE1_REG: u32 = 1073053800;
pub const SLC_SLC0_STATE1: u32 = 4294967295;
pub const SLC_SLC0_STATE1_V: u32 = 4294967295;
pub const SLC_SLC0_STATE1_S: u32 = 0;
pub const SLC_1_STATE0_REG: u32 = 1073053804;
pub const SLC_SLC1_STATE0: u32 = 4294967295;
pub const SLC_SLC1_STATE0_V: u32 = 4294967295;
pub const SLC_SLC1_STATE0_S: u32 = 0;
pub const SLC_1_STATE1_REG: u32 = 1073053808;
pub const SLC_SLC1_STATE1: u32 = 4294967295;
pub const SLC_SLC1_STATE1_V: u32 = 4294967295;
pub const SLC_SLC1_STATE1_S: u32 = 0;
pub const SLC_BRIDGE_CONF_REG: u32 = 1073053812;
pub const SLC_TX_PUSH_IDLE_NUM: u32 = 65535;
pub const SLC_TX_PUSH_IDLE_NUM_V: u32 = 65535;
pub const SLC_TX_PUSH_IDLE_NUM_S: u32 = 16;
pub const SLC_SLC1_TX_DUMMY_MODE_V: u32 = 1;
pub const SLC_SLC1_TX_DUMMY_MODE_S: u32 = 14;
pub const SLC_HDA_MAP_128K_V: u32 = 1;
pub const SLC_HDA_MAP_128K_S: u32 = 13;
pub const SLC_SLC0_TX_DUMMY_MODE_V: u32 = 1;
pub const SLC_SLC0_TX_DUMMY_MODE_S: u32 = 12;
pub const SLC_FIFO_MAP_ENA: u32 = 15;
pub const SLC_FIFO_MAP_ENA_V: u32 = 15;
pub const SLC_FIFO_MAP_ENA_S: u32 = 8;
pub const SLC_TXEOF_ENA: u32 = 63;
pub const SLC_TXEOF_ENA_V: u32 = 63;
pub const SLC_TXEOF_ENA_S: u32 = 0;
pub const SLC_0_TO_EOF_DES_ADDR_REG: u32 = 1073053816;
pub const SLC_SLC0_TO_EOF_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TO_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TO_EOF_DES_ADDR_S: u32 = 0;
pub const SLC_0_TX_EOF_DES_ADDR_REG: u32 = 1073053820;
pub const SLC_SLC0_TX_SUC_EOF_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TX_SUC_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TX_SUC_EOF_DES_ADDR_S: u32 = 0;
pub const SLC_0_TO_EOF_BFR_DES_ADDR_REG: u32 = 1073053824;
pub const SLC_SLC0_TO_EOF_BFR_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TO_EOF_BFR_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TO_EOF_BFR_DES_ADDR_S: u32 = 0;
pub const SLC_1_TO_EOF_DES_ADDR_REG: u32 = 1073053828;
pub const SLC_SLC1_TO_EOF_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC1_TO_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC1_TO_EOF_DES_ADDR_S: u32 = 0;
pub const SLC_1_TX_EOF_DES_ADDR_REG: u32 = 1073053832;
pub const SLC_SLC1_TX_SUC_EOF_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC1_TX_SUC_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC1_TX_SUC_EOF_DES_ADDR_S: u32 = 0;
pub const SLC_1_TO_EOF_BFR_DES_ADDR_REG: u32 = 1073053836;
pub const SLC_SLC1_TO_EOF_BFR_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC1_TO_EOF_BFR_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC1_TO_EOF_BFR_DES_ADDR_S: u32 = 0;
pub const SLC_AHB_TEST_REG: u32 = 1073053840;
pub const SLC_AHB_TESTADDR: u32 = 3;
pub const SLC_AHB_TESTADDR_V: u32 = 3;
pub const SLC_AHB_TESTADDR_S: u32 = 4;
pub const SLC_AHB_TESTMODE: u32 = 7;
pub const SLC_AHB_TESTMODE_V: u32 = 7;
pub const SLC_AHB_TESTMODE_S: u32 = 0;
pub const SLC_SDIO_ST_REG: u32 = 1073053844;
pub const SLC_FUNC2_ACC_STATE: u32 = 31;
pub const SLC_FUNC2_ACC_STATE_V: u32 = 31;
pub const SLC_FUNC2_ACC_STATE_S: u32 = 24;
pub const SLC_FUNC1_ACC_STATE: u32 = 31;
pub const SLC_FUNC1_ACC_STATE_V: u32 = 31;
pub const SLC_FUNC1_ACC_STATE_S: u32 = 16;
pub const SLC_BUS_ST: u32 = 7;
pub const SLC_BUS_ST_V: u32 = 7;
pub const SLC_BUS_ST_S: u32 = 12;
pub const SLC_SDIO_WAKEUP_V: u32 = 1;
pub const SLC_SDIO_WAKEUP_S: u32 = 8;
pub const SLC_FUNC_ST: u32 = 15;
pub const SLC_FUNC_ST_V: u32 = 15;
pub const SLC_FUNC_ST_S: u32 = 4;
pub const SLC_CMD_ST: u32 = 7;
pub const SLC_CMD_ST_V: u32 = 7;
pub const SLC_CMD_ST_S: u32 = 0;
pub const SLC_RX_DSCR_CONF_REG: u32 = 1073053848;
pub const SLC_SLC1_RD_RETRY_THRESHOLD: u32 = 2047;
pub const SLC_SLC1_RD_RETRY_THRESHOLD_V: u32 = 2047;
pub const SLC_SLC1_RD_RETRY_THRESHOLD_S: u32 = 21;
pub const SLC_SLC1_RX_FILL_EN_V: u32 = 1;
pub const SLC_SLC1_RX_FILL_EN_S: u32 = 20;
pub const SLC_SLC1_RX_EOF_MODE_V: u32 = 1;
pub const SLC_SLC1_RX_EOF_MODE_S: u32 = 19;
pub const SLC_SLC1_RX_FILL_MODE_V: u32 = 1;
pub const SLC_SLC1_RX_FILL_MODE_S: u32 = 18;
pub const SLC_SLC1_INFOR_NO_REPLACE_V: u32 = 1;
pub const SLC_SLC1_INFOR_NO_REPLACE_S: u32 = 17;
pub const SLC_SLC1_TOKEN_NO_REPLACE_V: u32 = 1;
pub const SLC_SLC1_TOKEN_NO_REPLACE_S: u32 = 16;
pub const SLC_SLC0_RD_RETRY_THRESHOLD: u32 = 2047;
pub const SLC_SLC0_RD_RETRY_THRESHOLD_V: u32 = 2047;
pub const SLC_SLC0_RD_RETRY_THRESHOLD_S: u32 = 5;
pub const SLC_SLC0_RX_FILL_EN_V: u32 = 1;
pub const SLC_SLC0_RX_FILL_EN_S: u32 = 4;
pub const SLC_SLC0_RX_EOF_MODE_V: u32 = 1;
pub const SLC_SLC0_RX_EOF_MODE_S: u32 = 3;
pub const SLC_SLC0_RX_FILL_MODE_V: u32 = 1;
pub const SLC_SLC0_RX_FILL_MODE_S: u32 = 2;
pub const SLC_SLC0_INFOR_NO_REPLACE_V: u32 = 1;
pub const SLC_SLC0_INFOR_NO_REPLACE_S: u32 = 1;
pub const SLC_SLC0_TOKEN_NO_REPLACE_V: u32 = 1;
pub const SLC_SLC0_TOKEN_NO_REPLACE_S: u32 = 0;
pub const SLC_0_TXLINK_DSCR_REG: u32 = 1073053852;
pub const SLC_SLC0_TXLINK_DSCR: u32 = 4294967295;
pub const SLC_SLC0_TXLINK_DSCR_V: u32 = 4294967295;
pub const SLC_SLC0_TXLINK_DSCR_S: u32 = 0;
pub const SLC_0_TXLINK_DSCR_BF0_REG: u32 = 1073053856;
pub const SLC_SLC0_TXLINK_DSCR_BF0: u32 = 4294967295;
pub const SLC_SLC0_TXLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SLC_SLC0_TXLINK_DSCR_BF0_S: u32 = 0;
pub const SLC_0_TXLINK_DSCR_BF1_REG: u32 = 1073053860;
pub const SLC_SLC0_TXLINK_DSCR_BF1: u32 = 4294967295;
pub const SLC_SLC0_TXLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SLC_SLC0_TXLINK_DSCR_BF1_S: u32 = 0;
pub const SLC_0_RXLINK_DSCR_REG: u32 = 1073053864;
pub const SLC_SLC0_RXLINK_DSCR: u32 = 4294967295;
pub const SLC_SLC0_RXLINK_DSCR_V: u32 = 4294967295;
pub const SLC_SLC0_RXLINK_DSCR_S: u32 = 0;
pub const SLC_0_RXLINK_DSCR_BF0_REG: u32 = 1073053868;
pub const SLC_SLC0_RXLINK_DSCR_BF0: u32 = 4294967295;
pub const SLC_SLC0_RXLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SLC_SLC0_RXLINK_DSCR_BF0_S: u32 = 0;
pub const SLC_0_RXLINK_DSCR_BF1_REG: u32 = 1073053872;
pub const SLC_SLC0_RXLINK_DSCR_BF1: u32 = 4294967295;
pub const SLC_SLC0_RXLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SLC_SLC0_RXLINK_DSCR_BF1_S: u32 = 0;
pub const SLC_1_TXLINK_DSCR_REG: u32 = 1073053876;
pub const SLC_SLC1_TXLINK_DSCR: u32 = 4294967295;
pub const SLC_SLC1_TXLINK_DSCR_V: u32 = 4294967295;
pub const SLC_SLC1_TXLINK_DSCR_S: u32 = 0;
pub const SLC_1_TXLINK_DSCR_BF0_REG: u32 = 1073053880;
pub const SLC_SLC1_TXLINK_DSCR_BF0: u32 = 4294967295;
pub const SLC_SLC1_TXLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SLC_SLC1_TXLINK_DSCR_BF0_S: u32 = 0;
pub const SLC_1_TXLINK_DSCR_BF1_REG: u32 = 1073053884;
pub const SLC_SLC1_TXLINK_DSCR_BF1: u32 = 4294967295;
pub const SLC_SLC1_TXLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SLC_SLC1_TXLINK_DSCR_BF1_S: u32 = 0;
pub const SLC_1_RXLINK_DSCR_REG: u32 = 1073053888;
pub const SLC_SLC1_RXLINK_DSCR: u32 = 4294967295;
pub const SLC_SLC1_RXLINK_DSCR_V: u32 = 4294967295;
pub const SLC_SLC1_RXLINK_DSCR_S: u32 = 0;
pub const SLC_1_RXLINK_DSCR_BF0_REG: u32 = 1073053892;
pub const SLC_SLC1_RXLINK_DSCR_BF0: u32 = 4294967295;
pub const SLC_SLC1_RXLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SLC_SLC1_RXLINK_DSCR_BF0_S: u32 = 0;
pub const SLC_1_RXLINK_DSCR_BF1_REG: u32 = 1073053896;
pub const SLC_SLC1_RXLINK_DSCR_BF1: u32 = 4294967295;
pub const SLC_SLC1_RXLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SLC_SLC1_RXLINK_DSCR_BF1_S: u32 = 0;
pub const SLC_0_TX_ERREOF_DES_ADDR_REG: u32 = 1073053900;
pub const SLC_SLC0_TX_ERR_EOF_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TX_ERR_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TX_ERR_EOF_DES_ADDR_S: u32 = 0;
pub const SLC_1_TX_ERREOF_DES_ADDR_REG: u32 = 1073053904;
pub const SLC_SLC1_TX_ERR_EOF_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC1_TX_ERR_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC1_TX_ERR_EOF_DES_ADDR_S: u32 = 0;
pub const SLC_TOKEN_LAT_REG: u32 = 1073053908;
pub const SLC_SLC1_TOKEN: u32 = 4095;
pub const SLC_SLC1_TOKEN_V: u32 = 4095;
pub const SLC_SLC1_TOKEN_S: u32 = 16;
pub const SLC_SLC0_TOKEN: u32 = 4095;
pub const SLC_SLC0_TOKEN_V: u32 = 4095;
pub const SLC_SLC0_TOKEN_S: u32 = 0;
pub const SLC_TX_DSCR_CONF_REG: u32 = 1073053912;
pub const SLC_WR_RETRY_THRESHOLD: u32 = 2047;
pub const SLC_WR_RETRY_THRESHOLD_V: u32 = 2047;
pub const SLC_WR_RETRY_THRESHOLD_S: u32 = 0;
pub const SLC_CMD_INFOR0_REG: u32 = 1073053916;
pub const SLC_CMD_CONTENT0: u32 = 4294967295;
pub const SLC_CMD_CONTENT0_V: u32 = 4294967295;
pub const SLC_CMD_CONTENT0_S: u32 = 0;
pub const SLC_CMD_INFOR1_REG: u32 = 1073053920;
pub const SLC_CMD_CONTENT1: u32 = 4294967295;
pub const SLC_CMD_CONTENT1_V: u32 = 4294967295;
pub const SLC_CMD_CONTENT1_S: u32 = 0;
pub const SLC_0_LEN_CONF_REG: u32 = 1073053924;
pub const SLC_SLC0_TX_NEW_PKT_IND_V: u32 = 1;
pub const SLC_SLC0_TX_NEW_PKT_IND_S: u32 = 28;
pub const SLC_SLC0_RX_NEW_PKT_IND_V: u32 = 1;
pub const SLC_SLC0_RX_NEW_PKT_IND_S: u32 = 27;
pub const SLC_SLC0_TX_GET_USED_DSCR_V: u32 = 1;
pub const SLC_SLC0_TX_GET_USED_DSCR_S: u32 = 26;
pub const SLC_SLC0_RX_GET_USED_DSCR_V: u32 = 1;
pub const SLC_SLC0_RX_GET_USED_DSCR_S: u32 = 25;
pub const SLC_SLC0_TX_PACKET_LOAD_EN_V: u32 = 1;
pub const SLC_SLC0_TX_PACKET_LOAD_EN_S: u32 = 24;
pub const SLC_SLC0_RX_PACKET_LOAD_EN_V: u32 = 1;
pub const SLC_SLC0_RX_PACKET_LOAD_EN_S: u32 = 23;
pub const SLC_SLC0_LEN_INC_MORE_V: u32 = 1;
pub const SLC_SLC0_LEN_INC_MORE_S: u32 = 22;
pub const SLC_SLC0_LEN_INC_V: u32 = 1;
pub const SLC_SLC0_LEN_INC_S: u32 = 21;
pub const SLC_SLC0_LEN_WR_V: u32 = 1;
pub const SLC_SLC0_LEN_WR_S: u32 = 20;
pub const SLC_SLC0_LEN_WDATA: u32 = 1048575;
pub const SLC_SLC0_LEN_WDATA_V: u32 = 1048575;
pub const SLC_SLC0_LEN_WDATA_S: u32 = 0;
pub const SLC_0_LENGTH_REG: u32 = 1073053928;
pub const SLC_SLC0_LEN: u32 = 1048575;
pub const SLC_SLC0_LEN_V: u32 = 1048575;
pub const SLC_SLC0_LEN_S: u32 = 0;
pub const SLC_0_TXPKT_H_DSCR_REG: u32 = 1073053932;
pub const SLC_SLC0_TX_PKT_H_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_H_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_H_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_TXPKT_E_DSCR_REG: u32 = 1073053936;
pub const SLC_SLC0_TX_PKT_E_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_E_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_E_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_RXPKT_H_DSCR_REG: u32 = 1073053940;
pub const SLC_SLC0_RX_PKT_H_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_H_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_H_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_RXPKT_E_DSCR_REG: u32 = 1073053944;
pub const SLC_SLC0_RX_PKT_E_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_E_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_E_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_TXPKTU_H_DSCR_REG: u32 = 1073053948;
pub const SLC_SLC0_TX_PKT_START_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_START_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_START_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_TXPKTU_E_DSCR_REG: u32 = 1073053952;
pub const SLC_SLC0_TX_PKT_END_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_END_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_TX_PKT_END_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_RXPKTU_H_DSCR_REG: u32 = 1073053956;
pub const SLC_SLC0_RX_PKT_START_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_START_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_START_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_RXPKTU_E_DSCR_REG: u32 = 1073053960;
pub const SLC_SLC0_RX_PKT_END_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_END_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_RX_PKT_END_DSCR_ADDR_S: u32 = 0;
pub const SLC_SEQ_POSITION_REG: u32 = 1073053972;
pub const SLC_SLC1_SEQ_POSITION: u32 = 255;
pub const SLC_SLC1_SEQ_POSITION_V: u32 = 255;
pub const SLC_SLC1_SEQ_POSITION_S: u32 = 8;
pub const SLC_SLC0_SEQ_POSITION: u32 = 255;
pub const SLC_SLC0_SEQ_POSITION_V: u32 = 255;
pub const SLC_SLC0_SEQ_POSITION_S: u32 = 0;
pub const SLC_0_DSCR_REC_CONF_REG: u32 = 1073053976;
pub const SLC_SLC0_RX_DSCR_REC_LIM: u32 = 1023;
pub const SLC_SLC0_RX_DSCR_REC_LIM_V: u32 = 1023;
pub const SLC_SLC0_RX_DSCR_REC_LIM_S: u32 = 0;
pub const SLC_SDIO_CRC_ST0_REG: u32 = 1073053980;
pub const SLC_DAT3_CRC_ERR_CNT: u32 = 255;
pub const SLC_DAT3_CRC_ERR_CNT_V: u32 = 255;
pub const SLC_DAT3_CRC_ERR_CNT_S: u32 = 24;
pub const SLC_DAT2_CRC_ERR_CNT: u32 = 255;
pub const SLC_DAT2_CRC_ERR_CNT_V: u32 = 255;
pub const SLC_DAT2_CRC_ERR_CNT_S: u32 = 16;
pub const SLC_DAT1_CRC_ERR_CNT: u32 = 255;
pub const SLC_DAT1_CRC_ERR_CNT_V: u32 = 255;
pub const SLC_DAT1_CRC_ERR_CNT_S: u32 = 8;
pub const SLC_DAT0_CRC_ERR_CNT: u32 = 255;
pub const SLC_DAT0_CRC_ERR_CNT_V: u32 = 255;
pub const SLC_DAT0_CRC_ERR_CNT_S: u32 = 0;
pub const SLC_SDIO_CRC_ST1_REG: u32 = 1073053984;
pub const SLC_ERR_CNT_CLR_V: u32 = 1;
pub const SLC_ERR_CNT_CLR_S: u32 = 31;
pub const SLC_CMD_CRC_ERR_CNT: u32 = 255;
pub const SLC_CMD_CRC_ERR_CNT_V: u32 = 255;
pub const SLC_CMD_CRC_ERR_CNT_S: u32 = 0;
pub const SLC_0_EOF_START_DES_REG: u32 = 1073053988;
pub const SLC_SLC0_EOF_START_DES_ADDR: u32 = 4294967295;
pub const SLC_SLC0_EOF_START_DES_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_EOF_START_DES_ADDR_S: u32 = 0;
pub const SLC_0_PUSH_DSCR_ADDR_REG: u32 = 1073053992;
pub const SLC_SLC0_RX_PUSH_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_RX_PUSH_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_RX_PUSH_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_DONE_DSCR_ADDR_REG: u32 = 1073053996;
pub const SLC_SLC0_RX_DONE_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_RX_DONE_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_RX_DONE_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_SUB_START_DES_REG: u32 = 1073054000;
pub const SLC_SLC0_SUB_PAC_START_DSCR_ADDR: u32 = 4294967295;
pub const SLC_SLC0_SUB_PAC_START_DSCR_ADDR_V: u32 = 4294967295;
pub const SLC_SLC0_SUB_PAC_START_DSCR_ADDR_S: u32 = 0;
pub const SLC_0_DSCR_CNT_REG: u32 = 1073054004;
pub const SLC_SLC0_RX_GET_EOF_OCC_V: u32 = 1;
pub const SLC_SLC0_RX_GET_EOF_OCC_S: u32 = 16;
pub const SLC_SLC0_RX_DSCR_CNT_LAT: u32 = 1023;
pub const SLC_SLC0_RX_DSCR_CNT_LAT_V: u32 = 1023;
pub const SLC_SLC0_RX_DSCR_CNT_LAT_S: u32 = 0;
pub const SLC_0_LEN_LIM_CONF_REG: u32 = 1073054008;
pub const SLC_SLC0_LEN_LIM: u32 = 1048575;
pub const SLC_SLC0_LEN_LIM_V: u32 = 1048575;
pub const SLC_SLC0_LEN_LIM_S: u32 = 0;
pub const SLC_0INT_ST1_REG: u32 = 1073054012;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ST1_S: u32 = 26;
pub const SLC_CMD_DTC_INT_ST1_V: u32 = 1;
pub const SLC_CMD_DTC_INT_ST1_S: u32 = 25;
pub const SLC_SLC0_TX_ERR_EOF_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TX_ERR_EOF_INT_ST1_S: u32 = 24;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ST1_S: u32 = 23;
pub const SLC_SLC0_HOST_RD_ACK_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_HOST_RD_ACK_INT_ST1_S: u32 = 22;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ST1_S: u32 = 21;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ST1_S: u32 = 20;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ST1_S: u32 = 19;
pub const SLC_SLC0_TOHOST_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TOHOST_INT_ST1_S: u32 = 18;
pub const SLC_SLC0_RX_EOF_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_RX_EOF_INT_ST1_S: u32 = 17;
pub const SLC_SLC0_RX_DONE_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_RX_DONE_INT_ST1_S: u32 = 16;
pub const SLC_SLC0_TX_SUC_EOF_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TX_SUC_EOF_INT_ST1_S: u32 = 15;
pub const SLC_SLC0_TX_DONE_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TX_DONE_INT_ST1_S: u32 = 14;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ST1_S: u32 = 13;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ST1_S: u32 = 12;
pub const SLC_SLC0_TX_OVF_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TX_OVF_INT_ST1_S: u32 = 11;
pub const SLC_SLC0_RX_UDF_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_RX_UDF_INT_ST1_S: u32 = 10;
pub const SLC_SLC0_TX_START_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_TX_START_INT_ST1_S: u32 = 9;
pub const SLC_SLC0_RX_START_INT_ST1_V: u32 = 1;
pub const SLC_SLC0_RX_START_INT_ST1_S: u32 = 8;
pub const SLC_FRHOST_BIT7_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT7_INT_ST1_S: u32 = 7;
pub const SLC_FRHOST_BIT6_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT6_INT_ST1_S: u32 = 6;
pub const SLC_FRHOST_BIT5_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT5_INT_ST1_S: u32 = 5;
pub const SLC_FRHOST_BIT4_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT4_INT_ST1_S: u32 = 4;
pub const SLC_FRHOST_BIT3_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT3_INT_ST1_S: u32 = 3;
pub const SLC_FRHOST_BIT2_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT2_INT_ST1_S: u32 = 2;
pub const SLC_FRHOST_BIT1_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT1_INT_ST1_S: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ST1_S: u32 = 0;
pub const SLC_0INT_ENA1_REG: u32 = 1073054016;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_RX_QUICK_EOF_INT_ENA1_S: u32 = 26;
pub const SLC_CMD_DTC_INT_ENA1_V: u32 = 1;
pub const SLC_CMD_DTC_INT_ENA1_S: u32 = 25;
pub const SLC_SLC0_TX_ERR_EOF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TX_ERR_EOF_INT_ENA1_S: u32 = 24;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_WR_RETRY_DONE_INT_ENA1_S: u32 = 23;
pub const SLC_SLC0_HOST_RD_ACK_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_HOST_RD_ACK_INT_ENA1_S: u32 = 22;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_EMPTY_INT_ENA1_S: u32 = 21;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_RX_DSCR_ERR_INT_ENA1_S: u32 = 20;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TX_DSCR_ERR_INT_ENA1_S: u32 = 19;
pub const SLC_SLC0_TOHOST_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TOHOST_INT_ENA1_S: u32 = 18;
pub const SLC_SLC0_RX_EOF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_RX_EOF_INT_ENA1_S: u32 = 17;
pub const SLC_SLC0_RX_DONE_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_RX_DONE_INT_ENA1_S: u32 = 16;
pub const SLC_SLC0_TX_SUC_EOF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TX_SUC_EOF_INT_ENA1_S: u32 = 15;
pub const SLC_SLC0_TX_DONE_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TX_DONE_INT_ENA1_S: u32 = 14;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TOKEN1_1TO0_INT_ENA1_S: u32 = 13;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TOKEN0_1TO0_INT_ENA1_S: u32 = 12;
pub const SLC_SLC0_TX_OVF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TX_OVF_INT_ENA1_S: u32 = 11;
pub const SLC_SLC0_RX_UDF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_RX_UDF_INT_ENA1_S: u32 = 10;
pub const SLC_SLC0_TX_START_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_TX_START_INT_ENA1_S: u32 = 9;
pub const SLC_SLC0_RX_START_INT_ENA1_V: u32 = 1;
pub const SLC_SLC0_RX_START_INT_ENA1_S: u32 = 8;
pub const SLC_FRHOST_BIT7_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT7_INT_ENA1_S: u32 = 7;
pub const SLC_FRHOST_BIT6_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT6_INT_ENA1_S: u32 = 6;
pub const SLC_FRHOST_BIT5_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT5_INT_ENA1_S: u32 = 5;
pub const SLC_FRHOST_BIT4_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT4_INT_ENA1_S: u32 = 4;
pub const SLC_FRHOST_BIT3_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT3_INT_ENA1_S: u32 = 3;
pub const SLC_FRHOST_BIT2_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT2_INT_ENA1_S: u32 = 2;
pub const SLC_FRHOST_BIT1_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT1_INT_ENA1_S: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT0_INT_ENA1_S: u32 = 0;
pub const SLC_1INT_ST1_REG: u32 = 1073054020;
pub const SLC_SLC1_TX_ERR_EOF_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TX_ERR_EOF_INT_ST1_S: u32 = 24;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ST1_S: u32 = 23;
pub const SLC_SLC1_HOST_RD_ACK_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_HOST_RD_ACK_INT_ST1_S: u32 = 22;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ST1_S: u32 = 21;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ST1_S: u32 = 20;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ST1_S: u32 = 19;
pub const SLC_SLC1_TOHOST_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TOHOST_INT_ST1_S: u32 = 18;
pub const SLC_SLC1_RX_EOF_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_RX_EOF_INT_ST1_S: u32 = 17;
pub const SLC_SLC1_RX_DONE_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_RX_DONE_INT_ST1_S: u32 = 16;
pub const SLC_SLC1_TX_SUC_EOF_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TX_SUC_EOF_INT_ST1_S: u32 = 15;
pub const SLC_SLC1_TX_DONE_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TX_DONE_INT_ST1_S: u32 = 14;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ST1_S: u32 = 13;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ST1_S: u32 = 12;
pub const SLC_SLC1_TX_OVF_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TX_OVF_INT_ST1_S: u32 = 11;
pub const SLC_SLC1_RX_UDF_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_RX_UDF_INT_ST1_S: u32 = 10;
pub const SLC_SLC1_TX_START_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_TX_START_INT_ST1_S: u32 = 9;
pub const SLC_SLC1_RX_START_INT_ST1_V: u32 = 1;
pub const SLC_SLC1_RX_START_INT_ST1_S: u32 = 8;
pub const SLC_FRHOST_BIT15_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT15_INT_ST1_S: u32 = 7;
pub const SLC_FRHOST_BIT14_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT14_INT_ST1_S: u32 = 6;
pub const SLC_FRHOST_BIT13_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT13_INT_ST1_S: u32 = 5;
pub const SLC_FRHOST_BIT12_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT12_INT_ST1_S: u32 = 4;
pub const SLC_FRHOST_BIT11_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT11_INT_ST1_S: u32 = 3;
pub const SLC_FRHOST_BIT10_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT10_INT_ST1_S: u32 = 2;
pub const SLC_FRHOST_BIT9_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT9_INT_ST1_S: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ST1_V: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ST1_S: u32 = 0;
pub const SLC_1INT_ENA1_REG: u32 = 1073054024;
pub const SLC_SLC1_TX_ERR_EOF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TX_ERR_EOF_INT_ENA1_S: u32 = 24;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_WR_RETRY_DONE_INT_ENA1_S: u32 = 23;
pub const SLC_SLC1_HOST_RD_ACK_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_HOST_RD_ACK_INT_ENA1_S: u32 = 22;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_EMPTY_INT_ENA1_S: u32 = 21;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_RX_DSCR_ERR_INT_ENA1_S: u32 = 20;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TX_DSCR_ERR_INT_ENA1_S: u32 = 19;
pub const SLC_SLC1_TOHOST_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TOHOST_INT_ENA1_S: u32 = 18;
pub const SLC_SLC1_RX_EOF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_RX_EOF_INT_ENA1_S: u32 = 17;
pub const SLC_SLC1_RX_DONE_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_RX_DONE_INT_ENA1_S: u32 = 16;
pub const SLC_SLC1_TX_SUC_EOF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TX_SUC_EOF_INT_ENA1_S: u32 = 15;
pub const SLC_SLC1_TX_DONE_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TX_DONE_INT_ENA1_S: u32 = 14;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TOKEN1_1TO0_INT_ENA1_S: u32 = 13;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TOKEN0_1TO0_INT_ENA1_S: u32 = 12;
pub const SLC_SLC1_TX_OVF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TX_OVF_INT_ENA1_S: u32 = 11;
pub const SLC_SLC1_RX_UDF_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_RX_UDF_INT_ENA1_S: u32 = 10;
pub const SLC_SLC1_TX_START_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_TX_START_INT_ENA1_S: u32 = 9;
pub const SLC_SLC1_RX_START_INT_ENA1_V: u32 = 1;
pub const SLC_SLC1_RX_START_INT_ENA1_S: u32 = 8;
pub const SLC_FRHOST_BIT15_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT15_INT_ENA1_S: u32 = 7;
pub const SLC_FRHOST_BIT14_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT14_INT_ENA1_S: u32 = 6;
pub const SLC_FRHOST_BIT13_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT13_INT_ENA1_S: u32 = 5;
pub const SLC_FRHOST_BIT12_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT12_INT_ENA1_S: u32 = 4;
pub const SLC_FRHOST_BIT11_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT11_INT_ENA1_S: u32 = 3;
pub const SLC_FRHOST_BIT10_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT10_INT_ENA1_S: u32 = 2;
pub const SLC_FRHOST_BIT9_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT9_INT_ENA1_S: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ENA1_V: u32 = 1;
pub const SLC_FRHOST_BIT8_INT_ENA1_S: u32 = 0;
pub const SLC_DATE_REG: u32 = 1073054200;
pub const SLC_DATE: u32 = 4294967295;
pub const SLC_DATE_V: u32 = 4294967295;
pub const SLC_DATE_S: u32 = 0;
pub const SLC_ID_REG: u32 = 1073054204;
pub const SLC_ID: u32 = 4294967295;
pub const SLC_ID_V: u32 = 4294967295;
pub const SLC_ID_S: u32 = 0;
pub const HOST_SLCHOST_FUNC2_0_REG: u32 = 1073041424;
pub const HOST_SLC_FUNC2_INT_V: u32 = 1;
pub const HOST_SLC_FUNC2_INT_S: u32 = 24;
pub const HOST_SLCHOST_FUNC2_1_REG: u32 = 1073041428;
pub const HOST_SLC_FUNC2_INT_EN_V: u32 = 1;
pub const HOST_SLC_FUNC2_INT_EN_S: u32 = 0;
pub const HOST_SLCHOST_FUNC2_2_REG: u32 = 1073041440;
pub const HOST_SLC_FUNC1_MDSTAT_V: u32 = 1;
pub const HOST_SLC_FUNC1_MDSTAT_S: u32 = 0;
pub const HOST_SLCHOST_GPIO_STATUS0_REG: u32 = 1073041460;
pub const HOST_GPIO_SDIO_INT0: u32 = 4294967295;
pub const HOST_GPIO_SDIO_INT0_V: u32 = 4294967295;
pub const HOST_GPIO_SDIO_INT0_S: u32 = 0;
pub const HOST_SLCHOST_GPIO_STATUS1_REG: u32 = 1073041464;
pub const HOST_GPIO_SDIO_INT1: u32 = 255;
pub const HOST_GPIO_SDIO_INT1_V: u32 = 255;
pub const HOST_GPIO_SDIO_INT1_S: u32 = 0;
pub const HOST_SLCHOST_GPIO_IN0_REG: u32 = 1073041468;
pub const HOST_GPIO_SDIO_IN0: u32 = 4294967295;
pub const HOST_GPIO_SDIO_IN0_V: u32 = 4294967295;
pub const HOST_GPIO_SDIO_IN0_S: u32 = 0;
pub const HOST_SLCHOST_GPIO_IN1_REG: u32 = 1073041472;
pub const HOST_GPIO_SDIO_IN1: u32 = 255;
pub const HOST_GPIO_SDIO_IN1_V: u32 = 255;
pub const HOST_GPIO_SDIO_IN1_S: u32 = 0;
pub const HOST_SLC0HOST_TOKEN_RDATA_REG: u32 = 1073041476;
pub const HOST_SLC0_RX_PF_EOF: u32 = 15;
pub const HOST_SLC0_RX_PF_EOF_V: u32 = 15;
pub const HOST_SLC0_RX_PF_EOF_S: u32 = 28;
pub const HOST_HOSTSLC0_TOKEN1: u32 = 4095;
pub const HOST_HOSTSLC0_TOKEN1_V: u32 = 4095;
pub const HOST_HOSTSLC0_TOKEN1_S: u32 = 16;
pub const HOST_SLC0_RX_PF_VALID_V: u32 = 1;
pub const HOST_SLC0_RX_PF_VALID_S: u32 = 12;
pub const HOST_SLC0_TOKEN0: u32 = 4095;
pub const HOST_SLC0_TOKEN0_V: u32 = 4095;
pub const HOST_SLC0_TOKEN0_S: u32 = 0;
pub const HOST_SLC0_HOST_PF_REG: u32 = 1073041480;
pub const HOST_SLC0_PF_DATA: u32 = 4294967295;
pub const HOST_SLC0_PF_DATA_V: u32 = 4294967295;
pub const HOST_SLC0_PF_DATA_S: u32 = 0;
pub const HOST_SLC1_HOST_PF_REG: u32 = 1073041484;
pub const HOST_SLC1_PF_DATA: u32 = 4294967295;
pub const HOST_SLC1_PF_DATA_V: u32 = 4294967295;
pub const HOST_SLC1_PF_DATA_S: u32 = 0;
pub const HOST_SLC0HOST_INT_RAW_REG: u32 = 1073041488;
pub const HOST_GPIO_SDIO_INT_RAW_V: u32 = 1;
pub const HOST_GPIO_SDIO_INT_RAW_S: u32 = 25;
pub const HOST_SLC0_HOST_RD_RETRY_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_HOST_RD_RETRY_INT_RAW_S: u32 = 24;
pub const HOST_SLC0_RX_NEW_PACKET_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_RX_NEW_PACKET_INT_RAW_S: u32 = 23;
pub const HOST_SLC0_EXT_BIT3_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT3_INT_RAW_S: u32 = 22;
pub const HOST_SLC0_EXT_BIT2_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT2_INT_RAW_S: u32 = 21;
pub const HOST_SLC0_EXT_BIT1_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT1_INT_RAW_S: u32 = 20;
pub const HOST_SLC0_EXT_BIT0_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT0_INT_RAW_S: u32 = 19;
pub const HOST_SLC0_RX_PF_VALID_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_RX_PF_VALID_INT_RAW_S: u32 = 18;
pub const HOST_SLC0_TX_OVF_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TX_OVF_INT_RAW_S: u32 = 17;
pub const HOST_SLC0_RX_UDF_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_RX_UDF_INT_RAW_S: u32 = 16;
pub const HOST_SLC0HOST_TX_START_INT_RAW_V: u32 = 1;
pub const HOST_SLC0HOST_TX_START_INT_RAW_S: u32 = 15;
pub const HOST_SLC0HOST_RX_START_INT_RAW_V: u32 = 1;
pub const HOST_SLC0HOST_RX_START_INT_RAW_S: u32 = 14;
pub const HOST_SLC0HOST_RX_EOF_INT_RAW_V: u32 = 1;
pub const HOST_SLC0HOST_RX_EOF_INT_RAW_S: u32 = 13;
pub const HOST_SLC0HOST_RX_SOF_INT_RAW_V: u32 = 1;
pub const HOST_SLC0HOST_RX_SOF_INT_RAW_S: u32 = 12;
pub const HOST_SLC0_TOKEN1_0TO1_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_0TO1_INT_RAW_S: u32 = 11;
pub const HOST_SLC0_TOKEN0_0TO1_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_0TO1_INT_RAW_S: u32 = 10;
pub const HOST_SLC0_TOKEN1_1TO0_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_1TO0_INT_RAW_S: u32 = 9;
pub const HOST_SLC0_TOKEN0_1TO0_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_1TO0_INT_RAW_S: u32 = 8;
pub const HOST_SLC0_TOHOST_BIT7_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT7_INT_RAW_S: u32 = 7;
pub const HOST_SLC0_TOHOST_BIT6_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT6_INT_RAW_S: u32 = 6;
pub const HOST_SLC0_TOHOST_BIT5_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT5_INT_RAW_S: u32 = 5;
pub const HOST_SLC0_TOHOST_BIT4_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT4_INT_RAW_S: u32 = 4;
pub const HOST_SLC0_TOHOST_BIT3_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT3_INT_RAW_S: u32 = 3;
pub const HOST_SLC0_TOHOST_BIT2_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT2_INT_RAW_S: u32 = 2;
pub const HOST_SLC0_TOHOST_BIT1_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT1_INT_RAW_S: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_RAW_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_RAW_S: u32 = 0;
pub const HOST_SLC1HOST_INT_RAW_REG: u32 = 1073041492;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_RAW_S: u32 = 25;
pub const HOST_SLC1_HOST_RD_RETRY_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_HOST_RD_RETRY_INT_RAW_S: u32 = 24;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_RAW_S: u32 = 23;
pub const HOST_SLC1_EXT_BIT3_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT3_INT_RAW_S: u32 = 22;
pub const HOST_SLC1_EXT_BIT2_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT2_INT_RAW_S: u32 = 21;
pub const HOST_SLC1_EXT_BIT1_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT1_INT_RAW_S: u32 = 20;
pub const HOST_SLC1_EXT_BIT0_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT0_INT_RAW_S: u32 = 19;
pub const HOST_SLC1_RX_PF_VALID_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_RX_PF_VALID_INT_RAW_S: u32 = 18;
pub const HOST_SLC1_TX_OVF_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TX_OVF_INT_RAW_S: u32 = 17;
pub const HOST_SLC1_RX_UDF_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_RX_UDF_INT_RAW_S: u32 = 16;
pub const HOST_SLC1HOST_TX_START_INT_RAW_V: u32 = 1;
pub const HOST_SLC1HOST_TX_START_INT_RAW_S: u32 = 15;
pub const HOST_SLC1HOST_RX_START_INT_RAW_V: u32 = 1;
pub const HOST_SLC1HOST_RX_START_INT_RAW_S: u32 = 14;
pub const HOST_SLC1HOST_RX_EOF_INT_RAW_V: u32 = 1;
pub const HOST_SLC1HOST_RX_EOF_INT_RAW_S: u32 = 13;
pub const HOST_SLC1HOST_RX_SOF_INT_RAW_V: u32 = 1;
pub const HOST_SLC1HOST_RX_SOF_INT_RAW_S: u32 = 12;
pub const HOST_SLC1_TOKEN1_0TO1_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_0TO1_INT_RAW_S: u32 = 11;
pub const HOST_SLC1_TOKEN0_0TO1_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_0TO1_INT_RAW_S: u32 = 10;
pub const HOST_SLC1_TOKEN1_1TO0_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_1TO0_INT_RAW_S: u32 = 9;
pub const HOST_SLC1_TOKEN0_1TO0_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_1TO0_INT_RAW_S: u32 = 8;
pub const HOST_SLC1_TOHOST_BIT7_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT7_INT_RAW_S: u32 = 7;
pub const HOST_SLC1_TOHOST_BIT6_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT6_INT_RAW_S: u32 = 6;
pub const HOST_SLC1_TOHOST_BIT5_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT5_INT_RAW_S: u32 = 5;
pub const HOST_SLC1_TOHOST_BIT4_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT4_INT_RAW_S: u32 = 4;
pub const HOST_SLC1_TOHOST_BIT3_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT3_INT_RAW_S: u32 = 3;
pub const HOST_SLC1_TOHOST_BIT2_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT2_INT_RAW_S: u32 = 2;
pub const HOST_SLC1_TOHOST_BIT1_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT1_INT_RAW_S: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_RAW_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_RAW_S: u32 = 0;
pub const HOST_SLC0HOST_INT_ST_REG: u32 = 1073041496;
pub const HOST_GPIO_SDIO_INT_ST_V: u32 = 1;
pub const HOST_GPIO_SDIO_INT_ST_S: u32 = 25;
pub const HOST_SLC0_HOST_RD_RETRY_INT_ST_V: u32 = 1;
pub const HOST_SLC0_HOST_RD_RETRY_INT_ST_S: u32 = 24;
pub const HOST_SLC0_RX_NEW_PACKET_INT_ST_V: u32 = 1;
pub const HOST_SLC0_RX_NEW_PACKET_INT_ST_S: u32 = 23;
pub const HOST_SLC0_EXT_BIT3_INT_ST_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT3_INT_ST_S: u32 = 22;
pub const HOST_SLC0_EXT_BIT2_INT_ST_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT2_INT_ST_S: u32 = 21;
pub const HOST_SLC0_EXT_BIT1_INT_ST_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT1_INT_ST_S: u32 = 20;
pub const HOST_SLC0_EXT_BIT0_INT_ST_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT0_INT_ST_S: u32 = 19;
pub const HOST_SLC0_RX_PF_VALID_INT_ST_V: u32 = 1;
pub const HOST_SLC0_RX_PF_VALID_INT_ST_S: u32 = 18;
pub const HOST_SLC0_TX_OVF_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TX_OVF_INT_ST_S: u32 = 17;
pub const HOST_SLC0_RX_UDF_INT_ST_V: u32 = 1;
pub const HOST_SLC0_RX_UDF_INT_ST_S: u32 = 16;
pub const HOST_SLC0HOST_TX_START_INT_ST_V: u32 = 1;
pub const HOST_SLC0HOST_TX_START_INT_ST_S: u32 = 15;
pub const HOST_SLC0HOST_RX_START_INT_ST_V: u32 = 1;
pub const HOST_SLC0HOST_RX_START_INT_ST_S: u32 = 14;
pub const HOST_SLC0HOST_RX_EOF_INT_ST_V: u32 = 1;
pub const HOST_SLC0HOST_RX_EOF_INT_ST_S: u32 = 13;
pub const HOST_SLC0HOST_RX_SOF_INT_ST_V: u32 = 1;
pub const HOST_SLC0HOST_RX_SOF_INT_ST_S: u32 = 12;
pub const HOST_SLC0_TOKEN1_0TO1_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_0TO1_INT_ST_S: u32 = 11;
pub const HOST_SLC0_TOKEN0_0TO1_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_0TO1_INT_ST_S: u32 = 10;
pub const HOST_SLC0_TOKEN1_1TO0_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_1TO0_INT_ST_S: u32 = 9;
pub const HOST_SLC0_TOKEN0_1TO0_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_1TO0_INT_ST_S: u32 = 8;
pub const HOST_SLC0_TOHOST_BIT7_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT7_INT_ST_S: u32 = 7;
pub const HOST_SLC0_TOHOST_BIT6_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT6_INT_ST_S: u32 = 6;
pub const HOST_SLC0_TOHOST_BIT5_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT5_INT_ST_S: u32 = 5;
pub const HOST_SLC0_TOHOST_BIT4_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT4_INT_ST_S: u32 = 4;
pub const HOST_SLC0_TOHOST_BIT3_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT3_INT_ST_S: u32 = 3;
pub const HOST_SLC0_TOHOST_BIT2_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT2_INT_ST_S: u32 = 2;
pub const HOST_SLC0_TOHOST_BIT1_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT1_INT_ST_S: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_ST_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_ST_S: u32 = 0;
pub const HOST_SLC1HOST_INT_ST_REG: u32 = 1073041500;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_ST_V: u32 = 1;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_ST_S: u32 = 25;
pub const HOST_SLC1_HOST_RD_RETRY_INT_ST_V: u32 = 1;
pub const HOST_SLC1_HOST_RD_RETRY_INT_ST_S: u32 = 24;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ST_V: u32 = 1;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ST_S: u32 = 23;
pub const HOST_SLC1_EXT_BIT3_INT_ST_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT3_INT_ST_S: u32 = 22;
pub const HOST_SLC1_EXT_BIT2_INT_ST_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT2_INT_ST_S: u32 = 21;
pub const HOST_SLC1_EXT_BIT1_INT_ST_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT1_INT_ST_S: u32 = 20;
pub const HOST_SLC1_EXT_BIT0_INT_ST_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT0_INT_ST_S: u32 = 19;
pub const HOST_SLC1_RX_PF_VALID_INT_ST_V: u32 = 1;
pub const HOST_SLC1_RX_PF_VALID_INT_ST_S: u32 = 18;
pub const HOST_SLC1_TX_OVF_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TX_OVF_INT_ST_S: u32 = 17;
pub const HOST_SLC1_RX_UDF_INT_ST_V: u32 = 1;
pub const HOST_SLC1_RX_UDF_INT_ST_S: u32 = 16;
pub const HOST_SLC1HOST_TX_START_INT_ST_V: u32 = 1;
pub const HOST_SLC1HOST_TX_START_INT_ST_S: u32 = 15;
pub const HOST_SLC1HOST_RX_START_INT_ST_V: u32 = 1;
pub const HOST_SLC1HOST_RX_START_INT_ST_S: u32 = 14;
pub const HOST_SLC1HOST_RX_EOF_INT_ST_V: u32 = 1;
pub const HOST_SLC1HOST_RX_EOF_INT_ST_S: u32 = 13;
pub const HOST_SLC1HOST_RX_SOF_INT_ST_V: u32 = 1;
pub const HOST_SLC1HOST_RX_SOF_INT_ST_S: u32 = 12;
pub const HOST_SLC1_TOKEN1_0TO1_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_0TO1_INT_ST_S: u32 = 11;
pub const HOST_SLC1_TOKEN0_0TO1_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_0TO1_INT_ST_S: u32 = 10;
pub const HOST_SLC1_TOKEN1_1TO0_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_1TO0_INT_ST_S: u32 = 9;
pub const HOST_SLC1_TOKEN0_1TO0_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_1TO0_INT_ST_S: u32 = 8;
pub const HOST_SLC1_TOHOST_BIT7_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT7_INT_ST_S: u32 = 7;
pub const HOST_SLC1_TOHOST_BIT6_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT6_INT_ST_S: u32 = 6;
pub const HOST_SLC1_TOHOST_BIT5_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT5_INT_ST_S: u32 = 5;
pub const HOST_SLC1_TOHOST_BIT4_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT4_INT_ST_S: u32 = 4;
pub const HOST_SLC1_TOHOST_BIT3_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT3_INT_ST_S: u32 = 3;
pub const HOST_SLC1_TOHOST_BIT2_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT2_INT_ST_S: u32 = 2;
pub const HOST_SLC1_TOHOST_BIT1_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT1_INT_ST_S: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_ST_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_ST_S: u32 = 0;
pub const HOST_SLCHOST_PKT_LEN_REG: u32 = 1073041504;
pub const HOST_HOSTSLC0_LEN_CHECK: u32 = 4095;
pub const HOST_HOSTSLC0_LEN_CHECK_V: u32 = 4095;
pub const HOST_HOSTSLC0_LEN_CHECK_S: u32 = 20;
pub const HOST_HOSTSLC0_LEN: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN_V: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN_S: u32 = 0;
pub const HOST_SLCHOST_STATE_W0_REG: u32 = 1073041508;
pub const HOST_SLCHOST_STATE3: u32 = 255;
pub const HOST_SLCHOST_STATE3_V: u32 = 255;
pub const HOST_SLCHOST_STATE3_S: u32 = 24;
pub const HOST_SLCHOST_STATE2: u32 = 255;
pub const HOST_SLCHOST_STATE2_V: u32 = 255;
pub const HOST_SLCHOST_STATE2_S: u32 = 16;
pub const HOST_SLCHOST_STATE1: u32 = 255;
pub const HOST_SLCHOST_STATE1_V: u32 = 255;
pub const HOST_SLCHOST_STATE1_S: u32 = 8;
pub const HOST_SLCHOST_STATE0: u32 = 255;
pub const HOST_SLCHOST_STATE0_V: u32 = 255;
pub const HOST_SLCHOST_STATE0_S: u32 = 0;
pub const HOST_SLCHOST_STATE_W1_REG: u32 = 1073041512;
pub const HOST_SLCHOST_STATE7: u32 = 255;
pub const HOST_SLCHOST_STATE7_V: u32 = 255;
pub const HOST_SLCHOST_STATE7_S: u32 = 24;
pub const HOST_SLCHOST_STATE6: u32 = 255;
pub const HOST_SLCHOST_STATE6_V: u32 = 255;
pub const HOST_SLCHOST_STATE6_S: u32 = 16;
pub const HOST_SLCHOST_STATE5: u32 = 255;
pub const HOST_SLCHOST_STATE5_V: u32 = 255;
pub const HOST_SLCHOST_STATE5_S: u32 = 8;
pub const HOST_SLCHOST_STATE4: u32 = 255;
pub const HOST_SLCHOST_STATE4_V: u32 = 255;
pub const HOST_SLCHOST_STATE4_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W0_REG: u32 = 1073041516;
pub const HOST_SLCHOST_CONF3: u32 = 255;
pub const HOST_SLCHOST_CONF3_V: u32 = 255;
pub const HOST_SLCHOST_CONF3_S: u32 = 24;
pub const HOST_SLCHOST_CONF2: u32 = 255;
pub const HOST_SLCHOST_CONF2_V: u32 = 255;
pub const HOST_SLCHOST_CONF2_S: u32 = 16;
pub const HOST_SLCHOST_CONF1: u32 = 255;
pub const HOST_SLCHOST_CONF1_V: u32 = 255;
pub const HOST_SLCHOST_CONF1_S: u32 = 8;
pub const HOST_SLCHOST_CONF0: u32 = 255;
pub const HOST_SLCHOST_CONF0_V: u32 = 255;
pub const HOST_SLCHOST_CONF0_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W1_REG: u32 = 1073041520;
pub const HOST_SLCHOST_CONF7: u32 = 255;
pub const HOST_SLCHOST_CONF7_V: u32 = 255;
pub const HOST_SLCHOST_CONF7_S: u32 = 24;
pub const HOST_SLCHOST_CONF6: u32 = 255;
pub const HOST_SLCHOST_CONF6_V: u32 = 255;
pub const HOST_SLCHOST_CONF6_S: u32 = 16;
pub const HOST_SLCHOST_CONF5: u32 = 255;
pub const HOST_SLCHOST_CONF5_V: u32 = 255;
pub const HOST_SLCHOST_CONF5_S: u32 = 8;
pub const HOST_SLCHOST_CONF4: u32 = 255;
pub const HOST_SLCHOST_CONF4_V: u32 = 255;
pub const HOST_SLCHOST_CONF4_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W2_REG: u32 = 1073041524;
pub const HOST_SLCHOST_CONF11: u32 = 255;
pub const HOST_SLCHOST_CONF11_V: u32 = 255;
pub const HOST_SLCHOST_CONF11_S: u32 = 24;
pub const HOST_SLCHOST_CONF10: u32 = 255;
pub const HOST_SLCHOST_CONF10_V: u32 = 255;
pub const HOST_SLCHOST_CONF10_S: u32 = 16;
pub const HOST_SLCHOST_CONF9: u32 = 255;
pub const HOST_SLCHOST_CONF9_V: u32 = 255;
pub const HOST_SLCHOST_CONF9_S: u32 = 8;
pub const HOST_SLCHOST_CONF8: u32 = 255;
pub const HOST_SLCHOST_CONF8_V: u32 = 255;
pub const HOST_SLCHOST_CONF8_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W3_REG: u32 = 1073041528;
pub const HOST_SLCHOST_CONF15: u32 = 255;
pub const HOST_SLCHOST_CONF15_V: u32 = 255;
pub const HOST_SLCHOST_CONF15_S: u32 = 24;
pub const HOST_SLCHOST_CONF14: u32 = 255;
pub const HOST_SLCHOST_CONF14_V: u32 = 255;
pub const HOST_SLCHOST_CONF14_S: u32 = 16;
pub const HOST_SLCHOST_CONF13: u32 = 255;
pub const HOST_SLCHOST_CONF13_V: u32 = 255;
pub const HOST_SLCHOST_CONF13_S: u32 = 8;
pub const HOST_SLCHOST_CONF12: u32 = 255;
pub const HOST_SLCHOST_CONF12_V: u32 = 255;
pub const HOST_SLCHOST_CONF12_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W4_REG: u32 = 1073041532;
pub const HOST_SLCHOST_CONF19: u32 = 255;
pub const HOST_SLCHOST_CONF19_V: u32 = 255;
pub const HOST_SLCHOST_CONF19_S: u32 = 24;
pub const HOST_SLCHOST_CONF18: u32 = 255;
pub const HOST_SLCHOST_CONF18_V: u32 = 255;
pub const HOST_SLCHOST_CONF18_S: u32 = 16;
pub const HOST_SLCHOST_CONF17: u32 = 255;
pub const HOST_SLCHOST_CONF17_V: u32 = 255;
pub const HOST_SLCHOST_CONF17_S: u32 = 8;
pub const HOST_SLCHOST_CONF16: u32 = 255;
pub const HOST_SLCHOST_CONF16_V: u32 = 255;
pub const HOST_SLCHOST_CONF16_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W5_REG: u32 = 1073041536;
pub const HOST_SLCHOST_CONF23: u32 = 255;
pub const HOST_SLCHOST_CONF23_V: u32 = 255;
pub const HOST_SLCHOST_CONF23_S: u32 = 24;
pub const HOST_SLCHOST_CONF22: u32 = 255;
pub const HOST_SLCHOST_CONF22_V: u32 = 255;
pub const HOST_SLCHOST_CONF22_S: u32 = 16;
pub const HOST_SLCHOST_CONF21: u32 = 255;
pub const HOST_SLCHOST_CONF21_V: u32 = 255;
pub const HOST_SLCHOST_CONF21_S: u32 = 8;
pub const HOST_SLCHOST_CONF20: u32 = 255;
pub const HOST_SLCHOST_CONF20_V: u32 = 255;
pub const HOST_SLCHOST_CONF20_S: u32 = 0;
pub const HOST_SLCHOST_WIN_CMD_REG: u32 = 1073041540;
pub const HOST_SLCHOST_CONF_W6_REG: u32 = 1073041544;
pub const HOST_SLCHOST_CONF27: u32 = 255;
pub const HOST_SLCHOST_CONF27_V: u32 = 255;
pub const HOST_SLCHOST_CONF27_S: u32 = 24;
pub const HOST_SLCHOST_CONF26: u32 = 255;
pub const HOST_SLCHOST_CONF26_V: u32 = 255;
pub const HOST_SLCHOST_CONF26_S: u32 = 16;
pub const HOST_SLCHOST_CONF25: u32 = 255;
pub const HOST_SLCHOST_CONF25_V: u32 = 255;
pub const HOST_SLCHOST_CONF25_S: u32 = 8;
pub const HOST_SLCHOST_CONF24: u32 = 255;
pub const HOST_SLCHOST_CONF24_V: u32 = 255;
pub const HOST_SLCHOST_CONF24_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W7_REG: u32 = 1073041548;
pub const HOST_SLCHOST_CONF31: u32 = 255;
pub const HOST_SLCHOST_CONF31_V: u32 = 255;
pub const HOST_SLCHOST_CONF31_S: u32 = 24;
pub const HOST_SLCHOST_CONF30: u32 = 255;
pub const HOST_SLCHOST_CONF30_V: u32 = 255;
pub const HOST_SLCHOST_CONF30_S: u32 = 16;
pub const HOST_SLCHOST_CONF29: u32 = 255;
pub const HOST_SLCHOST_CONF29_V: u32 = 255;
pub const HOST_SLCHOST_CONF29_S: u32 = 8;
pub const HOST_SLCHOST_CONF28: u32 = 255;
pub const HOST_SLCHOST_CONF28_V: u32 = 255;
pub const HOST_SLCHOST_CONF28_S: u32 = 0;
pub const HOST_SLCHOST_PKT_LEN0_REG: u32 = 1073041552;
pub const HOST_HOSTSLC0_LEN0: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN0_V: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN0_S: u32 = 0;
pub const HOST_SLCHOST_PKT_LEN1_REG: u32 = 1073041556;
pub const HOST_HOSTSLC0_LEN1: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN1_V: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN1_S: u32 = 0;
pub const HOST_SLCHOST_PKT_LEN2_REG: u32 = 1073041560;
pub const HOST_HOSTSLC0_LEN2: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN2_V: u32 = 1048575;
pub const HOST_HOSTSLC0_LEN2_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W8_REG: u32 = 1073041564;
pub const HOST_SLCHOST_CONF35: u32 = 255;
pub const HOST_SLCHOST_CONF35_V: u32 = 255;
pub const HOST_SLCHOST_CONF35_S: u32 = 24;
pub const HOST_SLCHOST_CONF34: u32 = 255;
pub const HOST_SLCHOST_CONF34_V: u32 = 255;
pub const HOST_SLCHOST_CONF34_S: u32 = 16;
pub const HOST_SLCHOST_CONF33: u32 = 255;
pub const HOST_SLCHOST_CONF33_V: u32 = 255;
pub const HOST_SLCHOST_CONF33_S: u32 = 8;
pub const HOST_SLCHOST_CONF32: u32 = 255;
pub const HOST_SLCHOST_CONF32_V: u32 = 255;
pub const HOST_SLCHOST_CONF32_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W9_REG: u32 = 1073041568;
pub const HOST_SLCHOST_CONF39: u32 = 255;
pub const HOST_SLCHOST_CONF39_V: u32 = 255;
pub const HOST_SLCHOST_CONF39_S: u32 = 24;
pub const HOST_SLCHOST_CONF38: u32 = 255;
pub const HOST_SLCHOST_CONF38_V: u32 = 255;
pub const HOST_SLCHOST_CONF38_S: u32 = 16;
pub const HOST_SLCHOST_CONF37: u32 = 255;
pub const HOST_SLCHOST_CONF37_V: u32 = 255;
pub const HOST_SLCHOST_CONF37_S: u32 = 8;
pub const HOST_SLCHOST_CONF36: u32 = 255;
pub const HOST_SLCHOST_CONF36_V: u32 = 255;
pub const HOST_SLCHOST_CONF36_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W10_REG: u32 = 1073041572;
pub const HOST_SLCHOST_CONF43: u32 = 255;
pub const HOST_SLCHOST_CONF43_V: u32 = 255;
pub const HOST_SLCHOST_CONF43_S: u32 = 24;
pub const HOST_SLCHOST_CONF42: u32 = 255;
pub const HOST_SLCHOST_CONF42_V: u32 = 255;
pub const HOST_SLCHOST_CONF42_S: u32 = 16;
pub const HOST_SLCHOST_CONF41: u32 = 255;
pub const HOST_SLCHOST_CONF41_V: u32 = 255;
pub const HOST_SLCHOST_CONF41_S: u32 = 8;
pub const HOST_SLCHOST_CONF40: u32 = 255;
pub const HOST_SLCHOST_CONF40_V: u32 = 255;
pub const HOST_SLCHOST_CONF40_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W11_REG: u32 = 1073041576;
pub const HOST_SLCHOST_CONF47: u32 = 255;
pub const HOST_SLCHOST_CONF47_V: u32 = 255;
pub const HOST_SLCHOST_CONF47_S: u32 = 24;
pub const HOST_SLCHOST_CONF46: u32 = 255;
pub const HOST_SLCHOST_CONF46_V: u32 = 255;
pub const HOST_SLCHOST_CONF46_S: u32 = 16;
pub const HOST_SLCHOST_CONF45: u32 = 255;
pub const HOST_SLCHOST_CONF45_V: u32 = 255;
pub const HOST_SLCHOST_CONF45_S: u32 = 8;
pub const HOST_SLCHOST_CONF44: u32 = 255;
pub const HOST_SLCHOST_CONF44_V: u32 = 255;
pub const HOST_SLCHOST_CONF44_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W12_REG: u32 = 1073041580;
pub const HOST_SLCHOST_CONF51: u32 = 255;
pub const HOST_SLCHOST_CONF51_V: u32 = 255;
pub const HOST_SLCHOST_CONF51_S: u32 = 24;
pub const HOST_SLCHOST_CONF50: u32 = 255;
pub const HOST_SLCHOST_CONF50_V: u32 = 255;
pub const HOST_SLCHOST_CONF50_S: u32 = 16;
pub const HOST_SLCHOST_CONF49: u32 = 255;
pub const HOST_SLCHOST_CONF49_V: u32 = 255;
pub const HOST_SLCHOST_CONF49_S: u32 = 8;
pub const HOST_SLCHOST_CONF48: u32 = 255;
pub const HOST_SLCHOST_CONF48_V: u32 = 255;
pub const HOST_SLCHOST_CONF48_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W13_REG: u32 = 1073041584;
pub const HOST_SLCHOST_CONF55: u32 = 255;
pub const HOST_SLCHOST_CONF55_V: u32 = 255;
pub const HOST_SLCHOST_CONF55_S: u32 = 24;
pub const HOST_SLCHOST_CONF54: u32 = 255;
pub const HOST_SLCHOST_CONF54_V: u32 = 255;
pub const HOST_SLCHOST_CONF54_S: u32 = 16;
pub const HOST_SLCHOST_CONF53: u32 = 255;
pub const HOST_SLCHOST_CONF53_V: u32 = 255;
pub const HOST_SLCHOST_CONF53_S: u32 = 8;
pub const HOST_SLCHOST_CONF52: u32 = 255;
pub const HOST_SLCHOST_CONF52_V: u32 = 255;
pub const HOST_SLCHOST_CONF52_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W14_REG: u32 = 1073041588;
pub const HOST_SLCHOST_CONF59: u32 = 255;
pub const HOST_SLCHOST_CONF59_V: u32 = 255;
pub const HOST_SLCHOST_CONF59_S: u32 = 24;
pub const HOST_SLCHOST_CONF58: u32 = 255;
pub const HOST_SLCHOST_CONF58_V: u32 = 255;
pub const HOST_SLCHOST_CONF58_S: u32 = 16;
pub const HOST_SLCHOST_CONF57: u32 = 255;
pub const HOST_SLCHOST_CONF57_V: u32 = 255;
pub const HOST_SLCHOST_CONF57_S: u32 = 8;
pub const HOST_SLCHOST_CONF56: u32 = 255;
pub const HOST_SLCHOST_CONF56_V: u32 = 255;
pub const HOST_SLCHOST_CONF56_S: u32 = 0;
pub const HOST_SLCHOST_CONF_W15_REG: u32 = 1073041592;
pub const HOST_SLCHOST_CONF63: u32 = 255;
pub const HOST_SLCHOST_CONF63_V: u32 = 255;
pub const HOST_SLCHOST_CONF63_S: u32 = 24;
pub const HOST_SLCHOST_CONF62: u32 = 255;
pub const HOST_SLCHOST_CONF62_V: u32 = 255;
pub const HOST_SLCHOST_CONF62_S: u32 = 16;
pub const HOST_SLCHOST_CONF61: u32 = 255;
pub const HOST_SLCHOST_CONF61_V: u32 = 255;
pub const HOST_SLCHOST_CONF61_S: u32 = 8;
pub const HOST_SLCHOST_CONF60: u32 = 255;
pub const HOST_SLCHOST_CONF60_V: u32 = 255;
pub const HOST_SLCHOST_CONF60_S: u32 = 0;
pub const HOST_SLCHOST_CHECK_SUM0_REG: u32 = 1073041596;
pub const HOST_SLCHOST_CHECK_SUM0: u32 = 4294967295;
pub const HOST_SLCHOST_CHECK_SUM0_V: u32 = 4294967295;
pub const HOST_SLCHOST_CHECK_SUM0_S: u32 = 0;
pub const HOST_SLCHOST_CHECK_SUM1_REG: u32 = 1073041600;
pub const HOST_SLCHOST_CHECK_SUM1: u32 = 4294967295;
pub const HOST_SLCHOST_CHECK_SUM1_V: u32 = 4294967295;
pub const HOST_SLCHOST_CHECK_SUM1_S: u32 = 0;
pub const HOST_SLC1HOST_TOKEN_RDATA_REG: u32 = 1073041604;
pub const HOST_SLC1_RX_PF_EOF: u32 = 15;
pub const HOST_SLC1_RX_PF_EOF_V: u32 = 15;
pub const HOST_SLC1_RX_PF_EOF_S: u32 = 28;
pub const HOST_HOSTSLC1_TOKEN1: u32 = 4095;
pub const HOST_HOSTSLC1_TOKEN1_V: u32 = 4095;
pub const HOST_HOSTSLC1_TOKEN1_S: u32 = 16;
pub const HOST_SLC1_RX_PF_VALID_V: u32 = 1;
pub const HOST_SLC1_RX_PF_VALID_S: u32 = 12;
pub const HOST_SLC1_TOKEN0: u32 = 4095;
pub const HOST_SLC1_TOKEN0_V: u32 = 4095;
pub const HOST_SLC1_TOKEN0_S: u32 = 0;
pub const HOST_SLC0HOST_TOKEN_WDATA_REG: u32 = 1073041608;
pub const HOST_SLC0HOST_TOKEN1_WD: u32 = 4095;
pub const HOST_SLC0HOST_TOKEN1_WD_V: u32 = 4095;
pub const HOST_SLC0HOST_TOKEN1_WD_S: u32 = 16;
pub const HOST_SLC0HOST_TOKEN0_WD: u32 = 4095;
pub const HOST_SLC0HOST_TOKEN0_WD_V: u32 = 4095;
pub const HOST_SLC0HOST_TOKEN0_WD_S: u32 = 0;
pub const HOST_SLC1HOST_TOKEN_WDATA_REG: u32 = 1073041612;
pub const HOST_SLC1HOST_TOKEN1_WD: u32 = 4095;
pub const HOST_SLC1HOST_TOKEN1_WD_V: u32 = 4095;
pub const HOST_SLC1HOST_TOKEN1_WD_S: u32 = 16;
pub const HOST_SLC1HOST_TOKEN0_WD: u32 = 4095;
pub const HOST_SLC1HOST_TOKEN0_WD_V: u32 = 4095;
pub const HOST_SLC1HOST_TOKEN0_WD_S: u32 = 0;
pub const HOST_SLCHOST_TOKEN_CON_REG: u32 = 1073041616;
pub const HOST_SLC0HOST_LEN_WR_V: u32 = 1;
pub const HOST_SLC0HOST_LEN_WR_S: u32 = 8;
pub const HOST_SLC1HOST_TOKEN1_WR_V: u32 = 1;
pub const HOST_SLC1HOST_TOKEN1_WR_S: u32 = 7;
pub const HOST_SLC1HOST_TOKEN0_WR_V: u32 = 1;
pub const HOST_SLC1HOST_TOKEN0_WR_S: u32 = 6;
pub const HOST_SLC1HOST_TOKEN1_DEC_V: u32 = 1;
pub const HOST_SLC1HOST_TOKEN1_DEC_S: u32 = 5;
pub const HOST_SLC1HOST_TOKEN0_DEC_V: u32 = 1;
pub const HOST_SLC1HOST_TOKEN0_DEC_S: u32 = 4;
pub const HOST_SLC0HOST_TOKEN1_WR_V: u32 = 1;
pub const HOST_SLC0HOST_TOKEN1_WR_S: u32 = 3;
pub const HOST_SLC0HOST_TOKEN0_WR_V: u32 = 1;
pub const HOST_SLC0HOST_TOKEN0_WR_S: u32 = 2;
pub const HOST_SLC0HOST_TOKEN1_DEC_V: u32 = 1;
pub const HOST_SLC0HOST_TOKEN1_DEC_S: u32 = 1;
pub const HOST_SLC0HOST_TOKEN0_DEC_V: u32 = 1;
pub const HOST_SLC0HOST_TOKEN0_DEC_S: u32 = 0;
pub const HOST_SLC0HOST_INT_CLR_REG: u32 = 1073041620;
pub const HOST_GPIO_SDIO_INT_CLR_V: u32 = 1;
pub const HOST_GPIO_SDIO_INT_CLR_S: u32 = 25;
pub const HOST_SLC0_HOST_RD_RETRY_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_HOST_RD_RETRY_INT_CLR_S: u32 = 24;
pub const HOST_SLC0_RX_NEW_PACKET_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_RX_NEW_PACKET_INT_CLR_S: u32 = 23;
pub const HOST_SLC0_EXT_BIT3_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT3_INT_CLR_S: u32 = 22;
pub const HOST_SLC0_EXT_BIT2_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT2_INT_CLR_S: u32 = 21;
pub const HOST_SLC0_EXT_BIT1_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT1_INT_CLR_S: u32 = 20;
pub const HOST_SLC0_EXT_BIT0_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT0_INT_CLR_S: u32 = 19;
pub const HOST_SLC0_RX_PF_VALID_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_RX_PF_VALID_INT_CLR_S: u32 = 18;
pub const HOST_SLC0_TX_OVF_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TX_OVF_INT_CLR_S: u32 = 17;
pub const HOST_SLC0_RX_UDF_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_RX_UDF_INT_CLR_S: u32 = 16;
pub const HOST_SLC0HOST_TX_START_INT_CLR_V: u32 = 1;
pub const HOST_SLC0HOST_TX_START_INT_CLR_S: u32 = 15;
pub const HOST_SLC0HOST_RX_START_INT_CLR_V: u32 = 1;
pub const HOST_SLC0HOST_RX_START_INT_CLR_S: u32 = 14;
pub const HOST_SLC0HOST_RX_EOF_INT_CLR_V: u32 = 1;
pub const HOST_SLC0HOST_RX_EOF_INT_CLR_S: u32 = 13;
pub const HOST_SLC0HOST_RX_SOF_INT_CLR_V: u32 = 1;
pub const HOST_SLC0HOST_RX_SOF_INT_CLR_S: u32 = 12;
pub const HOST_SLC0_TOKEN1_0TO1_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_0TO1_INT_CLR_S: u32 = 11;
pub const HOST_SLC0_TOKEN0_0TO1_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_0TO1_INT_CLR_S: u32 = 10;
pub const HOST_SLC0_TOKEN1_1TO0_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_1TO0_INT_CLR_S: u32 = 9;
pub const HOST_SLC0_TOKEN0_1TO0_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_1TO0_INT_CLR_S: u32 = 8;
pub const HOST_SLC0_TOHOST_BIT7_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT7_INT_CLR_S: u32 = 7;
pub const HOST_SLC0_TOHOST_BIT6_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT6_INT_CLR_S: u32 = 6;
pub const HOST_SLC0_TOHOST_BIT5_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT5_INT_CLR_S: u32 = 5;
pub const HOST_SLC0_TOHOST_BIT4_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT4_INT_CLR_S: u32 = 4;
pub const HOST_SLC0_TOHOST_BIT3_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT3_INT_CLR_S: u32 = 3;
pub const HOST_SLC0_TOHOST_BIT2_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT2_INT_CLR_S: u32 = 2;
pub const HOST_SLC0_TOHOST_BIT1_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT1_INT_CLR_S: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_CLR_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_CLR_S: u32 = 0;
pub const HOST_SLC1HOST_INT_CLR_REG: u32 = 1073041624;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_CLR_S: u32 = 25;
pub const HOST_SLC1_HOST_RD_RETRY_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_HOST_RD_RETRY_INT_CLR_S: u32 = 24;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_CLR_S: u32 = 23;
pub const HOST_SLC1_EXT_BIT3_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT3_INT_CLR_S: u32 = 22;
pub const HOST_SLC1_EXT_BIT2_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT2_INT_CLR_S: u32 = 21;
pub const HOST_SLC1_EXT_BIT1_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT1_INT_CLR_S: u32 = 20;
pub const HOST_SLC1_EXT_BIT0_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT0_INT_CLR_S: u32 = 19;
pub const HOST_SLC1_RX_PF_VALID_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_RX_PF_VALID_INT_CLR_S: u32 = 18;
pub const HOST_SLC1_TX_OVF_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TX_OVF_INT_CLR_S: u32 = 17;
pub const HOST_SLC1_RX_UDF_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_RX_UDF_INT_CLR_S: u32 = 16;
pub const HOST_SLC1HOST_TX_START_INT_CLR_V: u32 = 1;
pub const HOST_SLC1HOST_TX_START_INT_CLR_S: u32 = 15;
pub const HOST_SLC1HOST_RX_START_INT_CLR_V: u32 = 1;
pub const HOST_SLC1HOST_RX_START_INT_CLR_S: u32 = 14;
pub const HOST_SLC1HOST_RX_EOF_INT_CLR_V: u32 = 1;
pub const HOST_SLC1HOST_RX_EOF_INT_CLR_S: u32 = 13;
pub const HOST_SLC1HOST_RX_SOF_INT_CLR_V: u32 = 1;
pub const HOST_SLC1HOST_RX_SOF_INT_CLR_S: u32 = 12;
pub const HOST_SLC1_TOKEN1_0TO1_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_0TO1_INT_CLR_S: u32 = 11;
pub const HOST_SLC1_TOKEN0_0TO1_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_0TO1_INT_CLR_S: u32 = 10;
pub const HOST_SLC1_TOKEN1_1TO0_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_1TO0_INT_CLR_S: u32 = 9;
pub const HOST_SLC1_TOKEN0_1TO0_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_1TO0_INT_CLR_S: u32 = 8;
pub const HOST_SLC1_TOHOST_BIT7_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT7_INT_CLR_S: u32 = 7;
pub const HOST_SLC1_TOHOST_BIT6_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT6_INT_CLR_S: u32 = 6;
pub const HOST_SLC1_TOHOST_BIT5_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT5_INT_CLR_S: u32 = 5;
pub const HOST_SLC1_TOHOST_BIT4_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT4_INT_CLR_S: u32 = 4;
pub const HOST_SLC1_TOHOST_BIT3_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT3_INT_CLR_S: u32 = 3;
pub const HOST_SLC1_TOHOST_BIT2_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT2_INT_CLR_S: u32 = 2;
pub const HOST_SLC1_TOHOST_BIT1_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT1_INT_CLR_S: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_CLR_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_CLR_S: u32 = 0;
pub const HOST_SLC0HOST_FUNC1_INT_ENA_REG: u32 = 1073041628;
pub const HOST_FN1_GPIO_SDIO_INT_ENA_V: u32 = 1;
pub const HOST_FN1_GPIO_SDIO_INT_ENA_S: u32 = 25;
pub const HOST_FN1_SLC0_HOST_RD_RETRY_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_HOST_RD_RETRY_INT_ENA_S: u32 = 24;
pub const HOST_FN1_SLC0_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_RX_NEW_PACKET_INT_ENA_S: u32 = 23;
pub const HOST_FN1_SLC0_EXT_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_EXT_BIT3_INT_ENA_S: u32 = 22;
pub const HOST_FN1_SLC0_EXT_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_EXT_BIT2_INT_ENA_S: u32 = 21;
pub const HOST_FN1_SLC0_EXT_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_EXT_BIT1_INT_ENA_S: u32 = 20;
pub const HOST_FN1_SLC0_EXT_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_EXT_BIT0_INT_ENA_S: u32 = 19;
pub const HOST_FN1_SLC0_RX_PF_VALID_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_RX_PF_VALID_INT_ENA_S: u32 = 18;
pub const HOST_FN1_SLC0_TX_OVF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TX_OVF_INT_ENA_S: u32 = 17;
pub const HOST_FN1_SLC0_RX_UDF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_RX_UDF_INT_ENA_S: u32 = 16;
pub const HOST_FN1_SLC0HOST_TX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0HOST_TX_START_INT_ENA_S: u32 = 15;
pub const HOST_FN1_SLC0HOST_RX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0HOST_RX_START_INT_ENA_S: u32 = 14;
pub const HOST_FN1_SLC0HOST_RX_EOF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0HOST_RX_EOF_INT_ENA_S: u32 = 13;
pub const HOST_FN1_SLC0HOST_RX_SOF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0HOST_RX_SOF_INT_ENA_S: u32 = 12;
pub const HOST_FN1_SLC0_TOKEN1_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOKEN1_0TO1_INT_ENA_S: u32 = 11;
pub const HOST_FN1_SLC0_TOKEN0_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOKEN0_0TO1_INT_ENA_S: u32 = 10;
pub const HOST_FN1_SLC0_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOKEN1_1TO0_INT_ENA_S: u32 = 9;
pub const HOST_FN1_SLC0_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOKEN0_1TO0_INT_ENA_S: u32 = 8;
pub const HOST_FN1_SLC0_TOHOST_BIT7_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT7_INT_ENA_S: u32 = 7;
pub const HOST_FN1_SLC0_TOHOST_BIT6_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT6_INT_ENA_S: u32 = 6;
pub const HOST_FN1_SLC0_TOHOST_BIT5_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT5_INT_ENA_S: u32 = 5;
pub const HOST_FN1_SLC0_TOHOST_BIT4_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT4_INT_ENA_S: u32 = 4;
pub const HOST_FN1_SLC0_TOHOST_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT3_INT_ENA_S: u32 = 3;
pub const HOST_FN1_SLC0_TOHOST_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT2_INT_ENA_S: u32 = 2;
pub const HOST_FN1_SLC0_TOHOST_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT1_INT_ENA_S: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC0_TOHOST_BIT0_INT_ENA_S: u32 = 0;
pub const HOST_SLC1HOST_FUNC1_INT_ENA_REG: u32 = 1073041632;
pub const HOST_FN1_SLC1_BT_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_BT_RX_NEW_PACKET_INT_ENA_S: u32 = 25;
pub const HOST_FN1_SLC1_HOST_RD_RETRY_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_HOST_RD_RETRY_INT_ENA_S: u32 = 24;
pub const HOST_FN1_SLC1_WIFI_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_WIFI_RX_NEW_PACKET_INT_ENA_S: u32 = 23;
pub const HOST_FN1_SLC1_EXT_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_EXT_BIT3_INT_ENA_S: u32 = 22;
pub const HOST_FN1_SLC1_EXT_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_EXT_BIT2_INT_ENA_S: u32 = 21;
pub const HOST_FN1_SLC1_EXT_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_EXT_BIT1_INT_ENA_S: u32 = 20;
pub const HOST_FN1_SLC1_EXT_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_EXT_BIT0_INT_ENA_S: u32 = 19;
pub const HOST_FN1_SLC1_RX_PF_VALID_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_RX_PF_VALID_INT_ENA_S: u32 = 18;
pub const HOST_FN1_SLC1_TX_OVF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TX_OVF_INT_ENA_S: u32 = 17;
pub const HOST_FN1_SLC1_RX_UDF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_RX_UDF_INT_ENA_S: u32 = 16;
pub const HOST_FN1_SLC1HOST_TX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1HOST_TX_START_INT_ENA_S: u32 = 15;
pub const HOST_FN1_SLC1HOST_RX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1HOST_RX_START_INT_ENA_S: u32 = 14;
pub const HOST_FN1_SLC1HOST_RX_EOF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1HOST_RX_EOF_INT_ENA_S: u32 = 13;
pub const HOST_FN1_SLC1HOST_RX_SOF_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1HOST_RX_SOF_INT_ENA_S: u32 = 12;
pub const HOST_FN1_SLC1_TOKEN1_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOKEN1_0TO1_INT_ENA_S: u32 = 11;
pub const HOST_FN1_SLC1_TOKEN0_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOKEN0_0TO1_INT_ENA_S: u32 = 10;
pub const HOST_FN1_SLC1_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOKEN1_1TO0_INT_ENA_S: u32 = 9;
pub const HOST_FN1_SLC1_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOKEN0_1TO0_INT_ENA_S: u32 = 8;
pub const HOST_FN1_SLC1_TOHOST_BIT7_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT7_INT_ENA_S: u32 = 7;
pub const HOST_FN1_SLC1_TOHOST_BIT6_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT6_INT_ENA_S: u32 = 6;
pub const HOST_FN1_SLC1_TOHOST_BIT5_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT5_INT_ENA_S: u32 = 5;
pub const HOST_FN1_SLC1_TOHOST_BIT4_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT4_INT_ENA_S: u32 = 4;
pub const HOST_FN1_SLC1_TOHOST_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT3_INT_ENA_S: u32 = 3;
pub const HOST_FN1_SLC1_TOHOST_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT2_INT_ENA_S: u32 = 2;
pub const HOST_FN1_SLC1_TOHOST_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT1_INT_ENA_S: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN1_SLC1_TOHOST_BIT0_INT_ENA_S: u32 = 0;
pub const HOST_SLC0HOST_FUNC2_INT_ENA_REG: u32 = 1073041636;
pub const HOST_FN2_GPIO_SDIO_INT_ENA_V: u32 = 1;
pub const HOST_FN2_GPIO_SDIO_INT_ENA_S: u32 = 25;
pub const HOST_FN2_SLC0_HOST_RD_RETRY_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_HOST_RD_RETRY_INT_ENA_S: u32 = 24;
pub const HOST_FN2_SLC0_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_RX_NEW_PACKET_INT_ENA_S: u32 = 23;
pub const HOST_FN2_SLC0_EXT_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_EXT_BIT3_INT_ENA_S: u32 = 22;
pub const HOST_FN2_SLC0_EXT_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_EXT_BIT2_INT_ENA_S: u32 = 21;
pub const HOST_FN2_SLC0_EXT_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_EXT_BIT1_INT_ENA_S: u32 = 20;
pub const HOST_FN2_SLC0_EXT_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_EXT_BIT0_INT_ENA_S: u32 = 19;
pub const HOST_FN2_SLC0_RX_PF_VALID_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_RX_PF_VALID_INT_ENA_S: u32 = 18;
pub const HOST_FN2_SLC0_TX_OVF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TX_OVF_INT_ENA_S: u32 = 17;
pub const HOST_FN2_SLC0_RX_UDF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_RX_UDF_INT_ENA_S: u32 = 16;
pub const HOST_FN2_SLC0HOST_TX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0HOST_TX_START_INT_ENA_S: u32 = 15;
pub const HOST_FN2_SLC0HOST_RX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0HOST_RX_START_INT_ENA_S: u32 = 14;
pub const HOST_FN2_SLC0HOST_RX_EOF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0HOST_RX_EOF_INT_ENA_S: u32 = 13;
pub const HOST_FN2_SLC0HOST_RX_SOF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0HOST_RX_SOF_INT_ENA_S: u32 = 12;
pub const HOST_FN2_SLC0_TOKEN1_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOKEN1_0TO1_INT_ENA_S: u32 = 11;
pub const HOST_FN2_SLC0_TOKEN0_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOKEN0_0TO1_INT_ENA_S: u32 = 10;
pub const HOST_FN2_SLC0_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOKEN1_1TO0_INT_ENA_S: u32 = 9;
pub const HOST_FN2_SLC0_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOKEN0_1TO0_INT_ENA_S: u32 = 8;
pub const HOST_FN2_SLC0_TOHOST_BIT7_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT7_INT_ENA_S: u32 = 7;
pub const HOST_FN2_SLC0_TOHOST_BIT6_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT6_INT_ENA_S: u32 = 6;
pub const HOST_FN2_SLC0_TOHOST_BIT5_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT5_INT_ENA_S: u32 = 5;
pub const HOST_FN2_SLC0_TOHOST_BIT4_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT4_INT_ENA_S: u32 = 4;
pub const HOST_FN2_SLC0_TOHOST_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT3_INT_ENA_S: u32 = 3;
pub const HOST_FN2_SLC0_TOHOST_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT2_INT_ENA_S: u32 = 2;
pub const HOST_FN2_SLC0_TOHOST_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT1_INT_ENA_S: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC0_TOHOST_BIT0_INT_ENA_S: u32 = 0;
pub const HOST_SLC1HOST_FUNC2_INT_ENA_REG: u32 = 1073041640;
pub const HOST_FN2_SLC1_BT_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_BT_RX_NEW_PACKET_INT_ENA_S: u32 = 25;
pub const HOST_FN2_SLC1_HOST_RD_RETRY_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_HOST_RD_RETRY_INT_ENA_S: u32 = 24;
pub const HOST_FN2_SLC1_WIFI_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_WIFI_RX_NEW_PACKET_INT_ENA_S: u32 = 23;
pub const HOST_FN2_SLC1_EXT_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_EXT_BIT3_INT_ENA_S: u32 = 22;
pub const HOST_FN2_SLC1_EXT_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_EXT_BIT2_INT_ENA_S: u32 = 21;
pub const HOST_FN2_SLC1_EXT_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_EXT_BIT1_INT_ENA_S: u32 = 20;
pub const HOST_FN2_SLC1_EXT_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_EXT_BIT0_INT_ENA_S: u32 = 19;
pub const HOST_FN2_SLC1_RX_PF_VALID_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_RX_PF_VALID_INT_ENA_S: u32 = 18;
pub const HOST_FN2_SLC1_TX_OVF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TX_OVF_INT_ENA_S: u32 = 17;
pub const HOST_FN2_SLC1_RX_UDF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_RX_UDF_INT_ENA_S: u32 = 16;
pub const HOST_FN2_SLC1HOST_TX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1HOST_TX_START_INT_ENA_S: u32 = 15;
pub const HOST_FN2_SLC1HOST_RX_START_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1HOST_RX_START_INT_ENA_S: u32 = 14;
pub const HOST_FN2_SLC1HOST_RX_EOF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1HOST_RX_EOF_INT_ENA_S: u32 = 13;
pub const HOST_FN2_SLC1HOST_RX_SOF_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1HOST_RX_SOF_INT_ENA_S: u32 = 12;
pub const HOST_FN2_SLC1_TOKEN1_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOKEN1_0TO1_INT_ENA_S: u32 = 11;
pub const HOST_FN2_SLC1_TOKEN0_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOKEN0_0TO1_INT_ENA_S: u32 = 10;
pub const HOST_FN2_SLC1_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOKEN1_1TO0_INT_ENA_S: u32 = 9;
pub const HOST_FN2_SLC1_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOKEN0_1TO0_INT_ENA_S: u32 = 8;
pub const HOST_FN2_SLC1_TOHOST_BIT7_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT7_INT_ENA_S: u32 = 7;
pub const HOST_FN2_SLC1_TOHOST_BIT6_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT6_INT_ENA_S: u32 = 6;
pub const HOST_FN2_SLC1_TOHOST_BIT5_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT5_INT_ENA_S: u32 = 5;
pub const HOST_FN2_SLC1_TOHOST_BIT4_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT4_INT_ENA_S: u32 = 4;
pub const HOST_FN2_SLC1_TOHOST_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT3_INT_ENA_S: u32 = 3;
pub const HOST_FN2_SLC1_TOHOST_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT2_INT_ENA_S: u32 = 2;
pub const HOST_FN2_SLC1_TOHOST_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT1_INT_ENA_S: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_FN2_SLC1_TOHOST_BIT0_INT_ENA_S: u32 = 0;
pub const HOST_SLC0HOST_INT_ENA_REG: u32 = 1073041644;
pub const HOST_GPIO_SDIO_INT_ENA_V: u32 = 1;
pub const HOST_GPIO_SDIO_INT_ENA_S: u32 = 25;
pub const HOST_SLC0_HOST_RD_RETRY_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_HOST_RD_RETRY_INT_ENA_S: u32 = 24;
pub const HOST_SLC0_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_RX_NEW_PACKET_INT_ENA_S: u32 = 23;
pub const HOST_SLC0_EXT_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT3_INT_ENA_S: u32 = 22;
pub const HOST_SLC0_EXT_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT2_INT_ENA_S: u32 = 21;
pub const HOST_SLC0_EXT_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT1_INT_ENA_S: u32 = 20;
pub const HOST_SLC0_EXT_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT0_INT_ENA_S: u32 = 19;
pub const HOST_SLC0_RX_PF_VALID_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_RX_PF_VALID_INT_ENA_S: u32 = 18;
pub const HOST_SLC0_TX_OVF_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TX_OVF_INT_ENA_S: u32 = 17;
pub const HOST_SLC0_RX_UDF_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_RX_UDF_INT_ENA_S: u32 = 16;
pub const HOST_SLC0HOST_TX_START_INT_ENA_V: u32 = 1;
pub const HOST_SLC0HOST_TX_START_INT_ENA_S: u32 = 15;
pub const HOST_SLC0HOST_RX_START_INT_ENA_V: u32 = 1;
pub const HOST_SLC0HOST_RX_START_INT_ENA_S: u32 = 14;
pub const HOST_SLC0HOST_RX_EOF_INT_ENA_V: u32 = 1;
pub const HOST_SLC0HOST_RX_EOF_INT_ENA_S: u32 = 13;
pub const HOST_SLC0HOST_RX_SOF_INT_ENA_V: u32 = 1;
pub const HOST_SLC0HOST_RX_SOF_INT_ENA_S: u32 = 12;
pub const HOST_SLC0_TOKEN1_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_0TO1_INT_ENA_S: u32 = 11;
pub const HOST_SLC0_TOKEN0_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_0TO1_INT_ENA_S: u32 = 10;
pub const HOST_SLC0_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_1TO0_INT_ENA_S: u32 = 9;
pub const HOST_SLC0_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_1TO0_INT_ENA_S: u32 = 8;
pub const HOST_SLC0_TOHOST_BIT7_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT7_INT_ENA_S: u32 = 7;
pub const HOST_SLC0_TOHOST_BIT6_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT6_INT_ENA_S: u32 = 6;
pub const HOST_SLC0_TOHOST_BIT5_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT5_INT_ENA_S: u32 = 5;
pub const HOST_SLC0_TOHOST_BIT4_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT4_INT_ENA_S: u32 = 4;
pub const HOST_SLC0_TOHOST_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT3_INT_ENA_S: u32 = 3;
pub const HOST_SLC0_TOHOST_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT2_INT_ENA_S: u32 = 2;
pub const HOST_SLC0_TOHOST_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT1_INT_ENA_S: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_ENA_S: u32 = 0;
pub const HOST_SLC1HOST_INT_ENA_REG: u32 = 1073041648;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA_S: u32 = 25;
pub const HOST_SLC1_HOST_RD_RETRY_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_HOST_RD_RETRY_INT_ENA_S: u32 = 24;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA_S: u32 = 23;
pub const HOST_SLC1_EXT_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT3_INT_ENA_S: u32 = 22;
pub const HOST_SLC1_EXT_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT2_INT_ENA_S: u32 = 21;
pub const HOST_SLC1_EXT_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT1_INT_ENA_S: u32 = 20;
pub const HOST_SLC1_EXT_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT0_INT_ENA_S: u32 = 19;
pub const HOST_SLC1_RX_PF_VALID_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_RX_PF_VALID_INT_ENA_S: u32 = 18;
pub const HOST_SLC1_TX_OVF_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TX_OVF_INT_ENA_S: u32 = 17;
pub const HOST_SLC1_RX_UDF_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_RX_UDF_INT_ENA_S: u32 = 16;
pub const HOST_SLC1HOST_TX_START_INT_ENA_V: u32 = 1;
pub const HOST_SLC1HOST_TX_START_INT_ENA_S: u32 = 15;
pub const HOST_SLC1HOST_RX_START_INT_ENA_V: u32 = 1;
pub const HOST_SLC1HOST_RX_START_INT_ENA_S: u32 = 14;
pub const HOST_SLC1HOST_RX_EOF_INT_ENA_V: u32 = 1;
pub const HOST_SLC1HOST_RX_EOF_INT_ENA_S: u32 = 13;
pub const HOST_SLC1HOST_RX_SOF_INT_ENA_V: u32 = 1;
pub const HOST_SLC1HOST_RX_SOF_INT_ENA_S: u32 = 12;
pub const HOST_SLC1_TOKEN1_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_0TO1_INT_ENA_S: u32 = 11;
pub const HOST_SLC1_TOKEN0_0TO1_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_0TO1_INT_ENA_S: u32 = 10;
pub const HOST_SLC1_TOKEN1_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_1TO0_INT_ENA_S: u32 = 9;
pub const HOST_SLC1_TOKEN0_1TO0_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_1TO0_INT_ENA_S: u32 = 8;
pub const HOST_SLC1_TOHOST_BIT7_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT7_INT_ENA_S: u32 = 7;
pub const HOST_SLC1_TOHOST_BIT6_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT6_INT_ENA_S: u32 = 6;
pub const HOST_SLC1_TOHOST_BIT5_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT5_INT_ENA_S: u32 = 5;
pub const HOST_SLC1_TOHOST_BIT4_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT4_INT_ENA_S: u32 = 4;
pub const HOST_SLC1_TOHOST_BIT3_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT3_INT_ENA_S: u32 = 3;
pub const HOST_SLC1_TOHOST_BIT2_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT2_INT_ENA_S: u32 = 2;
pub const HOST_SLC1_TOHOST_BIT1_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT1_INT_ENA_S: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_ENA_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_ENA_S: u32 = 0;
pub const HOST_SLC0HOST_RX_INFOR_REG: u32 = 1073041652;
pub const HOST_SLC0HOST_RX_INFOR: u32 = 1048575;
pub const HOST_SLC0HOST_RX_INFOR_V: u32 = 1048575;
pub const HOST_SLC0HOST_RX_INFOR_S: u32 = 0;
pub const HOST_SLC1HOST_RX_INFOR_REG: u32 = 1073041656;
pub const HOST_SLC1HOST_RX_INFOR: u32 = 1048575;
pub const HOST_SLC1HOST_RX_INFOR_V: u32 = 1048575;
pub const HOST_SLC1HOST_RX_INFOR_S: u32 = 0;
pub const HOST_SLC0HOST_LEN_WD_REG: u32 = 1073041660;
pub const HOST_SLC0HOST_LEN_WD: u32 = 4294967295;
pub const HOST_SLC0HOST_LEN_WD_V: u32 = 4294967295;
pub const HOST_SLC0HOST_LEN_WD_S: u32 = 0;
pub const HOST_SLC_APBWIN_WDATA_REG: u32 = 1073041664;
pub const HOST_SLC_APBWIN_WDATA: u32 = 4294967295;
pub const HOST_SLC_APBWIN_WDATA_V: u32 = 4294967295;
pub const HOST_SLC_APBWIN_WDATA_S: u32 = 0;
pub const HOST_SLC_APBWIN_CONF_REG: u32 = 1073041668;
pub const HOST_SLC_APBWIN_START_V: u32 = 1;
pub const HOST_SLC_APBWIN_START_S: u32 = 29;
pub const HOST_SLC_APBWIN_WR_V: u32 = 1;
pub const HOST_SLC_APBWIN_WR_S: u32 = 28;
pub const HOST_SLC_APBWIN_ADDR: u32 = 268435455;
pub const HOST_SLC_APBWIN_ADDR_V: u32 = 268435455;
pub const HOST_SLC_APBWIN_ADDR_S: u32 = 0;
pub const HOST_SLC_APBWIN_RDATA_REG: u32 = 1073041672;
pub const HOST_SLC_APBWIN_RDATA: u32 = 4294967295;
pub const HOST_SLC_APBWIN_RDATA_V: u32 = 4294967295;
pub const HOST_SLC_APBWIN_RDATA_S: u32 = 0;
pub const HOST_SLCHOST_RDCLR0_REG: u32 = 1073041676;
pub const HOST_SLCHOST_SLC0_BIT6_CLRADDR: u32 = 511;
pub const HOST_SLCHOST_SLC0_BIT6_CLRADDR_V: u32 = 511;
pub const HOST_SLCHOST_SLC0_BIT6_CLRADDR_S: u32 = 9;
pub const HOST_SLCHOST_SLC0_BIT7_CLRADDR: u32 = 511;
pub const HOST_SLCHOST_SLC0_BIT7_CLRADDR_V: u32 = 511;
pub const HOST_SLCHOST_SLC0_BIT7_CLRADDR_S: u32 = 0;
pub const HOST_SLCHOST_RDCLR1_REG: u32 = 1073041680;
pub const HOST_SLCHOST_SLC1_BIT6_CLRADDR: u32 = 511;
pub const HOST_SLCHOST_SLC1_BIT6_CLRADDR_V: u32 = 511;
pub const HOST_SLCHOST_SLC1_BIT6_CLRADDR_S: u32 = 9;
pub const HOST_SLCHOST_SLC1_BIT7_CLRADDR: u32 = 511;
pub const HOST_SLCHOST_SLC1_BIT7_CLRADDR_V: u32 = 511;
pub const HOST_SLCHOST_SLC1_BIT7_CLRADDR_S: u32 = 0;
pub const HOST_SLC0HOST_INT_ENA1_REG: u32 = 1073041684;
pub const HOST_GPIO_SDIO_INT_ENA1_V: u32 = 1;
pub const HOST_GPIO_SDIO_INT_ENA1_S: u32 = 25;
pub const HOST_SLC0_HOST_RD_RETRY_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_HOST_RD_RETRY_INT_ENA1_S: u32 = 24;
pub const HOST_SLC0_RX_NEW_PACKET_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_RX_NEW_PACKET_INT_ENA1_S: u32 = 23;
pub const HOST_SLC0_EXT_BIT3_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT3_INT_ENA1_S: u32 = 22;
pub const HOST_SLC0_EXT_BIT2_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT2_INT_ENA1_S: u32 = 21;
pub const HOST_SLC0_EXT_BIT1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT1_INT_ENA1_S: u32 = 20;
pub const HOST_SLC0_EXT_BIT0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_EXT_BIT0_INT_ENA1_S: u32 = 19;
pub const HOST_SLC0_RX_PF_VALID_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_RX_PF_VALID_INT_ENA1_S: u32 = 18;
pub const HOST_SLC0_TX_OVF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TX_OVF_INT_ENA1_S: u32 = 17;
pub const HOST_SLC0_RX_UDF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_RX_UDF_INT_ENA1_S: u32 = 16;
pub const HOST_SLC0HOST_TX_START_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0HOST_TX_START_INT_ENA1_S: u32 = 15;
pub const HOST_SLC0HOST_RX_START_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0HOST_RX_START_INT_ENA1_S: u32 = 14;
pub const HOST_SLC0HOST_RX_EOF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0HOST_RX_EOF_INT_ENA1_S: u32 = 13;
pub const HOST_SLC0HOST_RX_SOF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0HOST_RX_SOF_INT_ENA1_S: u32 = 12;
pub const HOST_SLC0_TOKEN1_0TO1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_0TO1_INT_ENA1_S: u32 = 11;
pub const HOST_SLC0_TOKEN0_0TO1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_0TO1_INT_ENA1_S: u32 = 10;
pub const HOST_SLC0_TOKEN1_1TO0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOKEN1_1TO0_INT_ENA1_S: u32 = 9;
pub const HOST_SLC0_TOKEN0_1TO0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOKEN0_1TO0_INT_ENA1_S: u32 = 8;
pub const HOST_SLC0_TOHOST_BIT7_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT7_INT_ENA1_S: u32 = 7;
pub const HOST_SLC0_TOHOST_BIT6_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT6_INT_ENA1_S: u32 = 6;
pub const HOST_SLC0_TOHOST_BIT5_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT5_INT_ENA1_S: u32 = 5;
pub const HOST_SLC0_TOHOST_BIT4_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT4_INT_ENA1_S: u32 = 4;
pub const HOST_SLC0_TOHOST_BIT3_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT3_INT_ENA1_S: u32 = 3;
pub const HOST_SLC0_TOHOST_BIT2_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT2_INT_ENA1_S: u32 = 2;
pub const HOST_SLC0_TOHOST_BIT1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT1_INT_ENA1_S: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC0_TOHOST_BIT0_INT_ENA1_S: u32 = 0;
pub const HOST_SLC1HOST_INT_ENA1_REG: u32 = 1073041688;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_BT_RX_NEW_PACKET_INT_ENA1_S: u32 = 25;
pub const HOST_SLC1_HOST_RD_RETRY_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_HOST_RD_RETRY_INT_ENA1_S: u32 = 24;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_WIFI_RX_NEW_PACKET_INT_ENA1_S: u32 = 23;
pub const HOST_SLC1_EXT_BIT3_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT3_INT_ENA1_S: u32 = 22;
pub const HOST_SLC1_EXT_BIT2_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT2_INT_ENA1_S: u32 = 21;
pub const HOST_SLC1_EXT_BIT1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT1_INT_ENA1_S: u32 = 20;
pub const HOST_SLC1_EXT_BIT0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_EXT_BIT0_INT_ENA1_S: u32 = 19;
pub const HOST_SLC1_RX_PF_VALID_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_RX_PF_VALID_INT_ENA1_S: u32 = 18;
pub const HOST_SLC1_TX_OVF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TX_OVF_INT_ENA1_S: u32 = 17;
pub const HOST_SLC1_RX_UDF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_RX_UDF_INT_ENA1_S: u32 = 16;
pub const HOST_SLC1HOST_TX_START_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1HOST_TX_START_INT_ENA1_S: u32 = 15;
pub const HOST_SLC1HOST_RX_START_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1HOST_RX_START_INT_ENA1_S: u32 = 14;
pub const HOST_SLC1HOST_RX_EOF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1HOST_RX_EOF_INT_ENA1_S: u32 = 13;
pub const HOST_SLC1HOST_RX_SOF_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1HOST_RX_SOF_INT_ENA1_S: u32 = 12;
pub const HOST_SLC1_TOKEN1_0TO1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_0TO1_INT_ENA1_S: u32 = 11;
pub const HOST_SLC1_TOKEN0_0TO1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_0TO1_INT_ENA1_S: u32 = 10;
pub const HOST_SLC1_TOKEN1_1TO0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOKEN1_1TO0_INT_ENA1_S: u32 = 9;
pub const HOST_SLC1_TOKEN0_1TO0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOKEN0_1TO0_INT_ENA1_S: u32 = 8;
pub const HOST_SLC1_TOHOST_BIT7_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT7_INT_ENA1_S: u32 = 7;
pub const HOST_SLC1_TOHOST_BIT6_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT6_INT_ENA1_S: u32 = 6;
pub const HOST_SLC1_TOHOST_BIT5_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT5_INT_ENA1_S: u32 = 5;
pub const HOST_SLC1_TOHOST_BIT4_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT4_INT_ENA1_S: u32 = 4;
pub const HOST_SLC1_TOHOST_BIT3_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT3_INT_ENA1_S: u32 = 3;
pub const HOST_SLC1_TOHOST_BIT2_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT2_INT_ENA1_S: u32 = 2;
pub const HOST_SLC1_TOHOST_BIT1_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT1_INT_ENA1_S: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_ENA1_V: u32 = 1;
pub const HOST_SLC1_TOHOST_BIT0_INT_ENA1_S: u32 = 0;
pub const HOST_SLCHOSTDATE_REG: u32 = 1073041784;
pub const HOST_SLCHOST_DATE: u32 = 4294967295;
pub const HOST_SLCHOST_DATE_V: u32 = 4294967295;
pub const HOST_SLCHOST_DATE_S: u32 = 0;
pub const HOST_SLCHOSTID_REG: u32 = 1073041788;
pub const HOST_SLCHOST_ID: u32 = 4294967295;
pub const HOST_SLCHOST_ID_V: u32 = 4294967295;
pub const HOST_SLCHOST_ID_S: u32 = 0;
pub const HOST_SLCHOST_CONF_REG: u32 = 1073041904;
pub const HOST_HSPEED_CON_EN_V: u32 = 1;
pub const HOST_HSPEED_CON_EN_S: u32 = 27;
pub const HOST_SDIO_PAD_PULLUP_V: u32 = 1;
pub const HOST_SDIO_PAD_PULLUP_S: u32 = 26;
pub const HOST_SDIO20_INT_DELAY_V: u32 = 1;
pub const HOST_SDIO20_INT_DELAY_S: u32 = 25;
pub const HOST_FRC_QUICK_IN: u32 = 31;
pub const HOST_FRC_QUICK_IN_V: u32 = 31;
pub const HOST_FRC_QUICK_IN_S: u32 = 20;
pub const HOST_FRC_POS_SAMP: u32 = 31;
pub const HOST_FRC_POS_SAMP_V: u32 = 31;
pub const HOST_FRC_POS_SAMP_S: u32 = 15;
pub const HOST_FRC_NEG_SAMP: u32 = 31;
pub const HOST_FRC_NEG_SAMP_V: u32 = 31;
pub const HOST_FRC_NEG_SAMP_S: u32 = 10;
pub const HOST_FRC_SDIO20: u32 = 31;
pub const HOST_FRC_SDIO20_V: u32 = 31;
pub const HOST_FRC_SDIO20_S: u32 = 5;
pub const HOST_FRC_SDIO11: u32 = 31;
pub const HOST_FRC_SDIO11_V: u32 = 31;
pub const HOST_FRC_SDIO11_S: u32 = 0;
pub const HOST_SLCHOST_INF_ST_REG: u32 = 1073041908;
pub const HOST_SDIO_QUICK_IN: u32 = 31;
pub const HOST_SDIO_QUICK_IN_V: u32 = 31;
pub const HOST_SDIO_QUICK_IN_S: u32 = 10;
pub const HOST_SDIO_NEG_SAMP: u32 = 31;
pub const HOST_SDIO_NEG_SAMP_V: u32 = 31;
pub const HOST_SDIO_NEG_SAMP_S: u32 = 5;
pub const HOST_SDIO20_MODE: u32 = 31;
pub const HOST_SDIO20_MODE_V: u32 = 31;
pub const HOST_SDIO20_MODE_S: u32 = 0;
pub const HINF_CFG_DATA0_REG: u32 = 1073000448;
pub const HINF_DEVICE_ID_FN1: u32 = 65535;
pub const HINF_DEVICE_ID_FN1_V: u32 = 65535;
pub const HINF_DEVICE_ID_FN1_S: u32 = 16;
pub const HINF_USER_ID_FN1: u32 = 65535;
pub const HINF_USER_ID_FN1_V: u32 = 65535;
pub const HINF_USER_ID_FN1_S: u32 = 0;
pub const HINF_CFG_DATA1_REG: u32 = 1073000452;
pub const HINF_SDIO20_CONF1: u32 = 7;
pub const HINF_SDIO20_CONF1_V: u32 = 7;
pub const HINF_SDIO20_CONF1_S: u32 = 29;
pub const HINF_FUNC2_EPS_V: u32 = 1;
pub const HINF_FUNC2_EPS_S: u32 = 28;
pub const HINF_SDIO_VER: u32 = 4095;
pub const HINF_SDIO_VER_V: u32 = 4095;
pub const HINF_SDIO_VER_S: u32 = 16;
pub const HINF_SDIO20_CONF0: u32 = 15;
pub const HINF_SDIO20_CONF0_V: u32 = 15;
pub const HINF_SDIO20_CONF0_S: u32 = 12;
pub const HINF_IOENABLE1_V: u32 = 1;
pub const HINF_IOENABLE1_S: u32 = 11;
pub const HINF_EMP_V: u32 = 1;
pub const HINF_EMP_S: u32 = 10;
pub const HINF_FUNC1_EPS_V: u32 = 1;
pub const HINF_FUNC1_EPS_S: u32 = 9;
pub const HINF_CD_DISABLE_V: u32 = 1;
pub const HINF_CD_DISABLE_S: u32 = 8;
pub const HINF_IOENABLE2_V: u32 = 1;
pub const HINF_IOENABLE2_S: u32 = 7;
pub const HINF_SDIO_INT_MASK_V: u32 = 1;
pub const HINF_SDIO_INT_MASK_S: u32 = 6;
pub const HINF_SDIO_IOREADY2_V: u32 = 1;
pub const HINF_SDIO_IOREADY2_S: u32 = 5;
pub const HINF_SDIO_CD_ENABLE_V: u32 = 1;
pub const HINF_SDIO_CD_ENABLE_S: u32 = 4;
pub const HINF_HIGHSPEED_MODE_V: u32 = 1;
pub const HINF_HIGHSPEED_MODE_S: u32 = 3;
pub const HINF_HIGHSPEED_ENABLE_V: u32 = 1;
pub const HINF_HIGHSPEED_ENABLE_S: u32 = 2;
pub const HINF_SDIO_IOREADY1_V: u32 = 1;
pub const HINF_SDIO_IOREADY1_S: u32 = 1;
pub const HINF_SDIO_ENABLE_V: u32 = 1;
pub const HINF_SDIO_ENABLE_S: u32 = 0;
pub const HINF_CFG_DATA7_REG: u32 = 1073000476;
pub const HINF_SDIO_IOREADY0_V: u32 = 1;
pub const HINF_SDIO_IOREADY0_S: u32 = 17;
pub const HINF_SDIO_RST_V: u32 = 1;
pub const HINF_SDIO_RST_S: u32 = 16;
pub const HINF_CHIP_STATE: u32 = 255;
pub const HINF_CHIP_STATE_V: u32 = 255;
pub const HINF_CHIP_STATE_S: u32 = 8;
pub const HINF_PIN_STATE: u32 = 255;
pub const HINF_PIN_STATE_V: u32 = 255;
pub const HINF_PIN_STATE_S: u32 = 0;
pub const HINF_CIS_CONF0_REG: u32 = 1073000480;
pub const HINF_CIS_CONF_W0: u32 = 4294967295;
pub const HINF_CIS_CONF_W0_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W0_S: u32 = 0;
pub const HINF_CIS_CONF1_REG: u32 = 1073000484;
pub const HINF_CIS_CONF_W1: u32 = 4294967295;
pub const HINF_CIS_CONF_W1_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W1_S: u32 = 0;
pub const HINF_CIS_CONF2_REG: u32 = 1073000488;
pub const HINF_CIS_CONF_W2: u32 = 4294967295;
pub const HINF_CIS_CONF_W2_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W2_S: u32 = 0;
pub const HINF_CIS_CONF3_REG: u32 = 1073000492;
pub const HINF_CIS_CONF_W3: u32 = 4294967295;
pub const HINF_CIS_CONF_W3_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W3_S: u32 = 0;
pub const HINF_CIS_CONF4_REG: u32 = 1073000496;
pub const HINF_CIS_CONF_W4: u32 = 4294967295;
pub const HINF_CIS_CONF_W4_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W4_S: u32 = 0;
pub const HINF_CIS_CONF5_REG: u32 = 1073000500;
pub const HINF_CIS_CONF_W5: u32 = 4294967295;
pub const HINF_CIS_CONF_W5_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W5_S: u32 = 0;
pub const HINF_CIS_CONF6_REG: u32 = 1073000504;
pub const HINF_CIS_CONF_W6: u32 = 4294967295;
pub const HINF_CIS_CONF_W6_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W6_S: u32 = 0;
pub const HINF_CIS_CONF7_REG: u32 = 1073000508;
pub const HINF_CIS_CONF_W7: u32 = 4294967295;
pub const HINF_CIS_CONF_W7_V: u32 = 4294967295;
pub const HINF_CIS_CONF_W7_S: u32 = 0;
pub const HINF_CFG_DATA16_REG: u32 = 1073000512;
pub const HINF_DEVICE_ID_FN2: u32 = 65535;
pub const HINF_DEVICE_ID_FN2_V: u32 = 65535;
pub const HINF_DEVICE_ID_FN2_S: u32 = 16;
pub const HINF_USER_ID_FN2: u32 = 65535;
pub const HINF_USER_ID_FN2_V: u32 = 65535;
pub const HINF_USER_ID_FN2_S: u32 = 0;
pub const HINF_DATE_REG: u32 = 1073000700;
pub const HINF_SDIO_DATE: u32 = 4294967295;
pub const HINF_SDIO_DATE_V: u32 = 4294967295;
pub const HINF_SDIO_DATE_S: u32 = 0;
pub const SDIO_SLAVE_RECV_MAX_BUFFER: u32 = 4092;
pub const MMC_GO_IDLE_STATE: u32 = 0;
pub const MMC_SEND_OP_COND: u32 = 1;
pub const MMC_ALL_SEND_CID: u32 = 2;
pub const MMC_SET_RELATIVE_ADDR: u32 = 3;
pub const MMC_SWITCH: u32 = 6;
pub const MMC_SELECT_CARD: u32 = 7;
pub const MMC_SEND_EXT_CSD: u32 = 8;
pub const MMC_SEND_CSD: u32 = 9;
pub const MMC_SEND_CID: u32 = 10;
pub const MMC_READ_DAT_UNTIL_STOP: u32 = 11;
pub const MMC_STOP_TRANSMISSION: u32 = 12;
pub const MMC_SEND_STATUS: u32 = 13;
pub const MMC_SET_BLOCKLEN: u32 = 16;
pub const MMC_READ_BLOCK_SINGLE: u32 = 17;
pub const MMC_READ_BLOCK_MULTIPLE: u32 = 18;
pub const MMC_WRITE_DAT_UNTIL_STOP: u32 = 20;
pub const MMC_SET_BLOCK_COUNT: u32 = 23;
pub const MMC_WRITE_BLOCK_SINGLE: u32 = 24;
pub const MMC_WRITE_BLOCK_MULTIPLE: u32 = 25;
pub const MMC_APP_CMD: u32 = 55;
pub const SD_SEND_RELATIVE_ADDR: u32 = 3;
pub const SD_SEND_SWITCH_FUNC: u32 = 6;
pub const SD_SEND_IF_COND: u32 = 8;
pub const SD_READ_OCR: u32 = 58;
pub const SD_CRC_ON_OFF: u32 = 59;
pub const SD_APP_SET_BUS_WIDTH: u32 = 6;
pub const SD_APP_SD_STATUS: u32 = 13;
pub const SD_APP_OP_COND: u32 = 41;
pub const SD_APP_SEND_SCR: u32 = 51;
pub const SD_IO_SEND_OP_COND: u32 = 5;
pub const SD_IO_RW_DIRECT: u32 = 52;
pub const SD_IO_RW_EXTENDED: u32 = 53;
pub const MMC_OCR_MEM_READY: u32 = 2147483648;
pub const MMC_OCR_ACCESS_MODE_MASK: u32 = 1610612736;
pub const MMC_OCR_SECTOR_MODE: u32 = 1073741824;
pub const MMC_OCR_BYTE_MODE: u32 = 536870912;
pub const MMC_OCR_3_5V_3_6V: u32 = 8388608;
pub const MMC_OCR_3_4V_3_5V: u32 = 4194304;
pub const MMC_OCR_3_3V_3_4V: u32 = 2097152;
pub const MMC_OCR_3_2V_3_3V: u32 = 1048576;
pub const MMC_OCR_3_1V_3_2V: u32 = 524288;
pub const MMC_OCR_3_0V_3_1V: u32 = 262144;
pub const MMC_OCR_2_9V_3_0V: u32 = 131072;
pub const MMC_OCR_2_8V_2_9V: u32 = 65536;
pub const MMC_OCR_2_7V_2_8V: u32 = 32768;
pub const MMC_OCR_2_6V_2_7V: u32 = 16384;
pub const MMC_OCR_2_5V_2_6V: u32 = 8192;
pub const MMC_OCR_2_4V_2_5V: u32 = 4096;
pub const MMC_OCR_2_3V_2_4V: u32 = 2048;
pub const MMC_OCR_2_2V_2_3V: u32 = 1024;
pub const MMC_OCR_2_1V_2_2V: u32 = 512;
pub const MMC_OCR_2_0V_2_1V: u32 = 256;
pub const MMC_OCR_1_65V_1_95V: u32 = 128;
pub const SD_OCR_SDHC_CAP: u32 = 1073741824;
pub const SD_OCR_VOL_MASK: u32 = 16744448;
pub const MMC_R1_READY_FOR_DATA: u32 = 256;
pub const MMC_R1_APP_CMD: u32 = 32;
pub const MMC_R1_SWITCH_ERROR: u32 = 128;
pub const SD_SPI_R1_IDLE_STATE: u32 = 1;
pub const SD_SPI_R1_ERASE_RST: u32 = 2;
pub const SD_SPI_R1_ILLEGAL_CMD: u32 = 4;
pub const SD_SPI_R1_CMD_CRC_ERR: u32 = 8;
pub const SD_SPI_R1_ERASE_SEQ_ERR: u32 = 16;
pub const SD_SPI_R1_ADDR_ERR: u32 = 32;
pub const SD_SPI_R1_PARAM_ERR: u32 = 64;
pub const SD_SPI_R1_NO_RESPONSE: u32 = 128;
pub const SDIO_R1_FUNC_NUM_ERR: u32 = 16;
pub const SD_SPI_DATA_ACCEPTED: u32 = 2;
pub const SD_SPI_DATA_CRC_ERROR: u32 = 5;
pub const SD_SPI_DATA_WR_ERROR: u32 = 6;
pub const SD_ARG_BUS_WIDTH_1: u32 = 0;
pub const SD_ARG_BUS_WIDTH_4: u32 = 2;
pub const EXT_CSD_BUS_WIDTH: u32 = 183;
pub const EXT_CSD_HS_TIMING: u32 = 185;
pub const EXT_CSD_REV: u32 = 192;
pub const EXT_CSD_STRUCTURE: u32 = 194;
pub const EXT_CSD_CARD_TYPE: u32 = 196;
pub const EXT_CSD_SEC_COUNT: u32 = 212;
pub const EXT_CSD_PWR_CL_26_360: u32 = 203;
pub const EXT_CSD_PWR_CL_52_360: u32 = 202;
pub const EXT_CSD_PWR_CL_26_195: u32 = 201;
pub const EXT_CSD_PWR_CL_52_195: u32 = 200;
pub const EXT_CSD_POWER_CLASS: u32 = 187;
pub const EXT_CSD_CMD_SET: u32 = 191;
pub const EXT_CSD_S_CMD_SET: u32 = 504;
pub const EXT_CSD_CMD_SET_NORMAL: u32 = 1;
pub const EXT_CSD_CMD_SET_SECURE: u32 = 2;
pub const EXT_CSD_CMD_SET_CPSECURE: u32 = 4;
pub const EXT_CSD_HS_TIMING_BC: u32 = 0;
pub const EXT_CSD_HS_TIMING_HS: u32 = 1;
pub const EXT_CSD_HS_TIMING_HS200: u32 = 2;
pub const EXT_CSD_HS_TIMING_HS400: u32 = 3;
pub const EXT_CSD_BUS_WIDTH_1: u32 = 0;
pub const EXT_CSD_BUS_WIDTH_4: u32 = 1;
pub const EXT_CSD_BUS_WIDTH_8: u32 = 2;
pub const EXT_CSD_BUS_WIDTH_4_DDR: u32 = 5;
pub const EXT_CSD_BUS_WIDTH_8_DDR: u32 = 6;
pub const EXT_CSD_CARD_TYPE_F_26M: u32 = 1;
pub const EXT_CSD_CARD_TYPE_F_52M: u32 = 2;
pub const EXT_CSD_CARD_TYPE_F_52M_1_8V: u32 = 4;
pub const EXT_CSD_CARD_TYPE_F_52M_1_2V: u32 = 8;
pub const EXT_CSD_CARD_TYPE_26M: u32 = 1;
pub const EXT_CSD_CARD_TYPE_52M: u32 = 3;
pub const EXT_CSD_CARD_TYPE_52M_V18: u32 = 7;
pub const EXT_CSD_CARD_TYPE_52M_V12: u32 = 11;
pub const EXT_CSD_CARD_TYPE_52M_V12_18: u32 = 15;
pub const EXT_CSD_MMC_SIZE: u32 = 512;
pub const MMC_SWITCH_MODE_CMD_SET: u32 = 0;
pub const MMC_SWITCH_MODE_SET_BITS: u32 = 1;
pub const MMC_SWITCH_MODE_CLEAR_BITS: u32 = 2;
pub const MMC_SWITCH_MODE_WRITE_BYTE: u32 = 3;
pub const MMC_CSD_CSDVER_1_0: u32 = 1;
pub const MMC_CSD_CSDVER_2_0: u32 = 2;
pub const MMC_CSD_CSDVER_EXT_CSD: u32 = 3;
pub const MMC_CSD_MMCVER_1_0: u32 = 0;
pub const MMC_CSD_MMCVER_1_4: u32 = 1;
pub const MMC_CSD_MMCVER_2_0: u32 = 2;
pub const MMC_CSD_MMCVER_3_1: u32 = 3;
pub const MMC_CSD_MMCVER_4_0: u32 = 4;
pub const SD_CSD_CSDVER_1_0: u32 = 0;
pub const SD_CSD_CSDVER_2_0: u32 = 1;
pub const SD_CSD_TAAC_1_5_MSEC: u32 = 38;
pub const SD_CSD_SPEED_25_MHZ: u32 = 50;
pub const SD_CSD_SPEED_50_MHZ: u32 = 90;
pub const SD_CSD_CCC_BASIC: u32 = 1;
pub const SD_CSD_CCC_BR: u32 = 4;
pub const SD_CSD_CCC_BW: u32 = 16;
pub const SD_CSD_CCC_ERASE: u32 = 32;
pub const SD_CSD_CCC_WP: u32 = 64;
pub const SD_CSD_CCC_LC: u32 = 128;
pub const SD_CSD_CCC_AS: u32 = 256;
pub const SD_CSD_CCC_IOM: u32 = 512;
pub const SD_CSD_CCC_SWITCH: u32 = 1024;
pub const SD_CSD_V2_BL_LEN: u32 = 9;
pub const SD_CSD_VDD_RW_CURR_100mA: u32 = 7;
pub const SD_CSD_VDD_RW_CURR_80mA: u32 = 6;
pub const SD_CSD_RW_BL_LEN_2G: u32 = 10;
pub const SD_CSD_RW_BL_LEN_1G: u32 = 9;
pub const SCR_STRUCTURE_VER_1_0: u32 = 0;
pub const SCR_SD_SPEC_VER_1_0: u32 = 0;
pub const SCR_SD_SPEC_VER_1_10: u32 = 1;
pub const SCR_SD_SPEC_VER_2: u32 = 2;
pub const SCR_SD_SECURITY_NONE: u32 = 0;
pub const SCR_SD_SECURITY_1_0: u32 = 1;
pub const SCR_SD_SECURITY_1_0_2: u32 = 2;
pub const SCR_SD_BUS_WIDTHS_1BIT: u32 = 1;
pub const SCR_SD_BUS_WIDTHS_4BIT: u32 = 4;
pub const SD_SFUNC_GROUP_MAX: u32 = 6;
pub const SD_SFUNC_FUNC_MAX: u32 = 15;
pub const SD_ACCESS_MODE: u32 = 1;
pub const SD_ACCESS_MODE_SDR12: u32 = 0;
pub const SD_ACCESS_MODE_SDR25: u32 = 1;
pub const SD_ACCESS_MODE_SDR50: u32 = 2;
pub const SD_ACCESS_MODE_SDR104: u32 = 3;
pub const SD_ACCESS_MODE_DDR50: u32 = 4;
pub const SD_IO_OCR_MEM_READY: u32 = 2147483648;
pub const SD_IO_OCR_MEM_PRESENT: u32 = 134217728;
pub const SD_IO_OCR_MASK: u32 = 16777200;
pub const SD_ARG_CMD52_READ: u32 = 0;
pub const SD_ARG_CMD52_WRITE: u32 = 2147483648;
pub const SD_ARG_CMD52_FUNC_SHIFT: u32 = 28;
pub const SD_ARG_CMD52_FUNC_MASK: u32 = 7;
pub const SD_ARG_CMD52_EXCHANGE: u32 = 134217728;
pub const SD_ARG_CMD52_REG_SHIFT: u32 = 9;
pub const SD_ARG_CMD52_REG_MASK: u32 = 131071;
pub const SD_ARG_CMD52_DATA_SHIFT: u32 = 0;
pub const SD_ARG_CMD52_DATA_MASK: u32 = 255;
pub const SD_ARG_CMD53_READ: u32 = 0;
pub const SD_ARG_CMD53_WRITE: u32 = 2147483648;
pub const SD_ARG_CMD53_FUNC_SHIFT: u32 = 28;
pub const SD_ARG_CMD53_FUNC_MASK: u32 = 7;
pub const SD_ARG_CMD53_BLOCK_MODE: u32 = 134217728;
pub const SD_ARG_CMD53_INCREMENT: u32 = 67108864;
pub const SD_ARG_CMD53_REG_SHIFT: u32 = 9;
pub const SD_ARG_CMD53_REG_MASK: u32 = 131071;
pub const SD_ARG_CMD53_LENGTH_SHIFT: u32 = 0;
pub const SD_ARG_CMD53_LENGTH_MASK: u32 = 511;
pub const SD_ARG_CMD53_LENGTH_MAX: u32 = 512;
pub const SD_IO_CCCR_START: u32 = 0;
pub const SD_IO_CCCR_SIZE: u32 = 256;
pub const SD_IO_CCCR_FN_ENABLE: u32 = 2;
pub const SD_IO_CCCR_FN_READY: u32 = 3;
pub const SD_IO_CCCR_INT_ENABLE: u32 = 4;
pub const SD_IO_CCCR_INT_PENDING: u32 = 5;
pub const SD_IO_CCCR_CTL: u32 = 6;
pub const CCCR_CTL_RES: u32 = 8;
pub const SD_IO_CCCR_BUS_WIDTH: u32 = 7;
pub const CCCR_BUS_WIDTH_1: u32 = 0;
pub const CCCR_BUS_WIDTH_4: u32 = 2;
pub const CCCR_BUS_WIDTH_8: u32 = 3;
pub const CCCR_BUS_WIDTH_ECSI: u32 = 32;
pub const SD_IO_CCCR_CARD_CAP: u32 = 8;
pub const SD_IO_CCCR_CISPTR: u32 = 9;
pub const SD_IO_CCCR_BLKSIZEL: u32 = 16;
pub const SD_IO_CCCR_BLKSIZEH: u32 = 17;
pub const SD_IO_CCCR_HIGHSPEED: u32 = 19;
pub const SD_IO_FBR_START: u32 = 256;
pub const SD_IO_FBR_SIZE: u32 = 1792;
pub const SD_IO_CIS_START: u32 = 4096;
pub const SD_IO_CIS_SIZE: u32 = 94208;
pub const CISTPL_CODE_NULL: u32 = 0;
pub const CISTPL_CODE_DEVICE: u32 = 1;
pub const CISTPL_CODE_CHKSUM: u32 = 16;
pub const CISTPL_CODE_VERS1: u32 = 21;
pub const CISTPL_CODE_ALTSTR: u32 = 22;
pub const CISTPL_CODE_CONFIG: u32 = 26;
pub const CISTPL_CODE_CFTABLE_ENTRY: u32 = 27;
pub const CISTPL_CODE_MANFID: u32 = 32;
pub const CISTPL_CODE_FUNCID: u32 = 33;
pub const TPLFID_FUNCTION_SDIO: u32 = 12;
pub const CISTPL_CODE_FUNCE: u32 = 34;
pub const CISTPL_CODE_VENDER_BEGIN: u32 = 128;
pub const CISTPL_CODE_VENDER_END: u32 = 143;
pub const CISTPL_CODE_SDIO_STD: u32 = 145;
pub const CISTPL_CODE_SDIO_EXT: u32 = 146;
pub const CISTPL_CODE_END: u32 = 255;
pub const SDMMC_TIMING_LEGACY: u32 = 0;
pub const SDMMC_TIMING_HIGHSPEED: u32 = 1;
pub const SDMMC_TIMING_MMC_DDR52: u32 = 2;
pub const SCF_ITSDONE: u32 = 1;
pub const SCF_CMD_AC: u32 = 0;
pub const SCF_CMD_ADTC: u32 = 16;
pub const SCF_CMD_BC: u32 = 32;
pub const SCF_CMD_BCR: u32 = 48;
pub const SCF_CMD_READ: u32 = 64;
pub const SCF_RSP_BSY: u32 = 256;
pub const SCF_RSP_136: u32 = 512;
pub const SCF_RSP_CRC: u32 = 1024;
pub const SCF_RSP_IDX: u32 = 2048;
pub const SCF_RSP_PRESENT: u32 = 4096;
pub const SCF_RSP_R0: u32 = 0;
pub const SCF_RSP_R1: u32 = 7168;
pub const SCF_RSP_R1B: u32 = 7424;
pub const SCF_RSP_R2: u32 = 5632;
pub const SCF_RSP_R3: u32 = 4096;
pub const SCF_RSP_R4: u32 = 4096;
pub const SCF_RSP_R5: u32 = 7168;
pub const SCF_RSP_R5B: u32 = 7424;
pub const SCF_RSP_R6: u32 = 7168;
pub const SCF_RSP_R7: u32 = 7168;
pub const SCF_WAIT_BUSY: u32 = 8192;
pub const SDMMC_FREQ_DEFAULT: u32 = 20000;
pub const SDMMC_FREQ_HIGHSPEED: u32 = 40000;
pub const SDMMC_FREQ_PROBING: u32 = 400;
pub const SDMMC_FREQ_52M: u32 = 52000;
pub const SDMMC_FREQ_26M: u32 = 26000;
pub const SDMMC_HOST_SLOT_0: u32 = 0;
pub const SDMMC_HOST_SLOT_1: u32 = 1;
pub const SDMMC_SLOT_WIDTH_DEFAULT: u32 = 0;
pub const LLDESC_MAX_NUM_PER_DESC: u32 = 4092;
pub const SOC_SPI_PERIPH_NUM: u32 = 3;
pub const SOC_SPI_DMA_CHAN_NUM: u32 = 2;
pub const SPI_PERIPH_NUM: u32 = 3;
pub const SPI_FUNC_NUM: u32 = 1;
pub const SPI_IOMUX_PIN_NUM_MISO: u32 = 7;
pub const SPI_IOMUX_PIN_NUM_MOSI: u32 = 8;
pub const SPI_IOMUX_PIN_NUM_CLK: u32 = 6;
pub const SPI_IOMUX_PIN_NUM_CS: u32 = 11;
pub const SPI_IOMUX_PIN_NUM_WP: u32 = 10;
pub const SPI_IOMUX_PIN_NUM_HD: u32 = 9;
pub const HSPI_FUNC_NUM: u32 = 1;
pub const SPI_D2WD_PIN_NUM_MISO: u32 = 17;
pub const SPI_D2WD_PIN_NUM_MOSI: u32 = 8;
pub const SPI_D2WD_PIN_NUM_CLK: u32 = 6;
pub const SPI_D2WD_PIN_NUM_CS: u32 = 16;
pub const SPI_D2WD_PIN_NUM_WP: u32 = 7;
pub const SPI_D2WD_PIN_NUM_HD: u32 = 11;
pub const HSPI_IOMUX_PIN_NUM_MISO: u32 = 12;
pub const HSPI_IOMUX_PIN_NUM_MOSI: u32 = 13;
pub const HSPI_IOMUX_PIN_NUM_CLK: u32 = 14;
pub const HSPI_IOMUX_PIN_NUM_CS: u32 = 15;
pub const HSPI_IOMUX_PIN_NUM_WP: u32 = 2;
pub const HSPI_IOMUX_PIN_NUM_HD: u32 = 4;
pub const VSPI_FUNC_NUM: u32 = 1;
pub const VSPI_IOMUX_PIN_NUM_MISO: u32 = 19;
pub const VSPI_IOMUX_PIN_NUM_MOSI: u32 = 23;
pub const VSPI_IOMUX_PIN_NUM_CLK: u32 = 18;
pub const VSPI_IOMUX_PIN_NUM_CS: u32 = 5;
pub const VSPI_IOMUX_PIN_NUM_WP: u32 = 22;
pub const VSPI_IOMUX_PIN_NUM_HD: u32 = 21;
pub const SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const SOC_SPI_SUPPORT_AS_CS: u32 = 1;
pub const SPI_FLASH_READ_V: u32 = 1;
pub const SPI_FLASH_READ_S: u32 = 31;
pub const SPI_FLASH_WREN_V: u32 = 1;
pub const SPI_FLASH_WREN_S: u32 = 30;
pub const SPI_FLASH_WRDI_V: u32 = 1;
pub const SPI_FLASH_WRDI_S: u32 = 29;
pub const SPI_FLASH_RDID_V: u32 = 1;
pub const SPI_FLASH_RDID_S: u32 = 28;
pub const SPI_FLASH_RDSR_V: u32 = 1;
pub const SPI_FLASH_RDSR_S: u32 = 27;
pub const SPI_FLASH_WRSR_V: u32 = 1;
pub const SPI_FLASH_WRSR_S: u32 = 26;
pub const SPI_FLASH_PP_V: u32 = 1;
pub const SPI_FLASH_PP_S: u32 = 25;
pub const SPI_FLASH_SE_V: u32 = 1;
pub const SPI_FLASH_SE_S: u32 = 24;
pub const SPI_FLASH_BE_V: u32 = 1;
pub const SPI_FLASH_BE_S: u32 = 23;
pub const SPI_FLASH_CE_V: u32 = 1;
pub const SPI_FLASH_CE_S: u32 = 22;
pub const SPI_FLASH_DP_V: u32 = 1;
pub const SPI_FLASH_DP_S: u32 = 21;
pub const SPI_FLASH_RES_V: u32 = 1;
pub const SPI_FLASH_RES_S: u32 = 20;
pub const SPI_FLASH_HPM_V: u32 = 1;
pub const SPI_FLASH_HPM_S: u32 = 19;
pub const SPI_USR_V: u32 = 1;
pub const SPI_USR_S: u32 = 18;
pub const SPI_FLASH_PES_V: u32 = 1;
pub const SPI_FLASH_PES_S: u32 = 17;
pub const SPI_FLASH_PER_V: u32 = 1;
pub const SPI_FLASH_PER_S: u32 = 16;
pub const SPI_WR_BIT_ORDER_V: u32 = 1;
pub const SPI_WR_BIT_ORDER_S: u32 = 26;
pub const SPI_RD_BIT_ORDER_V: u32 = 1;
pub const SPI_RD_BIT_ORDER_S: u32 = 25;
pub const SPI_FREAD_QIO_V: u32 = 1;
pub const SPI_FREAD_QIO_S: u32 = 24;
pub const SPI_FREAD_DIO_V: u32 = 1;
pub const SPI_FREAD_DIO_S: u32 = 23;
pub const SPI_WRSR_2B_V: u32 = 1;
pub const SPI_WRSR_2B_S: u32 = 22;
pub const SPI_WP_REG_V: u32 = 1;
pub const SPI_WP_REG_S: u32 = 21;
pub const SPI_FREAD_QUAD_V: u32 = 1;
pub const SPI_FREAD_QUAD_S: u32 = 20;
pub const SPI_RESANDRES_V: u32 = 1;
pub const SPI_RESANDRES_S: u32 = 15;
pub const SPI_FREAD_DUAL_V: u32 = 1;
pub const SPI_FREAD_DUAL_S: u32 = 14;
pub const SPI_FASTRD_MODE_V: u32 = 1;
pub const SPI_FASTRD_MODE_S: u32 = 13;
pub const SPI_WAIT_FLASH_IDLE_EN_V: u32 = 1;
pub const SPI_WAIT_FLASH_IDLE_EN_S: u32 = 12;
pub const SPI_TX_CRC_EN_V: u32 = 1;
pub const SPI_TX_CRC_EN_S: u32 = 11;
pub const SPI_FCS_CRC_EN_V: u32 = 1;
pub const SPI_FCS_CRC_EN_S: u32 = 10;
pub const SPI_CS_HOLD_DELAY: u32 = 15;
pub const SPI_CS_HOLD_DELAY_V: u32 = 15;
pub const SPI_CS_HOLD_DELAY_S: u32 = 28;
pub const SPI_CS_HOLD_DELAY_RES: u32 = 4095;
pub const SPI_CS_HOLD_DELAY_RES_V: u32 = 4095;
pub const SPI_CS_HOLD_DELAY_RES_S: u32 = 16;
pub const SPI_STATUS_EXT: u32 = 255;
pub const SPI_STATUS_EXT_V: u32 = 255;
pub const SPI_STATUS_EXT_S: u32 = 24;
pub const SPI_WB_MODE: u32 = 255;
pub const SPI_WB_MODE_V: u32 = 255;
pub const SPI_WB_MODE_S: u32 = 16;
pub const SPI_STATUS: u32 = 65535;
pub const SPI_STATUS_V: u32 = 65535;
pub const SPI_STATUS_S: u32 = 0;
pub const SPI_CS_DELAY_NUM: u32 = 15;
pub const SPI_CS_DELAY_NUM_V: u32 = 15;
pub const SPI_CS_DELAY_NUM_S: u32 = 28;
pub const SPI_CS_DELAY_MODE: u32 = 3;
pub const SPI_CS_DELAY_MODE_V: u32 = 3;
pub const SPI_CS_DELAY_MODE_S: u32 = 26;
pub const SPI_MOSI_DELAY_NUM: u32 = 7;
pub const SPI_MOSI_DELAY_NUM_V: u32 = 7;
pub const SPI_MOSI_DELAY_NUM_S: u32 = 23;
pub const SPI_MOSI_DELAY_MODE: u32 = 3;
pub const SPI_MOSI_DELAY_MODE_V: u32 = 3;
pub const SPI_MOSI_DELAY_MODE_S: u32 = 21;
pub const SPI_MISO_DELAY_NUM: u32 = 7;
pub const SPI_MISO_DELAY_NUM_V: u32 = 7;
pub const SPI_MISO_DELAY_NUM_S: u32 = 18;
pub const SPI_MISO_DELAY_MODE: u32 = 3;
pub const SPI_MISO_DELAY_MODE_V: u32 = 3;
pub const SPI_MISO_DELAY_MODE_S: u32 = 16;
pub const SPI_CK_OUT_HIGH_MODE: u32 = 15;
pub const SPI_CK_OUT_HIGH_MODE_V: u32 = 15;
pub const SPI_CK_OUT_HIGH_MODE_S: u32 = 12;
pub const SPI_CK_OUT_LOW_MODE: u32 = 15;
pub const SPI_CK_OUT_LOW_MODE_V: u32 = 15;
pub const SPI_CK_OUT_LOW_MODE_S: u32 = 8;
pub const SPI_HOLD_TIME: u32 = 15;
pub const SPI_HOLD_TIME_V: u32 = 15;
pub const SPI_HOLD_TIME_S: u32 = 4;
pub const SPI_SETUP_TIME: u32 = 15;
pub const SPI_SETUP_TIME_V: u32 = 15;
pub const SPI_SETUP_TIME_S: u32 = 0;
pub const SPI_CLK_EQU_SYSCLK_V: u32 = 1;
pub const SPI_CLK_EQU_SYSCLK_S: u32 = 31;
pub const SPI_CLKDIV_PRE: u32 = 8191;
pub const SPI_CLKDIV_PRE_V: u32 = 8191;
pub const SPI_CLKDIV_PRE_S: u32 = 18;
pub const SPI_CLKCNT_N: u32 = 63;
pub const SPI_CLKCNT_N_V: u32 = 63;
pub const SPI_CLKCNT_N_S: u32 = 12;
pub const SPI_CLKCNT_H: u32 = 63;
pub const SPI_CLKCNT_H_V: u32 = 63;
pub const SPI_CLKCNT_H_S: u32 = 6;
pub const SPI_CLKCNT_L: u32 = 63;
pub const SPI_CLKCNT_L_V: u32 = 63;
pub const SPI_CLKCNT_L_S: u32 = 0;
pub const SPI_USR_COMMAND_V: u32 = 1;
pub const SPI_USR_COMMAND_S: u32 = 31;
pub const SPI_USR_ADDR_V: u32 = 1;
pub const SPI_USR_ADDR_S: u32 = 30;
pub const SPI_USR_DUMMY_V: u32 = 1;
pub const SPI_USR_DUMMY_S: u32 = 29;
pub const SPI_USR_MISO_V: u32 = 1;
pub const SPI_USR_MISO_S: u32 = 28;
pub const SPI_USR_MOSI_V: u32 = 1;
pub const SPI_USR_MOSI_S: u32 = 27;
pub const SPI_USR_DUMMY_IDLE_V: u32 = 1;
pub const SPI_USR_DUMMY_IDLE_S: u32 = 26;
pub const SPI_USR_MOSI_HIGHPART_V: u32 = 1;
pub const SPI_USR_MOSI_HIGHPART_S: u32 = 25;
pub const SPI_USR_MISO_HIGHPART_V: u32 = 1;
pub const SPI_USR_MISO_HIGHPART_S: u32 = 24;
pub const SPI_USR_PREP_HOLD_V: u32 = 1;
pub const SPI_USR_PREP_HOLD_S: u32 = 23;
pub const SPI_USR_CMD_HOLD_V: u32 = 1;
pub const SPI_USR_CMD_HOLD_S: u32 = 22;
pub const SPI_USR_ADDR_HOLD_V: u32 = 1;
pub const SPI_USR_ADDR_HOLD_S: u32 = 21;
pub const SPI_USR_DUMMY_HOLD_V: u32 = 1;
pub const SPI_USR_DUMMY_HOLD_S: u32 = 20;
pub const SPI_USR_DIN_HOLD_V: u32 = 1;
pub const SPI_USR_DIN_HOLD_S: u32 = 19;
pub const SPI_USR_DOUT_HOLD_V: u32 = 1;
pub const SPI_USR_DOUT_HOLD_S: u32 = 18;
pub const SPI_USR_HOLD_POL_V: u32 = 1;
pub const SPI_USR_HOLD_POL_S: u32 = 17;
pub const SPI_SIO_V: u32 = 1;
pub const SPI_SIO_S: u32 = 16;
pub const SPI_FWRITE_QIO_V: u32 = 1;
pub const SPI_FWRITE_QIO_S: u32 = 15;
pub const SPI_FWRITE_DIO_V: u32 = 1;
pub const SPI_FWRITE_DIO_S: u32 = 14;
pub const SPI_FWRITE_QUAD_V: u32 = 1;
pub const SPI_FWRITE_QUAD_S: u32 = 13;
pub const SPI_FWRITE_DUAL_V: u32 = 1;
pub const SPI_FWRITE_DUAL_S: u32 = 12;
pub const SPI_WR_BYTE_ORDER_V: u32 = 1;
pub const SPI_WR_BYTE_ORDER_S: u32 = 11;
pub const SPI_RD_BYTE_ORDER_V: u32 = 1;
pub const SPI_RD_BYTE_ORDER_S: u32 = 10;
pub const SPI_CK_OUT_EDGE_V: u32 = 1;
pub const SPI_CK_OUT_EDGE_S: u32 = 7;
pub const SPI_CK_I_EDGE_V: u32 = 1;
pub const SPI_CK_I_EDGE_S: u32 = 6;
pub const SPI_CS_SETUP_V: u32 = 1;
pub const SPI_CS_SETUP_S: u32 = 5;
pub const SPI_CS_HOLD_V: u32 = 1;
pub const SPI_CS_HOLD_S: u32 = 4;
pub const SPI_DOUTDIN_V: u32 = 1;
pub const SPI_DOUTDIN_S: u32 = 0;
pub const SPI_USR_ADDR_BITLEN: u32 = 63;
pub const SPI_USR_ADDR_BITLEN_V: u32 = 63;
pub const SPI_USR_ADDR_BITLEN_S: u32 = 26;
pub const SPI_USR_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_USR_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_USR_DUMMY_CYCLELEN_S: u32 = 0;
pub const SPI_USR_COMMAND_BITLEN: u32 = 15;
pub const SPI_USR_COMMAND_BITLEN_V: u32 = 15;
pub const SPI_USR_COMMAND_BITLEN_S: u32 = 28;
pub const SPI_USR_COMMAND_VALUE: u32 = 65535;
pub const SPI_USR_COMMAND_VALUE_V: u32 = 65535;
pub const SPI_USR_COMMAND_VALUE_S: u32 = 0;
pub const SPI_USR_MOSI_DBITLEN: u32 = 16777215;
pub const SPI_USR_MOSI_DBITLEN_V: u32 = 16777215;
pub const SPI_USR_MOSI_DBITLEN_S: u32 = 0;
pub const SPI_USR_MISO_DBITLEN: u32 = 16777215;
pub const SPI_USR_MISO_DBITLEN_V: u32 = 16777215;
pub const SPI_USR_MISO_DBITLEN_S: u32 = 0;
pub const SPI_SLV_WR_ST: u32 = 4294967295;
pub const SPI_SLV_WR_ST_V: u32 = 4294967295;
pub const SPI_SLV_WR_ST_S: u32 = 0;
pub const SPI_CS_KEEP_ACTIVE_V: u32 = 1;
pub const SPI_CS_KEEP_ACTIVE_S: u32 = 30;
pub const SPI_CK_IDLE_EDGE_V: u32 = 1;
pub const SPI_CK_IDLE_EDGE_S: u32 = 29;
pub const SPI_MASTER_CK_SEL: u32 = 7;
pub const SPI_MASTER_CK_SEL_V: u32 = 7;
pub const SPI_MASTER_CK_SEL_S: u32 = 11;
pub const SPI_MASTER_CS_POL: u32 = 7;
pub const SPI_MASTER_CS_POL_V: u32 = 7;
pub const SPI_MASTER_CS_POL_S: u32 = 6;
pub const SPI_CK_DIS_V: u32 = 1;
pub const SPI_CK_DIS_S: u32 = 5;
pub const SPI_CS2_DIS_V: u32 = 1;
pub const SPI_CS2_DIS_S: u32 = 2;
pub const SPI_CS1_DIS_V: u32 = 1;
pub const SPI_CS1_DIS_S: u32 = 1;
pub const SPI_CS0_DIS_V: u32 = 1;
pub const SPI_CS0_DIS_S: u32 = 0;
pub const SPI_SYNC_RESET_V: u32 = 1;
pub const SPI_SYNC_RESET_S: u32 = 31;
pub const SPI_SLAVE_MODE_V: u32 = 1;
pub const SPI_SLAVE_MODE_S: u32 = 30;
pub const SPI_SLV_WR_RD_BUF_EN_V: u32 = 1;
pub const SPI_SLV_WR_RD_BUF_EN_S: u32 = 29;
pub const SPI_SLV_WR_RD_STA_EN_V: u32 = 1;
pub const SPI_SLV_WR_RD_STA_EN_S: u32 = 28;
pub const SPI_SLV_CMD_DEFINE_V: u32 = 1;
pub const SPI_SLV_CMD_DEFINE_S: u32 = 27;
pub const SPI_TRANS_CNT: u32 = 15;
pub const SPI_TRANS_CNT_V: u32 = 15;
pub const SPI_TRANS_CNT_S: u32 = 23;
pub const SPI_SLV_LAST_STATE: u32 = 7;
pub const SPI_SLV_LAST_STATE_V: u32 = 7;
pub const SPI_SLV_LAST_STATE_S: u32 = 20;
pub const SPI_SLV_LAST_COMMAND: u32 = 7;
pub const SPI_SLV_LAST_COMMAND_V: u32 = 7;
pub const SPI_SLV_LAST_COMMAND_S: u32 = 17;
pub const SPI_CS_I_MODE: u32 = 3;
pub const SPI_CS_I_MODE_V: u32 = 3;
pub const SPI_CS_I_MODE_S: u32 = 10;
pub const SPI_INT_EN: u32 = 31;
pub const SPI_INT_EN_V: u32 = 31;
pub const SPI_INT_EN_S: u32 = 5;
pub const SPI_TRANS_DONE_V: u32 = 1;
pub const SPI_TRANS_DONE_S: u32 = 4;
pub const SPI_SLV_WR_STA_DONE_V: u32 = 1;
pub const SPI_SLV_WR_STA_DONE_S: u32 = 3;
pub const SPI_SLV_RD_STA_DONE_V: u32 = 1;
pub const SPI_SLV_RD_STA_DONE_S: u32 = 2;
pub const SPI_SLV_WR_BUF_DONE_V: u32 = 1;
pub const SPI_SLV_WR_BUF_DONE_S: u32 = 1;
pub const SPI_SLV_RD_BUF_DONE_V: u32 = 1;
pub const SPI_SLV_RD_BUF_DONE_S: u32 = 0;
pub const SPI_SLV_STATUS_BITLEN: u32 = 31;
pub const SPI_SLV_STATUS_BITLEN_V: u32 = 31;
pub const SPI_SLV_STATUS_BITLEN_S: u32 = 27;
pub const SPI_SLV_STATUS_FAST_EN_V: u32 = 1;
pub const SPI_SLV_STATUS_FAST_EN_S: u32 = 26;
pub const SPI_SLV_STATUS_READBACK_V: u32 = 1;
pub const SPI_SLV_STATUS_READBACK_S: u32 = 25;
pub const SPI_SLV_RD_ADDR_BITLEN: u32 = 63;
pub const SPI_SLV_RD_ADDR_BITLEN_V: u32 = 63;
pub const SPI_SLV_RD_ADDR_BITLEN_S: u32 = 10;
pub const SPI_SLV_WR_ADDR_BITLEN: u32 = 63;
pub const SPI_SLV_WR_ADDR_BITLEN_V: u32 = 63;
pub const SPI_SLV_WR_ADDR_BITLEN_S: u32 = 4;
pub const SPI_SLV_WRSTA_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_WRSTA_DUMMY_EN_S: u32 = 3;
pub const SPI_SLV_RDSTA_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_RDSTA_DUMMY_EN_S: u32 = 2;
pub const SPI_SLV_WRBUF_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_WRBUF_DUMMY_EN_S: u32 = 1;
pub const SPI_SLV_RDBUF_DUMMY_EN_V: u32 = 1;
pub const SPI_SLV_RDBUF_DUMMY_EN_S: u32 = 0;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_WRBUF_DUMMY_CYCLELEN_S: u32 = 24;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_RDBUF_DUMMY_CYCLELEN_S: u32 = 16;
pub const SPI_SLV_WRSTA_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_WRSTA_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_WRSTA_DUMMY_CYCLELEN_S: u32 = 8;
pub const SPI_SLV_RDSTA_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SLV_RDSTA_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SLV_RDSTA_DUMMY_CYCLELEN_S: u32 = 0;
pub const SPI_SLV_WRSTA_CMD_VALUE: u32 = 255;
pub const SPI_SLV_WRSTA_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_WRSTA_CMD_VALUE_S: u32 = 24;
pub const SPI_SLV_RDSTA_CMD_VALUE: u32 = 255;
pub const SPI_SLV_RDSTA_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_RDSTA_CMD_VALUE_S: u32 = 16;
pub const SPI_SLV_WRBUF_CMD_VALUE: u32 = 255;
pub const SPI_SLV_WRBUF_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_WRBUF_CMD_VALUE_S: u32 = 8;
pub const SPI_SLV_RDBUF_CMD_VALUE: u32 = 255;
pub const SPI_SLV_RDBUF_CMD_VALUE_V: u32 = 255;
pub const SPI_SLV_RDBUF_CMD_VALUE_S: u32 = 0;
pub const SPI_SLV_WRBUF_DBITLEN: u32 = 16777215;
pub const SPI_SLV_WRBUF_DBITLEN_V: u32 = 16777215;
pub const SPI_SLV_WRBUF_DBITLEN_S: u32 = 0;
pub const SPI_SLV_RDBUF_DBITLEN: u32 = 16777215;
pub const SPI_SLV_RDBUF_DBITLEN_V: u32 = 16777215;
pub const SPI_SLV_RDBUF_DBITLEN_S: u32 = 0;
pub const SPI_CACHE_FLASH_PES_EN_V: u32 = 1;
pub const SPI_CACHE_FLASH_PES_EN_S: u32 = 3;
pub const SPI_CACHE_FLASH_USR_CMD_V: u32 = 1;
pub const SPI_CACHE_FLASH_USR_CMD_S: u32 = 2;
pub const SPI_CACHE_USR_CMD_4BYTE_V: u32 = 1;
pub const SPI_CACHE_USR_CMD_4BYTE_S: u32 = 1;
pub const SPI_CACHE_REQ_EN_V: u32 = 1;
pub const SPI_CACHE_REQ_EN_S: u32 = 0;
pub const SPI_CACHE_SRAM_USR_WCMD_V: u32 = 1;
pub const SPI_CACHE_SRAM_USR_WCMD_S: u32 = 28;
pub const SPI_SRAM_ADDR_BITLEN: u32 = 63;
pub const SPI_SRAM_ADDR_BITLEN_V: u32 = 63;
pub const SPI_SRAM_ADDR_BITLEN_S: u32 = 22;
pub const SPI_SRAM_DUMMY_CYCLELEN: u32 = 255;
pub const SPI_SRAM_DUMMY_CYCLELEN_V: u32 = 255;
pub const SPI_SRAM_DUMMY_CYCLELEN_S: u32 = 14;
pub const SPI_SRAM_BYTES_LEN: u32 = 255;
pub const SPI_SRAM_BYTES_LEN_V: u32 = 255;
pub const SPI_SRAM_BYTES_LEN_S: u32 = 6;
pub const SPI_CACHE_SRAM_USR_RCMD_V: u32 = 1;
pub const SPI_CACHE_SRAM_USR_RCMD_S: u32 = 5;
pub const SPI_USR_RD_SRAM_DUMMY_V: u32 = 1;
pub const SPI_USR_RD_SRAM_DUMMY_S: u32 = 4;
pub const SPI_USR_WR_SRAM_DUMMY_V: u32 = 1;
pub const SPI_USR_WR_SRAM_DUMMY_S: u32 = 3;
pub const SPI_USR_SRAM_QIO_V: u32 = 1;
pub const SPI_USR_SRAM_QIO_S: u32 = 2;
pub const SPI_USR_SRAM_DIO_V: u32 = 1;
pub const SPI_USR_SRAM_DIO_S: u32 = 1;
pub const SPI_SRAM_RSTIO_V: u32 = 1;
pub const SPI_SRAM_RSTIO_S: u32 = 4;
pub const SPI_SRAM_QIO_V: u32 = 1;
pub const SPI_SRAM_QIO_S: u32 = 1;
pub const SPI_SRAM_DIO_V: u32 = 1;
pub const SPI_SRAM_DIO_S: u32 = 0;
pub const SPI_CACHE_SRAM_USR_RD_CMD_BITLEN: u32 = 15;
pub const SPI_CACHE_SRAM_USR_RD_CMD_BITLEN_V: u32 = 15;
pub const SPI_CACHE_SRAM_USR_RD_CMD_BITLEN_S: u32 = 28;
pub const SPI_CACHE_SRAM_USR_RD_CMD_VALUE: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_RD_CMD_VALUE_V: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_RD_CMD_VALUE_S: u32 = 0;
pub const SPI_CACHE_SRAM_USR_WR_CMD_BITLEN: u32 = 15;
pub const SPI_CACHE_SRAM_USR_WR_CMD_BITLEN_V: u32 = 15;
pub const SPI_CACHE_SRAM_USR_WR_CMD_BITLEN_S: u32 = 28;
pub const SPI_CACHE_SRAM_USR_WR_CMD_VALUE: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_WR_CMD_VALUE_V: u32 = 65535;
pub const SPI_CACHE_SRAM_USR_WR_CMD_VALUE_S: u32 = 0;
pub const SPI_SLV_RDATA_BIT: u32 = 16777215;
pub const SPI_SLV_RDATA_BIT_V: u32 = 16777215;
pub const SPI_SLV_RDATA_BIT_S: u32 = 0;
pub const SPI_BUF0: u32 = 4294967295;
pub const SPI_BUF0_V: u32 = 4294967295;
pub const SPI_BUF0_S: u32 = 0;
pub const SPI_BUF1: u32 = 4294967295;
pub const SPI_BUF1_V: u32 = 4294967295;
pub const SPI_BUF1_S: u32 = 0;
pub const SPI_BUF2: u32 = 4294967295;
pub const SPI_BUF2_V: u32 = 4294967295;
pub const SPI_BUF2_S: u32 = 0;
pub const SPI_BUF3: u32 = 4294967295;
pub const SPI_BUF3_V: u32 = 4294967295;
pub const SPI_BUF3_S: u32 = 0;
pub const SPI_BUF4: u32 = 4294967295;
pub const SPI_BUF4_V: u32 = 4294967295;
pub const SPI_BUF4_S: u32 = 0;
pub const SPI_BUF5: u32 = 4294967295;
pub const SPI_BUF5_V: u32 = 4294967295;
pub const SPI_BUF5_S: u32 = 0;
pub const SPI_BUF6: u32 = 4294967295;
pub const SPI_BUF6_V: u32 = 4294967295;
pub const SPI_BUF6_S: u32 = 0;
pub const SPI_BUF7: u32 = 4294967295;
pub const SPI_BUF7_V: u32 = 4294967295;
pub const SPI_BUF7_S: u32 = 0;
pub const SPI_BUF8: u32 = 4294967295;
pub const SPI_BUF8_V: u32 = 4294967295;
pub const SPI_BUF8_S: u32 = 0;
pub const SPI_BUF9: u32 = 4294967295;
pub const SPI_BUF9_V: u32 = 4294967295;
pub const SPI_BUF9_S: u32 = 0;
pub const SPI_BUF10: u32 = 4294967295;
pub const SPI_BUF10_V: u32 = 4294967295;
pub const SPI_BUF10_S: u32 = 0;
pub const SPI_BUF11: u32 = 4294967295;
pub const SPI_BUF11_V: u32 = 4294967295;
pub const SPI_BUF11_S: u32 = 0;
pub const SPI_BUF12: u32 = 4294967295;
pub const SPI_BUF12_V: u32 = 4294967295;
pub const SPI_BUF12_S: u32 = 0;
pub const SPI_BUF13: u32 = 4294967295;
pub const SPI_BUF13_V: u32 = 4294967295;
pub const SPI_BUF13_S: u32 = 0;
pub const SPI_BUF14: u32 = 4294967295;
pub const SPI_BUF14_V: u32 = 4294967295;
pub const SPI_BUF14_S: u32 = 0;
pub const SPI_BUF15: u32 = 4294967295;
pub const SPI_BUF15_V: u32 = 4294967295;
pub const SPI_BUF15_S: u32 = 0;
pub const SPI_TX_CRC_DATA: u32 = 4294967295;
pub const SPI_TX_CRC_DATA_V: u32 = 4294967295;
pub const SPI_TX_CRC_DATA_S: u32 = 0;
pub const SPI_T_PP_ENA_V: u32 = 1;
pub const SPI_T_PP_ENA_S: u32 = 31;
pub const SPI_T_PP_SHIFT: u32 = 15;
pub const SPI_T_PP_SHIFT_V: u32 = 15;
pub const SPI_T_PP_SHIFT_S: u32 = 16;
pub const SPI_T_PP_TIME: u32 = 4095;
pub const SPI_T_PP_TIME_V: u32 = 4095;
pub const SPI_T_PP_TIME_S: u32 = 0;
pub const SPI_T_ERASE_ENA_V: u32 = 1;
pub const SPI_T_ERASE_ENA_S: u32 = 31;
pub const SPI_T_ERASE_SHIFT: u32 = 15;
pub const SPI_T_ERASE_SHIFT_V: u32 = 15;
pub const SPI_T_ERASE_SHIFT_S: u32 = 16;
pub const SPI_T_ERASE_TIME: u32 = 4095;
pub const SPI_T_ERASE_TIME_V: u32 = 4095;
pub const SPI_T_ERASE_TIME_S: u32 = 0;
pub const SPI_ST: u32 = 7;
pub const SPI_ST_V: u32 = 7;
pub const SPI_ST_S: u32 = 0;
pub const SPI_INT_HOLD_ENA: u32 = 3;
pub const SPI_INT_HOLD_ENA_V: u32 = 3;
pub const SPI_INT_HOLD_ENA_S: u32 = 0;
pub const SPI_DMA_CONTINUE_V: u32 = 1;
pub const SPI_DMA_CONTINUE_S: u32 = 16;
pub const SPI_DMA_TX_STOP_V: u32 = 1;
pub const SPI_DMA_TX_STOP_S: u32 = 15;
pub const SPI_DMA_RX_STOP_V: u32 = 1;
pub const SPI_DMA_RX_STOP_S: u32 = 14;
pub const SPI_OUT_DATA_BURST_EN_V: u32 = 1;
pub const SPI_OUT_DATA_BURST_EN_S: u32 = 12;
pub const SPI_INDSCR_BURST_EN_V: u32 = 1;
pub const SPI_INDSCR_BURST_EN_S: u32 = 11;
pub const SPI_OUTDSCR_BURST_EN_V: u32 = 1;
pub const SPI_OUTDSCR_BURST_EN_S: u32 = 10;
pub const SPI_OUT_EOF_MODE_V: u32 = 1;
pub const SPI_OUT_EOF_MODE_S: u32 = 9;
pub const SPI_OUT_AUTO_WRBACK_V: u32 = 1;
pub const SPI_OUT_AUTO_WRBACK_S: u32 = 8;
pub const SPI_OUT_LOOP_TEST_V: u32 = 1;
pub const SPI_OUT_LOOP_TEST_S: u32 = 7;
pub const SPI_IN_LOOP_TEST_V: u32 = 1;
pub const SPI_IN_LOOP_TEST_S: u32 = 6;
pub const SPI_AHBM_RST_V: u32 = 1;
pub const SPI_AHBM_RST_S: u32 = 5;
pub const SPI_AHBM_FIFO_RST_V: u32 = 1;
pub const SPI_AHBM_FIFO_RST_S: u32 = 4;
pub const SPI_OUT_RST_V: u32 = 1;
pub const SPI_OUT_RST_S: u32 = 3;
pub const SPI_IN_RST_V: u32 = 1;
pub const SPI_IN_RST_S: u32 = 2;
pub const SPI_OUTLINK_RESTART_V: u32 = 1;
pub const SPI_OUTLINK_RESTART_S: u32 = 30;
pub const SPI_OUTLINK_START_V: u32 = 1;
pub const SPI_OUTLINK_START_S: u32 = 29;
pub const SPI_OUTLINK_STOP_V: u32 = 1;
pub const SPI_OUTLINK_STOP_S: u32 = 28;
pub const SPI_OUTLINK_ADDR: u32 = 1048575;
pub const SPI_OUTLINK_ADDR_V: u32 = 1048575;
pub const SPI_OUTLINK_ADDR_S: u32 = 0;
pub const SPI_INLINK_RESTART_V: u32 = 1;
pub const SPI_INLINK_RESTART_S: u32 = 30;
pub const SPI_INLINK_START_V: u32 = 1;
pub const SPI_INLINK_START_S: u32 = 29;
pub const SPI_INLINK_STOP_V: u32 = 1;
pub const SPI_INLINK_STOP_S: u32 = 28;
pub const SPI_INLINK_AUTO_RET_V: u32 = 1;
pub const SPI_INLINK_AUTO_RET_S: u32 = 20;
pub const SPI_INLINK_ADDR: u32 = 1048575;
pub const SPI_INLINK_ADDR_V: u32 = 1048575;
pub const SPI_INLINK_ADDR_S: u32 = 0;
pub const SPI_DMA_TX_EN_V: u32 = 1;
pub const SPI_DMA_TX_EN_S: u32 = 1;
pub const SPI_DMA_RX_EN_V: u32 = 1;
pub const SPI_DMA_RX_EN_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_ENA_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_ENA_S: u32 = 8;
pub const SPI_OUT_EOF_INT_ENA_V: u32 = 1;
pub const SPI_OUT_EOF_INT_ENA_S: u32 = 7;
pub const SPI_OUT_DONE_INT_ENA_V: u32 = 1;
pub const SPI_OUT_DONE_INT_ENA_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_ENA_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_ENA_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_ENA_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_ENA_S: u32 = 4;
pub const SPI_IN_DONE_INT_ENA_V: u32 = 1;
pub const SPI_IN_DONE_INT_ENA_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_ENA_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_ENA_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ENA_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ENA_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ENA_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ENA_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_RAW_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_RAW_S: u32 = 8;
pub const SPI_OUT_EOF_INT_RAW_V: u32 = 1;
pub const SPI_OUT_EOF_INT_RAW_S: u32 = 7;
pub const SPI_OUT_DONE_INT_RAW_V: u32 = 1;
pub const SPI_OUT_DONE_INT_RAW_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_RAW_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_RAW_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_RAW_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_RAW_S: u32 = 4;
pub const SPI_IN_DONE_INT_RAW_V: u32 = 1;
pub const SPI_IN_DONE_INT_RAW_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_RAW_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_RAW_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_RAW_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_RAW_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_RAW_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_RAW_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_ST_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_ST_S: u32 = 8;
pub const SPI_OUT_EOF_INT_ST_V: u32 = 1;
pub const SPI_OUT_EOF_INT_ST_S: u32 = 7;
pub const SPI_OUT_DONE_INT_ST_V: u32 = 1;
pub const SPI_OUT_DONE_INT_ST_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_ST_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_ST_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_ST_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_ST_S: u32 = 4;
pub const SPI_IN_DONE_INT_ST_V: u32 = 1;
pub const SPI_IN_DONE_INT_ST_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_ST_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_ST_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ST_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_ST_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ST_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_ST_S: u32 = 0;
pub const SPI_OUT_TOTAL_EOF_INT_CLR_V: u32 = 1;
pub const SPI_OUT_TOTAL_EOF_INT_CLR_S: u32 = 8;
pub const SPI_OUT_EOF_INT_CLR_V: u32 = 1;
pub const SPI_OUT_EOF_INT_CLR_S: u32 = 7;
pub const SPI_OUT_DONE_INT_CLR_V: u32 = 1;
pub const SPI_OUT_DONE_INT_CLR_S: u32 = 6;
pub const SPI_IN_SUC_EOF_INT_CLR_V: u32 = 1;
pub const SPI_IN_SUC_EOF_INT_CLR_S: u32 = 5;
pub const SPI_IN_ERR_EOF_INT_CLR_V: u32 = 1;
pub const SPI_IN_ERR_EOF_INT_CLR_S: u32 = 4;
pub const SPI_IN_DONE_INT_CLR_V: u32 = 1;
pub const SPI_IN_DONE_INT_CLR_S: u32 = 3;
pub const SPI_INLINK_DSCR_ERROR_INT_CLR_V: u32 = 1;
pub const SPI_INLINK_DSCR_ERROR_INT_CLR_S: u32 = 2;
pub const SPI_OUTLINK_DSCR_ERROR_INT_CLR_V: u32 = 1;
pub const SPI_OUTLINK_DSCR_ERROR_INT_CLR_S: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_CLR_V: u32 = 1;
pub const SPI_INLINK_DSCR_EMPTY_INT_CLR_S: u32 = 0;
pub const SPI_DMA_IN_ERR_EOF_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_IN_ERR_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_IN_ERR_EOF_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_IN_SUC_EOF_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_IN_SUC_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_IN_SUC_EOF_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_INLINK_DSCR: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_V: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_S: u32 = 0;
pub const SPI_DMA_INLINK_DSCR_BF0: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF0_S: u32 = 0;
pub const SPI_DMA_INLINK_DSCR_BF1: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SPI_DMA_INLINK_DSCR_BF1_S: u32 = 0;
pub const SPI_DMA_OUT_EOF_BFR_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_BFR_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_BFR_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_OUT_EOF_DES_ADDR: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_DES_ADDR_V: u32 = 4294967295;
pub const SPI_DMA_OUT_EOF_DES_ADDR_S: u32 = 0;
pub const SPI_DMA_OUTLINK_DSCR: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_V: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_S: u32 = 0;
pub const SPI_DMA_OUTLINK_DSCR_BF0: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF0_V: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF0_S: u32 = 0;
pub const SPI_DMA_OUTLINK_DSCR_BF1: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF1_V: u32 = 4294967295;
pub const SPI_DMA_OUTLINK_DSCR_BF1_S: u32 = 0;
pub const SPI_DMA_OUT_STATUS: u32 = 4294967295;
pub const SPI_DMA_OUT_STATUS_V: u32 = 4294967295;
pub const SPI_DMA_OUT_STATUS_S: u32 = 0;
pub const SPI_DMA_IN_STATUS: u32 = 4294967295;
pub const SPI_DMA_IN_STATUS_V: u32 = 4294967295;
pub const SPI_DMA_IN_STATUS_S: u32 = 0;
pub const SPI_DATE: u32 = 268435455;
pub const SPI_DATE_V: u32 = 268435455;
pub const SPI_DATE_S: u32 = 0;
pub const SPI_MAX_DMA_LEN: u32 = 4092;
pub const SPICOMMON_BUSFLAG_SLAVE: u32 = 0;
pub const SPICOMMON_BUSFLAG_MASTER: u32 = 1;
pub const SPICOMMON_BUSFLAG_IOMUX_PINS: u32 = 2;
pub const SPICOMMON_BUSFLAG_SCLK: u32 = 4;
pub const SPICOMMON_BUSFLAG_MISO: u32 = 8;
pub const SPICOMMON_BUSFLAG_MOSI: u32 = 16;
pub const SPICOMMON_BUSFLAG_DUAL: u32 = 32;
pub const SPICOMMON_BUSFLAG_WPHD: u32 = 64;
pub const SPICOMMON_BUSFLAG_QUAD: u32 = 96;
pub const SPICOMMON_BUSFLAG_NATIVE_PINS: u32 = 2;
pub const SPI_MASTER_FREQ_8M: u32 = 8000000;
pub const SPI_MASTER_FREQ_9M: u32 = 8888888;
pub const SPI_MASTER_FREQ_10M: u32 = 10000000;
pub const SPI_MASTER_FREQ_11M: u32 = 11428571;
pub const SPI_MASTER_FREQ_13M: u32 = 13333333;
pub const SPI_MASTER_FREQ_16M: u32 = 16000000;
pub const SPI_MASTER_FREQ_20M: u32 = 20000000;
pub const SPI_MASTER_FREQ_26M: u32 = 26666666;
pub const SPI_MASTER_FREQ_40M: u32 = 40000000;
pub const SPI_MASTER_FREQ_80M: u32 = 80000000;
pub const SPI_DEVICE_TXBIT_LSBFIRST: u32 = 1;
pub const SPI_DEVICE_RXBIT_LSBFIRST: u32 = 2;
pub const SPI_DEVICE_BIT_LSBFIRST: u32 = 3;
pub const SPI_DEVICE_3WIRE: u32 = 4;
pub const SPI_DEVICE_POSITIVE_CS: u32 = 8;
pub const SPI_DEVICE_HALFDUPLEX: u32 = 16;
pub const SPI_DEVICE_CLK_AS_CS: u32 = 32;
pub const SPI_DEVICE_NO_DUMMY: u32 = 64;
pub const SPI_DEVICE_DDRCLK: u32 = 128;
pub const SPI_TRANS_MODE_DIO: u32 = 1;
pub const SPI_TRANS_MODE_QIO: u32 = 2;
pub const SPI_TRANS_USE_RXDATA: u32 = 4;
pub const SPI_TRANS_USE_TXDATA: u32 = 8;
pub const SPI_TRANS_MODE_DIOQIO_ADDR: u32 = 16;
pub const SPI_TRANS_VARIABLE_CMD: u32 = 32;
pub const SPI_TRANS_VARIABLE_ADDR: u32 = 64;
pub const SPI_TRANS_VARIABLE_DUMMY: u32 = 128;
pub const SPI_TRANS_SET_CD: u32 = 128;
pub const GPIO_SIGMADELTA0_REG: u32 = 1072975616;
pub const GPIO_SD0_PRESCALE: u32 = 255;
pub const GPIO_SD0_PRESCALE_V: u32 = 255;
pub const GPIO_SD0_PRESCALE_S: u32 = 8;
pub const GPIO_SD0_IN: u32 = 255;
pub const GPIO_SD0_IN_V: u32 = 255;
pub const GPIO_SD0_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA1_REG: u32 = 1072975620;
pub const GPIO_SD1_PRESCALE: u32 = 255;
pub const GPIO_SD1_PRESCALE_V: u32 = 255;
pub const GPIO_SD1_PRESCALE_S: u32 = 8;
pub const GPIO_SD1_IN: u32 = 255;
pub const GPIO_SD1_IN_V: u32 = 255;
pub const GPIO_SD1_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA2_REG: u32 = 1072975624;
pub const GPIO_SD2_PRESCALE: u32 = 255;
pub const GPIO_SD2_PRESCALE_V: u32 = 255;
pub const GPIO_SD2_PRESCALE_S: u32 = 8;
pub const GPIO_SD2_IN: u32 = 255;
pub const GPIO_SD2_IN_V: u32 = 255;
pub const GPIO_SD2_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA3_REG: u32 = 1072975628;
pub const GPIO_SD3_PRESCALE: u32 = 255;
pub const GPIO_SD3_PRESCALE_V: u32 = 255;
pub const GPIO_SD3_PRESCALE_S: u32 = 8;
pub const GPIO_SD3_IN: u32 = 255;
pub const GPIO_SD3_IN_V: u32 = 255;
pub const GPIO_SD3_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA4_REG: u32 = 1072975632;
pub const GPIO_SD4_PRESCALE: u32 = 255;
pub const GPIO_SD4_PRESCALE_V: u32 = 255;
pub const GPIO_SD4_PRESCALE_S: u32 = 8;
pub const GPIO_SD4_IN: u32 = 255;
pub const GPIO_SD4_IN_V: u32 = 255;
pub const GPIO_SD4_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA5_REG: u32 = 1072975636;
pub const GPIO_SD5_PRESCALE: u32 = 255;
pub const GPIO_SD5_PRESCALE_V: u32 = 255;
pub const GPIO_SD5_PRESCALE_S: u32 = 8;
pub const GPIO_SD5_IN: u32 = 255;
pub const GPIO_SD5_IN_V: u32 = 255;
pub const GPIO_SD5_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA6_REG: u32 = 1072975640;
pub const GPIO_SD6_PRESCALE: u32 = 255;
pub const GPIO_SD6_PRESCALE_V: u32 = 255;
pub const GPIO_SD6_PRESCALE_S: u32 = 8;
pub const GPIO_SD6_IN: u32 = 255;
pub const GPIO_SD6_IN_V: u32 = 255;
pub const GPIO_SD6_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA7_REG: u32 = 1072975644;
pub const GPIO_SD7_PRESCALE: u32 = 255;
pub const GPIO_SD7_PRESCALE_V: u32 = 255;
pub const GPIO_SD7_PRESCALE_S: u32 = 8;
pub const GPIO_SD7_IN: u32 = 255;
pub const GPIO_SD7_IN_V: u32 = 255;
pub const GPIO_SD7_IN_S: u32 = 0;
pub const GPIO_SIGMADELTA_CG_REG: u32 = 1072975648;
pub const GPIO_SD_CLK_EN_V: u32 = 1;
pub const GPIO_SD_CLK_EN_S: u32 = 31;
pub const GPIO_SIGMADELTA_MISC_REG: u32 = 1072975652;
pub const GPIO_SPI_SWAP_V: u32 = 1;
pub const GPIO_SPI_SWAP_S: u32 = 31;
pub const GPIO_SIGMADELTA_VERSION_REG: u32 = 1072975656;
pub const GPIO_SD_DATE: u32 = 268435455;
pub const GPIO_SD_DATE_V: u32 = 268435455;
pub const GPIO_SD_DATE_S: u32 = 0;
pub const SIGMADELTA_GPIO_SD_DATE_VERSION: u32 = 22045072;
pub const SIGMADELTA_PORT_0: u32 = 0;
pub const SIGMADELTA_PORT_MAX: u32 = 1;
pub const SOC_SIGMADELTA_NUM: u32 = 1;
pub const SIGMADELTA_CHANNEL_0: u32 = 0;
pub const SIGMADELTA_CHANNEL_1: u32 = 1;
pub const SIGMADELTA_CHANNEL_2: u32 = 2;
pub const SIGMADELTA_CHANNEL_3: u32 = 3;
pub const SIGMADELTA_CHANNEL_4: u32 = 4;
pub const SIGMADELTA_CHANNEL_5: u32 = 5;
pub const SIGMADELTA_CHANNEL_6: u32 = 6;
pub const SIGMADELTA_CHANNEL_7: u32 = 7;
pub const SIGMADELTA_CHANNEL_MAX: u32 = 8;
pub const SPI_SLAVE_TXBIT_LSBFIRST: u32 = 1;
pub const SPI_SLAVE_RXBIT_LSBFIRST: u32 = 2;
pub const SPI_SLAVE_BIT_LSBFIRST: u32 = 3;
pub const TIMG_WDT_WKEY_VALUE: u32 = 1356348065;
pub const TIMG_WDT_STG_SEL_OFF: u32 = 0;
pub const TIMG_WDT_STG_SEL_INT: u32 = 1;
pub const TIMG_WDT_STG_SEL_RESET_CPU: u32 = 2;
pub const TIMG_WDT_STG_SEL_RESET_SYSTEM: u32 = 3;
pub const TIMG_T0_EN_V: u32 = 1;
pub const TIMG_T0_EN_S: u32 = 31;
pub const TIMG_T0_INCREASE_V: u32 = 1;
pub const TIMG_T0_INCREASE_S: u32 = 30;
pub const TIMG_T0_AUTORELOAD_V: u32 = 1;
pub const TIMG_T0_AUTORELOAD_S: u32 = 29;
pub const TIMG_T0_DIVIDER: u32 = 65535;
pub const TIMG_T0_DIVIDER_V: u32 = 65535;
pub const TIMG_T0_DIVIDER_S: u32 = 13;
pub const TIMG_T0_EDGE_INT_EN_V: u32 = 1;
pub const TIMG_T0_EDGE_INT_EN_S: u32 = 12;
pub const TIMG_T0_LEVEL_INT_EN_V: u32 = 1;
pub const TIMG_T0_LEVEL_INT_EN_S: u32 = 11;
pub const TIMG_T0_ALARM_EN_V: u32 = 1;
pub const TIMG_T0_ALARM_EN_S: u32 = 10;
pub const TIMG_T0_LO: u32 = 4294967295;
pub const TIMG_T0_LO_V: u32 = 4294967295;
pub const TIMG_T0_LO_S: u32 = 0;
pub const TIMG_T0_HI: u32 = 4294967295;
pub const TIMG_T0_HI_V: u32 = 4294967295;
pub const TIMG_T0_HI_S: u32 = 0;
pub const TIMG_T0_UPDATE: u32 = 4294967295;
pub const TIMG_T0_UPDATE_V: u32 = 4294967295;
pub const TIMG_T0_UPDATE_S: u32 = 0;
pub const TIMG_T0_ALARM_LO: u32 = 4294967295;
pub const TIMG_T0_ALARM_LO_V: u32 = 4294967295;
pub const TIMG_T0_ALARM_LO_S: u32 = 0;
pub const TIMG_T0_ALARM_HI: u32 = 4294967295;
pub const TIMG_T0_ALARM_HI_V: u32 = 4294967295;
pub const TIMG_T0_ALARM_HI_S: u32 = 0;
pub const TIMG_T0_LOAD_LO: u32 = 4294967295;
pub const TIMG_T0_LOAD_LO_V: u32 = 4294967295;
pub const TIMG_T0_LOAD_LO_S: u32 = 0;
pub const TIMG_T0_LOAD_HI: u32 = 4294967295;
pub const TIMG_T0_LOAD_HI_V: u32 = 4294967295;
pub const TIMG_T0_LOAD_HI_S: u32 = 0;
pub const TIMG_T0_LOAD: u32 = 4294967295;
pub const TIMG_T0_LOAD_V: u32 = 4294967295;
pub const TIMG_T0_LOAD_S: u32 = 0;
pub const TIMG_T1_EN_V: u32 = 1;
pub const TIMG_T1_EN_S: u32 = 31;
pub const TIMG_T1_INCREASE_V: u32 = 1;
pub const TIMG_T1_INCREASE_S: u32 = 30;
pub const TIMG_T1_AUTORELOAD_V: u32 = 1;
pub const TIMG_T1_AUTORELOAD_S: u32 = 29;
pub const TIMG_T1_DIVIDER: u32 = 65535;
pub const TIMG_T1_DIVIDER_V: u32 = 65535;
pub const TIMG_T1_DIVIDER_S: u32 = 13;
pub const TIMG_T1_EDGE_INT_EN_V: u32 = 1;
pub const TIMG_T1_EDGE_INT_EN_S: u32 = 12;
pub const TIMG_T1_LEVEL_INT_EN_V: u32 = 1;
pub const TIMG_T1_LEVEL_INT_EN_S: u32 = 11;
pub const TIMG_T1_ALARM_EN_V: u32 = 1;
pub const TIMG_T1_ALARM_EN_S: u32 = 10;
pub const TIMG_T1_LO: u32 = 4294967295;
pub const TIMG_T1_LO_V: u32 = 4294967295;
pub const TIMG_T1_LO_S: u32 = 0;
pub const TIMG_T1_HI: u32 = 4294967295;
pub const TIMG_T1_HI_V: u32 = 4294967295;
pub const TIMG_T1_HI_S: u32 = 0;
pub const TIMG_T1_UPDATE: u32 = 4294967295;
pub const TIMG_T1_UPDATE_V: u32 = 4294967295;
pub const TIMG_T1_UPDATE_S: u32 = 0;
pub const TIMG_T1_ALARM_LO: u32 = 4294967295;
pub const TIMG_T1_ALARM_LO_V: u32 = 4294967295;
pub const TIMG_T1_ALARM_LO_S: u32 = 0;
pub const TIMG_T1_ALARM_HI: u32 = 4294967295;
pub const TIMG_T1_ALARM_HI_V: u32 = 4294967295;
pub const TIMG_T1_ALARM_HI_S: u32 = 0;
pub const TIMG_T1_LOAD_LO: u32 = 4294967295;
pub const TIMG_T1_LOAD_LO_V: u32 = 4294967295;
pub const TIMG_T1_LOAD_LO_S: u32 = 0;
pub const TIMG_T1_LOAD_HI: u32 = 4294967295;
pub const TIMG_T1_LOAD_HI_V: u32 = 4294967295;
pub const TIMG_T1_LOAD_HI_S: u32 = 0;
pub const TIMG_T1_LOAD: u32 = 4294967295;
pub const TIMG_T1_LOAD_V: u32 = 4294967295;
pub const TIMG_T1_LOAD_S: u32 = 0;
pub const TIMG_WDT_EN_V: u32 = 1;
pub const TIMG_WDT_EN_S: u32 = 31;
pub const TIMG_WDT_STG0: u32 = 3;
pub const TIMG_WDT_STG0_V: u32 = 3;
pub const TIMG_WDT_STG0_S: u32 = 29;
pub const TIMG_WDT_STG1: u32 = 3;
pub const TIMG_WDT_STG1_V: u32 = 3;
pub const TIMG_WDT_STG1_S: u32 = 27;
pub const TIMG_WDT_STG2: u32 = 3;
pub const TIMG_WDT_STG2_V: u32 = 3;
pub const TIMG_WDT_STG2_S: u32 = 25;
pub const TIMG_WDT_STG3: u32 = 3;
pub const TIMG_WDT_STG3_V: u32 = 3;
pub const TIMG_WDT_STG3_S: u32 = 23;
pub const TIMG_WDT_EDGE_INT_EN_V: u32 = 1;
pub const TIMG_WDT_EDGE_INT_EN_S: u32 = 22;
pub const TIMG_WDT_LEVEL_INT_EN_V: u32 = 1;
pub const TIMG_WDT_LEVEL_INT_EN_S: u32 = 21;
pub const TIMG_WDT_CPU_RESET_LENGTH: u32 = 7;
pub const TIMG_WDT_CPU_RESET_LENGTH_V: u32 = 7;
pub const TIMG_WDT_CPU_RESET_LENGTH_S: u32 = 18;
pub const TIMG_WDT_SYS_RESET_LENGTH: u32 = 7;
pub const TIMG_WDT_SYS_RESET_LENGTH_V: u32 = 7;
pub const TIMG_WDT_SYS_RESET_LENGTH_S: u32 = 15;
pub const TIMG_WDT_FLASHBOOT_MOD_EN_V: u32 = 1;
pub const TIMG_WDT_FLASHBOOT_MOD_EN_S: u32 = 14;
pub const TIMG_WDT_CLK_PRESCALE: u32 = 65535;
pub const TIMG_WDT_CLK_PRESCALE_V: u32 = 65535;
pub const TIMG_WDT_CLK_PRESCALE_S: u32 = 16;
pub const TIMG_WDT_STG0_HOLD: u32 = 4294967295;
pub const TIMG_WDT_STG0_HOLD_V: u32 = 4294967295;
pub const TIMG_WDT_STG0_HOLD_S: u32 = 0;
pub const TIMG_WDT_STG1_HOLD: u32 = 4294967295;
pub const TIMG_WDT_STG1_HOLD_V: u32 = 4294967295;
pub const TIMG_WDT_STG1_HOLD_S: u32 = 0;
pub const TIMG_WDT_STG2_HOLD: u32 = 4294967295;
pub const TIMG_WDT_STG2_HOLD_V: u32 = 4294967295;
pub const TIMG_WDT_STG2_HOLD_S: u32 = 0;
pub const TIMG_WDT_STG3_HOLD: u32 = 4294967295;
pub const TIMG_WDT_STG3_HOLD_V: u32 = 4294967295;
pub const TIMG_WDT_STG3_HOLD_S: u32 = 0;
pub const TIMG_WDT_FEED: u32 = 4294967295;
pub const TIMG_WDT_FEED_V: u32 = 4294967295;
pub const TIMG_WDT_FEED_S: u32 = 0;
pub const TIMG_WDT_WKEY: u32 = 4294967295;
pub const TIMG_WDT_WKEY_V: u32 = 4294967295;
pub const TIMG_WDT_WKEY_S: u32 = 0;
pub const TIMG_RTC_CALI_START_V: u32 = 1;
pub const TIMG_RTC_CALI_START_S: u32 = 31;
pub const TIMG_RTC_CALI_MAX: u32 = 32767;
pub const TIMG_RTC_CALI_MAX_V: u32 = 32767;
pub const TIMG_RTC_CALI_MAX_S: u32 = 16;
pub const TIMG_RTC_CALI_RDY_V: u32 = 1;
pub const TIMG_RTC_CALI_RDY_S: u32 = 15;
pub const TIMG_RTC_CALI_CLK_SEL: u32 = 3;
pub const TIMG_RTC_CALI_CLK_SEL_V: u32 = 3;
pub const TIMG_RTC_CALI_CLK_SEL_S: u32 = 13;
pub const TIMG_RTC_CALI_START_CYCLING_V: u32 = 1;
pub const TIMG_RTC_CALI_START_CYCLING_S: u32 = 12;
pub const TIMG_RTC_CALI_VALUE: u32 = 33554431;
pub const TIMG_RTC_CALI_VALUE_V: u32 = 33554431;
pub const TIMG_RTC_CALI_VALUE_S: u32 = 7;
pub const TIMG_LACT_EN_V: u32 = 1;
pub const TIMG_LACT_EN_S: u32 = 31;
pub const TIMG_LACT_INCREASE_V: u32 = 1;
pub const TIMG_LACT_INCREASE_S: u32 = 30;
pub const TIMG_LACT_AUTORELOAD_V: u32 = 1;
pub const TIMG_LACT_AUTORELOAD_S: u32 = 29;
pub const TIMG_LACT_DIVIDER: u32 = 65535;
pub const TIMG_LACT_DIVIDER_V: u32 = 65535;
pub const TIMG_LACT_DIVIDER_S: u32 = 13;
pub const TIMG_LACT_EDGE_INT_EN_V: u32 = 1;
pub const TIMG_LACT_EDGE_INT_EN_S: u32 = 12;
pub const TIMG_LACT_LEVEL_INT_EN_V: u32 = 1;
pub const TIMG_LACT_LEVEL_INT_EN_S: u32 = 11;
pub const TIMG_LACT_ALARM_EN_V: u32 = 1;
pub const TIMG_LACT_ALARM_EN_S: u32 = 10;
pub const TIMG_LACT_LAC_EN_V: u32 = 1;
pub const TIMG_LACT_LAC_EN_S: u32 = 9;
pub const TIMG_LACT_CPST_EN_V: u32 = 1;
pub const TIMG_LACT_CPST_EN_S: u32 = 8;
pub const TIMG_LACT_RTC_ONLY_V: u32 = 1;
pub const TIMG_LACT_RTC_ONLY_S: u32 = 7;
pub const TIMG_LACT_RTC_STEP_LEN: u32 = 67108863;
pub const TIMG_LACT_RTC_STEP_LEN_V: u32 = 67108863;
pub const TIMG_LACT_RTC_STEP_LEN_S: u32 = 6;
pub const TIMG_LACT_LO: u32 = 4294967295;
pub const TIMG_LACT_LO_V: u32 = 4294967295;
pub const TIMG_LACT_LO_S: u32 = 0;
pub const TIMG_LACT_HI: u32 = 4294967295;
pub const TIMG_LACT_HI_V: u32 = 4294967295;
pub const TIMG_LACT_HI_S: u32 = 0;
pub const TIMG_LACT_UPDATE: u32 = 4294967295;
pub const TIMG_LACT_UPDATE_V: u32 = 4294967295;
pub const TIMG_LACT_UPDATE_S: u32 = 0;
pub const TIMG_LACT_ALARM_LO: u32 = 4294967295;
pub const TIMG_LACT_ALARM_LO_V: u32 = 4294967295;
pub const TIMG_LACT_ALARM_LO_S: u32 = 0;
pub const TIMG_LACT_ALARM_HI: u32 = 4294967295;
pub const TIMG_LACT_ALARM_HI_V: u32 = 4294967295;
pub const TIMG_LACT_ALARM_HI_S: u32 = 0;
pub const TIMG_LACT_LOAD_LO: u32 = 4294967295;
pub const TIMG_LACT_LOAD_LO_V: u32 = 4294967295;
pub const TIMG_LACT_LOAD_LO_S: u32 = 0;
pub const TIMG_LACT_LOAD_HI: u32 = 4294967295;
pub const TIMG_LACT_LOAD_HI_V: u32 = 4294967295;
pub const TIMG_LACT_LOAD_HI_S: u32 = 0;
pub const TIMG_LACT_LOAD: u32 = 4294967295;
pub const TIMG_LACT_LOAD_V: u32 = 4294967295;
pub const TIMG_LACT_LOAD_S: u32 = 0;
pub const TIMG_LACT_INT_ENA_V: u32 = 1;
pub const TIMG_LACT_INT_ENA_S: u32 = 3;
pub const TIMG_WDT_INT_ENA_V: u32 = 1;
pub const TIMG_WDT_INT_ENA_S: u32 = 2;
pub const TIMG_T1_INT_ENA_V: u32 = 1;
pub const TIMG_T1_INT_ENA_S: u32 = 1;
pub const TIMG_T0_INT_ENA_V: u32 = 1;
pub const TIMG_T0_INT_ENA_S: u32 = 0;
pub const TIMG_LACT_INT_RAW_V: u32 = 1;
pub const TIMG_LACT_INT_RAW_S: u32 = 3;
pub const TIMG_WDT_INT_RAW_V: u32 = 1;
pub const TIMG_WDT_INT_RAW_S: u32 = 2;
pub const TIMG_T1_INT_RAW_V: u32 = 1;
pub const TIMG_T1_INT_RAW_S: u32 = 1;
pub const TIMG_T0_INT_RAW_V: u32 = 1;
pub const TIMG_T0_INT_RAW_S: u32 = 0;
pub const TIMG_LACT_INT_ST_V: u32 = 1;
pub const TIMG_LACT_INT_ST_S: u32 = 3;
pub const TIMG_WDT_INT_ST_V: u32 = 1;
pub const TIMG_WDT_INT_ST_S: u32 = 2;
pub const TIMG_T1_INT_ST_V: u32 = 1;
pub const TIMG_T1_INT_ST_S: u32 = 1;
pub const TIMG_T0_INT_ST_V: u32 = 1;
pub const TIMG_T0_INT_ST_S: u32 = 0;
pub const TIMG_LACT_INT_CLR_V: u32 = 1;
pub const TIMG_LACT_INT_CLR_S: u32 = 3;
pub const TIMG_WDT_INT_CLR_V: u32 = 1;
pub const TIMG_WDT_INT_CLR_S: u32 = 2;
pub const TIMG_T1_INT_CLR_V: u32 = 1;
pub const TIMG_T1_INT_CLR_S: u32 = 1;
pub const TIMG_T0_INT_CLR_V: u32 = 1;
pub const TIMG_T0_INT_CLR_S: u32 = 0;
pub const TIMG_NTIMERS_DATE: u32 = 268435455;
pub const TIMG_NTIMERS_DATE_V: u32 = 268435455;
pub const TIMG_NTIMERS_DATE_S: u32 = 0;
pub const TIMG_CLK_EN_V: u32 = 1;
pub const TIMG_CLK_EN_S: u32 = 31;
pub const TIMER_BASE_CLK: u32 = 80000000;
pub const TOUCH_PAD_NUM0_GPIO_NUM: u32 = 4;
pub const TOUCH_PAD_NUM1_GPIO_NUM: u32 = 0;
pub const TOUCH_PAD_NUM2_GPIO_NUM: u32 = 2;
pub const TOUCH_PAD_NUM3_GPIO_NUM: u32 = 15;
pub const TOUCH_PAD_NUM4_GPIO_NUM: u32 = 13;
pub const TOUCH_PAD_NUM5_GPIO_NUM: u32 = 12;
pub const TOUCH_PAD_NUM6_GPIO_NUM: u32 = 14;
pub const TOUCH_PAD_NUM7_GPIO_NUM: u32 = 27;
pub const TOUCH_PAD_NUM8_GPIO_NUM: u32 = 33;
pub const TOUCH_PAD_NUM9_GPIO_NUM: u32 = 32;
pub const SOC_TOUCH_SENSOR_NUM: u32 = 10;
pub const SOC_TOUCH_SENSOR_BIT_MASK_MAX: u32 = 1023;
pub const SOC_TOUCH_PAD_MEASURE_WAIT: u32 = 255;
pub const SOC_TOUCH_PAD_THRESHOLD_MAX: u32 = 0;
pub const TOUCH_PAD_BIT_MASK_MAX: u32 = 1023;
pub const TOUCH_PAD_THRESHOLD_MAX: u32 = 0;
pub const UART_FIFO_LEN: u32 = 128;
pub const UART_BITRATE_MAX: u32 = 5000000;
pub const SOC_UART_NUM: u32 = 3;
pub const SOC_UART_MIN_WAKEUP_THRESH: u32 = 2;
pub const UART_INTR_MASK: u32 = 524287;
pub const UART_NUM_0: u32 = 0;
pub const UART_NUM_1: u32 = 1;
pub const UART_NUM_2: u32 = 2;
pub const UART_NUM_MAX: u32 = 3;
pub const UART_PIN_NO_CHANGE: i32 = -1;
pub const ESP_ERR_NOT_FINISHED: u32 = 513;
pub type __int8_t = c_types::c_schar;
pub type __uint8_t = c_types::c_uchar;
pub type __int16_t = c_types::c_short;
pub type __uint16_t = c_types::c_ushort;
pub type __int32_t = c_types::c_int;
pub type __uint32_t = c_types::c_uint;
pub type __int64_t = c_types::c_longlong;
pub type __uint64_t = c_types::c_ulonglong;
pub type __int_least8_t = c_types::c_schar;
pub type __uint_least8_t = c_types::c_uchar;
pub type __int_least16_t = c_types::c_short;
pub type __uint_least16_t = c_types::c_ushort;
pub type __int_least32_t = c_types::c_int;
pub type __uint_least32_t = c_types::c_uint;
pub type __int_least64_t = c_types::c_longlong;
pub type __uint_least64_t = c_types::c_ulonglong;
pub type __intmax_t = c_types::c_longlong;
pub type __uintmax_t = c_types::c_ulonglong;
pub type __intptr_t = c_types::c_int;
pub type __uintptr_t = c_types::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = c_types::c_schar;
pub type uint_fast8_t = c_types::c_uchar;
pub type int_fast16_t = c_types::c_short;
pub type uint_fast16_t = c_types::c_ushort;
pub type int_fast32_t = c_types::c_int;
pub type uint_fast32_t = c_types::c_uint;
pub type int_fast64_t = c_types::c_longlong;
pub type uint_fast64_t = c_types::c_ulonglong;
pub type size_t = c_types::c_uint;
pub type wchar_t = c_types::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: c_types::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type _lock_t = c_types::c_int;
pub type _LOCK_RECURSIVE_T = _lock_t;
pub type _LOCK_T = _lock_t;
extern "C" {
    pub fn _lock_init(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_try_acquire(lock: *mut _lock_t) -> c_types::c_int;
}
extern "C" {
    pub fn _lock_try_acquire_recursive(lock: *mut _lock_t) -> c_types::c_int;
}
extern "C" {
    pub fn _lock_release(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release_recursive(lock: *mut _lock_t);
}
pub type __blkcnt_t = c_types::c_long;
pub type __blksize_t = c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = c_types::c_long;
pub type __pid_t = c_types::c_int;
pub type __dev_t = c_types::c_short;
pub type __uid_t = c_types::c_ushort;
pub type __gid_t = c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = c_types::c_long;
pub type _fpos_t = c_types::c_long;
pub type __size_t = c_types::c_uint;
pub type _ssize_t = c_types::c_int;
pub type __ssize_t = _ssize_t;
pub type wint_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [c_types::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut c_types::c_void;
pub type __clock_t = c_types::c_ulong;
pub type __time_t = c_types::c_long;
pub type __clockid_t = c_types::c_ulong;
pub type __timer_t = c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = c_types::c_ushort;
pub type __suseconds_t = c_types::c_long;
pub type __useconds_t = c_types::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: c_types::c_int,
    pub _maxwds: c_types::c_int,
    pub _sign: c_types::c_int,
    pub _wds: c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: c_types::c_int,
    pub __tm_min: c_types::c_int,
    pub __tm_hour: c_types::c_int,
    pub __tm_mday: c_types::c_int,
    pub __tm_mon: c_types::c_int,
    pub __tm_year: c_types::c_int,
    pub __tm_wday: c_types::c_int,
    pub __tm_yday: c_types::c_int,
    pub __tm_isdst: c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut c_types::c_void; 32usize],
    pub _dso_handle: [*mut c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut c_types::c_uchar,
    pub _size: c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut c_types::c_uchar,
    pub _r: c_types::c_int,
    pub _w: c_types::c_int,
    pub _flags: c_types::c_short,
    pub _file: c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: c_types::c_int,
    pub _data: *mut _reent,
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut c_types::c_uchar,
    pub _r: c_types::c_int,
    pub _w: c_types::c_int,
    pub _flags: c_types::c_short,
    pub _file: c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut c_types::c_void,
            arg3: *mut c_types::c_char,
            arg4: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut c_types::c_void,
            arg3: *const c_types::c_char,
            arg4: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut c_types::c_void,
            arg3: _fpos_t,
            arg4: c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut c_types::c_uchar,
    pub _ur: c_types::c_int,
    pub _ubuf: [c_types::c_uchar; 3usize],
    pub _nbuf: [c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: c_types::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: c_types::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [c_types::c_ushort; 3usize],
    pub _mult: [c_types::c_ushort; 3usize],
    pub _add: c_types::c_ushort,
    pub _rand_next: c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [c_types::c_char; 8usize],
    pub _getdate_err: c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: c_types::c_int,
    pub _emergency: *mut c_types::c_char,
    pub __sdidinit: c_types::c_int,
    pub _unspecified_locale_info: c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: c_types::c_int,
    pub _cvtlen: c_types::c_int,
    pub _cvtbuf: *mut c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut c_types::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: c_types::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut c_types::c_char,
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = c_types::c_int;
pub type __sigset_t = c_types::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = c_types::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: c_types::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type fd_mask = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: c_types::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn pselect(
        __n: c_types::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> c_types::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = c_types::c_uchar;
pub type u_short = c_types::c_ushort;
pub type u_int = c_types::c_uint;
pub type u_long = c_types::c_ulong;
pub type ushort = c_types::c_ushort;
pub type uint = c_types::c_uint;
pub type ulong = c_types::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = c_types::c_ulong;
pub type daddr_t = c_types::c_long;
pub type caddr_t = *mut c_types::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: c_types::c_int,
}
extern "C" {
    pub fn sched_yield() -> c_types::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: c_types::c_int,
    pub stackaddr: *mut c_types::c_void,
    pub stacksize: c_types::c_int,
    pub contentionscope: c_types::c_int,
    pub inheritsched: c_types::c_int,
    pub schedpolicy: c_types::c_int,
    pub schedparam: sched_param,
    pub detachstate: c_types::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: c_types::c_int,
    pub type_: c_types::c_int,
    pub recursive: c_types::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: c_types::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: c_types::c_int,
    pub init_executed: c_types::c_int,
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn printf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const c_types::c_char, arg2: __builtin_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut c_types::c_char,
        arg2: c_types::c_int,
        arg3: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fputc(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const c_types::c_char, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar() -> c_types::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn putc(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn puts(arg1: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn ungetc(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut c_types::c_void,
        _size: c_types::c_uint,
        _n: c_types::c_uint,
        arg2: *mut FILE,
    ) -> c_types::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const c_types::c_void,
        _size: c_types::c_uint,
        _n: c_types::c_uint,
        arg2: *mut FILE,
    ) -> c_types::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: c_types::c_long, arg3: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> c_types::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn perror(arg1: *const c_types::c_char);
}
extern "C" {
    pub fn fopen(_name: *const c_types::c_char, _type: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut c_types::c_char, arg2: *const c_types::c_char, ...)
        -> c_types::c_int;
}
extern "C" {
    pub fn remove(arg1: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn rename(arg1: *const c_types::c_char, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut c_types::c_char,
        arg2: c_types::c_uint,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut c_types::c_char,
        arg2: c_types::c_uint,
        arg3: *const c_types::c_char,
        arg4: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const c_types::c_char, arg2: __builtin_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn diprintf(arg1: c_types::c_int, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut c_types::c_char,
        arg2: size_t,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: c_types::c_int,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const c_types::c_char, arg2: __gnuc_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const c_types::c_char, arg2: __gnuc_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut c_types::c_char,
        arg2: size_t,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fdopen(arg1: c_types::c_int, arg2: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn popen(arg1: *const c_types::c_char, arg2: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut c_types::c_char, arg3: c_types::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putw(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> c_types::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn dprintf(arg1: c_types::c_int, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut c_types::c_void,
        arg2: size_t,
        arg3: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut c_types::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: c_types::c_int,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: c_types::c_int,
        arg2: *const c_types::c_char,
        arg3: c_types::c_int,
        arg4: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> c_types::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        arg3: size_t,
        arg4: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: c_types::c_long,
        arg4: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> c_types::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> c_types::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const c_types::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const c_types::c_char,
        _new: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: c_types::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *mut c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *const c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __off: fpos_t,
                __whence: c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut c_types::c_void) -> c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *mut c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *const c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __off: fpos_t,
                __whence: c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut c_types::c_void) -> c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __assert(
        arg1: *const c_types::c_char,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const c_types::c_char,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        arg4: *const c_types::c_char,
    );
}
pub type esp_err_t = i32;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table and"]
    #[doc = " returns its string representation."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table of"]
    #[doc = " esp_err_t errors and returns its string representation. If the error code"]
    #[doc = " is not found then it is attempted to be found among system errors."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @param[out] buf buffer where the error message should be written"]
    #[doc = " @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte)."]
    #[doc = " @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut c_types::c_char,
        buflen: size_t,
    ) -> *const c_types::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const c_types::c_char,
        line: c_types::c_int,
        function: *const c_types::c_char,
        expression: *const c_types::c_char,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const c_types::c_char,
        line: c_types::c_int,
        function: *const c_types::c_char,
        expression: *const c_types::c_char,
    );
}
extern "C" {
    #[doc = " Return full IDF version string, same as 'git describe' output."]
    #[doc = ""]
    #[doc = " @note If you are printing the ESP-IDF version in a log file or other information,"]
    #[doc = " this function provides more information than using the numerical version macros."]
    #[doc = " For example, numerical version macros don't differentiate between development,"]
    #[doc = " pre-release and release versions, but the output of this function does."]
    #[doc = ""]
    #[doc = " @return constant string from IDF_VER"]
    pub fn esp_get_idf_version() -> *const c_types::c_char;
}
pub const esp_mac_type_t_ESP_MAC_WIFI_STA: esp_mac_type_t = 0;
pub const esp_mac_type_t_ESP_MAC_WIFI_SOFTAP: esp_mac_type_t = 1;
pub const esp_mac_type_t_ESP_MAC_BT: esp_mac_type_t = 2;
pub const esp_mac_type_t_ESP_MAC_ETH: esp_mac_type_t = 3;
pub type esp_mac_type_t = c_types::c_uint;
#[doc = "!< Reset reason can not be determined"]
pub const esp_reset_reason_t_ESP_RST_UNKNOWN: esp_reset_reason_t = 0;
#[doc = "!< Reset due to power-on event"]
pub const esp_reset_reason_t_ESP_RST_POWERON: esp_reset_reason_t = 1;
#[doc = "!< Reset by external pin (not applicable for ESP32)"]
pub const esp_reset_reason_t_ESP_RST_EXT: esp_reset_reason_t = 2;
#[doc = "!< Software reset via esp_restart"]
pub const esp_reset_reason_t_ESP_RST_SW: esp_reset_reason_t = 3;
#[doc = "!< Software reset due to exception/panic"]
pub const esp_reset_reason_t_ESP_RST_PANIC: esp_reset_reason_t = 4;
#[doc = "!< Reset (software or hardware) due to interrupt watchdog"]
pub const esp_reset_reason_t_ESP_RST_INT_WDT: esp_reset_reason_t = 5;
#[doc = "!< Reset due to task watchdog"]
pub const esp_reset_reason_t_ESP_RST_TASK_WDT: esp_reset_reason_t = 6;
#[doc = "!< Reset due to other watchdogs"]
pub const esp_reset_reason_t_ESP_RST_WDT: esp_reset_reason_t = 7;
#[doc = "!< Reset after exiting deep sleep mode"]
pub const esp_reset_reason_t_ESP_RST_DEEPSLEEP: esp_reset_reason_t = 8;
#[doc = "!< Brownout reset (software or hardware)"]
pub const esp_reset_reason_t_ESP_RST_BROWNOUT: esp_reset_reason_t = 9;
#[doc = "!< Reset over SDIO"]
pub const esp_reset_reason_t_ESP_RST_SDIO: esp_reset_reason_t = 10;
#[doc = " @brief Reset reasons"]
pub type esp_reset_reason_t = c_types::c_uint;
#[doc = " Shutdown handler type"]
pub type shutdown_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " @brief  Register shutdown handler"]
    #[doc = ""]
    #[doc = " This function allows you to register a handler that gets invoked before"]
    #[doc = " the application is restarted using esp_restart function."]
    #[doc = " @param handle function to execute on restart"]
    #[doc = " @return"]
    #[doc = "   - ESP_OK on success"]
    #[doc = "   - ESP_ERR_INVALID_STATE if the handler has already been registered"]
    #[doc = "   - ESP_ERR_NO_MEM if no more shutdown handler slots are available"]
    pub fn esp_register_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Unregister shutdown handler"]
    #[doc = ""]
    #[doc = " This function allows you to unregister a handler which was previously"]
    #[doc = " registered using esp_register_shutdown_handler function."]
    #[doc = "   - ESP_OK on success"]
    #[doc = "   - ESP_ERR_INVALID_STATE if the given handler hasn't been registered before"]
    pub fn esp_unregister_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restart PRO and APP CPUs."]
    #[doc = ""]
    #[doc = " This function can be called both from PRO and APP CPUs."]
    #[doc = " After successful restart, CPU reset reason will be SW_CPU_RESET."]
    #[doc = " Peripherals (except for WiFi, BT, UART0, SPI1, and legacy timers) are not reset."]
    #[doc = " This function does not return."]
    pub fn esp_restart();
}
extern "C" {
    #[doc = " @brief  Get reason of last reset"]
    #[doc = " @return See description of esp_reset_reason_t for explanation of each value."]
    pub fn esp_reset_reason() -> esp_reset_reason_t;
}
extern "C" {
    #[doc = " @brief  Get the size of available heap."]
    #[doc = ""]
    #[doc = " Note that the returned value may be larger than the maximum contiguous block"]
    #[doc = " which can be allocated."]
    #[doc = ""]
    #[doc = " @return Available heap size, in bytes."]
    pub fn esp_get_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief  Get the size of available internal heap."]
    #[doc = ""]
    #[doc = " Note that the returned value may be larger than the maximum contiguous block"]
    #[doc = " which can be allocated."]
    #[doc = ""]
    #[doc = " @return Available internal heap size, in bytes."]
    pub fn esp_get_free_internal_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief Get the minimum heap that has ever been available"]
    #[doc = ""]
    #[doc = " @return Minimum free heap ever available"]
    pub fn esp_get_minimum_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief  Get one random 32-bit word from hardware RNG"]
    #[doc = ""]
    #[doc = " The hardware RNG is fully functional whenever an RF subsystem is running (ie Bluetooth or WiFi is enabled). For"]
    #[doc = " random values, call this function after WiFi or Bluetooth are started."]
    #[doc = ""]
    #[doc = " If the RF subsystem is not used by the program, the function bootloader_random_enable() can be called to enable an"]
    #[doc = " entropy source. bootloader_random_disable() must be called before RF subsystem or I2S peripheral are used. See these functions'"]
    #[doc = " documentation for more details."]
    #[doc = ""]
    #[doc = " Any time the app is running without an RF subsystem (or bootloader_random) enabled, RNG hardware should be"]
    #[doc = " considered a PRNG. A very small amount of entropy is available due to pre-seeding while the IDF"]
    #[doc = " bootloader is running, but this should not be relied upon for any use."]
    #[doc = ""]
    #[doc = " @return Random value between 0 and UINT32_MAX"]
    pub fn esp_random() -> u32;
}
extern "C" {
    #[doc = " @brief Fill a buffer with random bytes from hardware RNG"]
    #[doc = ""]
    #[doc = " @note This function has the same restrictions regarding available entropy as esp_random()"]
    #[doc = ""]
    #[doc = " @param buf Pointer to buffer to fill with random numbers."]
    #[doc = " @param len Length of buffer in bytes"]
    pub fn esp_fill_random(buf: *mut c_types::c_void, len: size_t);
}
extern "C" {
    #[doc = " @brief  Set base MAC address with the MAC address which is stored in BLK3 of EFUSE or"]
    #[doc = "         external storage e.g. flash and EEPROM."]
    #[doc = ""]
    #[doc = " Base MAC address is used to generate the MAC addresses used by the networking interfaces."]
    #[doc = " If using base MAC address stored in BLK3 of EFUSE or external storage, call this API to set base MAC"]
    #[doc = " address with the MAC address which is stored in BLK3 of EFUSE or external storage before initializing"]
    #[doc = " WiFi/BT/Ethernet."]
    #[doc = ""]
    #[doc = " @note Base MAC must be a unicast MAC (least significant bit of first byte must be zero)."]
    #[doc = ""]
    #[doc = " @note If not using a valid OUI, set the \"locally administered\" bit"]
    #[doc = "       (bit value 0x02 in the first byte) to avoid collisions."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    #[doc = "         ESP_ERR_INVALID_ARG If mac is NULL or is not a unicast MAC"]
    pub fn esp_base_mac_addr_set(mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is set using esp_base_mac_addr_set."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    #[doc = "         ESP_ERR_INVALID_MAC base MAC address has not been set"]
    pub fn esp_base_mac_addr_get(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which was previously written to BLK3 of EFUSE."]
    #[doc = ""]
    #[doc = " Base MAC address is used to generate the MAC addresses used by the networking interfaces."]
    #[doc = " This API returns the custom base MAC address which was previously written to BLK3 of EFUSE."]
    #[doc = " Writing this EFUSE allows setting of a different (non-Espressif) base MAC address. It is also"]
    #[doc = " possible to store a custom base MAC address elsewhere, see esp_base_mac_addr_set() for details."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    #[doc = "         ESP_ERR_INVALID_VERSION An invalid MAC version field was read from BLK3 of EFUSE"]
    #[doc = "         ESP_ERR_INVALID_CRC An invalid MAC CRC was read from BLK3 of EFUSE"]
    pub fn esp_efuse_mac_get_custom(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is factory-programmed by Espressif in BLK0 of EFUSE."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_efuse_mac_get_default(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read base MAC address and set MAC address of the interface."]
    #[doc = ""]
    #[doc = " This function first get base MAC address using esp_base_mac_addr_get or reads base MAC address"]
    #[doc = " from BLK0 of EFUSE. Then set the MAC address of the interface including wifi station, wifi softap,"]
    #[doc = " bluetooth and ethernet."]
    #[doc = ""]
    #[doc = " @param  mac  MAC address of the interface, length: 6 bytes."]
    #[doc = " @param  type  type of MAC address, 0:wifi station, 1:wifi softap, 2:bluetooth, 3:ethernet."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_read_mac(mac: *mut u8, type_: esp_mac_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Derive local MAC address from universal MAC address."]
    #[doc = ""]
    #[doc = " This function derives a local MAC address from an universal MAC address."]
    #[doc = " A `definition of local vs universal MAC address can be found on Wikipedia"]
    #[doc = " <https://en.wikipedia.org/wiki/MAC_address#Universal_vs._local>`."]
    #[doc = " In ESP32, universal MAC address is generated from base MAC address in EFUSE or other external storage."]
    #[doc = " Local MAC address is derived from the universal MAC address."]
    #[doc = ""]
    #[doc = " @param  local_mac  Derived local MAC address, length: 6 bytes."]
    #[doc = " @param  universal_mac  Source universal MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_derive_local_mac(local_mac: *mut u8, universal_mac: *const u8) -> esp_err_t;
}
#[doc = "!< ESP32"]
pub const esp_chip_model_t_CHIP_ESP32: esp_chip_model_t = 1;
#[doc = "!< ESP32-S2 Beta"]
pub const esp_chip_model_t_CHIP_ESP32S2BETA: esp_chip_model_t = 2;
#[doc = " @brief Chip models"]
pub type esp_chip_model_t = c_types::c_uint;
#[doc = " @brief The structure represents information about the chip"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_chip_info_t {
    #[doc = "!< chip model, one of esp_chip_model_t"]
    pub model: esp_chip_model_t,
    #[doc = "!< bit mask of CHIP_FEATURE_x feature flags"]
    pub features: u32,
    #[doc = "!< number of CPU cores"]
    pub cores: u8,
    #[doc = "!< chip revision number"]
    pub revision: u8,
}
extern "C" {
    #[doc = " @brief Fill an esp_chip_info_t structure with information about the chip"]
    #[doc = " @param[out] out_info structure to be filled"]
    pub fn esp_chip_info(out_info: *mut esp_chip_info_t);
}
#[doc = "< No log output"]
pub const esp_log_level_t_ESP_LOG_NONE: esp_log_level_t = 0;
#[doc = "< Critical errors, software module can not recover on its own"]
pub const esp_log_level_t_ESP_LOG_ERROR: esp_log_level_t = 1;
#[doc = "< Error conditions from which recovery measures have been taken"]
pub const esp_log_level_t_ESP_LOG_WARN: esp_log_level_t = 2;
#[doc = "< Information messages which describe normal flow of events"]
pub const esp_log_level_t_ESP_LOG_INFO: esp_log_level_t = 3;
#[doc = "< Extra information which is not necessary for normal use (values, pointers, sizes, etc)."]
pub const esp_log_level_t_ESP_LOG_DEBUG: esp_log_level_t = 4;
#[doc = "< Bigger chunks of debugging information, or frequent messages which can potentially flood the output."]
pub const esp_log_level_t_ESP_LOG_VERBOSE: esp_log_level_t = 5;
#[doc = " @brief Log level"]
#[doc = ""]
pub type esp_log_level_t = c_types::c_uint;
pub type vprintf_like_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const c_types::c_char, arg2: va_list) -> c_types::c_int,
>;
extern "C" {
    #[doc = " @brief Set log level for given tag"]
    #[doc = ""]
    #[doc = " If logging for given component has already been enabled, changes previous setting."]
    #[doc = ""]
    #[doc = " Note that this function can not raise log level above the level set using"]
    #[doc = " CONFIG_LOG_DEFAULT_LEVEL setting in menuconfig."]
    #[doc = ""]
    #[doc = " To raise log level above the default one for a given file, define"]
    #[doc = " LOG_LOCAL_LEVEL to one of the ESP_LOG_* values, before including"]
    #[doc = " esp_log.h in this file."]
    #[doc = ""]
    #[doc = " @param tag Tag of the log entries to enable. Must be a non-NULL zero terminated string."]
    #[doc = "            Value \"*\" resets log level for all tags to the given value."]
    #[doc = ""]
    #[doc = " @param level  Selects log level to enable. Only logs at this and lower verbosity"]
    #[doc = " levels will be shown."]
    pub fn esp_log_level_set(tag: *const c_types::c_char, level: esp_log_level_t);
}
extern "C" {
    #[doc = " @brief Set function used to output log entries"]
    #[doc = ""]
    #[doc = " By default, log output goes to UART0. This function can be used to redirect log"]
    #[doc = " output to some other destination, such as file or network. Returns the original"]
    #[doc = " log handler, which may be necessary to return output to the previous destination."]
    #[doc = ""]
    #[doc = " @param func new Function used for output. Must have same signature as vprintf."]
    #[doc = ""]
    #[doc = " @return func old Function used for output."]
    pub fn esp_log_set_vprintf(func: vprintf_like_t) -> vprintf_like_t;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output"]
    #[doc = ""]
    #[doc = " This function is used in expansion of ESP_LOGx macros."]
    #[doc = " In the 2nd stage bootloader, and at early application startup stage"]
    #[doc = " this function uses CPU cycle counter as time source. Later when"]
    #[doc = " FreeRTOS scheduler start running, it switches to FreeRTOS tick count."]
    #[doc = ""]
    #[doc = " For now, we ignore millisecond counter overflow."]
    #[doc = ""]
    #[doc = " @return timestamp, in milliseconds"]
    pub fn esp_log_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Function which returns system timestamp to be used in log output"]
    #[doc = ""]
    #[doc = " This function is used in expansion of ESP_LOGx macros to print"]
    #[doc = " the system time as \"HH:MM:SS.sss\". The system time is initialized to"]
    #[doc = " 0 on startup, this can be set to the correct time with an SNTP sync,"]
    #[doc = " or manually with standard POSIX time functions."]
    #[doc = ""]
    #[doc = " Currently this will not get used in logging from binary blobs"]
    #[doc = " (i.e WiFi & Bluetooth libraries), these will still print the RTOS tick time."]
    #[doc = ""]
    #[doc = " @return timestamp, in \"HH:MM:SS.sss\""]
    pub fn esp_log_system_timestamp() -> *mut c_types::c_char;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output"]
    #[doc = ""]
    #[doc = " This function uses HW cycle counter and does not depend on OS,"]
    #[doc = " so it can be safely used after application crash."]
    #[doc = ""]
    #[doc = " @return timestamp, in milliseconds"]
    pub fn esp_log_early_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Write message into the log"]
    #[doc = ""]
    #[doc = " This function is not intended to be used directly. Instead, use one of"]
    #[doc = " ESP_LOGE, ESP_LOGW, ESP_LOGI, ESP_LOGD, ESP_LOGV macros."]
    #[doc = ""]
    #[doc = " This function or these macros should not be used from an interrupt."]
    pub fn esp_log_write(
        level: esp_log_level_t,
        tag: *const c_types::c_char,
        format: *const c_types::c_char,
        ...
    );
}
extern "C" {
    #[doc = " @brief Write message into the log, va_list variant"]
    #[doc = " @see esp_log_write()"]
    #[doc = ""]
    #[doc = " This function is provided to ease integration toward other logging framework,"]
    #[doc = " so that esp_log can be used as a log sink."]
    pub fn esp_log_writev(
        level: esp_log_level_t,
        tag: *const c_types::c_char,
        format: *const c_types::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn esp_log_buffer_hex_internal(
        tag: *const c_types::c_char,
        buffer: *const c_types::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_char_internal(
        tag: *const c_types::c_char,
        buffer: *const c_types::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_hexdump_internal(
        tag: *const c_types::c_char,
        buffer: *const c_types::c_void,
        buff_len: u16,
        log_level: esp_log_level_t,
    );
}
extern "C" {
    #[doc = " This function is defined to provide a deprecation warning whenever"]
    #[doc = " XT_CLOCK_FREQ macro is used."]
    #[doc = " Update the code to use esp_clk_cpu_freq function instead."]
    #[doc = " @return current CPU clock frequency, in Hz"]
    pub fn xt_clock_freq() -> c_types::c_int;
}
extern "C" {
    pub static Xthal_rev_no: c_types::c_uint;
}
extern "C" {
    pub fn xthal_save_extra(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_extra(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cpregs(base: *mut c_types::c_void, arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_restore_cpregs(base: *mut c_types::c_void, arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_save_cp0(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp1(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp2(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp3(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp4(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp5(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp6(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp7(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp0(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp1(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp2(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp3(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp4(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp5(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp6(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp7(base: *mut c_types::c_void);
}
extern "C" {
    pub static mut Xthal_cpregs_save_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_save_nw_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_nw_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static Xthal_extra_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_extra_align: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cpregs_size: [c_types::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_cpregs_align: [c_types::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_all_extra_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_all_extra_align: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_names: [*const c_types::c_char; 8usize];
}
extern "C" {
    pub fn xthal_init_mem_extra(arg1: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_init_mem_cp(arg1: *mut c_types::c_void, arg2: c_types::c_int);
}
extern "C" {
    pub static Xthal_num_coprocessors: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_num: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_max: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask: c_types::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs: c_types::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs_log2: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linewidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_linewidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linesize: c_types::c_ushort;
}
extern "C" {
    pub static Xthal_dcache_linesize: c_types::c_ushort;
}
extern "C" {
    pub static Xthal_icache_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_dcache_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_dcache_is_writeback: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_icache_region_invalidate(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_invalidate(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_writeback(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_writeback_inv(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_invalidate(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_invalidate(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_writeback(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_writeback_inv(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_icache_sync();
}
extern "C" {
    pub fn xthal_dcache_sync();
}
extern "C" {
    pub fn xthal_icache_get_ways() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_icache_set_ways(ways: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_get_ways() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_dcache_set_ways(ways: c_types::c_uint);
}
extern "C" {
    pub fn xthal_cache_coherence_on();
}
extern "C" {
    pub fn xthal_cache_coherence_off();
}
extern "C" {
    pub fn xthal_cache_coherence_optin();
}
extern "C" {
    pub fn xthal_cache_coherence_optout();
}
extern "C" {
    pub fn xthal_get_cache_prefetch() -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch_long(arg1: c_types::c_ulonglong) -> c_types::c_int;
}
extern "C" {
    pub static Xthal_debug_configured: c_types::c_int;
}
extern "C" {
    pub fn xthal_set_soft_break(addr: *mut c_types::c_void) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_remove_soft_break(addr: *mut c_types::c_void, arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_disassemble(
        instr_buf: *mut c_types::c_uchar,
        tgt_addr: *mut c_types::c_void,
        buffer: *mut c_types::c_char,
        buflen: c_types::c_uint,
        options: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_disassemble_size(instr_buf: *mut c_types::c_uchar) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_memcpy(
        dst: *mut c_types::c_void,
        src: *const c_types::c_void,
        len: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn xthal_bcopy(
        src: *const c_types::c_void,
        dst: *mut c_types::c_void,
        len: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn xthal_compare_and_set(
        addr: *mut c_types::c_int,
        test_val: c_types::c_int,
        compare_val: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub static Xthal_release_major: c_types::c_uint;
}
extern "C" {
    pub static Xthal_release_minor: c_types::c_uint;
}
extern "C" {
    pub static Xthal_release_name: *const c_types::c_char;
}
extern "C" {
    pub static Xthal_release_internal: *const c_types::c_char;
}
extern "C" {
    pub static Xthal_memory_order: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_windowed: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_density: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_booleans: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_loops: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_nsa: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_minmax: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_sext: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_clamps: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_mac16: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_mul16: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_fp: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_speculation: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_threadptr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_pif: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_writebuffer_entries: c_types::c_ushort;
}
extern "C" {
    pub static Xthal_build_unique_id: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid0: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid1: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_major: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_minor: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_name: *const c_types::c_char;
}
extern "C" {
    pub static Xthal_hw_release_internal: *const c_types::c_char;
}
extern "C" {
    pub fn xthal_clear_regcached_code();
}
extern "C" {
    pub fn xthal_window_spill();
}
extern "C" {
    pub fn xthal_validate_cp(arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_invalidate_cp(arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_set_cpenable(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_cpenable() -> c_types::c_uint;
}
extern "C" {
    pub static Xthal_num_intlevels: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_interrupts: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_excm_level: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_intlevel_mask: [c_types::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel_andbelow_mask: [c_types::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel: [c_types::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype: [c_types::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype_mask: [c_types::c_uint; 11usize];
}
extern "C" {
    pub static Xthal_timer_interrupt: [c_types::c_int; 4usize];
}
extern "C" {
    pub fn xthal_get_intenable() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_intenable(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_interrupt() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_intset(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_intclear(arg1: c_types::c_uint);
}
extern "C" {
    pub static Xthal_num_ibreak: c_types::c_int;
}
extern "C" {
    pub static Xthal_num_dbreak: c_types::c_int;
}
extern "C" {
    pub static Xthal_have_ccount: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_ccompare: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_get_ccount() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_ccompare(arg1: c_types::c_int, arg2: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_ccompare(arg1: c_types::c_int) -> c_types::c_uint;
}
extern "C" {
    pub static Xthal_have_prid: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_exceptions: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_xea_version: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_interrupts: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_highlevel_interrupts: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_nmi: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_get_prid() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_vpri_to_intlevel(vpri: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_intlevel_to_vpri(intlevel: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_int_enable(arg1: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_int_disable(arg1: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_int_vpri(intnum: c_types::c_int, vpri: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_get_int_vpri(intnum: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_vpri_locklevel(intlevel: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_vpri_locklevel() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri(vpri: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_get_vpri() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_intlevel(intlevel: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_lock() -> c_types::c_uint;
}
pub type XtHalVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut Xthal_tram_pending: c_types::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_enabled: c_types::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_sync: c_types::c_uint;
}
extern "C" {
    pub fn xthal_tram_pending_to_service() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_tram_done(serviced_mask: c_types::c_uint);
}
extern "C" {
    pub fn xthal_tram_set_sync(intnum: c_types::c_int, sync: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_tram_trigger_func(trigger_fn: XtHalVoidFunc) -> XtHalVoidFunc;
}
extern "C" {
    pub static Xthal_num_instrom: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_instram: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_datarom: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_dataram: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_xlmi: c_types::c_uchar;
}
extern "C" {
    pub static mut Xthal_instrom_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static Xthal_icache_setwidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_setwidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_icache_ways: c_types::c_uint;
}
extern "C" {
    pub static Xthal_dcache_ways: c_types::c_uint;
}
extern "C" {
    pub static Xthal_icache_line_lockable: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_line_lockable: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_get_cacheattr() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_get_icacheattr() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_get_dcacheattr() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_cacheattr(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_icacheattr(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_dcacheattr(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_region_attribute(
        addr: *mut c_types::c_void,
        size: c_types::c_uint,
        cattr: c_types::c_uint,
        flags: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_icache_enable();
}
extern "C" {
    pub fn xthal_dcache_enable();
}
extern "C" {
    pub fn xthal_icache_disable();
}
extern "C" {
    pub fn xthal_dcache_disable();
}
extern "C" {
    pub fn xthal_icache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_writeback();
}
extern "C" {
    pub fn xthal_dcache_all_writeback_inv();
}
extern "C" {
    pub fn xthal_icache_all_unlock();
}
extern "C" {
    pub fn xthal_dcache_all_unlock();
}
extern "C" {
    pub fn xthal_icache_region_lock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_lock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_region_unlock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_unlock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_hugerange_invalidate(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_hugerange_unlock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_hugerange_invalidate(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_hugerange_unlock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_hugerange_writeback(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_hugerange_writeback_inv(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_lock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_lock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_icache_line_unlock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_unlock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_memep_inject_error(
        addr: *mut c_types::c_void,
        size: c_types::c_int,
        flags: c_types::c_int,
    );
}
extern "C" {
    pub static Xthal_have_spanning_way: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_identity_map: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_mimic_cacheattr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_xlt_cacheattr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_cacheattr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_tlbs: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_kernel: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_rings: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ring_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_sr_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ca_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_max_pte_page_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_mmu_min_pte_page_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_itlb_way_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_ways: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_arf_ways: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_way_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_ways: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_arf_ways: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_static_v2p(vaddr: c_types::c_uint, paddrp: *mut c_types::c_uint)
        -> c_types::c_int;
}
extern "C" {
    pub fn xthal_static_p2v(
        paddr: c_types::c_uint,
        vaddrp: *mut c_types::c_uint,
        cached: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation(
        vaddr: *mut c_types::c_void,
        paddr: *mut c_types::c_void,
        size: c_types::c_uint,
        cache_atr: c_types::c_uint,
        flags: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_v2p(
        arg1: *mut c_types::c_void,
        arg2: *mut *mut c_types::c_void,
        arg3: *mut c_types::c_uint,
        arg4: *mut c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_invalidate_region(addr: *mut c_types::c_void) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation_raw(
        vaddr: *mut c_types::c_void,
        paddr: *mut c_types::c_void,
        cattr: c_types::c_uint,
    ) -> c_types::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xthal_MPU_entry {
    pub as_: u32,
    pub at: u32,
}
extern "C" {
    pub static mut Xthal_mpu_bgmap: [xthal_MPU_entry; 0usize];
}
extern "C" {
    pub fn xthal_is_kernel_readable(accessRights: u32) -> i32;
}
extern "C" {
    pub fn xthal_is_kernel_writeable(accessRights: u32) -> i32;
}
extern "C" {
    pub fn xthal_is_kernel_executable(accessRights: u32) -> i32;
}
extern "C" {
    pub fn xthal_is_user_readable(accessRights: u32) -> i32;
}
extern "C" {
    pub fn xthal_is_user_writeable(accessRights: u32) -> i32;
}
extern "C" {
    pub fn xthal_is_user_executable(accessRights: u32) -> i32;
}
extern "C" {
    pub fn xthal_encode_memory_type(x: u32) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_is_cacheable(memoryType: u32) -> i32;
}
extern "C" {
    pub fn xthal_is_writeback(memoryType: u32) -> i32;
}
extern "C" {
    pub fn xthal_is_device(memoryType: u32) -> i32;
}
extern "C" {
    pub fn xthal_read_map(entries: *mut xthal_MPU_entry) -> i32;
}
extern "C" {
    pub fn xthal_write_map(entries: *const xthal_MPU_entry, n: u32);
}
extern "C" {
    pub fn xthal_check_map(entries: *const xthal_MPU_entry, n: u32) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_get_entry_for_address(
        vaddr: *mut c_types::c_void,
        infgmap: *mut i32,
    ) -> xthal_MPU_entry;
}
extern "C" {
    pub fn xthal_calc_cacheadrdis(e: *const xthal_MPU_entry, n: u32) -> u32;
}
extern "C" {
    pub fn xthal_mpu_set_region_attribute(
        vaddr: *mut c_types::c_void,
        size: size_t,
        accessRights: i32,
        memoryType: i32,
        flags: u32,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_read_background_map(entries: *mut xthal_MPU_entry) -> i32;
}
extern "C" {
    pub static Xthal_cp_id_FPU: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_FPU: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP1_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP1_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP2_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP2_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP3_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP3_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP4_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP4_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP5_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP5_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP6_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP6_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP7_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP7_IDENT: c_types::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelFrame {
    pub pc: c_types::c_long,
    pub ps: c_types::c_long,
    pub areg: [c_types::c_long; 4usize],
    pub sar: c_types::c_long,
    pub lcount: c_types::c_long,
    pub lbeg: c_types::c_long,
    pub lend: c_types::c_long,
    pub acclo: c_types::c_long,
    pub acchi: c_types::c_long,
    pub mr: [c_types::c_long; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserFrame {
    pub pc: c_types::c_long,
    pub ps: c_types::c_long,
    pub sar: c_types::c_long,
    pub vpri: c_types::c_long,
    pub a2: c_types::c_long,
    pub a3: c_types::c_long,
    pub a4: c_types::c_long,
    pub a5: c_types::c_long,
    pub exccause: c_types::c_long,
    pub lcount: c_types::c_long,
    pub lbeg: c_types::c_long,
    pub lend: c_types::c_long,
    pub acclo: c_types::c_long,
    pub acchi: c_types::c_long,
    pub mr: [c_types::c_long; 4usize],
    pub pad: [c_types::c_long; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtExcFrame {
    pub exit: c_types::c_long,
    pub pc: c_types::c_long,
    pub ps: c_types::c_long,
    pub a0: c_types::c_long,
    pub a1: c_types::c_long,
    pub a2: c_types::c_long,
    pub a3: c_types::c_long,
    pub a4: c_types::c_long,
    pub a5: c_types::c_long,
    pub a6: c_types::c_long,
    pub a7: c_types::c_long,
    pub a8: c_types::c_long,
    pub a9: c_types::c_long,
    pub a10: c_types::c_long,
    pub a11: c_types::c_long,
    pub a12: c_types::c_long,
    pub a13: c_types::c_long,
    pub a14: c_types::c_long,
    pub a15: c_types::c_long,
    pub sar: c_types::c_long,
    pub exccause: c_types::c_long,
    pub excvaddr: c_types::c_long,
    pub lbeg: c_types::c_long,
    pub lend: c_types::c_long,
    pub lcount: c_types::c_long,
    pub tmp0: c_types::c_long,
    pub tmp1: c_types::c_long,
    pub tmp2: c_types::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtSolFrame {
    pub exit: c_types::c_long,
    pub pc: c_types::c_long,
    pub ps: c_types::c_long,
    pub next: c_types::c_long,
    pub a0: c_types::c_long,
    pub a1: c_types::c_long,
    pub a2: c_types::c_long,
    pub a3: c_types::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: c_types::c_int,
    pub rem: c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: c_types::c_long,
    pub rem: c_types::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: c_types::c_longlong,
    pub rem: c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const c_types::c_void,
        arg2: *const c_types::c_void,
    ) -> c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> c_types::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut c_types::c_void, arg2: size_t);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const c_types::c_void,
        __base: *const c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: c_types::c_uint, __size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn div(__numer: c_types::c_int, __denom: c_types::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: c_types::c_int);
}
extern "C" {
    pub fn free(arg1: *mut c_types::c_void);
}
extern "C" {
    pub fn getenv(__string: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(arg1: *mut _reent, __string: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const c_types::c_char,
        arg2: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut c_types::c_char,
        arg2: *const *mut c_types::c_char,
        arg3: *mut *mut c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: c_types::c_long) -> c_types::c_long;
}
extern "C" {
    pub fn ldiv(__numer: c_types::c_long, __denom: c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const c_types::c_char, arg2: size_t) -> c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: size_t,
        arg4: *mut _mbstate_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const c_types::c_char, arg3: size_t)
        -> c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut c_types::c_char, arg2: wchar_t) -> c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const c_types::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(arg1: *mut c_types::c_char, arg2: *const wchar_t, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const wchar_t,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut c_types::c_char, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> c_types::c_int;
}
extern "C" {
    pub fn realloc(__r: *mut c_types::c_void, __size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut c_types::c_void, __size: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const c_types::c_char,
        resolved_path: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: c_types::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const c_types::c_char, __end_PTR: *mut *mut c_types::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const c_types::c_char, __end_PTR: *mut *mut c_types::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: c_types::c_long) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: c_types::c_long) -> *mut c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: c_types::c_int, arg2: *mut c_types::c_void),
        >,
        __arg: *mut c_types::c_void,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: c_types::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        arg3: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const c_types::c_char,
        __value: *const c_types::c_char,
        __overwrite: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const c_types::c_char,
        __value: *const c_types::c_char,
        __overwrite: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: c_types::c_int,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: c_types::c_uint,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: c_types::c_int,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: c_types::c_uint,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut c_types::c_uint) -> c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut c_types::c_ushort) -> *mut c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> *mut c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: c_types::c_uint,
        arg2: *mut c_types::c_char,
        arg3: size_t,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn random() -> c_types::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: c_types::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const c_types::c_char) -> c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(arg1: *mut _reent, __nptr: *const c_types::c_char) -> c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: c_types::c_longlong) -> c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: c_types::c_longlong, __denom: c_types::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut c_types::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(arg1: *mut _reent, __string: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: c_types::c_int,
        arg4: c_types::c_int,
        arg5: *mut c_types::c_int,
        arg6: *mut c_types::c_int,
        arg7: *mut *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: size_t, arg3: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        arg3: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut c_types::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: c_types::c_uint,
        arg4: *const c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        __thunk: *mut c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut c_types::c_void,
                arg2: *const c_types::c_void,
                arg3: *const c_types::c_void,
            ) -> c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut *mut c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const c_types::c_char, arg2: *mut *mut c_types::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(arg1: size_t, arg2: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: c_types::c_int);
}
pub type TaskFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>;
extern "C" {
    #[doc = " @brief Stall CPU using RTC controller"]
    #[doc = " @param cpu_id ID of the CPU to stall (0 = PRO, 1 = APP)"]
    pub fn esp_cpu_stall(cpu_id: c_types::c_int);
}
extern "C" {
    #[doc = " @brief Un-stall CPU using RTC controller"]
    #[doc = " @param cpu_id ID of the CPU to un-stall (0 = PRO, 1 = APP)"]
    pub fn esp_cpu_unstall(cpu_id: c_types::c_int);
}
extern "C" {
    #[doc = " @brief Reset CPU using RTC controller"]
    #[doc = " @param cpu_id ID of the CPU to reset (0 = PRO, 1 = APP)"]
    pub fn esp_cpu_reset(cpu_id: c_types::c_int);
}
extern "C" {
    #[doc = " @brief Returns true if a JTAG debugger is attached to CPU"]
    #[doc = " OCD (on chip debug) port."]
    #[doc = ""]
    #[doc = " @note If \"Make exception and panic handlers JTAG/OCD aware\""]
    #[doc = " is disabled, this function always returns false."]
    pub fn esp_cpu_in_ocd_debug_mode() -> bool;
}
pub type esp_cpu_ccount_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XtosCoreState {
    pub signature: c_types::c_long,
    pub restore_label: c_types::c_long,
    pub aftersave_label: c_types::c_long,
    pub areg: [c_types::c_long; 64usize],
    pub caller_regs: [c_types::c_long; 16usize],
    pub caller_regs_saved: c_types::c_long,
    pub windowbase: c_types::c_long,
    pub windowstart: c_types::c_long,
    pub sar: c_types::c_long,
    pub epc1: c_types::c_long,
    pub ps: c_types::c_long,
    pub excsave1: c_types::c_long,
    pub depc: c_types::c_long,
    pub epc: [c_types::c_long; 6usize],
    pub eps: [c_types::c_long; 6usize],
    pub excsave: [c_types::c_long; 6usize],
    pub lcount: c_types::c_long,
    pub lbeg: c_types::c_long,
    pub lend: c_types::c_long,
    pub vecbase: c_types::c_long,
    pub atomctl: c_types::c_long,
    pub memctl: c_types::c_long,
    pub ccount: c_types::c_long,
    pub ccompare: [c_types::c_long; 3usize],
    pub intenable: c_types::c_long,
    pub interrupt: c_types::c_long,
    pub icount: c_types::c_long,
    pub icountlevel: c_types::c_long,
    pub debugcause: c_types::c_long,
    pub dbreakc: [c_types::c_long; 2usize],
    pub dbreaka: [c_types::c_long; 2usize],
    pub ibreaka: [c_types::c_long; 2usize],
    pub ibreakenable: c_types::c_long,
    pub misc: [c_types::c_long; 4usize],
    pub cpenable: c_types::c_long,
    pub tlbs: [c_types::c_long; 16usize],
    pub ncp: [c_types::c_char; 48usize],
    pub cp0: [c_types::c_char; 72usize],
}
pub type _xtos_handler_func = ::core::option::Option<unsafe extern "C" fn()>;
pub type _xtos_handler = _xtos_handler_func;
extern "C" {
    pub fn _xtos_ints_off(mask: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_ints_on(mask: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_set_intlevel(intlevel: c_types::c_int) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_set_min_intlevel(intlevel: c_types::c_int) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_restore_intlevel(restoreval: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_restore_just_intlevel(restoreval: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler(n: c_types::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler_arg(
        n: c_types::c_int,
        f: _xtos_handler,
        arg: *mut c_types::c_void,
    ) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_exception_handler(n: c_types::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_memep_initrams();
}
extern "C" {
    pub fn _xtos_memep_enable(flags: c_types::c_int);
}
extern "C" {
    pub fn _xtos_dispatch_level1_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level2_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level3_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level4_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level5_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level6_interrupts();
}
extern "C" {
    pub fn _xtos_read_ints() -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_clear_ints(mask: c_types::c_uint);
}
extern "C" {
    pub fn _xtos_core_shutoff(flags: c_types::c_uint) -> c_types::c_int;
}
extern "C" {
    pub fn _xtos_core_save(
        flags: c_types::c_uint,
        savearea: *mut XtosCoreState,
        code: *mut c_types::c_void,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _xtos_core_restore(retvalue: c_types::c_uint, savearea: *mut XtosCoreState);
}
extern "C" {
    pub fn _xtos_timer_0_delta(cycles: c_types::c_int);
}
extern "C" {
    pub fn _xtos_timer_1_delta(cycles: c_types::c_int);
}
extern "C" {
    pub fn _xtos_timer_2_delta(cycles: c_types::c_int);
}
extern "C" {
    #[doc = " Initialize the crosscore interrupt system for this CPU."]
    #[doc = " This needs to be called once on every CPU that is used"]
    #[doc = " by FreeRTOS."]
    #[doc = ""]
    #[doc = " If multicore FreeRTOS support is enabled, this will be"]
    #[doc = " called automatically by the startup code and should not"]
    #[doc = " be called manually."]
    pub fn esp_crosscore_int_init();
}
extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should yield its"]
    #[doc = " currently running task in favour of a higher-priority task"]
    #[doc = " that presumably just woke up."]
    #[doc = ""]
    #[doc = " This is used internally by FreeRTOS in multicore mode"]
    #[doc = " and should not be called by the user."]
    #[doc = ""]
    #[doc = " @param core_id Core that should do the yielding"]
    pub fn esp_crosscore_int_send_yield(core_id: c_types::c_int);
}
extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should update its"]
    #[doc = " CCOMPARE1 value due to a frequency switch."]
    #[doc = ""]
    #[doc = " This is used internally when dynamic frequency switching is"]
    #[doc = " enabled, and should not be called from application code."]
    #[doc = ""]
    #[doc = " @param core_id Core that should update its CCOMPARE1 value"]
    pub fn esp_crosscore_int_send_freq_switch(core_id: c_types::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single esp_timer"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type"]
#[doc = " @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>;
#[doc = "!< Callback is called from timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = " @brief Method for dispatching timer callback"]
pub type esp_timer_dispatch_t = c_types::c_uint;
#[doc = " @brief Timer configuration passed to esp_timer_create"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Function to call when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to the callback"]
    pub arg: *mut c_types::c_void,
    #[doc = "!< Call the callback from task or from ISR"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump function"]
    pub name: *const c_types::c_char,
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note This function is called from startup code. Applications do not need"]
    #[doc = " to call this function before using other esp_timer APIs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if allocation has failed"]
    #[doc = "      - ESP_ERR_INVALID_STATE if already initialized"]
    #[doc = "      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note Normally this function should not be called from applications"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance"]
    #[doc = ""]
    #[doc = " @note When done using the timer, delete it with esp_timer_delete function."]
    #[doc = ""]
    #[doc = " @param create_args   Pointer to a structure with timer creation arguments."]
    #[doc = "                      Not saved by the library, can be allocated on the stack."]
    #[doc = " @param[out] out_handle  Output, pointer to esp_timer_handle_t variable which"]
    #[doc = "                         will hold the created timer handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if some of the create_args are not valid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet"]
    #[doc = "      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start one-shot timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param timeout_us timer timeout, in microseconds relative to the current moment"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called. This function will"]
    #[doc = " start the timer which will trigger every 'period' microseconds."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param period timer period, in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the timer"]
    #[doc = ""]
    #[doc = " This function stops the timer previously started using esp_timer_start_once"]
    #[doc = " or esp_timer_start_periodic."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance"]
    #[doc = ""]
    #[doc = " The timer must be stopped before deleting. A one-shot timer which has expired"]
    #[doc = " does not need to be stopped."]
    #[doc = ""]
    #[doc = " @param timer timer handle allocated using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since boot"]
    #[doc = " @return number of microseconds since esp_timer_init was called (this normally"]
    #[doc = "          happens early during application startup)."]
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp when the next timeout is expected to occur"]
    #[doc = " @return Timestamp of the nearest timer event, in microseconds."]
    #[doc = "         The timebase is the same as for the values returned by esp_timer_get_time."]
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    #[doc = " @brief Dump the list of timers to a stream"]
    #[doc = ""]
    #[doc = " If CONFIG_ESP_TIMER_PROFILING option is enabled, this prints the list of all"]
    #[doc = " the existing timers. Otherwise, only the list active timers is printed."]
    #[doc = ""]
    #[doc = " The format is:"]
    #[doc = ""]
    #[doc = "   name  period  alarm  times_armed  times_triggered  total_callback_run_time"]
    #[doc = ""]
    #[doc = " where:"]
    #[doc = ""]
    #[doc = " name  timer name (if CONFIG_ESP_TIMER_PROFILING is defined), or timer pointer"]
    #[doc = " period  period of timer, in microseconds, or 0 for one-shot timer"]
    #[doc = " alarm - time of the next alarm, in microseconds since boot, or 0 if the timer"]
    #[doc = "         is not started"]
    #[doc = ""]
    #[doc = " The following fields are printed if CONFIG_ESP_TIMER_PROFILING is defined:"]
    #[doc = ""]
    #[doc = " times_armed  number of times the timer was armed via esp_timer_start_X"]
    #[doc = " times_triggered - number of times the callback was called"]
    #[doc = " total_callback_run_time - total time taken by callback to execute, across all calls"]
    #[doc = ""]
    #[doc = " @param stream stream (such as stdout) to dump the information to"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if can not allocate temporary buffer for the output"]
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to a registered heap"]
pub type multi_heap_handle_t = *mut multi_heap_info;
extern "C" {
    #[doc = " @brief allocate a chunk of memory with specific alignment"]
    #[doc = ""]
    #[doc = " @param heap  Handle to a registered heap."]
    #[doc = " @param size  size in bytes of memory chunk"]
    #[doc = " @param alignment  how the memory must be aligned"]
    #[doc = ""]
    #[doc = " @return pointer to the memory allocated, NULL on failure"]
    pub fn multi_heap_aligned_alloc(
        heap: multi_heap_handle_t,
        size: size_t,
        alignment: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief malloc() a buffer in a given heap"]
    #[doc = ""]
    #[doc = " Semantics are the same as standard malloc(), only the returned buffer will be allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param size Size of desired buffer."]
    #[doc = ""]
    #[doc = " @return Pointer to new memory, or NULL if allocation fails."]
    pub fn multi_heap_malloc(heap: multi_heap_handle_t, size: size_t) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief free() a buffer aligned in a given heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p NULL, or a pointer previously returned from multi_heap_aligned_alloc() for the same heap."]
    pub fn multi_heap_aligned_free(heap: multi_heap_handle_t, p: *mut c_types::c_void);
}
extern "C" {
    #[doc = " @brief free() a buffer in a given heap."]
    #[doc = ""]
    #[doc = " Semantics are the same as standard free(), only the argument 'p' must be NULL or have been allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    pub fn multi_heap_free(heap: multi_heap_handle_t, p: *mut c_types::c_void);
}
extern "C" {
    #[doc = " @brief realloc() a buffer in a given heap."]
    #[doc = ""]
    #[doc = " Semantics are the same as standard realloc(), only the argument 'p' must be NULL or have been allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    #[doc = " @param size Desired new size for buffer."]
    #[doc = ""]
    #[doc = " @return New buffer of 'size' containing contents of 'p', or NULL if reallocation failed."]
    pub fn multi_heap_realloc(
        heap: multi_heap_handle_t,
        p: *mut c_types::c_void,
        size: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p Pointer, must have been previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    #[doc = ""]
    #[doc = " @return Size of the memory allocated at this block. May be more than the original size argument, due"]
    #[doc = " to padding and minimum block sizes."]
    pub fn multi_heap_get_allocated_size(
        heap: multi_heap_handle_t,
        p: *mut c_types::c_void,
    ) -> size_t;
}
extern "C" {
    #[doc = " @brief Register a new heap for use"]
    #[doc = ""]
    #[doc = " This function initialises a heap at the specified address, and returns a handle for future heap operations."]
    #[doc = ""]
    #[doc = " There is no equivalent function for deregistering a heap - if all blocks in the heap are free, you can immediately start using the memory for other purposes."]
    #[doc = ""]
    #[doc = " @param start Start address of the memory to use for a new heap."]
    #[doc = " @param size Size (in bytes) of the new heap."]
    #[doc = ""]
    #[doc = " @return Handle of a new heap ready for use, or NULL if the heap region was too small to be initialised."]
    pub fn multi_heap_register(start: *mut c_types::c_void, size: size_t) -> multi_heap_handle_t;
}
extern "C" {
    #[doc = " @brief Associate a private lock pointer with a heap"]
    #[doc = ""]
    #[doc = " The lock argument is supplied to the MULTI_HEAP_LOCK() and MULTI_HEAP_UNLOCK() macros, defined in multi_heap_platform.h."]
    #[doc = ""]
    #[doc = " The lock in question must be recursive."]
    #[doc = ""]
    #[doc = " When the heap is first registered, the associated lock is NULL."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param lock Optional pointer to a locking structure to associate with this heap."]
    pub fn multi_heap_set_lock(heap: multi_heap_handle_t, lock: *mut c_types::c_void);
}
extern "C" {
    #[doc = " @brief Dump heap information to stdout"]
    #[doc = ""]
    #[doc = " For debugging purposes, this function dumps information about every block in the heap to stdout."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    pub fn multi_heap_dump(heap: multi_heap_handle_t);
}
extern "C" {
    #[doc = " @brief Check heap integrity"]
    #[doc = ""]
    #[doc = " Walks the heap and checks all heap data structures are valid. If any errors are detected, an error-specific message"]
    #[doc = " can be optionally printed to stderr. Print behaviour can be overriden at compile time by defining"]
    #[doc = " MULTI_CHECK_FAIL_PRINTF in multi_heap_platform.h."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param print_errors If true, errors will be printed to stderr."]
    #[doc = " @return true if heap is valid, false otherwise."]
    pub fn multi_heap_check(heap: multi_heap_handle_t, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Return free heap size"]
    #[doc = ""]
    #[doc = " Returns the number of bytes available in the heap."]
    #[doc = ""]
    #[doc = " Equivalent to the total_free_bytes member returned by multi_heap_get_heap_info()."]
    #[doc = ""]
    #[doc = " Note that the heap may be fragmented, so the actual maximum size for a single malloc() may be lower. To know this"]
    #[doc = " size, see the largest_free_block member returned by multi_heap_get_heap_info()."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @return Number of free bytes."]
    pub fn multi_heap_free_size(heap: multi_heap_handle_t) -> size_t;
}
extern "C" {
    #[doc = " @brief Return the lifetime minimum free heap size"]
    #[doc = ""]
    #[doc = " Equivalent to the minimum_free_bytes member returned by multi_heap_get_info()."]
    #[doc = ""]
    #[doc = " Returns the lifetime \"low water mark\" of possible values returned from multi_free_heap_size(), for the specified"]
    #[doc = " heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @return Number of free bytes."]
    pub fn multi_heap_minimum_free_size(heap: multi_heap_handle_t) -> size_t;
}
#[doc = " @brief Structure to access heap metadata via multi_heap_get_info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info_t {
    #[doc = "<  Total free bytes in the heap. Equivalent to multi_free_heap_size()."]
    pub total_free_bytes: size_t,
    #[doc = "<  Total bytes allocated to data in the heap."]
    pub total_allocated_bytes: size_t,
    #[doc = "<  Size of largest free block in the heap. This is the largest malloc-able size."]
    pub largest_free_block: size_t,
    #[doc = "<  Lifetime minimum free heap size. Equivalent to multi_minimum_free_heap_size()."]
    pub minimum_free_bytes: size_t,
    #[doc = "<  Number of (variable size) blocks allocated in the heap."]
    pub allocated_blocks: size_t,
    #[doc = "<  Number of (variable size) free blocks in the heap."]
    pub free_blocks: size_t,
    #[doc = "<  Total number of (variable size) blocks in the heap."]
    pub total_blocks: size_t,
}
extern "C" {
    #[doc = " @brief Return metadata about a given heap"]
    #[doc = ""]
    #[doc = " Fills a multi_heap_info_t structure with information about the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param info Pointer to a structure to fill with heap metadata."]
    pub fn multi_heap_get_info(heap: multi_heap_handle_t, info: *mut multi_heap_info_t);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities"]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc malloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``malloc(p)`` is equivalent to ``heap_caps_malloc(p, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " @param size Size, in bytes, of the amount of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc(size: size_t, caps: u32) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Free memory previously allocated via heap_caps_malloc() or heap_caps_realloc()."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc free(), for capability-aware memory."]
    #[doc = ""]
    #[doc = "  In IDF, ``free(p)`` is equivalent to ``heap_caps_free(p)``."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to memory previously returned from heap_caps_malloc() or heap_caps_realloc(). Can be NULL."]
    pub fn heap_caps_free(ptr: *mut c_types::c_void);
}
extern "C" {
    #[doc = " @brief Reallocate memory previously allocated via heap_caps_malloc() or heap_caps_realloc()."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc realloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``realloc(p, s)`` is equivalent to ``heap_caps_realloc(p, s, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " 'caps' parameter can be different to the capabilities that any original 'ptr' was allocated with. In this way,"]
    #[doc = " realloc can be used to \"move\" a buffer if necessary to ensure it meets a new set of capabilities."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to previously allocated memory, or NULL for a new allocation."]
    #[doc = " @param size Size of the new buffer requested, or 0 to free the buffer."]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory desired for the new allocation."]
    #[doc = ""]
    #[doc = " @return Pointer to a new buffer of size 'size' with capabilities 'caps', or NULL if allocation failed."]
    pub fn heap_caps_realloc(
        ptr: *mut c_types::c_void,
        size: size_t,
        caps: c_types::c_int,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a aligned chunk of memory which has the given capabilities"]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc aligned_alloc(), for capability-aware memory."]
    #[doc = " @param alignment  How the pointer received needs to be aligned"]
    #[doc = "                   must be a power of two"]
    #[doc = " @param size Size, in bytes, of the amount of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    #[doc = ""]
    #[doc = " @note Any memory allocated with heaps_caps_aligned_alloc() MUST"]
    #[doc = " be freed with heap_caps_aligned_free() and CANNOT be passed to free()"]
    #[doc = ""]
    pub fn heap_caps_aligned_alloc(
        alignment: size_t,
        size: size_t,
        caps: c_types::c_int,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a aligned chunk of memory which has the given capabilities. The initialized value in the memory is set to zero."]
    #[doc = ""]
    #[doc = " @param alignment  How the pointer received needs to be aligned"]
    #[doc = "                   must be a power of two"]
    #[doc = " @param n    Number of continuing chunks of memory to allocate"]
    #[doc = " @param size Size, in bytes, of a chunk of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    #[doc = ""]
    #[doc = " @note Any memory allocated with heap_caps_aligned_calloc() MUST"]
    #[doc = " be freed with heap_caps_aligned_free() and CANNOT be passed to free()"]
    pub fn heap_caps_aligned_calloc(
        alignment: size_t,
        n: size_t,
        size: size_t,
        caps: u32,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Used to deallocate memory previously allocated with heap_caps_aligned_alloc"]
    #[doc = ""]
    #[doc = " @param ptr Pointer to the memory allocated"]
    #[doc = " @note This function is aimed to deallocate only memory allocated with"]
    #[doc = "       heap_caps_aligned_alloc, memory allocated with heap_caps_malloc"]
    #[doc = "       MUST not be passed to this function"]
    pub fn heap_caps_aligned_free(ptr: *mut c_types::c_void);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities. The initialized value in the memory is set to zero."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc calloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``calloc(p)`` is equivalent to ``heap_caps_calloc(p, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " @param n    Number of continuing chunks of memory to allocate"]
    #[doc = " @param size Size, in bytes, of a chunk of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc(n: size_t, size: size_t, caps: u32) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Get the total size of all the regions that have the given capabilities"]
    #[doc = ""]
    #[doc = " This function takes all regions capable of having the given capabilities allocated in them"]
    #[doc = " and adds up the total space they have."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return total size in bytes"]
    pub fn heap_caps_get_total_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the total free size of all the regions that have the given capabilities"]
    #[doc = ""]
    #[doc = " This function takes all regions capable of having the given capabilities allocated in them"]
    #[doc = " and adds up the free space they have."]
    #[doc = ""]
    #[doc = " Note that because of heap fragmentation it is probably not possible to allocate a single block of memory"]
    #[doc = " of this size. Use heap_caps_get_largest_free_block() for this purpose."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the total minimum free memory of all regions with the given capabilities"]
    #[doc = ""]
    #[doc = " This adds all the low water marks of the regions capable of delivering the memory"]
    #[doc = " with the given capabilities."]
    #[doc = ""]
    #[doc = " Note the result may be less than the global all-time minimum available heap of this kind, as \"low water marks\" are"]
    #[doc = " tracked per-region. Individual regions' heaps may have reached their \"low water marks\" at different points in time. However"]
    #[doc = " this result still gives a \"worst case\" indication for all-time minimum free heap."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the largest free block of memory able to be allocated with the given capabilities."]
    #[doc = ""]
    #[doc = " Returns the largest value of ``s`` for which ``heap_caps_malloc(s, caps)`` will succeed."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Size of largest free block in bytes."]
    pub fn heap_caps_get_largest_free_block(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get heap info for all regions with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_info() on all heaps which share the given capabilities.  The information returned is an aggregate"]
    #[doc = " across all matching heaps.  The meanings of fields are the same as defined for multi_heap_info_t, except that"]
    #[doc = " ``minimum_free_bytes`` has the same caveats described in heap_caps_get_minimum_free_size()."]
    #[doc = ""]
    #[doc = " @param info        Pointer to a structure which will be filled with relevant"]
    #[doc = "                    heap metadata."]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    pub fn heap_caps_get_info(info: *mut multi_heap_info_t, caps: u32);
}
extern "C" {
    #[doc = " @brief Print a summary of all memory with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_info on all heaps which share the given capabilities, and"]
    #[doc = " prints a two-line summary for each, then a total summary."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    pub fn heap_caps_print_heap_info(caps: u32);
}
extern "C" {
    #[doc = " @brief Check integrity of all heap memory in the system."]
    #[doc = ""]
    #[doc = " Calls multi_heap_check on all heaps. Optionally print errors if heaps are corrupt."]
    #[doc = ""]
    #[doc = " Calling this function is equivalent to calling heap_caps_check_integrity"]
    #[doc = " with the caps argument set to MALLOC_CAP_INVALID."]
    #[doc = ""]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity_all(print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of all heaps with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_check on all heaps which share the given capabilities. Optionally"]
    #[doc = " print errors if the heaps are corrupt."]
    #[doc = ""]
    #[doc = " See also heap_caps_check_integrity_all to check all heap memory"]
    #[doc = " in the system and heap_caps_check_integrity_addr to check memory"]
    #[doc = " around a single address."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity(caps: u32, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of heap memory around a given address."]
    #[doc = ""]
    #[doc = " This function can be used to check the integrity of a single region of heap memory,"]
    #[doc = " which contains the given address."]
    #[doc = ""]
    #[doc = " This can be useful if debugging heap integrity for corruption at a known address,"]
    #[doc = " as it has a lower overhead than checking all heap regions. Note that if the corrupt"]
    #[doc = " address moves around between runs (due to timing or other factors) then this approach"]
    #[doc = " won't work and you should call heap_caps_check_integrity or"]
    #[doc = " heap_caps_check_integrity_all instead."]
    #[doc = ""]
    #[doc = " @note The entire heap region around the address is checked, not only the adjacent"]
    #[doc = " heap blocks."]
    #[doc = ""]
    #[doc = " @param addr Address in memory. Check for corruption in region containing this address."]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if the heap containing the specified address is valid,"]
    #[doc = " False if at least one heap is corrupt or the address doesn't belong to a heap region."]
    pub fn heap_caps_check_integrity_addr(addr: isize, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Enable malloc() in external memory and set limit below which"]
    #[doc = "        malloc() attempts are placed in internal memory."]
    #[doc = ""]
    #[doc = " When external memory is in use, the allocation strategy is to initially try to"]
    #[doc = " satisfy smaller allocation requests with internal memory and larger requests"]
    #[doc = " with external memory. This sets the limit between the two, as well as generally"]
    #[doc = " enabling allocation in external memory."]
    #[doc = ""]
    #[doc = " @param limit       Limit, in bytes."]
    pub fn heap_caps_malloc_extmem_enable(limit: size_t);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @attention The variable parameters are bitwise OR of MALLOC_CAP_* flags indicating the type of memory."]
    #[doc = "            This API prefers to allocate memory with the first parameter. If failed, allocate memory with"]
    #[doc = "            the next parameter. It will try in this order until allocating a chunk of memory successfully"]
    #[doc = "            or fail to allocate memories with any of the parameters."]
    #[doc = ""]
    #[doc = " @param size Size, in bytes, of the amount of memory to allocate"]
    #[doc = " @param num Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc_prefer(size: size_t, num: size_t, ...) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to previously allocated memory, or NULL for a new allocation."]
    #[doc = " @param size Size of the new buffer requested, or 0 to free the buffer."]
    #[doc = " @param num Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return Pointer to a new buffer of size 'size', or NULL if allocation failed."]
    pub fn heap_caps_realloc_prefer(
        ptr: *mut c_types::c_void,
        size: size_t,
        num: size_t,
        ...
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @param n    Number of continuing chunks of memory to allocate"]
    #[doc = " @param size Size, in bytes, of a chunk of memory to allocate"]
    #[doc = " @param num  Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc_prefer(
        n: size_t,
        size: size_t,
        num: size_t,
        ...
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps with matching capabilities."]
    #[doc = ""]
    #[doc = " Prints a large amount of output to serial (because of locking limitations,"]
    #[doc = " the output bypasses stdout/stderr). For each (variable sized) block"]
    #[doc = " in each matching heap, the following output is printed on a single line:"]
    #[doc = ""]
    #[doc = " - Block address (the data buffer returned by malloc is 4 bytes after this"]
    #[doc = "   if heap debugging is set to Basic, or 8 bytes otherwise)."]
    #[doc = " - Data size (the data size may be larger than the size requested by malloc,"]
    #[doc = "   either due to heap fragmentation or because of heap debugging level)."]
    #[doc = " - Address of next block in the heap."]
    #[doc = " - If the block is free, the address of the next free block is also printed."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    pub fn heap_caps_dump(caps: u32);
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps."]
    #[doc = ""]
    #[doc = " Covers all registered heaps. Prints a large amount of output to serial."]
    #[doc = ""]
    #[doc = " Output is the same as for heap_caps_dump."]
    #[doc = ""]
    pub fn heap_caps_dump_all();
}
extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to currently allocated heap memory. Must be a pointer value previously"]
    #[doc = " returned by heap_caps_malloc,malloc,calloc, etc. and not yet freed."]
    #[doc = ""]
    #[doc = " @note The app will crash with an assertion failure if the pointer is not valid."]
    #[doc = ""]
    #[doc = " @return Size of the memory allocated at this block."]
    #[doc = ""]
    pub fn heap_caps_get_allocated_size(ptr: *mut c_types::c_void) -> size_t;
}
pub type StackType_t = u8;
pub type BaseType_t = c_types::c_int;
pub type UBaseType_t = c_types::c_uint;
pub type TickType_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct portMUX_TYPE {
    pub owner: u32,
    pub count: u32,
}
extern "C" {
    pub fn vPortAssertIfInISR();
}
extern "C" {
    pub fn vPortCPUInitializeMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskExitCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskEnterCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortCPUAcquireMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    #[doc = " @brief Acquire a portmux spinlock with a timeout"]
    #[doc = ""]
    #[doc = " @param mux Pointer to portmux to acquire."]
    #[doc = " @param timeout_cycles Timeout to spin, in CPU cycles. Pass portMUX_NO_TIMEOUT to wait forever,"]
    #[doc = " portMUX_TRY_LOCK to try a single time to acquire the lock."]
    #[doc = ""]
    #[doc = " @return true if mutex is successfully acquired, false on timeout."]
    pub fn vPortCPUAcquireMutexTimeout(
        mux: *mut portMUX_TYPE,
        timeout_cycles: c_types::c_int,
    ) -> bool;
}
extern "C" {
    pub fn vPortCPUReleaseMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortYield();
}
extern "C" {
    pub fn _frxt_setup_switch();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMPU_SETTINGS {
    pub coproc_area: *mut StackType_t,
}
extern "C" {
    pub fn esp_vApplicationIdleHook();
}
extern "C" {
    pub fn esp_vApplicationTickHook();
}
extern "C" {
    pub fn _xt_coproc_release(coproc_sa_base: *mut c_types::c_void);
}
extern "C" {
    pub fn vApplicationSleep(xExpectedIdleTime: TickType_t);
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut c_types::c_void,
        xRunPrivileged: BaseType_t,
    ) -> *mut StackType_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn vPortYieldOtherCore(coreid: BaseType_t);
}
extern "C" {
    pub fn vPortSetStackWatchpoint(pxStackStart: *mut c_types::c_void);
}
extern "C" {
    pub fn xPortInIsrContext() -> BaseType_t;
}
extern "C" {
    pub fn xPortInterruptedFromISRContext() -> BaseType_t;
}
extern "C" {
    pub fn vPortStoreTaskMPUSettings(
        xMPUSettings: *mut xMPU_SETTINGS,
        xRegions: *const xMEMORY_REGION,
        pxBottomOfStack: *mut StackType_t,
        usStackDepth: u32,
    );
}
extern "C" {
    pub fn vPortReleaseTaskMPUSettings(xMPUSettings: *mut xMPU_SETTINGS);
}
extern "C" {
    pub fn xPortGetTickRateHz() -> u32;
}
extern "C" {
    pub fn uxPortCompareSetExtram(addr: *mut u32, compare: u32, set: *mut u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut c_types::c_void; 4usize],
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut c_types::c_void; 2usize],
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy1: UBaseType_t,
    pub pvDummy2: *mut c_types::c_void,
    pub xDummy3: StaticMiniListItem_t,
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut c_types::c_void,
    pub xDummy2: xMPU_SETTINGS,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut c_types::c_void,
    pub ucDummy7: [u8; 16usize],
    pub uxDummyCoreId: UBaseType_t,
    pub pxDummy8: *mut c_types::c_void,
    pub uxDummy9: UBaseType_t,
    pub OldInterruptState: u32,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut c_types::c_void; 1usize],
    pub pvDummyLocalStorageCallBack: [*mut c_types::c_void; 1usize],
    pub xDummy17: _reent,
    pub ulDummy18: u32,
    pub ucDummy19: u32,
    pub uxDummy20: u8,
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut c_types::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub pvDummy7: *mut c_types::c_void,
    pub muxDummy: portMUX_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut c_types::c_void,
    pub uxDummy2: UBaseType_t,
    _bindgen_union_align: u32,
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub muxDummy: portMUX_TYPE,
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut c_types::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub uxDummy4: UBaseType_t,
    pub pvDummy5: [*mut c_types::c_void; 2usize],
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut c_types::c_void,
    pub pvContainer: *mut c_types::c_void,
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an TaskHandle_t variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\ingroup Tasks"]
pub type TaskHandle_t = *mut c_types::c_void;
#[doc = " Defines the prototype to which the application task hook function must"]
#[doc = " conform."]
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void) -> BaseType_t>;
#[doc = "< A task is querying the state of itself, so must be running."]
pub const eTaskState_eRunning: eTaskState = 0;
#[doc = "< The task being queried is in a read or pending ready list."]
pub const eTaskState_eReady: eTaskState = 1;
#[doc = "< The task being queried is in the Blocked state."]
pub const eTaskState_eBlocked: eTaskState = 2;
#[doc = "< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out."]
pub const eTaskState_eSuspended: eTaskState = 3;
#[doc = "< The task being queried has been deleted, but its TCB has not yet been freed."]
pub const eTaskState_eDeleted: eTaskState = 4;
#[doc = " Task states returned by eTaskGetState."]
pub type eTaskState = c_types::c_uint;
#[doc = "< Notify the task without updating its notify value."]
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
#[doc = "< Set bits in the task's notification value."]
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
#[doc = "< Increment the task's notification value."]
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
#[doc = "< Set the task's notification value to a specific value even if the previous value has not yet been read by the task."]
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
#[doc = "< Set the task's notification value if the previous value has been read by the task."]
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
#[doc = " Actions that can be performed when vTaskNotify() is called."]
pub type eNotifyAction = c_types::c_uint;
#[doc = " @cond */"]
#[doc = " Used internally only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
#[doc = " @cond */"]
#[doc = " Used internally only."]
pub type TimeOut_t = xTIME_OUT;
#[doc = " Defines the memory ranges allocated to the task when an MPU is used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut c_types::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
#[doc = " Defines the memory ranges allocated to the task when an MPU is used."]
pub type MemoryRegion_t = xMEMORY_REGION;
#[doc = " Parameters required to create an MPU protected task."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const c_types::c_char,
    pub usStackDepth: u32,
    pub pvParameters: *mut c_types::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
#[doc = " Parameters required to create an MPU protected task."]
pub type TaskParameters_t = xTASK_PARAMETERS;
#[doc = "  Used with the uxTaskGetSystemState() function to return the state of each task in the system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    #[doc = "< The handle of the task to which the rest of the information in the structure relates."]
    pub xHandle: TaskHandle_t,
    #[doc = "< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated!"]
    pub pcTaskName: *const c_types::c_char,
    #[doc = "< A number unique to the task."]
    pub xTaskNumber: UBaseType_t,
    #[doc = "< The state in which the task existed when the structure was populated."]
    pub eCurrentState: eTaskState,
    #[doc = "< The priority at which the task was running (may be inherited) when the structure was populated."]
    pub uxCurrentPriority: UBaseType_t,
    #[doc = "< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h."]
    pub uxBasePriority: UBaseType_t,
    #[doc = "< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h."]
    pub ulRunTimeCounter: u32,
    #[doc = "< Points to the lowest address of the task's stack area."]
    pub pxStackBase: *mut StackType_t,
    #[doc = "< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack."]
    pub usStackHighWaterMark: u32,
}
#[doc = "  Used with the uxTaskGetSystemState() function to return the state of each task in the system."]
pub type TaskStatus_t = xTASK_STATUS;
#[doc = " Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system."]
#[doc = " We need this struct because TCB_t is defined (hidden) in tasks.c."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_SNAPSHOT {
    #[doc = "< Address of task control block."]
    pub pxTCB: *mut c_types::c_void,
    #[doc = "< Points to the location of the last item placed on the tasks stack."]
    pub pxTopOfStack: *mut StackType_t,
    #[doc = "< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo"]
    #[doc = "pxTopOfStack > pxEndOfStack, stack grows lo2hi"]
    pub pxEndOfStack: *mut StackType_t,
}
#[doc = " Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system."]
#[doc = " We need this struct because TCB_t is defined (hidden) in tasks.c."]
pub type TaskSnapshot_t = xTASK_SNAPSHOT;
#[doc = "< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode."]
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
#[doc = "< Enter a sleep mode that will not last any longer than the expected idle time."]
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
#[doc = "< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt."]
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
#[doc = " Possible return values for eTaskConfirmSleepModeStatus()."]
pub type eSleepModeStatus = c_types::c_uint;
extern "C" {
    pub fn xTaskCreatePinnedToCore(
        pvTaskCode: TaskFunction_t,
        pcName: *const c_types::c_char,
        usStackDepth: u32,
        pvParameters: *mut c_types::c_void,
        uxPriority: UBaseType_t,
        pvCreatedTask: *mut TaskHandle_t,
        xCoreID: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskCreateRestricted(
        pxTaskDefinition: *const TaskParameters_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Memory regions are assigned to a restricted task when the task is created by"]
    #[doc = " a call to xTaskCreateRestricted().  These regions can be redefined using"]
    #[doc = " vTaskAllocateMPURegions()."]
    #[doc = ""]
    #[doc = " @param xTask The handle of the task being updated."]
    #[doc = ""]
    #[doc = " @param xRegions A pointer to an MemoryRegion_t structure that contains the"]
    #[doc = " new memory region definitions."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = " @code{c}"]
    #[doc = " // Define an array of MemoryRegion_t structures that configures an MPU region"]
    #[doc = " // allowing read/write access for 1024 bytes starting at the beginning of the"]
    #[doc = " // ucOneKByte array.  The other two of the maximum 3 definable regions are"]
    #[doc = " // unused so set to zero."]
    #[doc = " static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] ="]
    #[doc = " {"]
    #[doc = " \t// Base address\t\tLength\t\tParameters"]
    #[doc = " \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },"]
    #[doc = " \t{ 0,\t\t\t\t0,\t\t\t0 },"]
    #[doc = " \t{ 0,\t\t\t\t0,\t\t\t0 }"]
    #[doc = " };"]
    #[doc = ""]
    #[doc = " void vATask( void *pvParameters )"]
    #[doc = " {"]
    #[doc = " \t// This task was created such that it has access to certain regions of"]
    #[doc = " \t// memory as defined by the MPU configuration.  At some point it is"]
    #[doc = " \t// desired that these MPU regions are replaced with that defined in the"]
    #[doc = " \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()"]
    #[doc = " \t// for this purpose.  NULL is used as the task handle to indicate that this"]
    #[doc = " \t// function should modify the MPU regions of the calling task."]
    #[doc = " \tvTaskAllocateMPURegions( NULL, xAltRegions );"]
    #[doc = ""]
    #[doc = " \t// Now the task can continue its function, but from this point on can only"]
    #[doc = " \t// access its stack and the ucOneKByte array (unless any other statically"]
    #[doc = " \t// defined or shared regions have been declared elsewhere)."]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    #[doc = " Remove a task from the RTOS real time kernel's management."]
    #[doc = ""]
    #[doc = " The task being deleted will be removed from all ready, blocked, suspended"]
    #[doc = " and event lists."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @note The idle task is responsible for freeing the kernel allocated"]
    #[doc = " memory from tasks that have been deleted.  It is therefore important that"]
    #[doc = " the idle task is not starved of microcontroller processing time if your"]
    #[doc = " application makes any calls to vTaskDelete ().  Memory allocated by the"]
    #[doc = " task code is not automatically freed, and should be freed before the task"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " See the demo application file death.c for sample code that utilises"]
    #[doc = " vTaskDelete ()."]
    #[doc = ""]
    #[doc = " @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will"]
    #[doc = " cause the calling task to be deleted."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vOtherFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = " \t // Create the task, storing the handle."]
    #[doc = " \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = " \t // Use the handle to delete the task."]
    #[doc = " \t vTaskDelete( xHandle );"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    #[doc = " Delay a task for a given number of ticks."]
    #[doc = ""]
    #[doc = " The actual time that the task remains blocked depends on the tick rate."]
    #[doc = " The constant portTICK_PERIOD_MS can be used to calculate real time from"]
    #[doc = " the tick rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelay must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " vTaskDelay() specifies a time at which the task wishes to unblock relative to"]
    #[doc = " the time at which vTaskDelay() is called.  For example, specifying a block"]
    #[doc = " period of 100 ticks will cause the task to unblock 100 ticks after"]
    #[doc = " vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method"]
    #[doc = " of controlling the frequency of a periodic task as the path taken through the"]
    #[doc = " code, as well as other task and interrupt activity, will effect the frequency"]
    #[doc = " at which vTaskDelay() gets called and therefore the time at which the task"]
    #[doc = " next executes.  See vTaskDelayUntil() for an alternative API function designed"]
    #[doc = " to facilitate fixed frequency execution.  It does this by specifying an"]
    #[doc = " absolute time (rather than a relative time) at which the calling task should"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " @param xTicksToDelay The amount of time, in tick periods, that"]
    #[doc = " the calling task should block."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTaskFunction( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "  // Block for 500ms."]
    #[doc = "  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;"]
    #[doc = ""]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t // Simply toggle the LED every 500ms, blocking between each toggle."]
    #[doc = " \t\t vToggleLED();"]
    #[doc = " \t\t vTaskDelay( xDelay );"]
    #[doc = " \t }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    #[doc = " Delay a task until a specified time."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " This function can be used by periodic tasks to ensure a constant execution frequency."]
    #[doc = ""]
    #[doc = " This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will"]
    #[doc = " cause a task to block for the specified number of ticks from the time vTaskDelay () is"]
    #[doc = " called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed"]
    #[doc = " execution frequency as the time between a task starting to execute and that task"]
    #[doc = " calling vTaskDelay () may not be fixed [the task may take a different path though the"]
    #[doc = " code between calls, or may get interrupted or preempted a different number of times"]
    #[doc = " each time it executes]."]
    #[doc = ""]
    #[doc = " Whereas vTaskDelay () specifies a wake time relative to the time at which the function"]
    #[doc = " is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " The constant portTICK_PERIOD_MS can be used to calculate real time from the tick"]
    #[doc = " rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " @param pxPreviousWakeTime Pointer to a variable that holds the time at which the"]
    #[doc = " task was last unblocked.  The variable must be initialised with the current time"]
    #[doc = " prior to its first use (see the example below).  Following this the variable is"]
    #[doc = " automatically updated within vTaskDelayUntil ()."]
    #[doc = ""]
    #[doc = " @param xTimeIncrement The cycle time period.  The task will be unblocked at"]
    #[doc = " time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the"]
    #[doc = " same xTimeIncrement parameter value will cause the task to execute with"]
    #[doc = " a fixed interface period."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  // Perform an action every 10 ticks."]
    #[doc = "  void vTaskFunction( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "  TickType_t xLastWakeTime;"]
    #[doc = "  const TickType_t xFrequency = 10;"]
    #[doc = ""]
    #[doc = " \t // Initialise the xLastWakeTime variable with the current time."]
    #[doc = " \t xLastWakeTime = xTaskGetTickCount ();"]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t // Wait for the next cycle."]
    #[doc = " \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );"]
    #[doc = ""]
    #[doc = " \t\t // Perform action here."]
    #[doc = " \t }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t);
}
extern "C" {
    #[doc = " Obtain the priority of any task."]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of xTask."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to obtain the priority of the created task."]
    #[doc = "   // It was created with tskIDLE_PRIORITY, but may have changed"]
    #[doc = "   // it itself."]
    #[doc = "   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )"]
    #[doc = "   {"]
    #[doc = "       // The task has changed it's priority."]
    #[doc = "   }"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Is our priority higher than the created task?"]
    #[doc = "   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )"]
    #[doc = "   {"]
    #[doc = "       // Our priority (obtained using NULL handle) is higher."]
    #[doc = "   }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " A version of uxTaskPriorityGet() that can be used from an ISR."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of xTask."]
    #[doc = ""]
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Obtain the state of any task."]
    #[doc = ""]
    #[doc = " States are encoded by the eTaskState enumerated type."]
    #[doc = ""]
    #[doc = " INCLUDE_eTaskGetState must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried."]
    #[doc = ""]
    #[doc = " @return The state of xTask at the time the function was called.  Note the"]
    #[doc = " state of the task might change between the function being called, and the"]
    #[doc = " functions return value being tested by the calling task."]
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    #[doc = " Set the priority of any task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A context switch will occur before the function returns if the priority"]
    #[doc = " being set is higher than the currently executing task."]
    #[doc = ""]
    #[doc = " @param xTask Handle to the task for which the priority is being set."]
    #[doc = " Passing a NULL handle results in the priority of the calling task being set."]
    #[doc = ""]
    #[doc = " @param uxNewPriority The priority to which the task will be set."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to raise the priority of the created task."]
    #[doc = "   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use a NULL handle to raise our priority to the same value."]
    #[doc = "   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    #[doc = " Suspend a task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " When suspended, a task will never get any microcontroller processing time,"]
    #[doc = " no matter what its priority."]
    #[doc = ""]
    #[doc = " Calls to vTaskSuspend are not accumulative -"]
    #[doc = " i.e. calling vTaskSuspend () twice on the same task still only requires one"]
    #[doc = " call to vTaskResume () to ready the suspended task."]
    #[doc = ""]
    #[doc = " @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL"]
    #[doc = " handle will cause the calling task to be suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to suspend the created task."]
    #[doc = "   vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // The created task will not run during this period, unless"]
    #[doc = "   // another task calls vTaskResume( xHandle )."]
    #[doc = ""]
    #[doc = "   //..."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "   // Suspend ourselves."]
    #[doc = "   vTaskSuspend( NULL );"]
    #[doc = ""]
    #[doc = "   // We cannot get here unless another task calls vTaskResume"]
    #[doc = "   // with our handle as the parameter."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    #[doc = " Resumes a suspended task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " vTaskResume ()."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to suspend the created task."]
    #[doc = "   vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // The created task will not run during this period, unless"]
    #[doc = "   // another task calls vTaskResume( xHandle )."]
    #[doc = ""]
    #[doc = "   //..."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "   // Resume the suspended task ourselves."]
    #[doc = "   vTaskResume( xHandle );"]
    #[doc = ""]
    #[doc = "   // The created task will once again get microcontroller processing"]
    #[doc = "   // time in accordance with its priority within the system."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    #[doc = " An implementation of vTaskResume() that can be called from within an ISR."]
    #[doc = ""]
    #[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be"]
    #[doc = " available.  See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " xTaskResumeFromISR ()."]
    #[doc = ""]
    #[doc = " xTaskResumeFromISR() should not be used to synchronise a task with an"]
    #[doc = " interrupt if there is a chance that the interrupt could arrive prior to the"]
    #[doc = " task being suspended - as this can lead to interrupts being missed. Use of a"]
    #[doc = " semaphore as a synchronisation mechanism would avoid this eventuality."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if resuming the task should result in a context switch,"]
    #[doc = " otherwise pdFALSE. This is used by the ISR to determine if a context switch"]
    #[doc = " may be required following the ISR."]
    #[doc = ""]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " Starts the real time kernel tick processing."]
    #[doc = ""]
    #[doc = " After calling the kernel has control over which tasks are executed and when."]
    #[doc = ""]
    #[doc = " See the demo application file main.c for an example of creating"]
    #[doc = " tasks and starting the kernel."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "   // Create at least one task before starting the kernel."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "   // Start the real time kernel with preemption."]
    #[doc = "   vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "   // Will not get here unless a task calls vTaskEndScheduler ()"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
extern "C" {
    #[doc = " Stops the real time kernel tick."]
    #[doc = ""]
    #[doc = " @note At the time of writing only the x86 real mode port, which runs on a PC"]
    #[doc = " in place of DOS, implements this function."]
    #[doc = ""]
    #[doc = " All created tasks will be automatically deleted and multitasking"]
    #[doc = " (either preemptive or cooperative) will stop."]
    #[doc = " Execution then resumes from the point where vTaskStartScheduler ()"]
    #[doc = " was called, as if vTaskStartScheduler () had just returned."]
    #[doc = ""]
    #[doc = " See the demo application file main. c in the demo/PC directory for an"]
    #[doc = " example that uses vTaskEndScheduler ()."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () requires an exit function to be defined within the"]
    #[doc = " portable layer (see vPortEndScheduler () in port. c for the PC port).  This"]
    #[doc = " performs hardware specific operations such as stopping the kernel tick."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () will cause all of the resources allocated by the"]
    #[doc = " kernel to be freed - but will not free resources allocated by application"]
    #[doc = " tasks."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTaskCode( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // At some point we want to end the real time kernel processing"]
    #[doc = "       // so call ..."]
    #[doc = "       vTaskEndScheduler ();"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "   // Create at least one task before starting the kernel."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "   // Start the real time kernel with preemption."]
    #[doc = "   vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "   // Will only get here when the vTaskCode () task has called"]
    #[doc = "   // vTaskEndScheduler ().  When we get here we are back to single task"]
    #[doc = "   // execution."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
extern "C" {
    #[doc = " Suspends the scheduler without disabling interrupts."]
    #[doc = ""]
    #[doc = " Context switches will not occur while the scheduler is suspended."]
    #[doc = ""]
    #[doc = " After calling vTaskSuspendAll () the calling task will continue to execute"]
    #[doc = " without risk of being swapped out until a call to xTaskResumeAll () has been"]
    #[doc = " made."]
    #[doc = ""]
    #[doc = " API functions that have the potential to cause a context switch (for example,"]
    #[doc = " vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler"]
    #[doc = " is suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTask1( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // At some point the task wants to perform a long operation during"]
    #[doc = "       // which it does not want to get swapped out.  It cannot use"]
    #[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
    #[doc = "       // operation may cause interrupts to be missed - including the"]
    #[doc = "       // ticks."]
    #[doc = ""]
    #[doc = "       // Prevent the real time kernel swapping out the task."]
    #[doc = "       vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = "       // Perform the operation here.  There is no need to use critical"]
    #[doc = "       // sections as we have all the microcontroller processing time."]
    #[doc = "       // During this time interrupts will still operate and the kernel"]
    #[doc = "       // tick count will be maintained."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // The operation is complete.  Restart the kernel."]
    #[doc = "       xTaskResumeAll ();"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
extern "C" {
    #[doc = " Resumes scheduler activity after it was suspended by a call to"]
    #[doc = " vTaskSuspendAll()."]
    #[doc = ""]
    #[doc = " xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks"]
    #[doc = " that were previously suspended by a call to vTaskSuspend()."]
    #[doc = ""]
    #[doc = " @return If resuming the scheduler caused a context switch then pdTRUE is"]
    #[doc = "\t\t  returned, otherwise pdFALSE is returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTask1( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // At some point the task wants to perform a long operation during"]
    #[doc = "       // which it does not want to get swapped out.  It cannot use"]
    #[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
    #[doc = "       // operation may cause interrupts to be missed - including the"]
    #[doc = "       // ticks."]
    #[doc = ""]
    #[doc = "       // Prevent the real time kernel swapping out the task."]
    #[doc = "       vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = "       // Perform the operation here.  There is no need to use critical"]
    #[doc = "       // sections as we have all the microcontroller processing time."]
    #[doc = "       // During this time interrupts will still operate and the real"]
    #[doc = "       // time kernel tick count will be maintained."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // The operation is complete.  Restart the kernel.  We want to force"]
    #[doc = "       // a context switch - but there is no point if resuming the scheduler"]
    #[doc = "       // caused a context switch already."]
    #[doc = "       if( !xTaskResumeAll () )"]
    #[doc = "       {"]
    #[doc = "            taskYIELD ();"]
    #[doc = "       }"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    #[doc = " Get tick count"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    #[doc = " Get tick count from ISR"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " This is a version of xTaskGetTickCount() that is safe to be called from an"]
    #[doc = " ISR - provided that TickType_t is the natural word size of the"]
    #[doc = " microcontroller being used or interrupt nesting is either not supported or"]
    #[doc = " not being used."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    #[doc = " Get current number of tasks"]
    #[doc = ""]
    #[doc = " @return The number of tasks that the real time kernel is currently managing."]
    #[doc = " This includes all ready, blocked and suspended tasks.  A task that"]
    #[doc = " has been deleted but not yet freed by the idle task will also be"]
    #[doc = " included in the count."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    #[doc = " Get task name"]
    #[doc = ""]
    #[doc = " @return The text (human readable) name of the task referenced by the handle"]
    #[doc = " xTaskToQuery.  A task can query its own name by either passing in its own"]
    #[doc = " handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be"]
    #[doc = " set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn pcTaskGetTaskName(xTaskToQuery: TaskHandle_t) -> *mut c_types::c_char;
}
extern "C" {
    #[doc = " Returns the high water mark of the stack associated with xTask."]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " High water mark is the minimum free stack space there has been (in bytes"]
    #[doc = " rather than words as found in vanilla FreeRTOS) since the task started."]
    #[doc = " The smaller the returned number the closer the task has come to overflowing its stack."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack to be checked."]
    #[doc = " Set xTask to NULL to check the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return The smallest amount of free stack space there has been (in bytes"]
    #[doc = " rather than words as found in vanilla FreeRTOS) since the task referenced by"]
    #[doc = " xTask was created."]
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Returns the start of the stack associated with xTask."]
    #[doc = ""]
    #[doc = " INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " Returns the highest stack memory address on architectures where the stack grows down"]
    #[doc = " from high memory, and the lowest memory address on architectures where the"]
    #[doc = " stack grows up from low memory."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack returned."]
    #[doc = " Set xTask to NULL to return the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return A pointer to the start of the stack."]
    pub fn pxTaskGetStackStart(xTask: TaskHandle_t) -> *mut u8;
}
extern "C" {
    #[doc = " Set local storage pointer specific to the given task."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " @param xTaskToSet  Task to set thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to set, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @param pvValue  Pointer value to set."]
    pub fn vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut c_types::c_void,
    );
}
extern "C" {
    #[doc = " Get local storage pointer specific to the given task."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " @param xTaskToQuery  Task to get thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to get, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @return  Pointer value"]
    pub fn pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut c_types::c_void;
}
#[doc = " Prototype of local storage pointer deletion callback."]
pub type TlsDeleteCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: c_types::c_int, arg2: *mut c_types::c_void)>;
extern "C" {
    #[doc = " Set local storage pointer and deletion callback."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " Local storage pointers set for a task can reference dynamically"]
    #[doc = " allocated resources. This function is similar to"]
    #[doc = " vTaskSetThreadLocalStoragePointer, but provides a way to release"]
    #[doc = " these resources when the task gets deleted. For each pointer,"]
    #[doc = " a callback function can be set. This function will be called"]
    #[doc = " when task is deleted, with the local storage pointer index"]
    #[doc = " and value as arguments."]
    #[doc = ""]
    #[doc = " @param xTaskToSet  Task to set thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to set, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @param pvValue  Pointer value to set."]
    #[doc = " @param pvDelCallback  Function to call to dispose of the local"]
    #[doc = "                       storage pointer when the task is deleted."]
    pub fn vTaskSetThreadLocalStoragePointerAndDelCallback(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut c_types::c_void,
        pvDelCallback: TlsDeleteCallbackFunction_t,
    );
}
extern "C" {
    #[doc = " Calls the hook function associated with xTask. Passing xTask as NULL has"]
    #[doc = " the effect of calling the Running tasks (the calling task) hook function."]
    #[doc = ""]
    #[doc = " @param xTask  Handle of the task to call the hook for."]
    #[doc = " @param pvParameter  Parameter passed to the hook function for the task to interpret as it"]
    #[doc = " wants.  The return value is the value returned by the task hook function"]
    #[doc = " registered by the user."]
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut c_types::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Get the handle of idle task for the current CPU."]
    #[doc = ""]
    #[doc = " xTaskGetIdleTaskHandle() is only available if"]
    #[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " @return The handle of the idle task.  It is not valid to call"]
    #[doc = " xTaskGetIdleTaskHandle() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " Get the handle of idle task for the given CPU."]
    #[doc = ""]
    #[doc = " xTaskGetIdleTaskHandleForCPU() is only available if"]
    #[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " @param cpuid The CPU to get the handle for"]
    #[doc = ""]
    #[doc = " @return Idle task handle of a given cpu. It is not valid to call"]
    #[doc = " xTaskGetIdleTaskHandleForCPU() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandleForCPU(cpuid: UBaseType_t) -> TaskHandle_t;
}
extern "C" {
    #[doc = " Get the state of tasks in the system."]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for"]
    #[doc = " uxTaskGetSystemState() to be available."]
    #[doc = ""]
    #[doc = " uxTaskGetSystemState() populates an TaskStatus_t structure for each task in"]
    #[doc = " the system.  TaskStatus_t structures contain, among other things, members"]
    #[doc = " for the task handle, task name, task priority, task state, and total amount"]
    #[doc = " of run time consumed by the task.  See the TaskStatus_t structure"]
    #[doc = " definition in this file for the full member list."]
    #[doc = ""]
    #[doc = " @note  This function is intended for debugging use only as its use results in"]
    #[doc = " the scheduler remaining suspended for an extended period."]
    #[doc = ""]
    #[doc = " @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures."]
    #[doc = " The array must contain at least one TaskStatus_t structure for each task"]
    #[doc = " that is under the control of the RTOS.  The number of tasks under the control"]
    #[doc = " of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function."]
    #[doc = ""]
    #[doc = " @param uxArraySize The size of the array pointed to by the pxTaskStatusArray"]
    #[doc = " parameter.  The size is specified as the number of indexes in the array, or"]
    #[doc = " the number of TaskStatus_t structures contained in the array, not by the"]
    #[doc = " number of bytes in the array."]
    #[doc = ""]
    #[doc = " @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in"]
    #[doc = " FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the"]
    #[doc = " total run time (as defined by the run time stats clock, see"]
    #[doc = " http://www.freertos.org/rtos-run-time-stats.html) since the target booted."]
    #[doc = " pulTotalRunTime can be set to NULL to omit the total run time information."]
    #[doc = ""]
    #[doc = " @return The number of TaskStatus_t structures that were populated by"]
    #[doc = " uxTaskGetSystemState().  This should equal the number returned by the"]
    #[doc = " uxTaskGetNumberOfTasks() API function, but will be zero if the value passed"]
    #[doc = " in the uxArraySize parameter was too small."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = " // This example demonstrates how a human readable table of run time stats"]
    #[doc = " // information is generated from raw data provided by uxTaskGetSystemState()."]
    #[doc = " // The human readable table is written to pcWriteBuffer"]
    #[doc = " void vTaskGetRunTimeStats( char *pcWriteBuffer )"]
    #[doc = " {"]
    #[doc = " TaskStatus_t *pxTaskStatusArray;"]
    #[doc = " volatile UBaseType_t uxArraySize, x;"]
    #[doc = " uint32_t ulTotalRunTime, ulStatsAsPercentage;"]
    #[doc = ""]
    #[doc = "  // Make sure the write buffer does not contain a string."]
    #[doc = "  *pcWriteBuffer = 0x00;"]
    #[doc = ""]
    #[doc = "  // Take a snapshot of the number of tasks in case it changes while this"]
    #[doc = "  // function is executing."]
    #[doc = "  uxArraySize = uxTaskGetNumberOfTasks();"]
    #[doc = ""]
    #[doc = "  // Allocate a TaskStatus_t structure for each task.  An array could be"]
    #[doc = "  // allocated statically at compile time."]
    #[doc = "  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );"]
    #[doc = ""]
    #[doc = "  if( pxTaskStatusArray != NULL )"]
    #[doc = "  {"]
    #[doc = "      // Generate raw status information about each task."]
    #[doc = "      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );"]
    #[doc = ""]
    #[doc = "      // For percentage calculations."]
    #[doc = "      ulTotalRunTime /= 100UL;"]
    #[doc = ""]
    #[doc = "      // Avoid divide by zero errors."]
    #[doc = "      if( ulTotalRunTime > 0 )"]
    #[doc = "      {"]
    #[doc = "          // For each populated position in the pxTaskStatusArray array,"]
    #[doc = "          // format the raw data as human readable ASCII data"]
    #[doc = "          for( x = 0; x < uxArraySize; x++ )"]
    #[doc = "          {"]
    #[doc = "              // What percentage of the total run time has the task used?"]
    #[doc = "              // This will always be rounded down to the nearest integer."]
    #[doc = "              // ulTotalRunTimeDiv100 has already been divided by 100."]
    #[doc = "              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;"]
    #[doc = ""]
    #[doc = "              if( ulStatsAsPercentage > 0UL )"]
    #[doc = "              {"]
    #[doc = "                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );"]
    #[doc = "              }"]
    #[doc = "              else"]
    #[doc = "              {"]
    #[doc = "                  // If the percentage is zero here then the task has"]
    #[doc = "                  // consumed less than 1% of the total run time."]
    #[doc = "                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );"]
    #[doc = "              }"]
    #[doc = ""]
    #[doc = "              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );"]
    #[doc = "          }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = "      // The array is no longer needed, free the memory it consumes."]
    #[doc = "      vPortFree( pxTaskStatusArray );"]
    #[doc = "  }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " List all the current tasks."]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must"]
    #[doc = " both be defined as 1 for this function to be available.  See the"]
    #[doc = " configuration section of the FreeRTOS.org website for more information."]
    #[doc = ""]
    #[doc = " @note This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Lists all the current tasks, along with their current state and stack"]
    #[doc = " usage high water mark."]
    #[doc = ""]
    #[doc = " Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or"]
    #[doc = " suspended ('S')."]
    #[doc = ""]
    #[doc = " @note This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskList() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays task"]
    #[doc = " names, states and stack usage."]
    #[doc = ""]
    #[doc = " vTaskList() has a dependency on the sprintf() C library function that might"]
    #[doc = " bloat the code size, use a lot of stack, and provide different results on"]
    #[doc = " different platforms.  An alternative, tiny, third party, and limited"]
    #[doc = " functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState()"]
    #[doc = " directly to get access to raw stats data, rather than indirectly through a"]
    #[doc = " call to vTaskList()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the above mentioned details"]
    #[doc = " will be written, in ASCII form.  This buffer is assumed to be large"]
    #[doc = " enough to contain the generated report.  Approximately 40 bytes per"]
    #[doc = " task should be sufficient."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskList(pcWriteBuffer: *mut c_types::c_char);
}
extern "C" {
    #[doc = " Get the state of running tasks as a string"]
    #[doc = ""]
    #[doc = " configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS"]
    #[doc = " must both be defined as 1 for this function to be available.  The application"]
    #[doc = " must also then provide definitions for"]
    #[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
    #[doc = " to configure a peripheral timer/counter and return the timers current count"]
    #[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
    #[doc = " the tick count."]
    #[doc = ""]
    #[doc = " @note This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
    #[doc = " accumulated execution time being stored for each task.  The resolution"]
    #[doc = " of the accumulated time value depends on the frequency of the timer"]
    #[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
    #[doc = " Calling vTaskGetRunTimeStats() writes the total execution time of each"]
    #[doc = " task into a buffer, both as an absolute count value and as a percentage"]
    #[doc = " of the total system execution time."]
    #[doc = ""]
    #[doc = " @note This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays the"]
    #[doc = " amount of time each task has spent in the Running state in both absolute and"]
    #[doc = " percentage terms."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() has a dependency on the sprintf() C library function"]
    #[doc = " that might bloat the code size, use a lot of stack, and provide different"]
    #[doc = " results on different platforms.  An alternative, tiny, third party, and"]
    #[doc = " limited functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState() directly"]
    #[doc = " to get access to raw stats data, rather than indirectly through a call to"]
    #[doc = " vTaskGetRunTimeStats()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the execution times will be"]
    #[doc = " written, in ASCII form.  This buffer is assumed to be large enough to"]
    #[doc = " contain the generated report.  Approximately 40 bytes per task should"]
    #[doc = " be sufficient."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut c_types::c_char);
}
extern "C" {
    #[doc = " Send task notification."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = "\t- eSetBits:"]
    #[doc = "\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " \t  always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eIncrement:"]
    #[doc = "\t  The task's notification value is incremented.  ulValue is not used and"]
    #[doc = "\t  xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithOverwrite:"]
    #[doc = "\t  The task's notification value is set to the value of ulValue, even if the"]
    #[doc = "\t  task being notified had not yet processed the previous notification (the"]
    #[doc = "\t  task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = "\t  pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithoutOverwrite:"]
    #[doc = "\t  If the task being notified did not already have a notification pending then"]
    #[doc = "\t  the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = "\t  return pdPASS.  If the task being notified already had a notification"]
    #[doc = "\t  pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = "\t- eNoAction:"]
    #[doc = "\t  The task receives a notification without its notification value being"]
    #[doc = "\t\u{a0}\u{a0}updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = "\t  this case."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Send task notification from an ISR."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotify() that can be used from an interrupt service routine"]
    #[doc = " (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = "\t- eSetBits:"]
    #[doc = "\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " \t  always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eIncrement:"]
    #[doc = "\t  The task's notification value is incremented.  ulValue is not used and"]
    #[doc = "\t  xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithOverwrite:"]
    #[doc = "\t  The task's notification value is set to the value of ulValue, even if the"]
    #[doc = "\t  task being notified had not yet processed the previous notification (the"]
    #[doc = "\t  task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = "\t  pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithoutOverwrite:"]
    #[doc = "\t  If the task being notified did not already have a notification pending then"]
    #[doc = "\t  the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = "\t  return pdPASS.  If the task being notified already had a notification"]
    #[doc = "\t  pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = "\t- eNoAction:"]
    #[doc = "\t  The task receives a notification without its notification value being"]
    #[doc = "\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = "\t  this case."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should"]
    #[doc = " be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Wait for task notification"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value"]
    #[doc = " will be cleared in the calling task's notification value before the task"]
    #[doc = " checks to see if any notifications are pending, and optionally blocks if no"]
    #[doc = " notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if"]
    #[doc = " limits.h is included) or 0xffffffffUL (if limits.h is not included) will have"]
    #[doc = " the effect of resetting the task's notification value to 0.  Setting"]
    #[doc = " ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnExit If a notification is pending or received before"]
    #[doc = " the calling task exits the xTaskNotifyWait() function then the task's"]
    #[doc = " notification value (see the xTaskNotify() API function) is passed out using"]
    #[doc = " the pulNotificationValue parameter.  Then any bits that are set in"]
    #[doc = " ulBitsToClearOnExit will be cleared in the task's notification value (note"]
    #[doc = " *pulNotificationValue is set before any bits are cleared).  Setting"]
    #[doc = " ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL"]
    #[doc = " (if limits.h is not included) will have the effect of resetting the task's"]
    #[doc = " notification value to 0 before the function exits.  Setting"]
    #[doc = " ulBitsToClearOnExit to 0 will leave the task's notification value unchanged"]
    #[doc = " when the function exits (in which case the value passed out in"]
    #[doc = " pulNotificationValue will match the task's notification value)."]
    #[doc = ""]
    #[doc = " @param pulNotificationValue Used to pass the task's notification value out"]
    #[doc = " of the function.  Note the value passed out will not be effected by the"]
    #[doc = " clearing of any bits caused by ulBitsToClearOnExit being non-zero."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for a notification to be received, should a notification"]
    #[doc = " not already be pending when xTaskNotifyWait() was called.  The task"]
    #[doc = " will not consume any processing time while it is in the Blocked state.  This"]
    #[doc = " is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be"]
    #[doc = " used to convert a time specified in milliseconds to a time specified in"]
    #[doc = " ticks."]
    #[doc = ""]
    #[doc = " @return If a notification was received (including notifications that were"]
    #[doc = " already pending when xTaskNotifyWait was called) then pdPASS is"]
    #[doc = " returned.  Otherwise pdFAIL is returned."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Simplified macro for sending task notification from ISR."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro"]
    #[doc = " to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotifyGive() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " vTaskNotifyGiveFromISR() is intended for use when task notifications are"]
    #[doc = " used as light weight and faster binary or counting semaphore equivalents."]
    #[doc = " Actual FreeRTOS semaphores are given from an ISR using the"]
    #[doc = " xSemaphoreGiveFromISR() API function, the equivalent action that instead uses"]
    #[doc = " a task notification is vTaskNotifyGiveFromISR()."]
    #[doc = ""]
    #[doc = " When task notifications are being used as a binary or counting semaphore"]
    #[doc = " equivalent then the task being notified should wait for the notification"]
    #[doc = " using the ulTaskNotificationTake() API function rather than the"]
    #[doc = " xTaskNotifyWait() API function."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch"]
    #[doc = " should be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn vTaskNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " Simplified macro for receiving task notification."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() is intended for use when a task notification is used as a"]
    #[doc = " faster and lighter weight binary or counting semaphore alternative.  Actual"]
    #[doc = " FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the"]
    #[doc = " equivalent action that instead uses a task notification is"]
    #[doc = " ulTaskNotifyTake()."]
    #[doc = ""]
    #[doc = " When a task is using its notification value as a binary or counting semaphore"]
    #[doc = " other tasks should send notifications to it using the xTaskNotifyGive()"]
    #[doc = " macro, or xTaskNotify() function with the eAction parameter set to"]
    #[doc = " eIncrement."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() can either clear the task's notification value to"]
    #[doc = " zero on exit, in which case the notification value acts like a binary"]
    #[doc = " semaphore, or decrement the task's notification value on exit, in which case"]
    #[doc = " the notification value acts like a counting semaphore."]
    #[doc = ""]
    #[doc = " A task can use ulTaskNotifyTake() to [optionally] block to wait for a"]
    #[doc = " the task's notification value to be non-zero.  The task does not consume any"]
    #[doc = " CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " Where as xTaskNotifyWait() will return when a notification is pending,"]
    #[doc = " ulTaskNotifyTake() will return when the task's notification value is"]
    #[doc = " not zero."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's"]
    #[doc = " notification value is decremented when the function exits.  In this way the"]
    #[doc = " notification value acts like a counting semaphore.  If xClearCountOnExit is"]
    #[doc = " not pdFALSE then the task's notification value is cleared to zero when the"]
    #[doc = " function exits.  In this way the notification value acts like a binary"]
    #[doc = " semaphore."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for the task's notification value to be greater than zero,"]
    #[doc = " should the count not already be greater than zero when"]
    #[doc = " ulTaskNotifyTake() was called.  The task will not consume any processing"]
    #[doc = " time while it is in the Blocked state.  This is specified in kernel ticks,"]
    #[doc = " the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time"]
    #[doc = " specified in milliseconds to a time specified in ticks."]
    #[doc = ""]
    #[doc = " @return The task's notification count before it is either cleared to zero or"]
    #[doc = " decremented (see the xClearCountOnExit parameter)."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn ulTaskNotifyTake(xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
    #[doc = " @cond"]
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandleForCPU(cpuid: BaseType_t) -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityInherit(pxMutexHolder: TaskHandle_t);
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xTaskGetAffinity(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> *mut c_types::c_void;
}
extern "C" {
    pub fn uxTaskGetSnapshotAll(
        pxTaskSnapshotArray: *mut TaskSnapshot_t,
        uxArraySize: UBaseType_t,
        pxTcbSz: *mut UBaseType_t,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " @brief  Initialize the Task Watchdog Timer (TWDT)"]
    #[doc = ""]
    #[doc = " This function configures and initializes the TWDT. If the TWDT is already"]
    #[doc = " initialized when this function is called, this function will update the"]
    #[doc = " TWDT's timeout period and panic configurations instead. After initializing"]
    #[doc = " the TWDT, any task can elect to be watched by the TWDT by subscribing to it"]
    #[doc = " using esp_task_wdt_add()."]
    #[doc = ""]
    #[doc = " @param[in]  timeout     Timeout period of TWDT in seconds"]
    #[doc = " @param[in]  panic       Flag that controls whether the panic handler will be"]
    #[doc = "                         executed when the TWDT times out"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: Initialization was successful"]
    #[doc = "     - ESP_ERR_NO_MEM: Initialization failed due to lack of memory"]
    #[doc = ""]
    #[doc = " @note   esp_task_wdt_init() must only be called after the scheduler"]
    #[doc = "         started"]
    pub fn esp_task_wdt_init(timeout: u32, panic: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Deinitialize the Task Watchdog Timer (TWDT)"]
    #[doc = ""]
    #[doc = " This function will deinitialize the TWDT. Calling this function whilst tasks"]
    #[doc = " are still subscribed to the TWDT, or when the TWDT is already deinitialized,"]
    #[doc = " will result in an error code being returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: TWDT successfully deinitialized"]
    #[doc = "      - ESP_ERR_INVALID_STATE: Error, tasks are still subscribed to the TWDT"]
    #[doc = "      - ESP_ERR_NOT_FOUND: Error, TWDT has already been deinitialized"]
    pub fn esp_task_wdt_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Subscribe a task to the Task Watchdog Timer (TWDT)"]
    #[doc = ""]
    #[doc = " This function subscribes a task to the TWDT. Each subscribed task must"]
    #[doc = " periodically call esp_task_wdt_reset() to prevent the TWDT from elapsing its"]
    #[doc = " timeout period. Failure to do so will result in a TWDT timeout. If the task"]
    #[doc = " being subscribed is one of the Idle Tasks, this function will automatically"]
    #[doc = " enable esp_task_wdt_reset() to called from the Idle Hook of the Idle Task."]
    #[doc = " Calling this function whilst the TWDT is uninitialized or attempting to"]
    #[doc = " subscribe an already subscribed task will result in an error code being"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle of the task. Input NULL to subscribe the current"]
    #[doc = "                     running task to the TWDT"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: Successfully subscribed the task to the TWDT"]
    #[doc = "     - ESP_ERR_INVALID_ARG: Error, the task is already subscribed"]
    #[doc = "     - ESP_ERR_NO_MEM: Error, could not subscribe the task due to lack of"]
    #[doc = "                       memory"]
    #[doc = "     - ESP_ERR_INVALID_STATE: Error, the TWDT has not been initialized yet"]
    pub fn esp_task_wdt_add(handle: TaskHandle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Reset the Task Watchdog Timer (TWDT) on behalf of the currently"]
    #[doc = "         running task"]
    #[doc = ""]
    #[doc = " This function will reset the TWDT on behalf of the currently running task."]
    #[doc = " Each subscribed task must periodically call this function to prevent the"]
    #[doc = " TWDT from timing out. If one or more subscribed tasks fail to reset the"]
    #[doc = " TWDT on their own behalf, a TWDT timeout will occur. If the IDLE tasks have"]
    #[doc = " been subscribed to the TWDT, they will automatically call this function from"]
    #[doc = " their idle hooks. Calling this function from a task that has not subscribed"]
    #[doc = " to the TWDT, or when the TWDT is uninitialized will result in an error code"]
    #[doc = " being returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: Successfully reset the TWDT on behalf of the currently"]
    #[doc = "               running task"]
    #[doc = "     - ESP_ERR_NOT_FOUND: Error, the current running task has not subscribed"]
    #[doc = "                          to the TWDT"]
    #[doc = "     - ESP_ERR_INVALID_STATE: Error, the TWDT has not been initialized yet"]
    pub fn esp_task_wdt_reset() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Unsubscribes a task from the Task Watchdog Timer (TWDT)"]
    #[doc = ""]
    #[doc = " This function will unsubscribe a task from the TWDT. After being"]
    #[doc = " unsubscribed, the task should no longer call esp_task_wdt_reset(). If the"]
    #[doc = " task is an IDLE task, this function will automatically disable the calling"]
    #[doc = " of esp_task_wdt_reset() from the Idle Hook. Calling this function whilst the"]
    #[doc = " TWDT is uninitialized or attempting to unsubscribe an already unsubscribed"]
    #[doc = " task from the TWDT will result in an error code being returned."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle of the task. Input NULL to unsubscribe the"]
    #[doc = "                     current running task."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: Successfully unsubscribed the task from the TWDT"]
    #[doc = "     - ESP_ERR_INVALID_ARG: Error, the task is already unsubscribed"]
    #[doc = "     - ESP_ERR_INVALID_STATE: Error, the TWDT has not been initialized yet"]
    pub fn esp_task_wdt_delete(handle: TaskHandle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Query whether a task is subscribed to the Task Watchdog Timer (TWDT)"]
    #[doc = ""]
    #[doc = " This function will query whether a task is currently subscribed to the TWDT,"]
    #[doc = " or whether the TWDT is initialized."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle of the task. Input NULL to query the current"]
    #[doc = "                     running task."]
    #[doc = ""]
    #[doc = " @return:"]
    #[doc = "     - ESP_OK: The task is currently subscribed to the TWDT"]
    #[doc = "     - ESP_ERR_NOT_FOUND: The task is currently not subscribed to the TWDT"]
    #[doc = "     - ESP_ERR_INVALID_STATE: The TWDT is not initialized, therefore no tasks"]
    #[doc = "                              can be subscribed"]
    pub fn esp_task_wdt_status(handle: TaskHandle_t) -> esp_err_t;
}
pub const spi_flash_wrap_mode_t_FLASH_WRAP_MODE_8B: spi_flash_wrap_mode_t = 0;
pub const spi_flash_wrap_mode_t_FLASH_WRAP_MODE_16B: spi_flash_wrap_mode_t = 2;
pub const spi_flash_wrap_mode_t_FLASH_WRAP_MODE_32B: spi_flash_wrap_mode_t = 4;
pub const spi_flash_wrap_mode_t_FLASH_WRAP_MODE_64B: spi_flash_wrap_mode_t = 6;
pub const spi_flash_wrap_mode_t_FLASH_WRAP_MODE_DISABLE: spi_flash_wrap_mode_t = 1;
pub type spi_flash_wrap_mode_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief set wrap mode of flash"]
    #[doc = ""]
    #[doc = " @param mode: wrap mode support disable, 16 32, 64 byte"]
    #[doc = ""]
    #[doc = " @return esp_err_t : ESP_OK for successful."]
    #[doc = ""]
    pub fn spi_flash_wrap_set(mode: spi_flash_wrap_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Initialize SPI flash access driver"]
    #[doc = ""]
    #[doc = "  This function must be called exactly once, before any other"]
    #[doc = "  spi_flash_* functions are called."]
    #[doc = "  Currently this function is called from startup code. There is"]
    #[doc = "  no need to call it from application code."]
    #[doc = ""]
    pub fn spi_flash_init();
}
extern "C" {
    #[doc = " @brief  Get flash chip size, as set in binary image header"]
    #[doc = ""]
    #[doc = " @note This value does not necessarily match real flash size."]
    #[doc = ""]
    #[doc = " @return size of flash chip, in bytes"]
    pub fn spi_flash_get_chip_size() -> size_t;
}
extern "C" {
    #[doc = " @brief  Erase the Flash sector."]
    #[doc = ""]
    #[doc = " @param  sector: Sector number, the count starts at sector 0, 4KB per sector."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_erase_sector(sector: size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Erase a range of flash sectors"]
    #[doc = ""]
    #[doc = " @param  start_address  Address where erase operation has to start."]
    #[doc = "                                  Must be 4kB-aligned"]
    #[doc = " @param  size  Size of erased range, in bytes. Must be divisible by 4kB."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_erase_range(start_address: size_t, size: size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Write data to Flash."]
    #[doc = ""]
    #[doc = " @note For fastest write performance, write a 4 byte aligned size at a"]
    #[doc = " 4 byte aligned offset in flash from a source buffer in DRAM. Varying any of"]
    #[doc = " these parameters will still work, but will be slower due to buffering."]
    #[doc = ""]
    #[doc = " @note Writing more than 8KB at a time will be split into multiple"]
    #[doc = " write operations to avoid disrupting other tasks in the system."]
    #[doc = ""]
    #[doc = " @param  dest_addr Destination address in Flash."]
    #[doc = " @param  src       Pointer to the source buffer."]
    #[doc = " @param  size      Length of data, in bytes."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_write(
        dest_addr: size_t,
        src: *const c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Write data encrypted to Flash."]
    #[doc = ""]
    #[doc = " @note Flash encryption must be enabled for this function to work."]
    #[doc = ""]
    #[doc = " @note Flash encryption must be enabled when calling this function."]
    #[doc = " If flash encryption is disabled, the function returns"]
    #[doc = " ESP_ERR_INVALID_STATE.  Use esp_flash_encryption_enabled()"]
    #[doc = " function to determine if flash encryption is enabled."]
    #[doc = ""]
    #[doc = " @note Both dest_addr and size must be multiples of 16 bytes. For"]
    #[doc = " absolute best performance, both dest_addr and size arguments should"]
    #[doc = " be multiples of 32 bytes."]
    #[doc = ""]
    #[doc = " @param  dest_addr Destination address in Flash. Must be a multiple of 16 bytes."]
    #[doc = " @param  src       Pointer to the source buffer."]
    #[doc = " @param  size      Length of data, in bytes. Must be a multiple of 16 bytes."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_write_encrypted(
        dest_addr: size_t,
        src: *const c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read data from Flash."]
    #[doc = ""]
    #[doc = " @note For fastest read performance, all parameters should be"]
    #[doc = " 4 byte aligned. If source address and read size are not 4 byte"]
    #[doc = " aligned, read may be split into multiple flash operations. If"]
    #[doc = " destination buffer is not 4 byte aligned, a temporary buffer will"]
    #[doc = " be allocated on the stack."]
    #[doc = ""]
    #[doc = " @note Reading more than 16KB of data at a time will be split"]
    #[doc = " into multiple reads to avoid disruption to other tasks in the"]
    #[doc = " system. Consider using spi_flash_mmap() to read large amounts"]
    #[doc = " of data."]
    #[doc = ""]
    #[doc = " @param  src_addr source address of the data in Flash."]
    #[doc = " @param  dest     pointer to the destination buffer"]
    #[doc = " @param  size     length of data"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_read(src_addr: size_t, dest: *mut c_types::c_void, size: size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read data from Encrypted Flash."]
    #[doc = ""]
    #[doc = " If flash encryption is enabled, this function will transparently decrypt data as it is read."]
    #[doc = " If flash encryption is not enabled, this function behaves the same as spi_flash_read()."]
    #[doc = ""]
    #[doc = " See esp_flash_encryption_enabled() for a function to check if flash encryption is enabled."]
    #[doc = ""]
    #[doc = " @param  src   source address of the data in Flash."]
    #[doc = " @param  dest  pointer to the destination buffer"]
    #[doc = " @param  size  length of data"]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_read_encrypted(
        src: size_t,
        dest: *mut c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
#[doc = "< map to data memory (Vaddr0), allows byte-aligned access, 4 MB total"]
pub const spi_flash_mmap_memory_t_SPI_FLASH_MMAP_DATA: spi_flash_mmap_memory_t = 0;
#[doc = "< map to instruction memory (Vaddr1-3), allows only 4-byte-aligned access, 11 MB total"]
pub const spi_flash_mmap_memory_t_SPI_FLASH_MMAP_INST: spi_flash_mmap_memory_t = 1;
#[doc = " @brief Enumeration which specifies memory space requested in an mmap call"]
pub type spi_flash_mmap_memory_t = c_types::c_uint;
#[doc = " @brief Opaque handle for memory region obtained from spi_flash_mmap."]
pub type spi_flash_mmap_handle_t = u32;
extern "C" {
    #[doc = " @brief Map region of flash memory into data or instruction address space"]
    #[doc = ""]
    #[doc = " This function allocates sufficient number of 64kB MMU pages and configures"]
    #[doc = " them to map the requested region of flash memory into the address space."]
    #[doc = " It may reuse MMU pages which already provide the required mapping."]
    #[doc = ""]
    #[doc = " As with any allocator, if mmap/munmap are heavily used then the address space"]
    #[doc = " may become fragmented. To troubleshoot issues with page allocation, use"]
    #[doc = " spi_flash_mmap_dump() function."]
    #[doc = ""]
    #[doc = " @param src_addr  Physical address in flash where requested region starts."]
    #[doc = "                  This address *must* be aligned to 64kB boundary"]
    #[doc = "                  (SPI_FLASH_MMU_PAGE_SIZE)"]
    #[doc = " @param size  Size of region to be mapped. This size will be rounded"]
    #[doc = "              up to a 64kB boundary"]
    #[doc = " @param memory  Address space where the region should be mapped (data or instruction)"]
    #[doc = " @param[out] out_ptr  Output, pointer to the mapped memory region"]
    #[doc = " @param[out] out_handle  Output, handle which should be used for spi_flash_munmap call"]
    #[doc = ""]
    #[doc = " @return  ESP_OK on success, ESP_ERR_NO_MEM if pages can not be allocated"]
    pub fn spi_flash_mmap(
        src_addr: size_t,
        size: size_t,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const c_types::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Map sequences of pages of flash memory into data or instruction address space"]
    #[doc = ""]
    #[doc = " This function allocates sufficient number of 64kB MMU pages and configures"]
    #[doc = " them to map the indicated pages of flash memory contiguously into address space."]
    #[doc = " In this respect, it works in a similar way as spi_flash_mmap() but it allows mapping"]
    #[doc = " a (maybe non-contiguous) set of pages into a contiguous region of memory."]
    #[doc = ""]
    #[doc = " @param pages An array of numbers indicating the 64kB pages in flash to be mapped"]
    #[doc = "              contiguously into memory. These indicate the indexes of the 64kB pages,"]
    #[doc = "              not the byte-size addresses as used in other functions."]
    #[doc = "              Array must be located in internal memory."]
    #[doc = " @param page_count  Number of entries in the pages array"]
    #[doc = " @param memory  Address space where the region should be mapped (instruction or data)"]
    #[doc = " @param[out] out_ptr  Output, pointer to the mapped memory region"]
    #[doc = " @param[out] out_handle  Output, handle which should be used for spi_flash_munmap call"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if pages can not be allocated"]
    #[doc = "      - ESP_ERR_INVALID_ARG if pagecount is zero or pages array is not in"]
    #[doc = "        internal memory"]
    pub fn spi_flash_mmap_pages(
        pages: *const c_types::c_int,
        page_count: size_t,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const c_types::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release region previously obtained using spi_flash_mmap"]
    #[doc = ""]
    #[doc = " @note Calling this function will not necessarily unmap memory region."]
    #[doc = "       Region will only be unmapped when there are no other handles which"]
    #[doc = "       reference this region. In case of partially overlapping regions"]
    #[doc = "       it is possible that memory will be unmapped partially."]
    #[doc = ""]
    #[doc = " @param handle  Handle obtained from spi_flash_mmap"]
    pub fn spi_flash_munmap(handle: spi_flash_mmap_handle_t);
}
extern "C" {
    #[doc = " @brief Display information about mapped regions"]
    #[doc = ""]
    #[doc = " This function lists handles obtained using spi_flash_mmap, along with range"]
    #[doc = " of pages allocated to each handle. It also lists all non-zero entries of"]
    #[doc = " MMU table and corresponding reference counts."]
    pub fn spi_flash_mmap_dump();
}
extern "C" {
    #[doc = " @brief get free pages number which can be mmap"]
    #[doc = ""]
    #[doc = " This function will return number of free pages available in mmu table. This could be useful"]
    #[doc = " before calling actual spi_flash_mmap (maps flash range to DCache or ICache memory) to check"]
    #[doc = " if there is sufficient space available for mapping."]
    #[doc = ""]
    #[doc = " @param memory memory type of MMU table free page"]
    #[doc = ""]
    #[doc = " @return number of free pages which can be mmaped"]
    pub fn spi_flash_mmap_get_free_pages(memory: spi_flash_mmap_memory_t) -> u32;
}
extern "C" {
    #[doc = " @brief Given a memory address where flash is mapped, return the corresponding physical flash offset."]
    #[doc = ""]
    #[doc = " Cache address does not have have been assigned via spi_flash_mmap(), any address in memory mapped flash space can be looked up."]
    #[doc = ""]
    #[doc = " @param cached Pointer to flashed cached memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - SPI_FLASH_CACHE2PHYS_FAIL If cache address is outside flash cache region, or the address is not mapped."]
    #[doc = " - Otherwise, returns physical offset in flash"]
    pub fn spi_flash_cache2phys(cached: *const c_types::c_void) -> size_t;
}
extern "C" {
    #[doc = " @brief Given a physical offset in flash, return the address where it is mapped in the memory space."]
    #[doc = ""]
    #[doc = " Physical address does not have to have been assigned via spi_flash_mmap(), any address in flash can be looked up."]
    #[doc = ""]
    #[doc = " @note Only the first matching cache address is returned. If MMU flash cache table is configured so multiple entries"]
    #[doc = " point to the same physical address, there may be more than one cache address corresponding to that physical"]
    #[doc = " address. It is also possible for a single physical address to be mapped to both the IROM and DROM regions."]
    #[doc = ""]
    #[doc = " @note This function doesn't impose any alignment constraints, but if memory argument is SPI_FLASH_MMAP_INST and"]
    #[doc = " phys_offs is not 4-byte aligned, then reading from the returned pointer will result in a crash."]
    #[doc = ""]
    #[doc = " @param phys_offs Physical offset in flash memory to look up."]
    #[doc = " @param memory Address space type to look up a flash cache address mapping for (instruction or data)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - NULL if the physical address is invalid or not mapped to flash cache of the specified memory type."]
    #[doc = " - Cached memory address (in IROM or DROM space) corresponding to phys_offs."]
    pub fn spi_flash_phys2cache(
        phys_offs: size_t,
        memory: spi_flash_mmap_memory_t,
    ) -> *const c_types::c_void;
}
extern "C" {
    #[doc = " @brief Check at runtime if flash cache is enabled on both CPUs"]
    #[doc = ""]
    #[doc = " @return true if both CPUs have flash cache enabled, false otherwise."]
    pub fn spi_flash_cache_enabled() -> bool;
}
extern "C" {
    #[doc = " @brief Re-enable cache for the core defined as cpuid parameter."]
    #[doc = ""]
    #[doc = " @param cpuid the core number to enable instruction cache for"]
    pub fn spi_flash_enable_cache(cpuid: u32);
}
#[doc = " @brief SPI flash critical section enter function."]
#[doc = ""]
pub type spi_flash_guard_start_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief SPI flash critical section exit function."]
pub type spi_flash_guard_end_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief SPI flash operation lock function."]
pub type spi_flash_op_lock_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief SPI flash operation unlock function."]
pub type spi_flash_op_unlock_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief Function to protect SPI flash critical regions corruption."]
pub type spi_flash_is_safe_write_address_t =
    ::core::option::Option<unsafe extern "C" fn(addr: size_t, size: size_t) -> bool>;
#[doc = " @brief Function to yield to the OS during erase operation."]
pub type spi_flash_os_yield_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Structure holding SPI flash access critical sections management functions."]
#[doc = ""]
#[doc = " Flash API uses two types of flash access management functions:"]
#[doc = " 1) Functions which prepare/restore flash cache and interrupts before calling"]
#[doc = "    appropriate ROM functions (SPIWrite, SPIRead and SPIEraseBlock):"]
#[doc = "   - 'start' function should disables flash cache and non-IRAM interrupts and"]
#[doc = "      is invoked before the call to one of ROM function above."]
#[doc = "   - 'end' function should restore state of flash cache and non-IRAM interrupts and"]
#[doc = "      is invoked after the call to one of ROM function above."]
#[doc = "    These two functions are not recursive."]
#[doc = " 2) Functions which synchronizes access to internal data used by flash API."]
#[doc = "    This functions are mostly intended to synchronize access to flash API internal data"]
#[doc = "    in multithreaded environment and use OS primitives:"]
#[doc = "   - 'op_lock' locks access to flash API internal data."]
#[doc = "   - 'op_unlock' unlocks access to flash API internal data."]
#[doc = "   These two functions are recursive and can be used around the outside of multiple calls to"]
#[doc = "   'start' & 'end', in order to create atomic multi-part flash operations."]
#[doc = " 3) When CONFIG_SPI_FLASH_DANGEROUS_WRITE_ALLOWED is disabled, flash writing/erasing"]
#[doc = "    API checks for addresses provided by user to avoid corruption of critical flash regions"]
#[doc = "    (bootloader, partition table, running application etc.)."]
#[doc = ""]
#[doc = " Different versions of the guarding functions should be used depending on the context of"]
#[doc = " execution (with or without functional OS). In normal conditions when flash API is called"]
#[doc = " from task the functions use OS primitives. When there is no OS at all or when"]
#[doc = " it is not guaranteed that OS is functional (accessing flash from exception handler) these"]
#[doc = " functions cannot use OS primitives or even does not need them (multithreaded access is not possible)."]
#[doc = ""]
#[doc = " @note Structure and corresponding guard functions should not reside in flash."]
#[doc = "       For example structure can be placed in DRAM and functions in IRAM sections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_guard_funcs_t {
    #[doc = "< critical section start function."]
    pub start: spi_flash_guard_start_func_t,
    #[doc = "< critical section end function."]
    pub end: spi_flash_guard_end_func_t,
    #[doc = "< flash access API lock function."]
    pub op_lock: spi_flash_op_lock_func_t,
    #[doc = "< flash access API unlock function."]
    pub op_unlock: spi_flash_op_unlock_func_t,
    #[doc = "< checks flash write addresses."]
    pub is_safe_write_address: spi_flash_is_safe_write_address_t,
    #[doc = "< yield to the OS during flash erase"]
    pub yield_: spi_flash_os_yield_t,
}
extern "C" {
    #[doc = " @brief  Sets guard functions to access flash."]
    #[doc = ""]
    #[doc = " @note Pointed structure and corresponding guard functions should not reside in flash."]
    #[doc = "       For example structure can be placed in DRAM and functions in IRAM sections."]
    #[doc = ""]
    #[doc = " @param funcs pointer to structure holding flash access guard functions."]
    pub fn spi_flash_guard_set(funcs: *const spi_flash_guard_funcs_t);
}
extern "C" {
    #[doc = " @brief Get the guard functions used for flash access"]
    #[doc = ""]
    #[doc = " @return The guard functions that were set via spi_flash_guard_set(). These functions"]
    #[doc = " can be called if implementing custom low-level SPI flash operations."]
    pub fn spi_flash_guard_get() -> *const spi_flash_guard_funcs_t;
}
extern "C" {
    pub static g_flash_guard_default_ops: spi_flash_guard_funcs_t;
}
extern "C" {
    pub static g_flash_guard_no_os_ops: spi_flash_guard_funcs_t;
}
extern "C" {
    #[doc = " @brief  Initialize the non-CPU-specific parts of interrupt watchdog."]
    #[doc = "         This is called in the init code if the interrupt watchdog"]
    #[doc = "         is enabled in menuconfig."]
    #[doc = ""]
    pub fn esp_int_wdt_init();
}
extern "C" {
    #[doc = " @brief  Enable the interrupt watchdog on the current CPU. This is called"]
    #[doc = "         in the init code by both CPUs if the interrupt watchdog is enabled"]
    #[doc = "         in menuconfig."]
    #[doc = ""]
    pub fn esp_int_wdt_cpu_init();
}
#[doc = "< ESP32 station interface"]
pub const esp_interface_t_ESP_IF_WIFI_STA: esp_interface_t = 0;
#[doc = "< ESP32 soft-AP interface"]
pub const esp_interface_t_ESP_IF_WIFI_AP: esp_interface_t = 1;
#[doc = "< ESP32 ethernet interface"]
pub const esp_interface_t_ESP_IF_ETH: esp_interface_t = 2;
pub const esp_interface_t_ESP_IF_MAX: esp_interface_t = 3;
pub type esp_interface_t = c_types::c_uint;
#[doc = " @cond"]
pub type esp_ipc_func_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>;
extern "C" {
    #[doc = " @brief Execute a function on the given CPU"]
    #[doc = ""]
    #[doc = " Run a given function on a particular CPU. The given function must accept a"]
    #[doc = " void* argument and return void. The given function is run in the context of"]
    #[doc = " the IPC task of the CPU specified by the cpu_id parameter. The calling task"]
    #[doc = " will be blocked until the IPC task begins executing the given function. If"]
    #[doc = " another IPC call is ongoing, the calling task will block until the other IPC"]
    #[doc = " call completes. The stack size allocated for the IPC task can be configured"]
    #[doc = " in the \"Inter-Processor Call (IPC) task stack size\" setting in menuconfig."]
    #[doc = " Increase this setting if the given function requires more stack than default."]
    #[doc = ""]
    #[doc = " @note In single-core mode, returns ESP_ERR_INVALID_ARG for cpu_id 1."]
    #[doc = ""]
    #[doc = " @param[in]   cpu_id  CPU where the given function should be executed (0 or 1)"]
    #[doc = " @param[in]   func    Pointer to a function of type void func(void* arg) to be executed"]
    #[doc = " @param[in]   arg     Arbitrary argument of type void* to be passed into the function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_ERR_INVALID_ARG if cpu_id is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the FreeRTOS scheduler is not running"]
    #[doc = "      - ESP_OK otherwise"]
    pub fn esp_ipc_call(cpu_id: u32, func: esp_ipc_func_t, arg: *mut c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Execute a function on the given CPU and blocks until it completes"]
    #[doc = ""]
    #[doc = " Run a given function on a particular CPU. The given function must accept a"]
    #[doc = " void* argument and return void. The given function is run in the context of"]
    #[doc = " the IPC task of the CPU specified by the cpu_id parameter. The calling task"]
    #[doc = " will be blocked until the IPC task completes execution of the given function."]
    #[doc = " If another IPC call is ongoing, the calling task will block until the other"]
    #[doc = " IPC call completes. The stack size allocated for the IPC task can be"]
    #[doc = " configured in the \"Inter-Processor Call (IPC) task stack size\" setting in"]
    #[doc = " menuconfig. Increase this setting if the given function requires more stack"]
    #[doc = " than default."]
    #[doc = ""]
    #[doc = " @note    In single-core mode, returns ESP_ERR_INVALID_ARG for cpu_id 1."]
    #[doc = ""]
    #[doc = " @param[in]   cpu_id  CPU where the given function should be executed (0 or 1)"]
    #[doc = " @param[in]   func    Pointer to a function of type void func(void* arg) to be executed"]
    #[doc = " @param[in]   arg     Arbitrary argument of type void* to be passed into the function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_ERR_INVALID_ARG if cpu_id is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the FreeRTOS scheduler is not running"]
    #[doc = "      - ESP_OK otherwise"]
    pub fn esp_ipc_call_blocking(
        cpu_id: u32,
        func: esp_ipc_func_t,
        arg: *mut c_types::c_void,
    ) -> esp_err_t;
}
#[doc = " Require CPU frequency to be at the maximum value set via esp_pm_configure."]
#[doc = " Argument is unused and should be set to 0."]
pub const esp_pm_lock_type_t_ESP_PM_CPU_FREQ_MAX: esp_pm_lock_type_t = 0;
#[doc = " Require APB frequency to be at the maximum value supported by the chip."]
#[doc = " Argument is unused and should be set to 0."]
pub const esp_pm_lock_type_t_ESP_PM_APB_FREQ_MAX: esp_pm_lock_type_t = 1;
#[doc = " Prevent the system from going into light sleep."]
#[doc = " Argument is unused and should be set to 0."]
pub const esp_pm_lock_type_t_ESP_PM_NO_LIGHT_SLEEP: esp_pm_lock_type_t = 2;
#[doc = " @brief Power management constraints"]
pub type esp_pm_lock_type_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Set implementation-specific power management configuration"]
    #[doc = " @param config pointer to implementation-specific configuration structure (e.g. esp_pm_config_esp32)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the configuration values are not correct"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if certain combination of values is not supported,"]
    #[doc = "        or if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_configure(config: *const c_types::c_void) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_pm_lock {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to the power management lock"]
pub type esp_pm_lock_handle_t = *mut esp_pm_lock;
extern "C" {
    #[doc = " @brief Initialize a lock handle for certain power management parameter"]
    #[doc = ""]
    #[doc = " When lock is created, initially it is not taken."]
    #[doc = " Call esp_pm_lock_acquire to take the lock."]
    #[doc = ""]
    #[doc = " This function must not be called from an ISR."]
    #[doc = ""]
    #[doc = " @param lock_type Power management constraint which the lock should control"]
    #[doc = " @param arg argument, value depends on lock_type, see esp_pm_lock_type_t"]
    #[doc = " @param name arbitrary string identifying the lock (e.g. \"wifi\" or \"spi\")."]
    #[doc = "             Used by the esp_pm_dump_locks function to list existing locks."]
    #[doc = "             May be set to NULL. If not set to NULL, must point to a string which is valid"]
    #[doc = "             for the lifetime of the lock."]
    #[doc = " @param[out] out_handle  handle returned from this function. Use this handle when calling"]
    #[doc = "                         esp_pm_lock_delete, esp_pm_lock_acquire, esp_pm_lock_release."]
    #[doc = "                         Must not be NULL."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if the lock structure can not be allocated"]
    #[doc = "      - ESP_ERR_INVALID_ARG if out_handle is NULL or type argument is not valid"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_create(
        lock_type: esp_pm_lock_type_t,
        arg: c_types::c_int,
        name: *const c_types::c_char,
        out_handle: *mut esp_pm_lock_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Take a power management lock"]
    #[doc = ""]
    #[doc = " Once the lock is taken, power management algorithm will not switch to the"]
    #[doc = " mode specified in a call to esp_pm_lock_create, or any of the lower power"]
    #[doc = " modes (higher numeric values of 'mode')."]
    #[doc = ""]
    #[doc = " The lock is recursive, in the sense that if esp_pm_lock_acquire is called"]
    #[doc = " a number of times, esp_pm_lock_release has to be called the same number of"]
    #[doc = " times in order to release the lock."]
    #[doc = ""]
    #[doc = " This function may be called from an ISR."]
    #[doc = ""]
    #[doc = " This function is not thread-safe w.r.t. calls to other esp_pm_lock_*"]
    #[doc = " functions for the same handle."]
    #[doc = ""]
    #[doc = " @param handle handle obtained from esp_pm_lock_create function"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_acquire(handle: esp_pm_lock_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release the lock taken using esp_pm_lock_acquire."]
    #[doc = ""]
    #[doc = " Call to this functions removes power management restrictions placed when"]
    #[doc = " taking the lock."]
    #[doc = ""]
    #[doc = " Locks are recursive, so if esp_pm_lock_acquire is called a number of times,"]
    #[doc = " esp_pm_lock_release has to be called the same number of times in order to"]
    #[doc = " actually release the lock."]
    #[doc = ""]
    #[doc = " This function may be called from an ISR."]
    #[doc = ""]
    #[doc = " This function is not thread-safe w.r.t. calls to other esp_pm_lock_*"]
    #[doc = " functions for the same handle."]
    #[doc = ""]
    #[doc = " @param handle handle obtained from esp_pm_lock_create function"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if lock is not acquired"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_release(handle: esp_pm_lock_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete a lock created using esp_pm_lock"]
    #[doc = ""]
    #[doc = " The lock must be released before calling this function."]
    #[doc = ""]
    #[doc = " This function must not be called from an ISR."]
    #[doc = ""]
    #[doc = " @param handle handle obtained from esp_pm_lock_create function"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle argument is NULL"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the lock is still acquired"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_lock_delete(handle: esp_pm_lock_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Dump the list of all locks to stderr"]
    #[doc = ""]
    #[doc = " This function dumps debugging information about locks created using"]
    #[doc = " esp_pm_lock_create to an output stream."]
    #[doc = ""]
    #[doc = " This function must not be called from an ISR. If esp_pm_lock_acquire/release"]
    #[doc = " are called while this function is running, inconsistent results may be"]
    #[doc = " reported."]
    #[doc = ""]
    #[doc = " @param stream stream to print information to; use stdout or stderr to print"]
    #[doc = "               to the console; use fmemopen/open_memstream to print to a"]
    #[doc = "               string buffer."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if CONFIG_PM_ENABLE is not enabled in sdkconfig"]
    pub fn esp_pm_dump_locks(stream: *mut FILE) -> esp_err_t;
}
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()"]
#[doc = " returns an QueueHandle_t variable that can then be used as a parameter to"]
#[doc = " xQueueSend(), xQueueReceive(), etc."]
pub type QueueHandle_t = *mut c_types::c_void;
#[doc = " Type by which queue sets are referenced.  For example, a call to"]
#[doc = " xQueueCreateSet() returns an xQueueSet variable that can then be used as a"]
#[doc = " parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc."]
pub type QueueSetHandle_t = *mut c_types::c_void;
#[doc = " Queue sets can contain both queues and semaphores, so the"]
#[doc = " QueueSetMemberHandle_t is defined as a type to be used where a parameter or"]
#[doc = " return value can be either an QueueHandle_t or an SemaphoreHandle_t."]
pub type QueueSetMemberHandle_t = *mut c_types::c_void;
extern "C" {
    #[doc = " It is preferred that the macros xQueueSend(), xQueueSendToFront() and"]
    #[doc = " xQueueSendToBack() are used in place of calling this function directly."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  The item is queued by copy, not by reference."]
    #[doc = " This function must not be called from an interrupt service routine."]
    #[doc = " See xQueueSendFromISR () for an alternative which may be used in an ISR."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for space to become available on the queue, should it already"]
    #[doc = " be full.  The call will return immediately if this is set to 0 and the"]
    #[doc = " queue is full.  The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  struct AMessage"]
    #[doc = "  {"]
    #[doc = "  char ucMessageID;"]
    #[doc = "  char ucData[ 20 ];"]
    #[doc = "  } xMessage;"]
    #[doc = ""]
    #[doc = "  uint32_t ulVar = 10UL;"]
    #[doc = ""]
    #[doc = "  void vATask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  QueueHandle_t xQueue1, xQueue2;"]
    #[doc = "  struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "  // Create a queue capable of containing 10 uint32_t values."]
    #[doc = "  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );"]
    #[doc = ""]
    #[doc = "  // Create a queue capable of containing 10 pointers to AMessage structures."]
    #[doc = "  // These should be passed by pointer as they contain a lot of data."]
    #[doc = "  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = ""]
    #[doc = "  // ..."]
    #[doc = ""]
    #[doc = "  if( xQueue1 != 0 )"]
    #[doc = "  {"]
    #[doc = "      // Send an uint32_t.  Wait for 10 ticks for space to become"]
    #[doc = "      // available if necessary."]
    #[doc = "      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )"]
    #[doc = "      {"]
    #[doc = "          // Failed to post the message, even after 10 ticks."]
    #[doc = "      }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  if( xQueue2 != 0 )"]
    #[doc = "  {"]
    #[doc = "      // Send a pointer to a struct AMessage object.  Don't block if the"]
    #[doc = "      // queue is already full."]
    #[doc = "      pxMessage = & xMessage;"]
    #[doc = "      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // ... Rest of task code."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " A version of xQueuePeek() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Receive an item from a queue without removing the item from the queue."]
    #[doc = " The item is received by copy so a buffer of adequate size must be"]
    #[doc = " provided.  The number of bytes copied into the buffer was defined when"]
    #[doc = " the queue was created."]
    #[doc = ""]
    #[doc = " Successfully received items remain on the queue so will be returned again"]
    #[doc = " by the next call, or a call to xQueueReceive()."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueuePeekFromISR(xQueue: QueueHandle_t, pvBuffer: *mut c_types::c_void) -> BaseType_t;
}
extern "C" {
    #[doc = " It is preferred that the macro xQueueReceive() be used rather than calling"]
    #[doc = " this function directly."]
    #[doc = ""]
    #[doc = " Receive an item from a queue.  The item is received by copy so a buffer of"]
    #[doc = " adequate size must be provided.  The number of bytes copied into the buffer"]
    #[doc = " was defined when the queue was created."]
    #[doc = ""]
    #[doc = " This function must not be used in an interrupt service routine.  See"]
    #[doc = " xQueueReceiveFromISR for an alternative that can."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for an item to receive should the queue be empty at the time"]
    #[doc = " of the call.\t The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = " xQueueGenericReceive() will return immediately if the queue is empty and"]
    #[doc = " xTicksToWait is 0."]
    #[doc = ""]
    #[doc = " @param xJustPeek When set to true, the item received from the queue is not"]
    #[doc = " actually removed from the queue - meaning a subsequent call to"]
    #[doc = " xQueueReceive() will return the same item.  When set to false, the item"]
    #[doc = " being received from the queue is also removed from the queue."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  struct AMessage"]
    #[doc = "  {"]
    #[doc = " \tchar ucMessageID;"]
    #[doc = " \tchar ucData[ 20 ];"]
    #[doc = "  } xMessage;"]
    #[doc = ""]
    #[doc = "  QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "  // Task to create a queue and post a value."]
    #[doc = "  void vATask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = " \t// Create a queue capable of containing 10 pointers to AMessage structures."]
    #[doc = " \t// These should be passed by pointer as they contain a lot of data."]
    #[doc = " \txQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = " \tif( xQueue == 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Failed to create the queue."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ..."]
    #[doc = ""]
    #[doc = " \t// Send a pointer to a struct AMessage object.  Don't block if the"]
    #[doc = " \t// queue is already full."]
    #[doc = " \tpxMessage = & xMessage;"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );"]
    #[doc = ""]
    #[doc = " \t// ... Rest of task code."]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // Task to receive from the queue."]
    #[doc = "  void vADifferentTask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  struct AMessage *pxRxedMessage;"]
    #[doc = ""]
    #[doc = " \tif( xQueue != 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Receive a message on the created queue.  Block for 10 ticks if a"]
    #[doc = " \t\t// message is not immediately available."]
    #[doc = " \t\tif( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// pcRxedMessage now points to the struct AMessage variable posted"]
    #[doc = " \t\t\t// by vATask."]
    #[doc = " \t\t}"]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ... Rest of task code."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: TickType_t,
        xJustPeek: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Return the number of messages stored in a queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of messages available in the queue."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Return the number of free spaces available in a queue.  This is equal to the"]
    #[doc = " number of items that can be sent to the queue before the queue becomes full"]
    #[doc = " if no items are removed."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of spaces available in the queue."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Delete a queue - freeing all the memory allocated for storing of items"]
    #[doc = " placed on the queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue to be deleted."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " It is preferred that the macros xQueueSendFromISR(),"]
    #[doc = " xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place"]
    #[doc = " of calling this function directly.  xQueueGiveFromISR() is an"]
    #[doc = " equivalent for use by semaphores that don't actually copy any data."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " Items are queued by copy not reference so it is preferable to only"]
    #[doc = " queue small items, especially when called from an ISR.  In most cases"]
    #[doc = " it would be preferable to store a pointer to the item being queued."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param[out] pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task"]
    #[doc = " to unblock, and the unblocked task has a priority higher than the currently"]
    #[doc = " running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then"]
    #[doc = " a context switch should be requested before the interrupt is exited."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the data was successfully sent to the queue, otherwise"]
    #[doc = " errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage for buffered IO (where the ISR can obtain more than one value"]
    #[doc = " per call):"]
    #[doc = " @code{c}"]
    #[doc = "  void vBufferISR( void )"]
    #[doc = "  {"]
    #[doc = "  char cIn;"]
    #[doc = "  BaseType_t xHigherPriorityTaskWokenByPost;"]
    #[doc = ""]
    #[doc = " \t// We have not woken a task at the start of the ISR."]
    #[doc = " \txHigherPriorityTaskWokenByPost = pdFALSE;"]
    #[doc = ""]
    #[doc = " \t// Loop until the buffer is empty."]
    #[doc = " \tdo"]
    #[doc = " \t{"]
    #[doc = " \t\t// Obtain a byte from the buffer."]
    #[doc = " \t\tcIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );"]
    #[doc = ""]
    #[doc = " \t\t// Post each byte."]
    #[doc = " \t\txQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );"]
    #[doc = ""]
    #[doc = " \t} while( portINPUT_BYTE( BUFFER_COUNT ) );"]
    #[doc = ""]
    #[doc = " \t// Now the buffer is empty we can switch context if necessary.  Note that the"]
    #[doc = " \t// name of the yield function required is port specific."]
    #[doc = " \tif( xHigherPriorityTaskWokenByPost )"]
    #[doc = " \t{"]
    #[doc = " \t\ttaskYIELD_YIELD_FROM_ISR();"]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Receive an item from a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param[out] pxHigherPriorityTaskWoken A task may be blocked waiting for space to become"]
    #[doc = " available on the queue.  If xQueueReceiveFromISR causes such a task to"]
    #[doc = " unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will"]
    #[doc = " remain unchanged."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "  // Function to create a queue and post some values."]
    #[doc = "  void vAFunction( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  char cValueToPost;"]
    #[doc = "  const TickType_t xTicksToWait = ( TickType_t )0xff;"]
    #[doc = ""]
    #[doc = " \t// Create a queue capable of containing 10 characters."]
    #[doc = " \txQueue = xQueueCreate( 10, sizeof( char ) );"]
    #[doc = " \tif( xQueue == 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Failed to create the queue."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ..."]
    #[doc = ""]
    #[doc = " \t// Post some characters that will be used within an ISR.  If the queue"]
    #[doc = " \t// is full then this task will block for xTicksToWait ticks."]
    #[doc = " \tcValueToPost = 'a';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = " \tcValueToPost = 'b';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = ""]
    #[doc = " \t// ... keep posting characters ... this task may block when the queue"]
    #[doc = " \t// becomes full."]
    #[doc = ""]
    #[doc = " \tcValueToPost = 'c';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // ISR that outputs all the characters received on the queue."]
    #[doc = "  void vISR_Routine( void )"]
    #[doc = "  {"]
    #[doc = "  BaseType_t xTaskWokenByReceive = pdFALSE;"]
    #[doc = "  char cRxedChar;"]
    #[doc = ""]
    #[doc = " \twhile( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )"]
    #[doc = " \t{"]
    #[doc = " \t\t// A character was received.  Output the character now."]
    #[doc = " \t\tvOutputCharacter( cRxedChar );"]
    #[doc = ""]
    #[doc = " \t\t// If removing the character from the queue woke the task that was"]
    #[doc = " \t\t// posting onto the queue cTaskWokenByReceive will have been set to"]
    #[doc = " \t\t// pdTRUE.  No matter how many times this loop iterates only one"]
    #[doc = " \t\t// task will be woken."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \tif( cTaskWokenByPost != ( char ) pdFALSE;"]
    #[doc = " \t{"]
    #[doc = " \t\ttaskYIELD ();"]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " Utilities to query queues that are safe to use from an ISR.  These utilities"]
    #[doc = " should be used only from witin an ISR, or within a critical section."]
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " xQueueAltGenericSend() is an alternative version of xQueueGenericSend()."]
    #[doc = " Likewise xQueueAltGenericReceive() is an alternative version of"]
    #[doc = " xQueueGenericReceive()."]
    #[doc = ""]
    #[doc = " The source code that implements the alternative (Alt) API is much"]
    #[doc = " simpler\tbecause it executes everything from within a critical section."]
    #[doc = " This is\tthe approach taken by many other RTOSes, but FreeRTOS.org has the"]
    #[doc = " preferred fully featured API too.  The fully featured API has more"]
    #[doc = " complex\tcode that takes longer to execute, but makes much less use of"]
    #[doc = " critical sections.  Therefore the alternative API sacrifices interrupt"]
    #[doc = " responsiveness to gain execution speed, whereas the fully featured API"]
    #[doc = " sacrifices execution speed to ensure better interrupt responsiveness."]
    pub fn xQueueAltGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueAltGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: TickType_t,
        xJustPeeking: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(pxMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    #[doc = " Queue sets provide a mechanism to allow a task to block (pend) on a read"]
    #[doc = " operation from multiple queues or semaphores simultaneously."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " A queue set must be explicitly created using a call to xQueueCreateSet()"]
    #[doc = " before it can be used.  Once created, standard FreeRTOS queues and semaphores"]
    #[doc = " can be added to the set using calls to xQueueAddToSet()."]
    #[doc = " xQueueSelectFromSet() is then used to determine which, if any, of the queues"]
    #[doc = " or semaphores contained in the set is in a state where a queue read or"]
    #[doc = " semaphore take operation would be successful."]
    #[doc = ""]
    #[doc = " Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html"]
    #[doc = " for reasons why queue sets are very rarely needed in practice as there are"]
    #[doc = " simpler methods of blocking on multiple objects."]
    #[doc = ""]
    #[doc = " Note 2:  Blocking on a queue set that contains a mutex will not cause the"]
    #[doc = " mutex holder to inherit the priority of the blocked task."]
    #[doc = ""]
    #[doc = " Note 3:  An additional 4 bytes of RAM is required for each space in a every"]
    #[doc = " queue added to a queue set.  Therefore counting semaphores that have a high"]
    #[doc = " maximum count value should not be added to a queue set."]
    #[doc = ""]
    #[doc = " Note 4:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param uxEventQueueLength Queue sets store events that occur on"]
    #[doc = " the queues and semaphores contained in the set.  uxEventQueueLength specifies"]
    #[doc = " the maximum number of events that can be queued at once.  To be absolutely"]
    #[doc = " certain that events are not lost uxEventQueueLength should be set to the"]
    #[doc = " total sum of the length of the queues added to the set, where binary"]
    #[doc = " semaphores and mutexes have a length of 1, and counting semaphores have a"]
    #[doc = " length set by their maximum count value.  Examples:"]
    #[doc = "  + If a queue set is to hold a queue of length 5, another queue of length 12,"]
    #[doc = "    and a binary semaphore, then uxEventQueueLength should be set to"]
    #[doc = "    (5 + 12 + 1), or 18."]
    #[doc = "  + If a queue set is to hold three binary semaphores then uxEventQueueLength"]
    #[doc = "    should be set to (1 + 1 + 1 ), or 3."]
    #[doc = "  + If a queue set is to hold a counting semaphore that has a maximum count of"]
    #[doc = "    5, and a counting semaphore that has a maximum count of 3, then"]
    #[doc = "    uxEventQueueLength should be set to (5 + 3), or 8."]
    #[doc = ""]
    #[doc = " @return If the queue set is created successfully then a handle to the created"]
    #[doc = " queue set is returned.  Otherwise NULL is returned."]
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    #[doc = " Adds a queue or semaphore to a queue set that was previously created by a"]
    #[doc = " call to xQueueCreateSet()."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Note 1:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param xQueueOrSemaphore The handle of the queue or semaphore being added to"]
    #[doc = " the queue set (cast to an QueueSetMemberHandle_t type)."]
    #[doc = ""]
    #[doc = " @param xQueueSet The handle of the queue set to which the queue or semaphore"]
    #[doc = " is being added."]
    #[doc = ""]
    #[doc = " @return If the queue or semaphore was successfully added to the queue set"]
    #[doc = " then pdPASS is returned.  If the queue could not be successfully added to the"]
    #[doc = " queue set because it is already a member of a different queue set then pdFAIL"]
    #[doc = " is returned."]
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Removes a queue or semaphore from a queue set.  A queue or semaphore can only"]
    #[doc = " be removed from a set if the queue or semaphore is empty."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param xQueueOrSemaphore The handle of the queue or semaphore being removed"]
    #[doc = " from the queue set (cast to an QueueSetMemberHandle_t type)."]
    #[doc = ""]
    #[doc = " @param xQueueSet The handle of the queue set in which the queue or semaphore"]
    #[doc = " is included."]
    #[doc = ""]
    #[doc = " @return If the queue or semaphore was successfully removed from the queue set"]
    #[doc = " then pdPASS is returned.  If the queue was not in the queue set, or the"]
    #[doc = " queue (or semaphore) was not empty, then pdFAIL is returned."]
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " xQueueSelectFromSet() selects from the members of a queue set a queue or"]
    #[doc = " semaphore that either contains data (in the case of a queue) or is available"]
    #[doc = " to take (in the case of a semaphore).  xQueueSelectFromSet() effectively"]
    #[doc = " allows a task to block (pend) on a read operation on all the queues and"]
    #[doc = " semaphores in a queue set simultaneously."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html"]
    #[doc = " for reasons why queue sets are very rarely needed in practice as there are"]
    #[doc = " simpler methods of blocking on multiple objects."]
    #[doc = ""]
    #[doc = " Note 2:  Blocking on a queue set that contains a mutex will not cause the"]
    #[doc = " mutex holder to inherit the priority of the blocked task."]
    #[doc = ""]
    #[doc = " Note 3:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param xQueueSet The queue set on which the task will (potentially) block."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum time, in ticks, that the calling task will"]
    #[doc = " remain in the Blocked state (with other tasks executing) to wait for a member"]
    #[doc = " of the queue set to be ready for a successful queue read or semaphore take"]
    #[doc = " operation."]
    #[doc = ""]
    #[doc = " @return xQueueSelectFromSet() will return the handle of a queue (cast to"]
    #[doc = " a QueueSetMemberHandle_t type) contained in the queue set that contains data,"]
    #[doc = " or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained"]
    #[doc = " in the queue set that is available, or NULL if no such queue or semaphore"]
    #[doc = " exists before before the specified block time expires."]
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " A version of xQueueSelectFromSet() that can be used from an ISR."]
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " @cond"]
    pub fn vQueueWaitForMessageRestricted(xQueue: QueueHandle_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
pub type SemaphoreHandle_t = QueueHandle_t;
pub type esp_event_base_t = *const c_types::c_char;
pub type esp_event_loop_handle_t = *mut c_types::c_void;
pub type esp_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_handler_arg: *mut c_types::c_void,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut c_types::c_void,
    ),
>;
#[doc = "< null mode"]
pub const wifi_mode_t_WIFI_MODE_NULL: wifi_mode_t = 0;
#[doc = "< WiFi station mode"]
pub const wifi_mode_t_WIFI_MODE_STA: wifi_mode_t = 1;
#[doc = "< WiFi soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_AP: wifi_mode_t = 2;
#[doc = "< WiFi station + soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_APSTA: wifi_mode_t = 3;
pub const wifi_mode_t_WIFI_MODE_MAX: wifi_mode_t = 4;
pub type wifi_mode_t = c_types::c_uint;
pub use self::esp_interface_t as wifi_interface_t;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_AUTO: wifi_country_policy_t = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_MANUAL: wifi_country_policy_t = 1;
pub type wifi_country_policy_t = c_types::c_uint;
#[doc = " @brief Structure describing WiFi country-based regional restrictions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< country code string"]
    pub cc: [c_types::c_char; 3usize],
    #[doc = "< start channel"]
    pub schan: u8,
    #[doc = "< total channel number"]
    pub nchan: u8,
    #[doc = "< This field is used for getting WiFi maximum transmitting power, call esp_wifi_set_max_tx_power to set the maximum transmitting power."]
    pub max_tx_power: i8,
    #[doc = "< country policy"]
    pub policy: wifi_country_policy_t,
}
#[doc = "< authenticate mode : open"]
pub const wifi_auth_mode_t_WIFI_AUTH_OPEN: wifi_auth_mode_t = 0;
#[doc = "< authenticate mode : WEP"]
pub const wifi_auth_mode_t_WIFI_AUTH_WEP: wifi_auth_mode_t = 1;
#[doc = "< authenticate mode : WPA_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_PSK: wifi_auth_mode_t = 2;
#[doc = "< authenticate mode : WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_PSK: wifi_auth_mode_t = 3;
#[doc = "< authenticate mode : WPA_WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_WPA2_PSK: wifi_auth_mode_t = 4;
#[doc = "< authenticate mode : WPA2_ENTERPRISE"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_ENTERPRISE: wifi_auth_mode_t = 5;
#[doc = "< authenticate mode : WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA3_PSK: wifi_auth_mode_t = 6;
#[doc = "< authenticate mode : WPA2_WPA3_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_WPA3_PSK: wifi_auth_mode_t = 7;
pub const wifi_auth_mode_t_WIFI_AUTH_MAX: wifi_auth_mode_t = 8;
pub type wifi_auth_mode_t = c_types::c_uint;
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED: wifi_err_reason_t = 1;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_EXPIRE: wifi_err_reason_t = 2;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_LEAVE: wifi_err_reason_t = 3;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_EXPIRE: wifi_err_reason_t = 4;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_TOOMANY: wifi_err_reason_t = 5;
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHED: wifi_err_reason_t = 6;
pub const wifi_err_reason_t_WIFI_REASON_NOT_ASSOCED: wifi_err_reason_t = 7;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_LEAVE: wifi_err_reason_t = 8;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_NOT_AUTHED: wifi_err_reason_t = 9;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_PWRCAP_BAD: wifi_err_reason_t = 10;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_SUPCHAN_BAD: wifi_err_reason_t = 11;
pub const wifi_err_reason_t_WIFI_REASON_IE_INVALID: wifi_err_reason_t = 13;
pub const wifi_err_reason_t_WIFI_REASON_MIC_FAILURE: wifi_err_reason_t = 14;
pub const wifi_err_reason_t_WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 15;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT: wifi_err_reason_t = 16;
pub const wifi_err_reason_t_WIFI_REASON_IE_IN_4WAY_DIFFERS: wifi_err_reason_t = 17;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_CIPHER_INVALID: wifi_err_reason_t = 18;
pub const wifi_err_reason_t_WIFI_REASON_PAIRWISE_CIPHER_INVALID: wifi_err_reason_t = 19;
pub const wifi_err_reason_t_WIFI_REASON_AKMP_INVALID: wifi_err_reason_t = 20;
pub const wifi_err_reason_t_WIFI_REASON_UNSUPP_RSN_IE_VERSION: wifi_err_reason_t = 21;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_RSN_IE_CAP: wifi_err_reason_t = 22;
pub const wifi_err_reason_t_WIFI_REASON_802_1X_AUTH_FAILED: wifi_err_reason_t = 23;
pub const wifi_err_reason_t_WIFI_REASON_CIPHER_SUITE_REJECTED: wifi_err_reason_t = 24;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_PMKID: wifi_err_reason_t = 53;
pub const wifi_err_reason_t_WIFI_REASON_BEACON_TIMEOUT: wifi_err_reason_t = 200;
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND: wifi_err_reason_t = 201;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_FAIL: wifi_err_reason_t = 202;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_FAIL: wifi_err_reason_t = 203;
pub const wifi_err_reason_t_WIFI_REASON_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 204;
pub const wifi_err_reason_t_WIFI_REASON_CONNECTION_FAIL: wifi_err_reason_t = 205;
pub const wifi_err_reason_t_WIFI_REASON_AP_TSF_RESET: wifi_err_reason_t = 206;
pub type wifi_err_reason_t = c_types::c_uint;
#[doc = "< the channel width is HT20"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_NONE: wifi_second_chan_t = 0;
#[doc = "< the channel width is HT40 and the secondary channel is above the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_ABOVE: wifi_second_chan_t = 1;
#[doc = "< the channel width is HT40 and the secondary channel is below the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_BELOW: wifi_second_chan_t = 2;
pub type wifi_second_chan_t = c_types::c_uint;
#[doc = "< active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
pub type wifi_scan_type_t = c_types::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< maximum active scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_scan_time_t {
    #[doc = "< active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< passive scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub passive: u32,
}
#[doc = " @brief Parameters for an SSID scan."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_scan_config_t {
    #[doc = "< SSID of AP"]
    pub ssid: *mut u8,
    #[doc = "< MAC address of AP"]
    pub bssid: *mut u8,
    #[doc = "< channel, scan the specific channel"]
    pub channel: u8,
    #[doc = "< enable to scan AP whose SSID is hidden"]
    pub show_hidden: bool,
    #[doc = "< scan type, active or passive"]
    pub scan_type: wifi_scan_type_t,
    #[doc = "< scan time per channel"]
    pub scan_time: wifi_scan_time_t,
}
#[doc = "< the cipher type is none"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_NONE: wifi_cipher_type_t = 0;
#[doc = "< the cipher type is WEP40"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP40: wifi_cipher_type_t = 1;
#[doc = "< the cipher type is WEP104"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP104: wifi_cipher_type_t = 2;
#[doc = "< the cipher type is TKIP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP: wifi_cipher_type_t = 3;
#[doc = "< the cipher type is CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_CCMP: wifi_cipher_type_t = 4;
#[doc = "< the cipher type is TKIP and CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP_CCMP: wifi_cipher_type_t = 5;
#[doc = "< the cipher type is AES-CMAC-128"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_AES_CMAC128: wifi_cipher_type_t = 6;
#[doc = "< the cipher type is unknown"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_UNKNOWN: wifi_cipher_type_t = 7;
pub type wifi_cipher_type_t = c_types::c_uint;
#[doc = "< WiFi antenna 0"]
pub const wifi_ant_t_WIFI_ANT_ANT0: wifi_ant_t = 0;
#[doc = "< WiFi antenna 1"]
pub const wifi_ant_t_WIFI_ANT_ANT1: wifi_ant_t = 1;
#[doc = "< Invalid WiFi antenna"]
pub const wifi_ant_t_WIFI_ANT_MAX: wifi_ant_t = 2;
#[doc = " @brief WiFi antenna"]
#[doc = ""]
pub type wifi_ant_t = c_types::c_uint;
#[doc = " @brief Description of a WiFi AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_record_t {
    #[doc = "< MAC address of AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 33usize],
    #[doc = "< channel of AP"]
    pub primary: u8,
    #[doc = "< secondary channel of AP"]
    pub second: wifi_second_chan_t,
    #[doc = "< signal strength of AP"]
    pub rssi: i8,
    #[doc = "< authmode of AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< pairwise cipher of AP"]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< group cipher of AP"]
    pub group_cipher: wifi_cipher_type_t,
    #[doc = "< antenna used to receive beacon from AP"]
    pub ant: wifi_ant_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< country information of AP"]
    pub country: wifi_country_t,
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        wps: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Do fast scan, scan will end after find SSID match AP"]
pub const wifi_scan_method_t_WIFI_FAST_SCAN: wifi_scan_method_t = 0;
#[doc = "< All channel scan, scan will end after scan all the channel"]
pub const wifi_scan_method_t_WIFI_ALL_CHANNEL_SCAN: wifi_scan_method_t = 1;
pub type wifi_scan_method_t = c_types::c_uint;
#[doc = "< Sort match AP in scan list by RSSI"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SIGNAL: wifi_sort_method_t = 0;
#[doc = "< Sort match AP in scan list by security mode"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SECURITY: wifi_sort_method_t = 1;
pub type wifi_sort_method_t = c_types::c_uint;
#[doc = " @brief Structure describing parameters for a WiFi fast scan"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_scan_threshold_t {
    #[doc = "< The minimum rssi to accept in the fast scan mode"]
    pub rssi: i8,
    #[doc = "< The weakest authmode to accept in the fast scan mode"]
    pub authmode: wifi_auth_mode_t,
}
#[doc = "< No power save"]
pub const wifi_ps_type_t_WIFI_PS_NONE: wifi_ps_type_t = 0;
#[doc = "< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period"]
pub const wifi_ps_type_t_WIFI_PS_MIN_MODEM: wifi_ps_type_t = 1;
#[doc = "< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t"]
pub const wifi_ps_type_t_WIFI_PS_MAX_MODEM: wifi_ps_type_t = 2;
pub type wifi_ps_type_t = c_types::c_uint;
pub const wifi_bandwidth_t_WIFI_BW_HT20: wifi_bandwidth_t = 1;
pub const wifi_bandwidth_t_WIFI_BW_HT40: wifi_bandwidth_t = 2;
pub type wifi_bandwidth_t = c_types::c_uint;
#[doc = " Configuration structure for Protected Management Frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_pmf_config_t {
    #[doc = "< Advertizes support for Protected Management Frame. Device will prefer to connect in PMF mode if other device also advertizes PMF capability."]
    pub capable: bool,
    #[doc = "< Advertizes that Protected Management Frame is required. Device will not associate to non-PMF capable devices."]
    pub required: bool,
}
#[doc = " @brief Soft-AP configuration settings for the ESP32"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_config_t {
    #[doc = "< SSID of ESP32 soft-AP. If ssid_len field is 0, this must be a Null terminated string. Otherwise, length is set according to ssid_len."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of ESP32 soft-AP. Null terminated string."]
    pub password: [u8; 64usize],
    #[doc = "< Optional length of SSID field."]
    pub ssid_len: u8,
    #[doc = "< Channel of ESP32 soft-AP"]
    pub channel: u8,
    #[doc = "< Auth mode of ESP32 soft-AP. Do not support AUTH_WEP in soft-AP mode"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Broadcast SSID or not, default 0, broadcast the SSID"]
    pub ssid_hidden: u8,
    #[doc = "< Max number of stations allowed to connect in, default 4, max 10"]
    pub max_connection: u8,
    #[doc = "< Beacon interval, 100 ~ 60000 ms, default 100 ms"]
    pub beacon_interval: u16,
}
#[doc = " @brief STA configuration settings for the ESP32"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_config_t {
    #[doc = "< SSID of target AP. Null terminated string."]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of target AP. Null terminated string."]
    pub password: [u8; 64usize],
    #[doc = "< do all channel scan or fast scan"]
    pub scan_method: wifi_scan_method_t,
    #[doc = "< whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of target AP. Set to 1~13 to scan starting from the specified channel before connecting to AP. If the channel of AP is unknown, set it to 0."]
    pub channel: u8,
    #[doc = "< Listen interval for ESP32 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0."]
    pub listen_interval: u16,
    #[doc = "< sort the connect AP in the list by rssi or security mode"]
    pub sort_method: wifi_sort_method_t,
    #[doc = "< When sort_method is set, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used."]
    pub threshold: wifi_scan_threshold_t,
    #[doc = "< Configuration for Protected Management Frame. Will be advertized in RSN Capabilities in RSN IE."]
    pub pmf_cfg: wifi_pmf_config_t,
}
#[doc = " @brief Configuration data for ESP32 AP or STA."]
#[doc = ""]
#[doc = " The usage of this union (for ap or sta configuration) is determined by the accompanying"]
#[doc = " interface argument passed to esp_wifi_set_config() or esp_wifi_get_config()"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    #[doc = "< configuration of AP"]
    pub ap: wifi_ap_config_t,
    #[doc = "< configuration of STA"]
    pub sta: wifi_sta_config_t,
    _bindgen_union_align: [u32; 32usize],
}
#[doc = " @brief Description of STA associated with AP"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_sta_info_t {
    #[doc = "< mac address"]
    pub mac: [u8; 6usize],
    #[doc = "< current average rssi of sta connected"]
    pub rssi: i8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief List of stations associated with the ESP32 Soft-AP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_sta_list_t {
    #[doc = "< station list"]
    pub sta: [wifi_sta_info_t; 10usize],
    #[doc = "< number of stations in the list (other entries are invalid)"]
    pub num: c_types::c_int,
}
#[doc = "< all configuration will store in both memory and flash"]
pub const wifi_storage_t_WIFI_STORAGE_FLASH: wifi_storage_t = 0;
#[doc = "< all configuration will only store in the memory"]
pub const wifi_storage_t_WIFI_STORAGE_RAM: wifi_storage_t = 1;
pub type wifi_storage_t = c_types::c_uint;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_BEACON: wifi_vendor_ie_type_t = 0;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_REQ: wifi_vendor_ie_type_t = 1;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_RESP: wifi_vendor_ie_type_t = 2;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_REQ: wifi_vendor_ie_type_t = 3;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_RESP: wifi_vendor_ie_type_t = 4;
#[doc = " @brief     Vendor Information Element type"]
#[doc = ""]
#[doc = " Determines the frame type that the IE will be associated with."]
pub type wifi_vendor_ie_type_t = c_types::c_uint;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_0: wifi_vendor_ie_id_t = 0;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_1: wifi_vendor_ie_id_t = 1;
#[doc = " @brief     Vendor Information Element index"]
#[doc = ""]
#[doc = " Each IE type can have up to two associated vendor ID elements."]
pub type wifi_vendor_ie_id_t = c_types::c_uint;
#[doc = " @brief Vendor Information Element header"]
#[doc = ""]
#[doc = " The first bytes of the Information Element will match this header. Payload follows."]
#[repr(C)]
#[derive(Debug)]
pub struct vendor_ie_data_t {
    #[doc = "< Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    pub element_id: u8,
    #[doc = "< Length of all bytes in the element data following this field. Minimum 4."]
    pub length: u8,
    #[doc = "< Vendor identifier (OUI)."]
    pub vendor_oui: [u8; 3usize],
    #[doc = "< Vendor-specific OUI type."]
    pub vendor_oui_type: u8,
    #[doc = "< Payload. Length is equal to value in 'length' field, minus 4."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = " @brief Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 28usize], u32>,
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary_channel(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(76usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondary_channel(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(76usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ant(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(191usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ant(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(191usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_len(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(192usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sig_len(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(192usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_state(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(216usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_state(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(216usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rssi: c_types::c_int,
        rate: c_types::c_uint,
        sig_mode: c_types::c_uint,
        mcs: c_types::c_uint,
        cwb: c_types::c_uint,
        smoothing: c_types::c_uint,
        not_sounding: c_types::c_uint,
        aggregation: c_types::c_uint,
        stbc: c_types::c_uint,
        fec_coding: c_types::c_uint,
        sgi: c_types::c_uint,
        ampdu_cnt: c_types::c_uint,
        channel: c_types::c_uint,
        secondary_channel: c_types::c_uint,
        timestamp: c_types::c_uint,
        ant: c_types::c_uint,
        sig_len: c_types::c_uint,
        rx_state: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 28usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 28usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rssi: u32 = unsafe { ::core::mem::transmute(rssi) };
            rssi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let rate: u32 = unsafe { ::core::mem::transmute(rate) };
            rate as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let sig_mode: u32 = unsafe { ::core::mem::transmute(sig_mode) };
            sig_mode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 7u8, {
            let mcs: u32 = unsafe { ::core::mem::transmute(mcs) };
            mcs as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let cwb: u32 = unsafe { ::core::mem::transmute(cwb) };
            cwb as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let smoothing: u32 = unsafe { ::core::mem::transmute(smoothing) };
            smoothing as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let not_sounding: u32 = unsafe { ::core::mem::transmute(not_sounding) };
            not_sounding as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let aggregation: u32 = unsafe { ::core::mem::transmute(aggregation) };
            aggregation as u64
        });
        __bindgen_bitfield_unit.set(60usize, 2u8, {
            let stbc: u32 = unsafe { ::core::mem::transmute(stbc) };
            stbc as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fec_coding: u32 = unsafe { ::core::mem::transmute(fec_coding) };
            fec_coding as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sgi: u32 = unsafe { ::core::mem::transmute(sgi) };
            sgi as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let ampdu_cnt: u32 = unsafe { ::core::mem::transmute(ampdu_cnt) };
            ampdu_cnt as u64
        });
        __bindgen_bitfield_unit.set(72usize, 4u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(76usize, 4u8, {
            let secondary_channel: u32 = unsafe { ::core::mem::transmute(secondary_channel) };
            secondary_channel as u64
        });
        __bindgen_bitfield_unit.set(96usize, 32u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit.set(191usize, 1u8, {
            let ant: u32 = unsafe { ::core::mem::transmute(ant) };
            ant as u64
        });
        __bindgen_bitfield_unit.set(192usize, 12u8, {
            let sig_len: u32 = unsafe { ::core::mem::transmute(sig_len) };
            sig_len as u64
        });
        __bindgen_bitfield_unit.set(216usize, 8u8, {
            let rx_state: u32 = unsafe { ::core::mem::transmute(rx_state) };
            rx_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Payload passed to 'buf' parameter of promiscuous mode RX callback."]
#[repr(C)]
#[derive(Debug)]
pub struct wifi_promiscuous_pkt_t {
    #[doc = "< metadata header"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< Data or management payload. Length of payload is described by rx_ctrl.sig_len. Type of content determined by packet type argument of callback."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Management frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MGMT: wifi_promiscuous_pkt_type_t = 0;
#[doc = "< Control frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_CTRL: wifi_promiscuous_pkt_type_t = 1;
#[doc = "< Data frame, indiciates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_DATA: wifi_promiscuous_pkt_type_t = 2;
#[doc = "< Other type, such as MIMO etc. 'buf' argument is wifi_promiscuous_pkt_t but the payload is zero length."]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MISC: wifi_promiscuous_pkt_type_t = 3;
#[doc = " @brief Promiscuous frame type"]
#[doc = ""]
#[doc = " Passed to promiscuous mode RX callback to indicate the type of parameter in the buffer."]
#[doc = ""]
pub type wifi_promiscuous_pkt_type_t = c_types::c_uint;
#[doc = " @brief Mask for filtering different packet types in promiscuous mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_promiscuous_filter_t {
    #[doc = "< OR of one or more filter values WIFI_PROMIS_FILTER_*"]
    pub filter_mask: u32,
}
#[doc = " @brief Channel state information(CSI) configuration type"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_csi_config_t {
    #[doc = "< enable to receive legacy long training field(lltf) data. Default enabled"]
    pub lltf_en: bool,
    #[doc = "< enable to receive HT long training field(htltf) data. Default enabled"]
    pub htltf_en: bool,
    #[doc = "< enable to receive space time block code HT long training field(stbc-htltf2) data. Default enabled"]
    pub stbc_htltf2_en: bool,
    #[doc = "< enable to generate htlft data by averaging lltf and ht_ltf data when receiving HT packet. Otherwise, use ht_ltf data directly. Default enabled"]
    pub ltf_merge_en: bool,
    #[doc = "< enable to turn on channel filter to smooth adjacent sub-carrier. Disable it to keep independence of adjacent sub-carrier. Default enabled"]
    pub channel_filter_en: bool,
    #[doc = "< manually scale the CSI data by left shifting or automatically scale the CSI data. If set true, please set the shift bits. false: automatically. true: manually. Default false"]
    pub manu_scale: bool,
    #[doc = "< manually left shift bits of the scale of the CSI data. The range of the left shift bits is 0~15"]
    pub shift: u8,
}
#[doc = " @brief CSI data type"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_csi_info_t {
    #[doc = "< received packet radio metadata header of the CSI data"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< source MAC address of the CSI data"]
    pub mac: [u8; 6usize],
    #[doc = "< first four bytes of the CSI data is invalid or not"]
    pub first_word_invalid: bool,
    #[doc = "< buffer of CSI data"]
    pub buf: *mut i8,
    #[doc = "< length of CSI data"]
    pub len: u16,
}
#[doc = " @brief WiFi GPIO configuration for antenna selection"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ant_gpio_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl wifi_ant_gpio_t {
    #[inline]
    pub fn gpio_select(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_select(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gpio_select: u8,
        gpio_num: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpio_select: u8 = unsafe { ::core::mem::transmute(gpio_select) };
            gpio_select as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let gpio_num: u8 = unsafe { ::core::mem::transmute(gpio_num) };
            gpio_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief WiFi GPIOs configuration for antenna selection"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ant_gpio_config_t {
    #[doc = "< The configurations of GPIOs that connect to external antenna switch"]
    pub gpio_cfg: [wifi_ant_gpio_t; 4usize],
}
#[doc = "< Enable WiFi antenna 0 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT0: wifi_ant_mode_t = 0;
#[doc = "< Enable WiFi antenna 1 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT1: wifi_ant_mode_t = 1;
#[doc = "< Enable WiFi antenna 0 and 1, automatically select an antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_AUTO: wifi_ant_mode_t = 2;
#[doc = "< Invalid WiFi enabled antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_MAX: wifi_ant_mode_t = 3;
#[doc = " @brief WiFi antenna mode"]
#[doc = ""]
pub type wifi_ant_mode_t = c_types::c_uint;
#[doc = " @brief WiFi antenna configuration"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ant_config_t {
    #[doc = "< WiFi antenna mode for receiving"]
    pub rx_ant_mode: wifi_ant_mode_t,
    #[doc = "< Default antenna mode for receiving, it's ignored if rx_ant_mode is not WIFI_ANT_MODE_AUTO"]
    pub rx_ant_default: wifi_ant_t,
    #[doc = "< WiFi antenna mode for transmission, it can be set to WIFI_ANT_MODE_AUTO only if rx_ant_mode is set to WIFI_ANT_MODE_AUTO"]
    pub tx_ant_mode: wifi_ant_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_ant_config_t {
    #[inline]
    pub fn enabled_ant0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_ant1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled_ant0: u8,
        enabled_ant1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let enabled_ant0: u8 = unsafe { ::core::mem::transmute(enabled_ant0) };
            enabled_ant0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let enabled_ant1: u8 = unsafe { ::core::mem::transmute(enabled_ant1) };
            enabled_ant1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< 1 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_1M_L: wifi_phy_rate_t = 0;
#[doc = "< 2 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_L: wifi_phy_rate_t = 1;
#[doc = "< 5.5 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_L: wifi_phy_rate_t = 2;
#[doc = "< 11 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_L: wifi_phy_rate_t = 3;
#[doc = "< 2 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_S: wifi_phy_rate_t = 5;
#[doc = "< 5.5 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_S: wifi_phy_rate_t = 6;
#[doc = "< 11 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_S: wifi_phy_rate_t = 7;
#[doc = "< 48 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_48M: wifi_phy_rate_t = 8;
#[doc = "< 24 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_24M: wifi_phy_rate_t = 9;
#[doc = "< 12 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_12M: wifi_phy_rate_t = 10;
#[doc = "< 6 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_6M: wifi_phy_rate_t = 11;
#[doc = "< 54 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_54M: wifi_phy_rate_t = 12;
#[doc = "< 36 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_36M: wifi_phy_rate_t = 13;
#[doc = "< 18 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_18M: wifi_phy_rate_t = 14;
#[doc = "< 9 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_9M: wifi_phy_rate_t = 15;
#[doc = "< MCS0 with long GI, 6.5 Mbps for 20MHz, 13.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_LGI: wifi_phy_rate_t = 16;
#[doc = "< MCS1 with long GI, 13 Mbps for 20MHz, 27 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_LGI: wifi_phy_rate_t = 17;
#[doc = "< MCS2 with long GI, 19.5 Mbps for 20MHz, 40.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_LGI: wifi_phy_rate_t = 18;
#[doc = "< MCS3 with long GI, 26 Mbps for 20MHz, 54 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_LGI: wifi_phy_rate_t = 19;
#[doc = "< MCS4 with long GI, 39 Mbps for 20MHz, 81 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_LGI: wifi_phy_rate_t = 20;
#[doc = "< MCS5 with long GI, 52 Mbps for 20MHz, 108 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_LGI: wifi_phy_rate_t = 21;
#[doc = "< MCS6 with long GI, 58.5 Mbps for 20MHz, 121.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_LGI: wifi_phy_rate_t = 22;
#[doc = "< MCS7 with long GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_LGI: wifi_phy_rate_t = 23;
#[doc = "< MCS0 with short GI, 7.2 Mbps for 20MHz, 15 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_SGI: wifi_phy_rate_t = 24;
#[doc = "< MCS1 with short GI, 14.4 Mbps for 20MHz, 30 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_SGI: wifi_phy_rate_t = 25;
#[doc = "< MCS2 with short GI, 21.7 Mbps for 20MHz, 45 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_SGI: wifi_phy_rate_t = 26;
#[doc = "< MCS3 with short GI, 28.9 Mbps for 20MHz, 60 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_SGI: wifi_phy_rate_t = 27;
#[doc = "< MCS4 with short GI, 43.3 Mbps for 20MHz, 90 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_SGI: wifi_phy_rate_t = 28;
#[doc = "< MCS5 with short GI, 57.8 Mbps for 20MHz, 120 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_SGI: wifi_phy_rate_t = 29;
#[doc = "< MCS6 with short GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_SGI: wifi_phy_rate_t = 30;
#[doc = "< MCS7 with short GI, 72.2 Mbps for 20MHz, 150 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_SGI: wifi_phy_rate_t = 31;
#[doc = "< 250 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_250K: wifi_phy_rate_t = 41;
#[doc = "< 500 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_500K: wifi_phy_rate_t = 42;
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MAX: wifi_phy_rate_t = 43;
#[doc = " @brief WiFi PHY rate encodings"]
#[doc = ""]
pub type wifi_phy_rate_t = c_types::c_uint;
#[doc = "< ESP32 WiFi ready"]
pub const wifi_event_t_WIFI_EVENT_WIFI_READY: wifi_event_t = 0;
#[doc = "< ESP32 finish scanning AP"]
pub const wifi_event_t_WIFI_EVENT_SCAN_DONE: wifi_event_t = 1;
#[doc = "< ESP32 station start"]
pub const wifi_event_t_WIFI_EVENT_STA_START: wifi_event_t = 2;
#[doc = "< ESP32 station stop"]
pub const wifi_event_t_WIFI_EVENT_STA_STOP: wifi_event_t = 3;
#[doc = "< ESP32 station connected to AP"]
pub const wifi_event_t_WIFI_EVENT_STA_CONNECTED: wifi_event_t = 4;
#[doc = "< ESP32 station disconnected from AP"]
pub const wifi_event_t_WIFI_EVENT_STA_DISCONNECTED: wifi_event_t = 5;
#[doc = "< the auth mode of AP connected by ESP32 station changed"]
pub const wifi_event_t_WIFI_EVENT_STA_AUTHMODE_CHANGE: wifi_event_t = 6;
#[doc = "< ESP32 station wps succeeds in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_SUCCESS: wifi_event_t = 7;
#[doc = "< ESP32 station wps fails in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_FAILED: wifi_event_t = 8;
#[doc = "< ESP32 station wps timeout in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_TIMEOUT: wifi_event_t = 9;
#[doc = "< ESP32 station wps pin code in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PIN: wifi_event_t = 10;
#[doc = "< ESP32 station wps overlap in enrollee mode"]
pub const wifi_event_t_WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP: wifi_event_t = 11;
#[doc = "< ESP32 soft-AP start"]
pub const wifi_event_t_WIFI_EVENT_AP_START: wifi_event_t = 12;
#[doc = "< ESP32 soft-AP stop"]
pub const wifi_event_t_WIFI_EVENT_AP_STOP: wifi_event_t = 13;
#[doc = "< a station connected to ESP32 soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STACONNECTED: wifi_event_t = 14;
#[doc = "< a station disconnected from ESP32 soft-AP"]
pub const wifi_event_t_WIFI_EVENT_AP_STADISCONNECTED: wifi_event_t = 15;
#[doc = "< Receive probe request packet in soft-AP interface"]
pub const wifi_event_t_WIFI_EVENT_AP_PROBEREQRECVED: wifi_event_t = 16;
#[doc = "< Invalid WiFi event ID"]
pub const wifi_event_t_WIFI_EVENT_MAX: wifi_event_t = 17;
#[doc = " WiFi event declarations"]
pub type wifi_event_t = c_types::c_uint;
extern "C" {
    pub static mut WIFI_EVENT: esp_event_base_t;
}
#[doc = " Argument structure for WIFI_EVENT_SCAN_DONE event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_scan_done_t {
    #[doc = "< status of scanning APs: 0  success, 1 - failure"]
    pub status: u32,
    #[doc = "< number of scan results"]
    pub number: u8,
    #[doc = "< scan sequence number, used for block scan"]
    pub scan_id: u8,
}
#[doc = " Argument structure for WIFI_EVENT_STA_CONNECTED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_connected_t {
    #[doc = "< SSID of connected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of connected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of connected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of connected AP"]
    pub channel: u8,
    #[doc = "< authentication mode used by AP"]
    pub authmode: wifi_auth_mode_t,
}
#[doc = " Argument structure for WIFI_EVENT_STA_DISCONNECTED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_disconnected_t {
    #[doc = "< SSID of disconnected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of disconnected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of disconnected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< reason of disconnection"]
    pub reason: u8,
}
#[doc = " Argument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_authmode_change_t {
    #[doc = "< the old auth mode of AP"]
    pub old_mode: wifi_auth_mode_t,
    #[doc = "< the new auth mode of AP"]
    pub new_mode: wifi_auth_mode_t,
}
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_PIN event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_sta_wps_er_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[doc = "< ESP32 WPS normal fail reason"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_NORMAL:
    wifi_event_sta_wps_fail_reason_t = 0;
#[doc = "< ESP32 WPS receive M2D frame"]
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_M2D:
    wifi_event_sta_wps_fail_reason_t = 1;
pub const wifi_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_MAX: wifi_event_sta_wps_fail_reason_t =
    2;
#[doc = " Argument structure for WIFI_EVENT_STA_WPS_ER_FAILED event"]
pub type wifi_event_sta_wps_fail_reason_t = c_types::c_uint;
#[doc = " Argument structure for WIFI_EVENT_AP_STACONNECTED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_ap_staconnected_t {
    #[doc = "< MAC address of the station connected to ESP32 soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that ESP32 soft-AP gives to the station connected to"]
    pub aid: u8,
}
#[doc = " Argument structure for WIFI_EVENT_AP_STADISCONNECTED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_ap_stadisconnected_t {
    #[doc = "< MAC address of the station disconnects to ESP32 soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that ESP32 soft-AP gave to the station disconnects to"]
    pub aid: u8,
}
#[doc = " Argument structure for WIFI_EVENT_AP_PROBEREQRECVED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_event_ap_probe_req_rx_t {
    #[doc = "< Received probe request signal strength"]
    pub rssi: c_types::c_int,
    #[doc = "< MAC address of the station which send probe request"]
    pub mac: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_ip6_addr {
    pub addr: [u32; 4usize],
    pub zone: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_ip4_addr {
    pub addr: u32,
}
pub type esp_ip4_addr_t = esp_ip4_addr;
pub type esp_ip6_addr_t = esp_ip6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ip_addr {
    pub u_addr: _ip_addr__bindgen_ty_1,
    pub type_: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ip_addr__bindgen_ty_1 {
    pub ip6: esp_ip6_addr_t,
    pub ip4: esp_ip4_addr_t,
    _bindgen_union_align: [u32; 5usize],
}
pub type esp_ip_addr_t = _ip_addr;
#[doc = " @brief Type of esp_netif_object server"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_obj {
    _unused: [u8; 0],
}
pub type esp_netif_t = esp_netif_obj;
#[doc = "< DNS main server address"]
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_MAIN: esp_netif_dns_type_t = 0;
#[doc = "< DNS backup server address (Wi-Fi STA and Ethernet only)"]
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_BACKUP: esp_netif_dns_type_t = 1;
#[doc = "< DNS fallback server address (Wi-Fi STA and Ethernet only)"]
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_FALLBACK: esp_netif_dns_type_t = 2;
pub const esp_netif_dns_type_t_ESP_NETIF_DNS_MAX: esp_netif_dns_type_t = 3;
#[doc = " @brief Type of DNS server"]
pub type esp_netif_dns_type_t = c_types::c_uint;
#[doc = " @brief DNS server info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_netif_dns_info_t {
    #[doc = "< IPV4 address of DNS server"]
    pub ip: esp_ip_addr_t,
}
#[doc = "< DHCP client/server is in initial state (not yet started)"]
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_INIT: esp_netif_dhcp_status_t = 0;
#[doc = "< DHCP client/server has been started"]
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_STARTED: esp_netif_dhcp_status_t = 1;
#[doc = "< DHCP client/server has been stopped"]
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_STOPPED: esp_netif_dhcp_status_t = 2;
pub const esp_netif_dhcp_status_t_ESP_NETIF_DHCP_STATUS_MAX: esp_netif_dhcp_status_t = 3;
#[doc = " @brief Status of DHCP client or DHCP server"]
pub type esp_netif_dhcp_status_t = c_types::c_uint;
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_START: esp_netif_dhcp_option_mode_t = 0;
#[doc = "< Set option"]
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_SET: esp_netif_dhcp_option_mode_t = 1;
#[doc = "< Get option"]
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_GET: esp_netif_dhcp_option_mode_t = 2;
pub const esp_netif_dhcp_option_mode_t_ESP_NETIF_OP_MAX: esp_netif_dhcp_option_mode_t = 3;
#[doc = " @brief Mode for DHCP client or DHCP server option functions"]
pub type esp_netif_dhcp_option_mode_t = c_types::c_uint;
#[doc = "< Domain name server"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_DOMAIN_NAME_SERVER: esp_netif_dhcp_option_id_t = 6;
#[doc = "< Solicitation router address"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_ROUTER_SOLICITATION_ADDRESS:
    esp_netif_dhcp_option_id_t = 32;
#[doc = "< Request specific IP address"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_REQUESTED_IP_ADDRESS: esp_netif_dhcp_option_id_t =
    50;
#[doc = "< Request IP address lease time"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_IP_ADDRESS_LEASE_TIME: esp_netif_dhcp_option_id_t =
    51;
#[doc = "< Request IP address retry counter"]
pub const esp_netif_dhcp_option_id_t_ESP_NETIF_IP_REQUEST_RETRY_TIME: esp_netif_dhcp_option_id_t =
    52;
#[doc = " @brief Supported options for DHCP client or DHCP server"]
pub type esp_netif_dhcp_option_id_t = c_types::c_uint;
#[doc = "< station got IP from connected AP"]
pub const ip_event_t_IP_EVENT_STA_GOT_IP: ip_event_t = 0;
#[doc = "< station lost IP and the IP is reset to 0"]
pub const ip_event_t_IP_EVENT_STA_LOST_IP: ip_event_t = 1;
#[doc = "< soft-AP assign an IP to a connected station"]
pub const ip_event_t_IP_EVENT_AP_STAIPASSIGNED: ip_event_t = 2;
#[doc = "< station or ap or ethernet interface v6IP addr is preferred"]
pub const ip_event_t_IP_EVENT_GOT_IP6: ip_event_t = 3;
#[doc = "< ethernet got IP from connected AP"]
pub const ip_event_t_IP_EVENT_ETH_GOT_IP: ip_event_t = 4;
#[doc = "< PPP interface got IP"]
pub const ip_event_t_IP_EVENT_PPP_GOT_IP: ip_event_t = 5;
#[doc = "< PPP interface lost IP"]
pub const ip_event_t_IP_EVENT_PPP_LOST_IP: ip_event_t = 6;
#[doc = " IP event declarations"]
pub type ip_event_t = c_types::c_uint;
extern "C" {
    pub static mut IP_EVENT: esp_event_base_t;
}
#[doc = " Event structure for IP_EVENT_STA_GOT_IP, IP_EVENT_ETH_GOT_IP events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_ip_info_t {
    #[doc = "< Interface IPV4 address"]
    pub ip: esp_ip4_addr_t,
    #[doc = "< Interface IPV4 netmask"]
    pub netmask: esp_ip4_addr_t,
    #[doc = "< Interface IPV4 gateway address"]
    pub gw: esp_ip4_addr_t,
}
#[doc = " @brief IPV6 IP address information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_ip6_info_t {
    #[doc = "< Interface IPV6 address"]
    pub ip: esp_ip6_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_event_got_ip_t {
    #[doc = "< Interface index for which the event is received (left for legacy compilation)"]
    pub if_index: c_types::c_int,
    #[doc = "< Pointer to corresponding esp-netif object"]
    pub esp_netif: *mut esp_netif_t,
    #[doc = "< IP address, netmask, gatway IP address"]
    pub ip_info: esp_netif_ip_info_t,
    #[doc = "< Whether the assigned IP has changed or not"]
    pub ip_changed: bool,
}
#[doc = " Event structure for IP_EVENT_GOT_IP6 event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_event_got_ip6_t {
    #[doc = "< Interface index for which the event is received (left for legacy compilation)"]
    pub if_index: c_types::c_int,
    #[doc = "< Pointer to corresponding esp-netif object"]
    pub esp_netif: *mut esp_netif_t,
    #[doc = "< IPv6 address of the interface"]
    pub ip6_info: esp_netif_ip6_info_t,
}
#[doc = " Event structure for IP_EVENT_AP_STAIPASSIGNED event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_event_ap_staipassigned_t {
    #[doc = "< IP address which was assigned to the station"]
    pub ip: esp_ip4_addr_t,
}
pub const esp_netif_flags_ESP_NETIF_DHCP_CLIENT: esp_netif_flags = 1;
pub const esp_netif_flags_ESP_NETIF_DHCP_SERVER: esp_netif_flags = 2;
pub const esp_netif_flags_ESP_NETIF_FLAG_AUTOUP: esp_netif_flags = 4;
pub const esp_netif_flags_ESP_NETIF_FLAG_GARP: esp_netif_flags = 8;
pub const esp_netif_flags_ESP_NETIF_FLAG_EVENT_IP_MODIFIED: esp_netif_flags = 16;
pub const esp_netif_flags_ESP_NETIF_FLAG_IS_PPP: esp_netif_flags = 32;
pub type esp_netif_flags = c_types::c_uint;
pub use self::esp_netif_flags as esp_netif_flags_t;
pub const esp_netif_ip_event_type_ESP_NETIF_IP_EVENT_GOT_IP: esp_netif_ip_event_type = 1;
pub const esp_netif_ip_event_type_ESP_NETIF_IP_EVENT_LOST_IP: esp_netif_ip_event_type = 2;
pub type esp_netif_ip_event_type = c_types::c_uint;
pub use self::esp_netif_ip_event_type as esp_netif_ip_event_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_inherent_config {
    #[doc = "< flags that define esp-netif behavior"]
    pub flags: esp_netif_flags_t,
    #[doc = "< initial mac address for this interface"]
    pub mac: [u8; 6usize],
    #[doc = "< initial ip address for this interface"]
    pub ip_info: *mut esp_netif_ip_info_t,
    #[doc = "< event id to be raised when interface gets an IP"]
    pub get_ip_event: u32,
    #[doc = "< event id to be raised when interface losts its IP"]
    pub lost_ip_event: u32,
    #[doc = "< string identifier of the interface"]
    pub if_key: *const c_types::c_char,
    #[doc = "< textual description of the interface"]
    pub if_desc: *const c_types::c_char,
    #[doc = "< numeric priority of this interface to become a default"]
    #[doc = "routing if (if other netifs are up)"]
    pub route_prio: c_types::c_int,
}
pub type esp_netif_inherent_config_t = esp_netif_inherent_config;
pub type esp_netif_config_t = esp_netif_config;
#[doc = " @brief  IO driver handle type"]
pub type esp_netif_iodriver_handle = *mut c_types::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_driver_base_s {
    pub post_attach: ::core::option::Option<
        unsafe extern "C" fn(netif: *mut esp_netif_t, h: esp_netif_iodriver_handle) -> esp_err_t,
    >,
    pub netif: *mut esp_netif_t,
}
pub type esp_netif_driver_base_t = esp_netif_driver_base_s;
#[doc = " @brief  Specific IO driver configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_driver_ifconfig {
    pub handle: esp_netif_iodriver_handle,
    pub transmit: ::core::option::Option<
        unsafe extern "C" fn(
            h: *mut c_types::c_void,
            buffer: *mut c_types::c_void,
            len: size_t,
        ) -> esp_err_t,
    >,
    pub driver_free_rx_buffer: ::core::option::Option<
        unsafe extern "C" fn(h: *mut c_types::c_void, buffer: *mut c_types::c_void),
    >,
}
pub type esp_netif_driver_ifconfig_t = esp_netif_driver_ifconfig;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_netstack_config {
    _unused: [u8; 0],
}
#[doc = " @brief  Specific L3 network stack configuration"]
pub type esp_netif_netstack_config_t = esp_netif_netstack_config;
#[doc = " @brief  Generic esp_netif configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_netif_config {
    pub base: *const esp_netif_inherent_config_t,
    pub driver: *const esp_netif_driver_ifconfig_t,
    pub stack: *const esp_netif_netstack_config_t,
}
#[doc = " @brief  ESP-NETIF Receive function type"]
pub type esp_netif_receive_t = ::core::option::Option<
    unsafe extern "C" fn(
        esp_netif: *mut esp_netif_t,
        buffer: *mut c_types::c_void,
        len: size_t,
        eb: *mut c_types::c_void,
    ) -> esp_err_t,
>;
extern "C" {
    pub static mut _g_esp_netif_netstack_default_eth: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static mut _g_esp_netif_netstack_default_wifi_sta: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static mut _g_esp_netif_netstack_default_wifi_ap: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static mut _g_esp_netif_netstack_default_ppp: *const esp_netif_netstack_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_sta_config: esp_netif_inherent_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_ap_config: esp_netif_inherent_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_eth_config: esp_netif_inherent_config_t;
}
extern "C" {
    pub static _g_esp_netif_inherent_ppp_config: esp_netif_inherent_config_t;
}
extern "C" {
    #[doc = " @brief  Initialize the underlying TCP/IP stack"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK on success"]
    #[doc = "         - ESP_FAIL if initializing failed"]
    #[doc = ""]
    #[doc = " @note This function should be called exactly once from application code, when the application starts up."]
    pub fn esp_netif_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinitialize the esp-netif component (and the underlying TCP/IP stack)"]
    #[doc = ""]
    #[doc = "          Note: Deinitialization is not supported yet"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_STATE if esp_netif not initialized"]
    #[doc = "         - ESP_ERR_NOT_SUPPORTED otherwise"]
    pub fn esp_netif_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Creates an instance of new esp-netif object based on provided config"]
    #[doc = ""]
    #[doc = " @param[in]     esp_netif_config pointer esp-netif configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - pointer to esp-netif object on success"]
    #[doc = "         - NULL otherwise"]
    pub fn esp_netif_new(esp_netif_config: *const esp_netif_config_t) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief   Destroys the esp_netif object"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif pointer to the object to be deleted"]
    pub fn esp_netif_destroy(esp_netif: *mut esp_netif_t);
}
extern "C" {
    #[doc = " @brief   Configures driver related options of esp_netif object"]
    #[doc = ""]
    #[doc = " @param[inout]  esp_netif pointer to the object to be configured"]
    #[doc = " @param[in]     driver_config pointer esp-netif io driver related configuration"]
    #[doc = " @return"]
    #[doc = "         - ESP_OK on success"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS if invalid parameters provided"]
    #[doc = ""]
    pub fn esp_netif_set_driver_config(
        esp_netif: *mut esp_netif_t,
        driver_config: *const esp_netif_driver_ifconfig_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Attaches esp_netif instance to the io driver handle"]
    #[doc = ""]
    #[doc = " Calling this function enables connecting specific esp_netif object"]
    #[doc = " with already initialized io driver to update esp_netif object with driver"]
    #[doc = " specific configuration (i.e. calls post_attach callback, which typically"]
    #[doc = " sets io driver callbacks to esp_netif instance and starts the driver)"]
    #[doc = ""]
    #[doc = " @param[inout]  esp_netif pointer to esp_netif object to be attached"]
    #[doc = " @param[in]  driver_handle pointer to the driver handle"]
    #[doc = " @return"]
    #[doc = "         - ESP_OK on success"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DRIVER_ATTACH_FAILED if driver's pot_attach callback failed"]
    pub fn esp_netif_attach(
        esp_netif: *mut esp_netif_t,
        driver_handle: esp_netif_iodriver_handle,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Passes the raw packets from communication media to the appropriate TCP/IP stack"]
    #[doc = ""]
    #[doc = " This function is called from the configured (peripheral) driver layer."]
    #[doc = " The data are then forwarded as frames to the TCP/IP stack."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in]  buffer Received data"]
    #[doc = " @param[in]  len Length of the data frame"]
    #[doc = " @param[in]  eb Pointer to internal buffer (used in Wi-Fi driver)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn esp_netif_receive(
        esp_netif: *mut esp_netif_t,
        buffer: *mut c_types::c_void,
        len: size_t,
        eb: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver start event"]
    #[doc = " Creates network interface, if AUTOUP enabled turns the interface on,"]
    #[doc = " if DHCPS enabled starts dhcp server"]
    #[doc = ""]
    #[doc = " @note This API can be directly used as event handler"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param base"]
    #[doc = " @param event_id"]
    #[doc = " @param data"]
    pub fn esp_netif_action_start(
        esp_netif: *mut c_types::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut c_types::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver stop event"]
    #[doc = ""]
    #[doc = " @note This API can be directly used as event handler"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param base"]
    #[doc = " @param event_id"]
    #[doc = " @param data"]
    pub fn esp_netif_action_stop(
        esp_netif: *mut c_types::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut c_types::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver connected event"]
    #[doc = ""]
    #[doc = " @note This API can be directly used as event handler"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param base"]
    #[doc = " @param event_id"]
    #[doc = " @param data"]
    pub fn esp_netif_action_connected(
        esp_netif: *mut c_types::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut c_types::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon IO driver disconnected event"]
    #[doc = ""]
    #[doc = " @note This API can be directly used as event handler"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param base"]
    #[doc = " @param event_id"]
    #[doc = " @param data"]
    pub fn esp_netif_action_disconnected(
        esp_netif: *mut c_types::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut c_types::c_void,
    );
}
extern "C" {
    #[doc = " @brief Default building block for network interface action upon network got IP event"]
    #[doc = ""]
    #[doc = " @note This API can be directly used as event handler"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param base"]
    #[doc = " @param event_id"]
    #[doc = " @param data"]
    pub fn esp_netif_action_got_ip(
        esp_netif: *mut c_types::c_void,
        base: esp_event_base_t,
        event_id: i32,
        data: *mut c_types::c_void,
    );
}
extern "C" {
    #[doc = " @brief Set the mac address for the interface instance"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in]  mac Desired mac address for the related network interface"]
    #[doc = " @return     ESP_OK"]
    pub fn esp_netif_set_mac(esp_netif: *mut esp_netif_t, mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set the hostname of an interface"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in]   hostname New hostname for the interface. Maximum length 32 bytes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK - success"]
    #[doc = "         - ESP_ERR_ESP_NETIF_IF_NOT_READY - interface status error"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS - parameter error"]
    pub fn esp_netif_set_hostname(
        esp_netif: *mut esp_netif_t,
        hostname: *const c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface hostname."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[out]   hostname Returns a pointer to the hostname. May be NULL if no hostname is set. If set non-NULL, pointer remains valid (and string may change if the hostname changes)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK - success"]
    #[doc = "         - ESP_ERR_ESP_NETIF_IF_NOT_READY - interface status error"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS - parameter error"]
    pub fn esp_netif_get_hostname(
        esp_netif: *mut esp_netif_t,
        hostname: *mut *const c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Test if supplied interface is up or down"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - true - Interface is up"]
    #[doc = "         - false - Interface is down"]
    pub fn esp_netif_is_netif_up(esp_netif: *mut esp_netif_t) -> bool;
}
extern "C" {
    #[doc = " @brief  Get interface's IP address information"]
    #[doc = ""]
    #[doc = " If the interface is up, IP information is read directly from the TCP/IP stack."]
    #[doc = " If the interface is down, IP information is read from a copy kept in the ESP-NETIF instance"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[out]  ip_info If successful, IP information will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_get_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *mut esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface's old IP information"]
    #[doc = ""]
    #[doc = " Returns an \"old\" IP address previously stored for the interface when the valid IP changed."]
    #[doc = ""]
    #[doc = " If the IP lost timer has expired (meaning the interface was down for longer than the configured interval)"]
    #[doc = " then the old IP information will be zero."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[out]  ip_info If successful, IP information will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_get_old_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *mut esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface's IP address information"]
    #[doc = ""]
    #[doc = " This function is mainly used to set a static IP on an interface."]
    #[doc = ""]
    #[doc = " If the interface is up, the new IP information is set directly in the TCP/IP stack."]
    #[doc = ""]
    #[doc = " The copy of IP information kept in the ESP-NETIF instance is also updated (this"]
    #[doc = " copy is returned if the IP is queried while the interface is still down.)"]
    #[doc = ""]
    #[doc = " @note DHCP client/server must be stopped (if enabled for this interface) before setting new IP information."]
    #[doc = ""]
    #[doc = " @note Calling this interface for may generate a SYSTEM_EVENT_STA_GOT_IP or SYSTEM_EVENT_ETH_GOT_IP event."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in] ip_info IP information to set on the specified interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    #[doc = "      - ESP_ERR_ESP_NETIF_DHCP_NOT_STOPPED If DHCP server or client is still running"]
    pub fn esp_netif_set_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *const esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface old IP information"]
    #[doc = ""]
    #[doc = " This function is called from the DHCP client (if enabled), before a new IP is set."]
    #[doc = " It is also called from the default handlers for the SYSTEM_EVENT_STA_CONNECTED and SYSTEM_EVENT_ETH_CONNECTED events."]
    #[doc = ""]
    #[doc = " Calling this function stores the previously configured IP, which can be used to determine if the IP changes in the future."]
    #[doc = ""]
    #[doc = " If the interface is disconnected or down for too long, the \"IP lost timer\" will expire (after the configured interval) and set the old IP information to zero."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in]  ip_info Store the old IP information for the specified interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_set_old_ip_info(
        esp_netif: *mut esp_netif_t,
        ip_info: *const esp_netif_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get net interface index from network stack implementation"]
    #[doc = ""]
    #[doc = " @note This index could be used in `setsockopt()` to bind socket with multicast interface"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         implementation specific index of interface represented with supplied esp_netif"]
    pub fn esp_netif_get_netif_impl_index(esp_netif: *mut esp_netif_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP server option"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in] opt_op ESP_NETIF_OP_SET to set an option, ESP_NETIF_OP_GET to get an option."]
    #[doc = " @param[in] opt_id Option index to get or set, must be one of the supported enum values."]
    #[doc = " @param[inout] opt_val Pointer to the option parameter."]
    #[doc = " @param[in] opt_len Length of the option parameter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED"]
    pub fn esp_netif_dhcps_option(
        esp_netif: *mut esp_netif_t,
        opt_op: esp_netif_dhcp_option_mode_t,
        opt_id: esp_netif_dhcp_option_id_t,
        opt_val: *mut c_types::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP client option"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in] opt_op ESP_NETIF_OP_SET to set an option, ESP_NETIF_OP_GET to get an option."]
    #[doc = " @param[in] opt_id Option index to get or set, must be one of the supported enum values."]
    #[doc = " @param[inout] opt_val Pointer to the option parameter."]
    #[doc = " @param[in] opt_len Length of the option parameter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED"]
    pub fn esp_netif_dhcpc_option(
        esp_netif: *mut esp_netif_t,
        opt_op: esp_netif_dhcp_option_mode_t,
        opt_id: esp_netif_dhcp_option_id_t,
        opt_val: *mut c_types::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start DHCP client (only if enabled in interface object)"]
    #[doc = ""]
    #[doc = " @note The default event handlers for the SYSTEM_EVENT_STA_CONNECTED and SYSTEM_EVENT_ETH_CONNECTED events call this function."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DHCPC_START_FAILED"]
    pub fn esp_netif_dhcpc_start(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP client (only if enabled in interface object)"]
    #[doc = ""]
    #[doc = " @note Calling action_netif_stop() will also stop the DHCP Client if it is running."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    #[doc = "      - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED"]
    #[doc = "      - ESP_ERR_ESP_NETIF_IF_NOT_READY"]
    pub fn esp_netif_dhcpc_stop(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP client status"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[out] status If successful, the status of DHCP client will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn esp_netif_dhcpc_get_status(
        esp_netif: *mut esp_netif_t,
        status: *mut esp_netif_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP Server status"]
    #[doc = ""]
    #[doc = " @param[in]   esp_netif Handle to esp-netif instance"]
    #[doc = " @param[out]  status If successful, the status of the DHCP server will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn esp_netif_dhcps_get_status(
        esp_netif: *mut esp_netif_t,
        status: *mut esp_netif_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start DHCP server (only if enabled in interface object)"]
    #[doc = ""]
    #[doc = " @param[in]   esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STARTED"]
    pub fn esp_netif_dhcps_start(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP server (only if enabled in interface object)"]
    #[doc = ""]
    #[doc = " @param[in]   esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    #[doc = "      - ESP_ERR_ESP_NETIF_DHCP_ALREADY_STOPPED"]
    #[doc = "      - ESP_ERR_ESP_NETIF_IF_NOT_READY"]
    pub fn esp_netif_dhcps_stop(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set DNS Server information"]
    #[doc = ""]
    #[doc = " This function behaves differently if DHCP server or client is enabled"]
    #[doc = ""]
    #[doc = "   If DHCP client is enabled, main and backup DNS servers will be updated automatically"]
    #[doc = "   from the DHCP lease if the relevant DHCP options are set. Fallback DNS Server is never updated from the DHCP lease"]
    #[doc = "   and is designed to be set via this API."]
    #[doc = "   If DHCP client is disabled, all DNS server types can be set via this API only."]
    #[doc = ""]
    #[doc = "   If DHCP server is enabled, the Main DNS Server setting is used by the DHCP server to provide a DNS Server option"]
    #[doc = "   to DHCP clients (Wi-Fi stations)."]
    #[doc = "   - The default Main DNS server is typically the IP of the Wi-Fi AP interface itself."]
    #[doc = "   - This function can override it by setting server type ESP_NETIF_DNS_MAIN."]
    #[doc = "   - Other DNS Server types are not supported for the Wi-Fi AP interface."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in]  type Type of DNS Server to set: ESP_NETIF_DNS_MAIN, ESP_NETIF_DNS_BACKUP, ESP_NETIF_DNS_FALLBACK"]
    #[doc = " @param[in]  dns  DNS Server address to set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_ESP_NETIF_INVALID_PARAMS invalid params"]
    pub fn esp_netif_set_dns_info(
        esp_netif: *mut esp_netif_t,
        type_: esp_netif_dns_type_t,
        dns: *mut esp_netif_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DNS Server information"]
    #[doc = ""]
    #[doc = " Return the currently configured DNS Server address for the specified interface and Server type."]
    #[doc = ""]
    #[doc = " This may be result of a previous call to esp_netif_set_dns_info(). If the interface's DHCP client is enabled,"]
    #[doc = " the Main or Backup DNS Server may be set by the current DHCP lease."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[in]  type Type of DNS Server to get: ESP_NETIF_DNS_MAIN, ESP_NETIF_DNS_BACKUP, ESP_NETIF_DNS_FALLBACK"]
    #[doc = " @param[out] dns  DNS Server result is written here on success"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_ESP_NETIF_INVALID_PARAMS invalid params"]
    pub fn esp_netif_get_dns_info(
        esp_netif: *mut esp_netif_t,
        type_: esp_netif_dns_type_t,
        dns: *mut esp_netif_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Create interface link-local IPv6 address"]
    #[doc = ""]
    #[doc = " Cause the TCP/IP stack to create a link-local IPv6 address for the specified interface."]
    #[doc = ""]
    #[doc = " This function also registers a callback for the specified interface, so that if the link-local address becomes"]
    #[doc = " verified as the preferred address then a SYSTEM_EVENT_GOT_IP6 event will be sent."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_ESP_NETIF_INVALID_PARAMS"]
    pub fn esp_netif_create_ip6_linklocal(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface link-local IPv6 address"]
    #[doc = ""]
    #[doc = " If the specified interface is up and a preferred link-local IPv6 address"]
    #[doc = " has been created for the interface, return a copy of it."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[out] if_ip6 IPv6 information will be returned in this argument if successful."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_FAIL If interface is down, does not have a link-local IPv6 address,"]
    #[doc = "        or the link-local IPv6 address is not a preferred address."]
    pub fn esp_netif_get_ip6_linklocal(
        esp_netif: *mut esp_netif_t,
        if_ip6: *mut esp_ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface global IPv6 address"]
    #[doc = ""]
    #[doc = " If the specified interface is up and a preferred global IPv6 address"]
    #[doc = " has been created for the interface, return a copy of it."]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = " @param[out] if_ip6 IPv6 information will be returned in this argument if successful."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_FAIL If interface is down, does not have a global IPv6 address,"]
    #[doc = "        or the global IPv6 address is not a preferred address."]
    pub fn esp_netif_get_ip6_global(
        esp_netif: *mut esp_netif_t,
        if_ip6: *mut esp_ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets IPv4 address to the specified octets"]
    #[doc = ""]
    #[doc = " @param[out] addr IP address to be set"]
    #[doc = " @param a the first octet (127 for IP 127.0.0.1)"]
    #[doc = " @param b"]
    #[doc = " @param c"]
    #[doc = " @param d"]
    pub fn esp_netif_set_ip4_addr(addr: *mut esp_ip4_addr_t, a: u8, b: u8, c: u8, d: u8);
}
extern "C" {
    #[doc = " @brief Converts numeric IP address into decimal dotted ASCII representation."]
    #[doc = ""]
    #[doc = " @param addr ip address in network order to convert"]
    #[doc = " @param buf target buffer where the string is stored"]
    #[doc = " @param buflen length of buf"]
    #[doc = " @return either pointer to buf which now holds the ASCII"]
    #[doc = "         representation of addr or NULL if buf was too small"]
    pub fn esp_ip4addr_ntoa(
        addr: *const esp_ip4_addr_t,
        buf: *mut c_types::c_char,
        buflen: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    #[doc = " @brief Ascii internet address interpretation routine"]
    #[doc = " The value returned is in network order."]
    #[doc = ""]
    #[doc = " @param addr IP address in ascii representation (e.g. \"127.0.0.1\")"]
    #[doc = " @return ip address in network order"]
    pub fn esp_ip4addr_aton(addr: *const c_types::c_char) -> u32;
}
extern "C" {
    #[doc = " @brief Gets media driver handle for this esp-netif instance"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return opaque pointer of related IO driver"]
    pub fn esp_netif_get_io_driver(esp_netif: *mut esp_netif_t) -> esp_netif_iodriver_handle;
}
extern "C" {
    #[doc = " @brief Searches over a list of created objects to find an instance with supplied if key"]
    #[doc = ""]
    #[doc = " @param if_key Textual description of network interface"]
    #[doc = ""]
    #[doc = " @return Handle to esp-netif instance"]
    pub fn esp_netif_get_handle_from_ifkey(if_key: *const c_types::c_char) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Returns configured flags for this interface"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return Configuration flags"]
    pub fn esp_netif_get_flags(esp_netif: *mut esp_netif_t) -> esp_netif_flags_t;
}
extern "C" {
    #[doc = " @brief Returns configured interface key for this esp-netif instance"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return Textual description of related interface"]
    pub fn esp_netif_get_ifkey(esp_netif: *mut esp_netif_t) -> *const c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns configured interface type for this esp-netif instance"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return Enumerated type of this interface, such as station, AP, ethernet"]
    pub fn esp_netif_get_desc(esp_netif: *mut esp_netif_t) -> *const c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns configured event for this esp-netif instance and supplied event type"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @param event_type (either get or lost IP)"]
    #[doc = ""]
    #[doc = " @return specific event id which is configured to be raised if the interface lost or acquired IP address"]
    #[doc = "         -1 if supplied event_type is not known"]
    pub fn esp_netif_get_event_id(
        esp_netif: *mut esp_netif_t,
        event_type: esp_netif_ip_event_type_t,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Iterates over list of interfaces. Returns first netif if NULL given as parameter"]
    #[doc = ""]
    #[doc = " @param[in]  esp_netif Handle to esp-netif instance"]
    #[doc = ""]
    #[doc = " @return First netif from the list if supplied parameter is NULL, next one otherwise"]
    pub fn esp_netif_next(esp_netif: *mut esp_netif_t) -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Returns number of registered esp_netif objects"]
    #[doc = ""]
    #[doc = " @return Number of esp_netifs"]
    pub fn esp_netif_get_nr_of_ifs() -> size_t;
}
#[doc = "< ESP32 WiFi ready"]
pub const system_event_id_t_SYSTEM_EVENT_WIFI_READY: system_event_id_t = 0;
#[doc = "< ESP32 finish scanning AP"]
pub const system_event_id_t_SYSTEM_EVENT_SCAN_DONE: system_event_id_t = 1;
#[doc = "< ESP32 station start"]
pub const system_event_id_t_SYSTEM_EVENT_STA_START: system_event_id_t = 2;
#[doc = "< ESP32 station stop"]
pub const system_event_id_t_SYSTEM_EVENT_STA_STOP: system_event_id_t = 3;
#[doc = "< ESP32 station connected to AP"]
pub const system_event_id_t_SYSTEM_EVENT_STA_CONNECTED: system_event_id_t = 4;
#[doc = "< ESP32 station disconnected from AP"]
pub const system_event_id_t_SYSTEM_EVENT_STA_DISCONNECTED: system_event_id_t = 5;
#[doc = "< the auth mode of AP connected by ESP32 station changed"]
pub const system_event_id_t_SYSTEM_EVENT_STA_AUTHMODE_CHANGE: system_event_id_t = 6;
#[doc = "< ESP32 station got IP from connected AP"]
pub const system_event_id_t_SYSTEM_EVENT_STA_GOT_IP: system_event_id_t = 7;
#[doc = "< ESP32 station lost IP and the IP is reset to 0"]
pub const system_event_id_t_SYSTEM_EVENT_STA_LOST_IP: system_event_id_t = 8;
#[doc = "< ESP32 station wps succeeds in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_SUCCESS: system_event_id_t = 9;
#[doc = "< ESP32 station wps fails in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_FAILED: system_event_id_t = 10;
#[doc = "< ESP32 station wps timeout in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_TIMEOUT: system_event_id_t = 11;
#[doc = "< ESP32 station wps pin code in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_PIN: system_event_id_t = 12;
#[doc = "< ESP32 station wps overlap in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP: system_event_id_t = 13;
#[doc = "< ESP32 soft-AP start"]
pub const system_event_id_t_SYSTEM_EVENT_AP_START: system_event_id_t = 14;
#[doc = "< ESP32 soft-AP stop"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STOP: system_event_id_t = 15;
#[doc = "< a station connected to ESP32 soft-AP"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STACONNECTED: system_event_id_t = 16;
#[doc = "< a station disconnected from ESP32 soft-AP"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STADISCONNECTED: system_event_id_t = 17;
#[doc = "< ESP32 soft-AP assign an IP to a connected station"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STAIPASSIGNED: system_event_id_t = 18;
#[doc = "< Receive probe request packet in soft-AP interface"]
pub const system_event_id_t_SYSTEM_EVENT_AP_PROBEREQRECVED: system_event_id_t = 19;
#[doc = "< ESP32 station or ap or ethernet interface v6IP addr is preferred"]
pub const system_event_id_t_SYSTEM_EVENT_GOT_IP6: system_event_id_t = 20;
#[doc = "< ESP32 ethernet start"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_START: system_event_id_t = 21;
#[doc = "< ESP32 ethernet stop"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_STOP: system_event_id_t = 22;
#[doc = "< ESP32 ethernet phy link up"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_CONNECTED: system_event_id_t = 23;
#[doc = "< ESP32 ethernet phy link down"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_DISCONNECTED: system_event_id_t = 24;
#[doc = "< ESP32 ethernet got IP from connected AP"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_GOT_IP: system_event_id_t = 25;
#[doc = "< Number of members in this enum"]
pub const system_event_id_t_SYSTEM_EVENT_MAX: system_event_id_t = 26;
#[doc = " System event types enumeration"]
pub type system_event_id_t = c_types::c_uint;
#[doc = " Argument structure of SYSTEM_EVENT_STA_WPS_ER_FAILED event"]
pub use self::wifi_event_sta_wps_fail_reason_t as system_event_sta_wps_fail_reason_t;
#[doc = " Argument structure of SYSTEM_EVENT_SCAN_DONE event"]
pub type system_event_sta_scan_done_t = wifi_event_sta_scan_done_t;
#[doc = " Argument structure of SYSTEM_EVENT_STA_CONNECTED event"]
pub type system_event_sta_connected_t = wifi_event_sta_connected_t;
#[doc = " Argument structure of SYSTEM_EVENT_STA_DISCONNECTED event"]
pub type system_event_sta_disconnected_t = wifi_event_sta_disconnected_t;
#[doc = " Argument structure of SYSTEM_EVENT_STA_AUTHMODE_CHANGE event"]
pub type system_event_sta_authmode_change_t = wifi_event_sta_authmode_change_t;
#[doc = " Argument structure of SYSTEM_EVENT_STA_WPS_ER_PIN event"]
pub type system_event_sta_wps_er_pin_t = wifi_event_sta_wps_er_pin_t;
#[doc = " Argument structure of  event"]
pub type system_event_ap_staconnected_t = wifi_event_ap_staconnected_t;
#[doc = " Argument structure of  event"]
pub type system_event_ap_stadisconnected_t = wifi_event_ap_stadisconnected_t;
#[doc = " Argument structure of  event"]
pub type system_event_ap_probe_req_rx_t = wifi_event_ap_probe_req_rx_t;
#[doc = " Argument structure of  event"]
pub type system_event_ap_staipassigned_t = ip_event_ap_staipassigned_t;
#[doc = " Argument structure of  event"]
pub type system_event_sta_got_ip_t = ip_event_got_ip_t;
#[doc = " Argument structure of  event"]
pub type system_event_got_ip6_t = ip_event_got_ip6_t;
#[doc = " Union of all possible system_event argument structures"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union system_event_info_t {
    #[doc = "< ESP32 station connected to AP"]
    pub connected: system_event_sta_connected_t,
    #[doc = "< ESP32 station disconnected to AP"]
    pub disconnected: system_event_sta_disconnected_t,
    #[doc = "< ESP32 station scan (APs) done"]
    pub scan_done: system_event_sta_scan_done_t,
    #[doc = "< the auth mode of AP ESP32 station connected to changed"]
    pub auth_change: system_event_sta_authmode_change_t,
    #[doc = "< ESP32 station got IP, first time got IP or when IP is changed"]
    pub got_ip: system_event_sta_got_ip_t,
    #[doc = "< ESP32 station WPS enrollee mode PIN code received"]
    pub sta_er_pin: system_event_sta_wps_er_pin_t,
    #[doc = "< ESP32 station WPS enrollee mode failed reason code received"]
    pub sta_er_fail_reason: system_event_sta_wps_fail_reason_t,
    #[doc = "< a station connected to ESP32 soft-AP"]
    pub sta_connected: system_event_ap_staconnected_t,
    #[doc = "< a station disconnected to ESP32 soft-AP"]
    pub sta_disconnected: system_event_ap_stadisconnected_t,
    #[doc = "< ESP32 soft-AP receive probe request packet"]
    pub ap_probereqrecved: system_event_ap_probe_req_rx_t,
    #[doc = "< ESP32 soft-AP assign an IP to the station"]
    pub ap_staipassigned: system_event_ap_staipassigned_t,
    #[doc = "< ESP32 station\u{3000}or ap or ethernet ipv6 addr state change to preferred"]
    pub got_ip6: system_event_got_ip6_t,
    _bindgen_union_align: [u32; 11usize],
}
#[doc = " Event, as a tagged enum"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_event_t {
    #[doc = "< event ID"]
    pub event_id: system_event_id_t,
    #[doc = "< event information"]
    pub event_info: system_event_info_t,
}
#[doc = " Event handler function type"]
pub type system_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut c_types::c_void,
        event_data_size: size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief  Send a event to event task"]
    #[doc = ""]
    #[doc = " @note This API is part of the legacy event system. New code should use event library API in esp_event.h"]
    #[doc = ""]
    #[doc = " Other task/modules, such as the tcpip_adapter, can call this API to send an event to event task"]
    #[doc = ""]
    #[doc = " @param event Event to send"]
    #[doc = ""]
    #[doc = " @return ESP_OK : succeed"]
    #[doc = " @return others : fail"]
    pub fn esp_event_send(event: *mut system_event_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Send a event to event task"]
    #[doc = ""]
    #[doc = " @note This API is used by WiFi Driver only."]
    #[doc = ""]
    #[doc = " Other task/modules, such as the tcpip_adapter, can call this API to send an event to event task"]
    #[doc = ""]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the event id that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[in] ticks_to_wait number of ticks to block on a full event queue"]
    #[doc = ""]
    #[doc = " @return ESP_OK : succeed"]
    #[doc = " @return others : fail"]
    pub fn esp_event_send_internal(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut c_types::c_void,
        event_data_size: size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Default event handler for system events"]
    #[doc = ""]
    #[doc = " @note This API is part of the legacy event system. New code should use event library API in esp_event.h"]
    #[doc = ""]
    #[doc = " This function performs default handling of system events."]
    #[doc = " When using esp_event_loop APIs, it is called automatically before invoking the user-provided"]
    #[doc = " callback function."]
    #[doc = ""]
    #[doc = " Applications which implement a custom event loop must call this function"]
    #[doc = " as part of event processing."]
    #[doc = ""]
    #[doc = " @param  event   pointer to event to be handled"]
    #[doc = " @return ESP_OK if an event was handled successfully"]
    pub fn esp_event_process_default(event: *mut system_event_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Install default event handlers for Ethernet interface"]
    #[doc = ""]
    #[doc = " @note This API is part of the legacy event system. New code should use event library API in esp_event.h"]
    #[doc = ""]
    pub fn esp_event_set_default_eth_handlers();
}
extern "C" {
    #[doc = " @brief  Install default event handlers for Wi-Fi interfaces (station and AP)"]
    #[doc = ""]
    #[doc = " @note This API is part of the legacy event system. New code should use event library API in esp_event.h"]
    pub fn esp_event_set_default_wifi_handlers();
}
#[doc = " @brief  Application specified event callback function"]
#[doc = ""]
#[doc = " @note This API is part of the legacy event system. New code should use event library API in esp_event.h"]
#[doc = ""]
#[doc = ""]
#[doc = " @param  ctx    reserved for user"]
#[doc = " @param  event  event type defined in this file"]
#[doc = ""]
#[doc = " @return"]
#[doc = "    - ESP_OK: succeed"]
#[doc = "    - others: fail"]
pub type system_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut c_types::c_void, event: *mut system_event_t) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief  Initialize event loop"]
    #[doc = ""]
    #[doc = " @note This API is part of the legacy event system. New code should use event library API in esp_event.h"]
    #[doc = ""]
    #[doc = " Create the event handler and task"]
    #[doc = ""]
    #[doc = " @param  cb   application specified event callback, it can be modified by call esp_event_set_cb"]
    #[doc = " @param  ctx  reserved for user"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: fail"]
    pub fn esp_event_loop_init(cb: system_event_cb_t, ctx: *mut c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set application specified event callback function"]
    #[doc = ""]
    #[doc = " @note This API is part of the legacy event system. New code should use event library API in esp_event.h"]
    #[doc = ""]
    #[doc = " @attention 1. If cb is NULL, means application don't need to handle"]
    #[doc = "               If cb is not NULL, it will be call when an event is received, after the default event callback is completed"]
    #[doc = ""]
    #[doc = " @param  cb   application callback function"]
    #[doc = " @param  ctx  argument to be passed to callback"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return old callback"]
    pub fn esp_event_loop_set_cb(
        cb: system_event_cb_t,
        ctx: *mut c_types::c_void,
    ) -> system_event_cb_t;
}
#[doc = " Configuration for creating event loops"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_event_loop_args_t {
    #[doc = "< size of the event loop queue"]
    pub queue_size: i32,
    #[doc = "< name of the event loop task; if NULL,"]
    #[doc = "a dedicated task is not created for event loop"]
    pub task_name: *const c_types::c_char,
    #[doc = "< priority of the event loop task, ignored if task name is NULL"]
    pub task_priority: UBaseType_t,
    #[doc = "< stack size of the event loop task, ignored if task name is NULL"]
    pub task_stack_size: u32,
    #[doc = "< core to which the event loop task is pinned to,"]
    #[doc = "ignored if task name is NULL"]
    pub task_core_id: BaseType_t,
}
extern "C" {
    #[doc = " @brief Create a new event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_loop_args configuration structure for the event loop to create"]
    #[doc = " @param[out] event_loop handle to the created event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - ESP_FAIL: Failed to create task loop"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_create(
        event_loop_args: *const esp_event_loop_args_t,
        event_loop: *mut esp_event_loop_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an existing event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_loop event loop to delete"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_delete(event_loop: esp_event_loop_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create default event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - ESP_FAIL: Failed to create task loop"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_create_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the default event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_delete_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dispatch events posted to an event loop."]
    #[doc = ""]
    #[doc = " This function is used to dispatch events posted to a loop with no dedicated task, i.e task name was set to NULL"]
    #[doc = " in event_loop_args argument during loop creation. This function includes an argument to limit the amount of time"]
    #[doc = " it runs, returning control to the caller when that time expires (or some time afterwards). There is no guarantee"]
    #[doc = " that a call to this function will exit at exactly the time of expiry. There is also no guarantee that events have"]
    #[doc = " been dispatched during the call, as the function might have spent all of the alloted time waiting on the event queue."]
    #[doc = " Once an event has been unqueued, however, it is guaranteed to be dispatched. This guarantee contributes to not being"]
    #[doc = " able to exit exactly at time of expiry as (1) blocking on internal mutexes is necessary for dispatching the unqueued"]
    #[doc = " event, and (2) during  dispatch of the unqueued event there is no way to control the time occupied by handler code"]
    #[doc = " execution. The guaranteed time of exit is therefore the alloted time + amount of time required to dispatch"]
    #[doc = " the last unqueued event."]
    #[doc = ""]
    #[doc = " In cases where waiting on the queue times out, ESP_OK is returned and not ESP_ERR_TIMEOUT, since it is"]
    #[doc = " normal behavior."]
    #[doc = ""]
    #[doc = " @param[in] event_loop event loop to dispatch posted events from"]
    #[doc = " @param[in] ticks_to_run number of ticks to run the loop"]
    #[doc = ""]
    #[doc = " @note encountering an unknown event that has been posted to the loop will only generate a warning, not an error."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_run(
        event_loop: esp_event_loop_handle_t,
        ticks_to_run: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to the system event loop."]
    #[doc = ""]
    #[doc = " This function can be used to register a handler for either: (1) specific events,"]
    #[doc = " (2) all events of a certain event base, or (3) all events known by the system event loop."]
    #[doc = ""]
    #[doc = "  - specific events: specify exact event_base and event_id"]
    #[doc = "  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id"]
    #[doc = "  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id"]
    #[doc = ""]
    #[doc = " Registering multiple handlers to events is possible. Registering a single handler to multiple events is"]
    #[doc = " also possible. However, registering the same handler to the same event multiple times would cause the"]
    #[doc = " previous registrations to be overwritten."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base id of the event to register the handler for"]
    #[doc = " @param[in] event_id the id of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to a specific loop."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_handler_register, except the additional"]
    #[doc = " specification of the event loop to register the handler to."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to register this handler function to"]
    #[doc = " @param[in] event_base the base id of the event to register the handler for"]
    #[doc = " @param[in] event_id the id of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop."]
    #[doc = ""]
    #[doc = " This function can be used to unregister a handler so that it no longer gets called during dispatch."]
    #[doc = " Handlers can be unregistered for either: (1) specific events, (2) all events of a certain event base,"]
    #[doc = " or (3) all events known by the system event loop"]
    #[doc = ""]
    #[doc = "  - specific events: specify exact event_base and event_id"]
    #[doc = "  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id"]
    #[doc = "  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id"]
    #[doc = ""]
    #[doc = " This function ignores unregistration of handlers that has not been previously registered."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the id of the event with which to unregister the handler"]
    #[doc = " @param[in] event_handler the handler to unregister"]
    #[doc = ""]
    #[doc = " @return ESP_OK success"]
    #[doc = " @return ESP_ERR_INVALID_ARG invalid combination of event base and event id"]
    #[doc = " @return others fail"]
    pub fn esp_event_handler_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_handler_unregister, except the additional specification of"]
    #[doc = " the event loop to unregister the handler with."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop with which to unregister this handler function"]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the id of the event with which to unregister the handler"]
    #[doc = " @param[in] event_handler the handler to unregister"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the system default event loop. The event loop library keeps a copy of event_data and manages"]
    #[doc = " the copy's lifetime automatically (allocation + deletion); this ensures that the data the"]
    #[doc = " handler recieves is always valid."]
    #[doc = ""]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the event id that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[in] ticks_to_wait number of ticks to block on a full event queue"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,"]
    #[doc = "                      queue full when posting from ISR"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut c_types::c_void,
        event_data_size: size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the specified event loop. The event loop library keeps a copy of event_data and manages"]
    #[doc = " the copy's lifetime automatically (allocation + deletion); this ensures that the data the"]
    #[doc = " handler recieves is always valid."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_post_to, except the additional specification of the event loop"]
    #[doc = " to post the event to."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to post to"]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the event id that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[in] ticks_to_wait number of ticks to block on a full event queue"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired,"]
    #[doc = "                      queue full when posting from ISR"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut c_types::c_void,
        event_data_size: size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dumps statistics of all event loops."]
    #[doc = ""]
    #[doc = " Dumps event loop info in the format:"]
    #[doc = ""]
    #[doc = "@verbatim"]
    #[doc = "event loop"]
    #[doc = "handler"]
    #[doc = "handler"]
    #[doc = "..."]
    #[doc = "event loop"]
    #[doc = "handler"]
    #[doc = "handler"]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "where:"]
    #[doc = ""]
    #[doc = "event loop"]
    #[doc = "format: address,name rx:total_recieved dr:total_dropped"]
    #[doc = "where:"]
    #[doc = "address - memory address of the event loop"]
    #[doc = "name - name of the event loop, 'none' if no dedicated task"]
    #[doc = "total_recieved - number of successfully posted events"]
    #[doc = "total_dropped - number of events unsuccessfully posted due to queue being full"]
    #[doc = ""]
    #[doc = "handler"]
    #[doc = "format: address ev:base,id inv:total_invoked run:total_runtime"]
    #[doc = "where:"]
    #[doc = "address - address of the handler function"]
    #[doc = "base,id - the event specified by event base and id this handler executes"]
    #[doc = "total_invoked - number of times this handler has been invoked"]
    #[doc = "total_runtime - total amount of time used for invoking this handler"]
    #[doc = ""]
    #[doc = "@endverbatim"]
    #[doc = ""]
    #[doc = " @param[in] file the file stream to output to"]
    #[doc = ""]
    #[doc = " @note this function is a noop when CONFIG_ESP_EVENT_LOOP_PROFILING is disabled"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_dump(file: *mut FILE) -> esp_err_t;
}
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_MD5: esp_crypto_hash_alg_t = 0;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA1: esp_crypto_hash_alg_t = 1;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_MD5: esp_crypto_hash_alg_t = 2;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA1: esp_crypto_hash_alg_t = 3;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA256: esp_crypto_hash_alg_t = 4;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA256: esp_crypto_hash_alg_t = 5;
pub type esp_crypto_hash_alg_t = c_types::c_uint;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_NULL: esp_crypto_cipher_alg_t = 0;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_AES: esp_crypto_cipher_alg_t = 1;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_3DES: esp_crypto_cipher_alg_t = 2;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_DES: esp_crypto_cipher_alg_t = 3;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC2: esp_crypto_cipher_alg_t = 4;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC4: esp_crypto_cipher_alg_t = 5;
pub type esp_crypto_cipher_alg_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_hash {
    _unused: [u8; 0],
}
pub type esp_crypto_hash_t = crypto_hash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_cipher {
    _unused: [u8; 0],
}
pub type esp_crypto_cipher_t = crypto_cipher;
#[doc = " @brief The AES callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Encryption key."]
#[doc = " @param iv  Encryption IV for CBC mode (16 bytes)."]
#[doc = " @param data  Data to encrypt in-place."]
#[doc = " @param data_len  Length of data in bytes (must be divisible by 16)"]
pub type esp_aes_128_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        iv: *const c_types::c_uchar,
        data: *mut c_types::c_uchar,
        data_len: c_types::c_int,
    ) -> c_types::c_int,
>;
#[doc = " @brief The AES callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Decryption key."]
#[doc = " @param iv  Decryption IV for CBC mode (16 bytes)."]
#[doc = " @param data  Data to decrypt in-place."]
#[doc = " @param data_len  Length of data in bytes (must be divisible by 16)"]
#[doc = ""]
pub type esp_aes_128_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        iv: *const c_types::c_uchar,
        data: *mut c_types::c_uchar,
        data_len: c_types::c_int,
    ) -> c_types::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param kek  16-octet Key encryption key (KEK)."]
#[doc = " @param n  Length of the plaintext key in 64-bit units;"]
#[doc = " @param plain  Plaintext key to be wrapped, n * 64 bits"]
#[doc = " @param cipher  Wrapped key, (n + 1) * 64 bits"]
#[doc = ""]
pub type esp_aes_wrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const c_types::c_uchar,
        n: c_types::c_int,
        plain: *const c_types::c_uchar,
        cipher: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param kek  16-octet Key decryption key (KEK)."]
#[doc = " @param n  Length of the plaintext key in 64-bit units;"]
#[doc = " @param cipher  Wrapped key to be unwrapped, (n + 1) * 64 bits"]
#[doc = " @param plain  Plaintext key, n * 64 bits"]
#[doc = ""]
pub type esp_aes_unwrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const c_types::c_uchar,
        n: c_types::c_int,
        cipher: *const c_types::c_uchar,
        plain: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief The SHA256 callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Key for HMAC operations."]
#[doc = " @param key_len  Length of the key in bytes."]
#[doc = " @param num_elem  Number of elements in the data vector."]
#[doc = " @param addr  Pointers to the data areas."]
#[doc = " @param len  Lengths of the data blocks."]
#[doc = " @param mac  Buffer for the hash (32 bytes)."]
#[doc = ""]
pub type esp_hmac_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        key_len: c_types::c_int,
        num_elem: c_types::c_int,
        addr: *mut *const c_types::c_uchar,
        len: *const c_types::c_int,
        mac: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param key  Key for PRF."]
#[doc = " @param key_len  Length of the key in bytes."]
#[doc = " @param label  A unique label for each purpose of the PRF."]
#[doc = " @param data  Extra data to bind into the key."]
#[doc = " @param data_len  Length of the data."]
#[doc = " @param buf  Buffer for the generated pseudo-random key."]
#[doc = " @param buf_len  Number of bytes of key to generate."]
#[doc = ""]
pub type esp_sha256_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        key_len: c_types::c_int,
        label: *const c_types::c_char,
        data: *const c_types::c_uchar,
        data_len: c_types::c_int,
        buf: *mut c_types::c_uchar,
        buf_len: c_types::c_int,
    ) -> c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 over data buffer (RFC 2104)'"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @data: Pointers to the data area"]
#[doc = " @data_len: Length of the data area"]
#[doc = " @mac: Buffer for the hash (16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        key_len: c_types::c_uint,
        data: *const c_types::c_uchar,
        data_len: c_types::c_uint,
        mac: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief HMAC-MD5 over data vector (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash (16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        key_len: c_types::c_uint,
        num_elem: c_types::c_uint,
        addr: *mut *const c_types::c_uchar,
        len: *const c_types::c_uint,
        mac: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data buffer (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @data: Pointers to the data area"]
#[doc = " @data_len: Length of the data area"]
#[doc = " @mac: Buffer for the hash (20 bytes)"]
#[doc = " Returns: 0 on success, -1 of failure"]
pub type esp_hmac_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        key_len: c_types::c_uint,
        data: *const c_types::c_uchar,
        data_len: c_types::c_uint,
        mac: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data vector (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash (20 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        key_len: c_types::c_uint,
        num_elem: c_types::c_uint,
        addr: *mut *const c_types::c_uchar,
        len: *const c_types::c_uint,
        mac: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1)"]
#[doc = ""]
#[doc = " @key: Key for PRF"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @label: A unique label for each purpose of the PRF"]
#[doc = " @data: Extra data to bind into the key"]
#[doc = " @data_len: Length of the data"]
#[doc = " @buf: Buffer for the generated pseudo-random key"]
#[doc = " @buf_len: Number of bytes of key to generate"]
#[doc = " Returns: 0 on success, -1 of failure"]
#[doc = ""]
#[doc = " This function is used to derive new, cryptographically separate keys from a"]
#[doc = " given key (e.g., PMK in IEEE 802.11i)."]
pub type esp_sha1_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        key_len: c_types::c_uint,
        label: *const c_types::c_char,
        data: *const c_types::c_uchar,
        data_len: c_types::c_uint,
        buf: *mut c_types::c_uchar,
        buf_len: c_types::c_uint,
    ) -> c_types::c_int,
>;
#[doc = " @brief SHA-1 hash for data vector"]
#[doc = ""]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: c_types::c_uint,
        addr: *mut *const c_types::c_uchar,
        len: *const c_types::c_uint,
        mac: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief SHA1-based key derivation function (PBKDF2) for IEEE 802.11i"]
#[doc = ""]
#[doc = " @passphrase: ASCII passphrase"]
#[doc = " @ssid: SSID"]
#[doc = " @ssid_len: SSID length in bytes"]
#[doc = " @iterations: Number of iterations to run"]
#[doc = " @buf: Buffer for the generated key"]
#[doc = " @buflen: Length of the buffer in bytes"]
#[doc = " Returns: 0 on success, -1 of failure"]
#[doc = ""]
#[doc = " This function is used to derive PSK for WPA-PSK. For this protocol,"]
#[doc = " iterations is set to 4096 and buflen to 32. This function is described in"]
#[doc = " IEEE Std 802.11-2004, Clause H.4. The main construction is from PKCS#5 v2.0."]
pub type esp_pbkdf2_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        passphrase: *const c_types::c_char,
        ssid: *const c_types::c_char,
        ssid_len: c_types::c_uint,
        iterations: c_types::c_int,
        buf: *mut c_types::c_uchar,
        buflen: c_types::c_uint,
    ) -> c_types::c_int,
>;
#[doc = " @brief XOR RC4 stream to given data with skip-stream-start"]
#[doc = ""]
#[doc = " @key: RC4 key"]
#[doc = " @keylen: RC4 key length"]
#[doc = " @skip: number of bytes to skip from the beginning of the RC4 stream"]
#[doc = " @data: data to be XOR'ed with RC4 stream"]
#[doc = " @data_len: buf length"]
#[doc = " Returns: 0 on success, -1 on failure"]
#[doc = ""]
#[doc = " Generate RC4 pseudo random stream for the given key, skip beginning of the"]
#[doc = " stream, and XOR the end result with the data buffer to perform RC4"]
#[doc = " encryption/decryption."]
pub type esp_rc4_skip_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        keylen: c_types::c_uint,
        skip: c_types::c_uint,
        data: *mut c_types::c_uchar,
        data_len: c_types::c_uint,
    ) -> c_types::c_int,
>;
#[doc = " @brief MD5 hash for data vector"]
#[doc = ""]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: c_types::c_uint,
        addr: *mut *const c_types::c_uchar,
        len: *const c_types::c_uint,
        mac: *mut c_types::c_uchar,
    ) -> c_types::c_int,
>;
#[doc = " @brief Encrypt one AES block"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
#[doc = " @plain: Plaintext data to be encrypted (16 bytes)"]
#[doc = " @crypt: Buffer for the encrypted data (16 bytes)"]
pub type esp_aes_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut c_types::c_void,
        plain: *const c_types::c_uchar,
        crypt: *mut c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for encryption"]
#[doc = ""]
#[doc = " @key: Encryption key"]
#[doc = " @len: Key length in bytes (usually 16, i.e., 128 bits)"]
#[doc = " Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_encrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        len: c_types::c_uint,
    ) -> *mut c_types::c_void,
>;
#[doc = " @brief Deinitialize AES encryption"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_encrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut c_types::c_void)>;
#[doc = " @brief Decrypt one AES block"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
#[doc = " @crypt: Encrypted data (16 bytes)"]
#[doc = " @plain: Buffer for the decrypted data (16 bytes)"]
pub type esp_aes_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut c_types::c_void,
        crypt: *const c_types::c_uchar,
        plain: *mut c_types::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for decryption"]
#[doc = ""]
#[doc = " @key: Decryption key"]
#[doc = " @len: Key length in bytes (usually 16, i.e., 128 bits)"]
#[doc = " Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_decrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const c_types::c_uchar,
        len: c_types::c_uint,
    ) -> *mut c_types::c_void,
>;
#[doc = " @brief Deinitialize AES decryption"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_decrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut c_types::c_void)>;
#[doc = " @brief One-Key CBC MAC (OMAC1) hash with AES-128 for MIC computation"]
#[doc = ""]
#[doc = " @key: 128-bit key for the hash operation"]
#[doc = " @data: Data buffer for which a MIC is computed"]
#[doc = " @data_len: Length of data buffer in bytes"]
#[doc = " @mic: Buffer for MIC (128 bits, i.e., 16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_omac1_aes_128_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const u8,
        data: *const u8,
        data_len: size_t,
        mic: *mut u8,
    ) -> c_types::c_int,
>;
#[doc = " @brief Decrypt data using CCMP (Counter Mode CBC-MAC Protocol OR"]
#[doc = "        Counter Mode Cipher Block Chaining Message Authentication"]
#[doc = "        Code Protocol) which is used in IEEE 802.11i RSN standard."]
#[doc = " @tk: 128-bit Temporal Key for obtained during 4-way handshake"]
#[doc = " @hdr: Pointer to IEEE802.11 frame headeri needed for AAD"]
#[doc = " @data: Pointer to encrypted data buffer"]
#[doc = " @data_len: Encrypted data length in bytes"]
#[doc = " @decrypted_len: Length of decrypted data"]
#[doc = " Returns: Pointer to decrypted data on success, NULL on failure"]
pub type esp_ccmp_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        ieee80211_hdr: *const u8,
        data: *const u8,
        data_len: size_t,
        decrypted_len: *mut size_t,
    ) -> *mut u8,
>;
#[doc = " @brief Encrypt data using CCMP (Counter Mode CBC-MAC Protocol OR"]
#[doc = "        Counter Mode Cipher Block Chaining Message Authentication"]
#[doc = "        Code Protocol) which is used in IEEE 802.11i RSN standard."]
#[doc = " @tk: 128-bit Temporal Key for obtained during 4-way handshake"]
#[doc = " @frame: Pointer to IEEE802.11 frame including header"]
#[doc = " @len: Length of the frame including header"]
#[doc = " @hdrlen: Length of the header"]
#[doc = " @pn: Packet Number counter"]
#[doc = " @keyid: Key ID to be mentioned in CCMP Vector"]
#[doc = " @encrypted_len: Length of the encrypted frame including header"]
pub type esp_ccmp_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        tk: *const u8,
        frame: *mut u8,
        len: size_t,
        hdrlen: size_t,
        pn: *mut u8,
        keyid: c_types::c_int,
        encrypted_len: *mut size_t,
    ) -> *mut u8,
>;
#[doc = " @brief The crypto callback function structure used when do station security connect."]
#[doc = "        The structure can be set as software crypto or the crypto optimized by ESP32"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpa_crypto_funcs_t {
    pub size: u32,
    pub version: u32,
    #[doc = "< station connect function used when send EAPOL frame"]
    pub aes_wrap: esp_aes_wrap_t,
    #[doc = "< station connect function used when decrypt key data"]
    pub aes_unwrap: esp_aes_unwrap_t,
    #[doc = "< station connect function used when check MIC"]
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    #[doc = "< station connect function used when check MIC"]
    pub sha256_prf: esp_sha256_prf_t,
    pub hmac_md5: esp_hmac_md5_t,
    pub hamc_md5_vector: esp_hmac_md5_vector_t,
    pub hmac_sha1: esp_hmac_sha1_t,
    pub hmac_sha1_vector: esp_hmac_sha1_vector_t,
    pub sha1_prf: esp_sha1_prf_t,
    pub sha1_vector: esp_sha1_vector_t,
    pub pbkdf2_sha1: esp_pbkdf2_sha1_t,
    pub rc4_skip: esp_rc4_skip_t,
    pub md5_vector: esp_md5_vector_t,
    pub aes_encrypt: esp_aes_encrypt_t,
    pub aes_encrypt_init: esp_aes_encrypt_init_t,
    pub aes_encrypt_deinit: esp_aes_encrypt_deinit_t,
    pub aes_decrypt: esp_aes_decrypt_t,
    pub aes_decrypt_init: esp_aes_decrypt_init_t,
    pub aes_decrypt_deinit: esp_aes_decrypt_deinit_t,
    pub omac1_aes_128: esp_omac1_aes_128_t,
    pub ccmp_decrypt: esp_ccmp_decrypt_t,
    pub ccmp_encrypt: esp_ccmp_encrypt_t,
}
#[doc = " @brief The crypto callback function structure used in mesh vendor IE encryption. The"]
#[doc = "        structure can be set as software crypto or the crypto optimized by ESP32"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_crypto_funcs_t {
    #[doc = "< function used in mesh vendor IE encryption"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< function used in mesh vendor IE decryption"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_osi_funcs_t {
    pub _version: i32,
    pub _set_isr: ::core::option::Option<
        unsafe extern "C" fn(n: i32, f: *mut c_types::c_void, arg: *mut c_types::c_void),
    >,
    pub _ints_on: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _ints_off: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _spin_lock_create: ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub _spin_lock_delete: ::core::option::Option<unsafe extern "C" fn(lock: *mut c_types::c_void)>,
    pub _wifi_int_disable:
        ::core::option::Option<unsafe extern "C" fn(wifi_int_mux: *mut c_types::c_void) -> u32>,
    pub _wifi_int_restore:
        ::core::option::Option<unsafe extern "C" fn(wifi_int_mux: *mut c_types::c_void, tmp: u32)>,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create:
        ::core::option::Option<unsafe extern "C" fn(max: u32, init: u32) -> *mut c_types::c_void>,
    pub _semphr_delete: ::core::option::Option<unsafe extern "C" fn(semphr: *mut c_types::c_void)>,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut c_types::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut c_types::c_void) -> i32>,
    pub _wifi_thread_semphr_get:
        ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub _mutex_create: ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub _recursive_mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub _mutex_delete: ::core::option::Option<unsafe extern "C" fn(mutex: *mut c_types::c_void)>,
    pub _mutex_lock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut c_types::c_void) -> i32>,
    pub _mutex_unlock:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut c_types::c_void) -> i32>,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut c_types::c_void,
    >,
    pub _queue_delete: ::core::option::Option<unsafe extern "C" fn(queue: *mut c_types::c_void)>,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut c_types::c_void,
            item: *mut c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut c_types::c_void,
            item: *mut c_types::c_void,
            hptw: *mut c_types::c_void,
        ) -> i32,
    >,
    pub _queue_send_to_back: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut c_types::c_void,
            item: *mut c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_to_front: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut c_types::c_void,
            item: *mut c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut c_types::c_void,
            item: *mut c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_msg_waiting:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut c_types::c_void) -> u32>,
    pub _event_group_create: ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub _event_group_delete:
        ::core::option::Option<unsafe extern "C" fn(event: *mut c_types::c_void)>,
    pub _event_group_set_bits:
        ::core::option::Option<unsafe extern "C" fn(event: *mut c_types::c_void, bits: u32) -> u32>,
    pub _event_group_clear_bits:
        ::core::option::Option<unsafe extern "C" fn(event: *mut c_types::c_void, bits: u32) -> u32>,
    pub _event_group_wait_bits: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut c_types::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: i32,
            wait_for_all_bits: i32,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _task_create_pinned_to_core: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut c_types::c_void,
            name: *const c_types::c_char,
            stack_depth: u32,
            param: *mut c_types::c_void,
            prio: u32,
            task_handle: *mut c_types::c_void,
            core_id: u32,
        ) -> i32,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut c_types::c_void,
            name: *const c_types::c_char,
            stack_depth: u32,
            param: *mut c_types::c_void,
            prio: u32,
            task_handle: *mut c_types::c_void,
        ) -> i32,
    >,
    pub _task_delete:
        ::core::option::Option<unsafe extern "C" fn(task_handle: *mut c_types::c_void)>,
    pub _task_delay: ::core::option::Option<unsafe extern "C" fn(tick: u32)>,
    pub _task_ms_to_tick: ::core::option::Option<unsafe extern "C" fn(ms: u32) -> i32>,
    pub _task_get_current_task:
        ::core::option::Option<unsafe extern "C" fn() -> *mut c_types::c_void>,
    pub _task_get_max_priority: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc: ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut c_types::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut c_types::c_void)>,
    pub _event_post: ::core::option::Option<
        unsafe extern "C" fn(
            event_base: *const c_types::c_char,
            event_id: i32,
            event_data: *mut c_types::c_void,
            event_data_size: size_t,
            ticks_to_wait: u32,
        ) -> i32,
    >,
    pub _get_free_heap_size: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _rand: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _dport_access_stall_other_cpu_start_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _dport_access_stall_other_cpu_end_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_rf_deinit: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _phy_load_cal_and_init: ::core::option::Option<unsafe extern "C" fn(module: u32)>,
    pub _read_mac: ::core::option::Option<unsafe extern "C" fn(mac: *mut u8, type_: u32) -> i32>,
    pub _timer_arm: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut c_types::c_void, tmout: u32, repeat: bool),
    >,
    pub _timer_disarm: ::core::option::Option<unsafe extern "C" fn(timer: *mut c_types::c_void)>,
    pub _timer_done: ::core::option::Option<unsafe extern "C" fn(ptimer: *mut c_types::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut c_types::c_void,
            pfunction: *mut c_types::c_void,
            parg: *mut c_types::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut c_types::c_void, us: u32, repeat: bool),
    >,
    pub _periph_module_enable: ::core::option::Option<unsafe extern "C" fn(periph: u32)>,
    pub _periph_module_disable: ::core::option::Option<unsafe extern "C" fn(periph: u32)>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _nvs_set_i8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const c_types::c_char, value: i8) -> i32,
    >,
    pub _nvs_get_i8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const c_types::c_char, out_value: *mut i8) -> i32,
    >,
    pub _nvs_set_u8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const c_types::c_char, value: u8) -> i32,
    >,
    pub _nvs_get_u8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const c_types::c_char, out_value: *mut u8) -> i32,
    >,
    pub _nvs_set_u16: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const c_types::c_char, value: u16) -> i32,
    >,
    pub _nvs_get_u16: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const c_types::c_char, out_value: *mut u16) -> i32,
    >,
    pub _nvs_open: ::core::option::Option<
        unsafe extern "C" fn(
            name: *const c_types::c_char,
            open_mode: u32,
            out_handle: *mut u32,
        ) -> i32,
    >,
    pub _nvs_close: ::core::option::Option<unsafe extern "C" fn(handle: u32)>,
    pub _nvs_commit: ::core::option::Option<unsafe extern "C" fn(handle: u32) -> i32>,
    pub _nvs_set_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const c_types::c_char,
            value: *const c_types::c_void,
            length: size_t,
        ) -> i32,
    >,
    pub _nvs_get_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const c_types::c_char,
            out_value: *mut c_types::c_void,
            length: *mut size_t,
        ) -> i32,
    >,
    pub _nvs_erase_key: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const c_types::c_char) -> i32,
    >,
    pub _get_random: ::core::option::Option<unsafe extern "C" fn(buf: *mut u8, len: size_t) -> i32>,
    pub _get_time: ::core::option::Option<unsafe extern "C" fn(t: *mut c_types::c_void) -> i32>,
    pub _random: ::core::option::Option<unsafe extern "C" fn() -> c_types::c_ulong>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(
            level: u32,
            tag: *const c_types::c_char,
            format: *const c_types::c_char,
            ...
        ),
    >,
    pub _log_writev: ::core::option::Option<
        unsafe extern "C" fn(
            level: u32,
            tag: *const c_types::c_char,
            format: *const c_types::c_char,
            args: va_list,
        ),
    >,
    pub _log_timestamp: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut c_types::c_void>,
    pub _realloc_internal: ::core::option::Option<
        unsafe extern "C" fn(ptr: *mut c_types::c_void, size: size_t) -> *mut c_types::c_void,
    >,
    pub _calloc_internal: ::core::option::Option<
        unsafe extern "C" fn(n: size_t, size: size_t) -> *mut c_types::c_void,
    >,
    pub _zalloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut c_types::c_void>,
    pub _wifi_malloc:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut c_types::c_void>,
    pub _wifi_realloc: ::core::option::Option<
        unsafe extern "C" fn(ptr: *mut c_types::c_void, size: size_t) -> *mut c_types::c_void,
    >,
    pub _wifi_calloc: ::core::option::Option<
        unsafe extern "C" fn(n: size_t, size: size_t) -> *mut c_types::c_void,
    >,
    pub _wifi_zalloc:
        ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut c_types::c_void>,
    pub _wifi_create_queue: ::core::option::Option<
        unsafe extern "C" fn(queue_len: i32, item_size: i32) -> *mut c_types::c_void,
    >,
    pub _wifi_delete_queue:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut c_types::c_void)>,
    pub _modem_sleep_enter: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_exit: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_register: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_deregister: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _coex_status_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_condition_set:
        ::core::option::Option<unsafe extern "C" fn(type_: u32, dissatisfy: bool)>,
    pub _coex_wifi_request: ::core::option::Option<
        unsafe extern "C" fn(event: u32, latency: u32, duration: u32) -> i32,
    >,
    pub _coex_wifi_release: ::core::option::Option<unsafe extern "C" fn(event: u32) -> i32>,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_wifi_osi_funcs: wifi_osi_funcs_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi station interface to supplied netif"]
    #[doc = ""]
    #[doc = " @param esp_netif instance to attach the wifi station to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success"]
    #[doc = "  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_station(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Attaches wifi soft AP interface to supplied netif"]
    #[doc = ""]
    #[doc = " @param esp_netif instance to attach the wifi AP to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success"]
    #[doc = "  - ESP_FAIL if attach failed"]
    pub fn esp_netif_attach_wifi_ap(esp_netif: *mut esp_netif_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for STA interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_sta_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Sets default wifi event handlers for STA interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_set_default_wifi_ap_handlers() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clears default wifi event handlers for supplied network interface"]
    #[doc = ""]
    #[doc = " @param esp_netif instance of corresponding if object"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success, error returned from esp_event_handler_register if failed"]
    pub fn esp_wifi_clear_default_wifi_driver_and_handlers(
        esp_netif: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI AP. In case of any init error this API aborts."]
    #[doc = ""]
    #[doc = " @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_ap() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default WIFI STA. In case of any init error this API aborts."]
    #[doc = ""]
    #[doc = " @return pointer to esp-netif instance"]
    pub fn esp_netif_create_default_wifi_sta() -> *mut esp_netif_t;
}
extern "C" {
    #[doc = " @brief Creates default STA and AP network interfaces for esp-mesh."]
    #[doc = ""]
    #[doc = " Both netifs are almost identical to the default station and softAP, but with"]
    #[doc = " DHCP client and server disabled. Please note that the DHCP client is typically"]
    #[doc = " enabled only if the device is promoted to a root node."]
    #[doc = ""]
    #[doc = " Returns created interfaces which could be ignored setting parameters to NULL"]
    #[doc = " if an application code does not need to save the interface instances"]
    #[doc = " for further processing."]
    #[doc = ""]
    #[doc = " @param[out] p_netif_sta pointer where the resultant STA interface is saved (if non NULL)"]
    #[doc = " @param[out] p_netif_ap pointer where the resultant AP interface is saved (if non NULL)"]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_netif_create_default_wifi_mesh_netifs(
        p_netif_sta: *mut *mut esp_netif_t,
        p_netif_ap: *mut *mut esp_netif_t,
    ) -> esp_err_t;
}
#[doc = " @brief WiFi stack configuration parameters passed to esp_wifi_init call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_init_config_t {
    #[doc = "< WiFi event handler"]
    pub event_handler: system_event_handler_t,
    #[doc = "< WiFi OS functions"]
    pub osi_funcs: *mut wifi_osi_funcs_t,
    #[doc = "< WiFi station crypto functions when connect"]
    pub wpa_crypto_funcs: wpa_crypto_funcs_t,
    #[doc = "< WiFi static RX buffer number"]
    pub static_rx_buf_num: c_types::c_int,
    #[doc = "< WiFi dynamic RX buffer number"]
    pub dynamic_rx_buf_num: c_types::c_int,
    #[doc = "< WiFi TX buffer type"]
    pub tx_buf_type: c_types::c_int,
    #[doc = "< WiFi static TX buffer number"]
    pub static_tx_buf_num: c_types::c_int,
    #[doc = "< WiFi dynamic TX buffer number"]
    pub dynamic_tx_buf_num: c_types::c_int,
    #[doc = "< WiFi channel state information enable flag"]
    pub csi_enable: c_types::c_int,
    #[doc = "< WiFi AMPDU RX feature enable flag"]
    pub ampdu_rx_enable: c_types::c_int,
    #[doc = "< WiFi AMPDU TX feature enable flag"]
    pub ampdu_tx_enable: c_types::c_int,
    #[doc = "< WiFi NVS flash enable flag"]
    pub nvs_enable: c_types::c_int,
    #[doc = "< Nano option for printf/scan family enable flag"]
    pub nano_enable: c_types::c_int,
    #[doc = "< WiFi Block Ack TX window size"]
    pub tx_ba_win: c_types::c_int,
    #[doc = "< WiFi Block Ack RX window size"]
    pub rx_ba_win: c_types::c_int,
    #[doc = "< WiFi Task Core ID"]
    pub wifi_task_core_id: c_types::c_int,
    #[doc = "< WiFi softAP maximum length of the beacon"]
    pub beacon_max_len: c_types::c_int,
    #[doc = "< WiFi management short buffer number, the minimum value is 6, the maximum value is 32"]
    pub mgmt_sbuf_num: c_types::c_int,
    #[doc = "< Enables additional WiFi features and capabilities"]
    pub feature_caps: u64,
    #[doc = "< WiFi init magic number, it should be the last field"]
    pub magic: c_types::c_int,
}
extern "C" {
    pub static g_wifi_default_wpa_crypto_funcs: wpa_crypto_funcs_t;
}
extern "C" {
    pub static mut g_wifi_feature_caps: u64;
}
extern "C" {
    #[doc = " @brief  Init WiFi"]
    #[doc = "         Alloc resource for WiFi driver, such as WiFi control structure, RX/TX buffer,"]
    #[doc = "         WiFi NVS structure etc, this WiFi also start WiFi task"]
    #[doc = ""]
    #[doc = " @attention 1. This API must be called before all other WiFi API can be called"]
    #[doc = " @attention 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to init the config to default values, this can"]
    #[doc = "               guarantee all the fields got correct value when more fields are added into wifi_init_config_t"]
    #[doc = "               in future release. If you want to set your owner initial values, overwrite the default values"]
    #[doc = "               which are set by WIFI_INIT_CONFIG_DEFAULT, please be notified that the field 'magic' of"]
    #[doc = "               wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC!"]
    #[doc = ""]
    #[doc = " @param  config pointer to WiFi init configuration structure; can point to a temporary variable."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinit WiFi"]
    #[doc = "         Free all resource allocated in esp_wifi_init and stop WiFi task"]
    #[doc = ""]
    #[doc = " @attention 1. This API should be called if you want to remove WiFi driver from the system"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi operating mode"]
    #[doc = ""]
    #[doc = "            Set the WiFi operating mode as station, soft-AP or station+soft-AP,"]
    #[doc = "            The default mode is soft-AP mode."]
    #[doc = ""]
    #[doc = " @param     mode  WiFi operating mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_mode(mode: wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get current operating mode of WiFi"]
    #[doc = ""]
    #[doc = " @param[out]  mode  store current WiFi mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_mode(mode: *mut wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start WiFi according to current configuration"]
    #[doc = "         If mode is WIFI_MODE_STA, it create station control block and start station"]
    #[doc = "         If mode is WIFI_MODE_AP, it create soft-AP control block and start soft-AP"]
    #[doc = "         If mode is WIFI_MODE_APSTA, it create soft-AP and station control block and start soft-AP and station"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong"]
    #[doc = "    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop WiFi"]
    #[doc = "         If mode is WIFI_MODE_STA, it stop station and free station control block"]
    #[doc = "         If mode is WIFI_MODE_AP, it stop soft-AP and free soft-AP control block"]
    #[doc = "         If mode is WIFI_MODE_APSTA, it stop station/soft-AP and free station/soft-AP control block"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restore WiFi stack persistent settings to default values"]
    #[doc = ""]
    #[doc = " This function will reset settings made using the following APIs:"]
    #[doc = " - esp_wifi_get_auto_connect,"]
    #[doc = " - esp_wifi_set_protocol,"]
    #[doc = " - esp_wifi_set_config related"]
    #[doc = " - esp_wifi_set_mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_restore() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect the ESP32 WiFi station to the AP."]
    #[doc = ""]
    #[doc = " @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode"]
    #[doc = " @attention 2. If the ESP32 is connected to an AP, call esp_wifi_disconnect to disconnect."]
    #[doc = " @attention 3. The scanning triggered by esp_wifi_start_scan() will not be effective until connection between ESP32 and the AP is established."]
    #[doc = "               If ESP32 is scanning and connecting at the same time, ESP32 will abort scanning and return a warning message and error"]
    #[doc = "               number ESP_ERR_WIFI_STATE."]
    #[doc = "               If you want to do reconnection after ESP32 received disconnect event, remember to add the maximum retry time, otherwise the called"]
    #[doc = "               scan will not work. This is especially true when the AP doesn't exist, and you still try reconnection after ESP32 received disconnect"]
    #[doc = "               event with the reason code WIFI_REASON_NO_AP_FOUND."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong"]
    #[doc = "    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect the ESP32 WiFi station from the AP."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_disconnect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Currently this API is just an stub API"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: fail"]
    pub fn esp_wifi_clear_fast_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     deauthenticate all stations or associated id equals to aid"]
    #[doc = ""]
    #[doc = " @param     aid  when aid is 0, deauthenticate all stations, otherwise deauthenticate station whose associated id is aid"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    pub fn esp_wifi_deauth_sta(aid: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Scan all available APs."]
    #[doc = ""]
    #[doc = " @attention If this API is called, the found APs are stored in WiFi driver dynamic allocated memory and the"]
    #[doc = "            will be freed in esp_wifi_scan_get_ap_records, so generally, call esp_wifi_scan_get_ap_records to cause"]
    #[doc = "            the memory to be freed once the scan is done"]
    #[doc = " @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds."]
    #[doc = "            Values above 1500ms may cause station to disconnect from AP and are not recommended."]
    #[doc = ""]
    #[doc = " @param     config  configuration of scanning"]
    #[doc = " @param     block if block is true, this API will block the caller until the scan is done, otherwise"]
    #[doc = "                         it will return immediately"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_TIMEOUT: blocking scan is timeout"]
    #[doc = "    - ESP_ERR_WIFI_STATE: wifi still connecting when invoke esp_wifi_scan_start"]
    #[doc = "    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_scan_start(config: *const wifi_scan_config_t, block: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop the scan in process"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_scan_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get number of APs found in last scan"]
    #[doc = ""]
    #[doc = " @param[out] number  store number of APIs found in last scan"]
    #[doc = ""]
    #[doc = " @attention This API can only be called when the scan is completed, otherwise it may get wrong value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_scan_get_ap_num(number: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AP list found in last scan"]
    #[doc = ""]
    #[doc = " @param[inout]  number As input param, it stores max AP number ap_records can hold."]
    #[doc = "                As output param, it receives the actual AP number this API returns."]
    #[doc = " @param         ap_records  wifi_ap_record_t array to hold the found APs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    pub fn esp_wifi_scan_get_ap_records(
        number: *mut u16,
        ap_records: *mut wifi_ap_record_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get information of AP which the ESP32 station is associated with"]
    #[doc = ""]
    #[doc = " @param     ap_info  the wifi_ap_record_t to hold AP information"]
    #[doc = "            sta can get the connected ap's phy mode info through the struct member"]
    #[doc = "            phy_11bphy_11gphy_11nphy_lr in the wifi_ap_record_t struct."]
    #[doc = "            For example, phy_11b = 1 imply that ap support 802.11b mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_CONN: The station interface don't initialized"]
    #[doc = "    - ESP_ERR_WIFI_NOT_CONNECT: The station is in disconnect status"]
    pub fn esp_wifi_sta_get_ap_info(ap_info: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi power save type"]
    #[doc = ""]
    #[doc = " @attention Default power save type is WIFI_PS_MIN_MODEM."]
    #[doc = ""]
    #[doc = " @param     type  power save type"]
    #[doc = ""]
    #[doc = " @return    ESP_OK: succeed"]
    pub fn esp_wifi_set_ps(type_: wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi power save type"]
    #[doc = ""]
    #[doc = " @attention Default power save type is WIFI_PS_MIN_MODEM."]
    #[doc = ""]
    #[doc = " @param[out]  type: store current power save type"]
    #[doc = ""]
    #[doc = " @return    ESP_OK: succeed"]
    pub fn esp_wifi_get_ps(type_: *mut wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of specified interface"]
    #[doc = "            The default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)"]
    #[doc = ""]
    #[doc = " @attention Currently we only support 802.11b or 802.11bg or 802.11bgn mode"]
    #[doc = ""]
    #[doc = " @param     ifx  interfaces"]
    #[doc = " @param     protocol_bitmap  WiFi protocol bitmap"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_protocol(ifx: wifi_interface_t, protocol_bitmap: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the current protocol bitmap of the specified interface"]
    #[doc = ""]
    #[doc = " @param     ifx  interface"]
    #[doc = " @param[out] protocol_bitmap  store current WiFi protocol bitmap of interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_get_protocol(ifx: wifi_interface_t, protocol_bitmap: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the bandwidth of ESP32 specified interface"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to configure an interface that is not enabled"]
    #[doc = " @attention 2. WIFI_BW_HT40 is supported only when the interface support 11N"]
    #[doc = ""]
    #[doc = " @param     ifx  interface to be configured"]
    #[doc = " @param     bw  bandwidth"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_bandwidth(ifx: wifi_interface_t, bw: wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the bandwidth of ESP32 specified interface"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to get a interface that is not enable"]
    #[doc = ""]
    #[doc = " @param     ifx interface to be configured"]
    #[doc = " @param[out] bw  store bandwidth of interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_bandwidth(ifx: wifi_interface_t, bw: *mut wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set primary/secondary channel of ESP32"]
    #[doc = ""]
    #[doc = " @attention 1. This API should be called after esp_wifi_start()"]
    #[doc = " @attention 2. When ESP32 is in STA mode, this API should not be called when STA is scanning or connecting to an external AP"]
    #[doc = " @attention 3. When ESP32 is in softAP mode, this API should not be called when softAP has connected to external STAs"]
    #[doc = " @attention 4. When ESP32 is in STA+softAP mode, this API should not be called when in the scenarios described above"]
    #[doc = ""]
    #[doc = " @param     primary  for HT20, primary is the channel number, for HT40, primary is the primary channel"]
    #[doc = " @param     second   for HT20, second is ignored, for HT40, second is the second channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_channel(primary: u8, second: wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the primary/secondary channel of ESP32"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to get a interface that is not enable"]
    #[doc = ""]
    #[doc = " @param     primary   store current primary channel"]
    #[doc = " @param[out]  second  store current second channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_channel(primary: *mut u8, second: *mut wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country info"]
    #[doc = ""]
    #[doc = " @attention 1. The default country is {.cc=\"CN\", .schan=1, .nchan=13, policy=WIFI_COUNTRY_POLICY_AUTO}"]
    #[doc = " @attention 2. When the country policy is WIFI_COUNTRY_POLICY_AUTO, the country info of the AP to which"]
    #[doc = "               the station is connected is used. E.g. if the configured country info is {.cc=\"USA\", .schan=1, .nchan=11}"]
    #[doc = "               and the country info of the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}"]
    #[doc = "               then the country info that will be used is {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected"]
    #[doc = "               from the AP the country info is set back back to the country info of the station automatically,"]
    #[doc = "               {.cc=\"US\", .schan=1, .nchan=11} in the example."]
    #[doc = " @attention 3. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, always use the configured country info."]
    #[doc = " @attention 4. When the country info is changed because of configuration or because the station connects to a different"]
    #[doc = "               external AP, the country IE in probe response/beacon of the soft-AP is changed also."]
    #[doc = " @attention 5. The country configuration is not stored into flash"]
    #[doc = " @attention 6. This API doesn't validate the per-country rules, it's up to the user to fill in all fields according to"]
    #[doc = "               local regulations."]
    #[doc = ""]
    #[doc = " @param     country   the configured country info"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country(country: *const wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country info"]
    #[doc = ""]
    #[doc = " @param     country  country info"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country(country: *mut wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set MAC address of the ESP32 WiFi station or the soft-AP interface."]
    #[doc = ""]
    #[doc = " @attention 1. This API can only be called when the interface is disabled"]
    #[doc = " @attention 2. ESP32 soft-AP and station have different MAC addresses, do not set them to be the same."]
    #[doc = " @attention 3. The bit 0 of the first byte of ESP32 MAC address can not be 1. For example, the MAC address"]
    #[doc = "      can set to be \"1a:XX:XX:XX:XX:XX\", but can not be \"15:XX:XX:XX:XX:XX\"."]
    #[doc = ""]
    #[doc = " @param     ifx  interface"]
    #[doc = " @param     mac  the MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_WIFI_MAC: invalid mac address"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_mac(ifx: wifi_interface_t, mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mac of specified interface"]
    #[doc = ""]
    #[doc = " @param      ifx  interface"]
    #[doc = " @param[out] mac  store mac of the interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_mac(ifx: wifi_interface_t, mac: *mut u8) -> esp_err_t;
}
#[doc = " @brief The RX callback function in the promiscuous mode."]
#[doc = "        Each time a packet is received, the callback function will be called."]
#[doc = ""]
#[doc = " @param buf  Data received. Type of data in buffer (wifi_promiscuous_pkt_t or wifi_pkt_rx_ctrl_t) indicated by 'type' parameter."]
#[doc = " @param type  promiscuous packet type."]
#[doc = ""]
pub type wifi_promiscuous_cb_t = ::core::option::Option<
    unsafe extern "C" fn(buf: *mut c_types::c_void, type_: wifi_promiscuous_pkt_type_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function in the promiscuous mode."]
    #[doc = ""]
    #[doc = " Each time a packet is received, the registered callback function will be called."]
    #[doc = ""]
    #[doc = " @param cb  callback"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Enable the promiscuous mode."]
    #[doc = ""]
    #[doc = " @param     en  false - disable, true - enable"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[out] en  store the current status of promiscuous mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous(en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the promiscuous mode packet type filter."]
    #[doc = ""]
    #[doc = " @note The default filter is to filter all packets except WIFI_PKT_MISC"]
    #[doc = ""]
    #[doc = " @param filter the packet type filtered in promiscuous mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_filter(filter: *const wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous filter."]
    #[doc = ""]
    #[doc = " @param[out] filter  store the current status of promiscuous filter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_filter(filter: *mut wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable subtype filter of the control packet in promiscuous mode."]
    #[doc = ""]
    #[doc = " @note The default filter is to filter none control packet."]
    #[doc = ""]
    #[doc = " @param filter the subtype of the control packet filtered in promiscuous mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_ctrl_filter(
        filter: *const wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the subtype filter of the control packet in promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[out] filter  store the current status of subtype filter of the control packet in promiscuous mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_ctrl_filter(
        filter: *mut wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the configuration of the ESP32 STA or AP"]
    #[doc = ""]
    #[doc = " @attention 1. This API can be called only when specified interface is enabled, otherwise, API fail"]
    #[doc = " @attention 2. For station configuration, bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    #[doc = " @attention 3. ESP32 is limited to only one channel, so when in the soft-AP+station mode, the soft-AP will adjust its channel automatically to be the same as"]
    #[doc = "               the channel of the ESP32 station."]
    #[doc = ""]
    #[doc = " @param     interface  interface"]
    #[doc = " @param     conf  station or soft-AP configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_WIFI_MODE: invalid mode"]
    #[doc = "    - ESP_ERR_WIFI_PASSWORD: invalid password"]
    #[doc = "    - ESP_ERR_WIFI_NVS: WiFi internal NVS error"]
    #[doc = "    - others: refer to the erro code in esp_err.h"]
    pub fn esp_wifi_set_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get configuration of specified interface"]
    #[doc = ""]
    #[doc = " @param     interface  interface"]
    #[doc = " @param[out]  conf  station or soft-AP configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get STAs associated with soft-AP"]
    #[doc = ""]
    #[doc = " @attention SSC only API"]
    #[doc = ""]
    #[doc = " @param[out] sta  station list"]
    #[doc = "             ap can get the connected sta's phy mode info through the struct member"]
    #[doc = "             phy_11bphy_11gphy_11nphy_lr in the wifi_sta_info_t struct."]
    #[doc = "             For example, phy_11b = 1 imply that sta support 802.11b mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_list(sta: *mut wifi_sta_list_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AID of STA connected with soft-AP"]
    #[doc = ""]
    #[doc = " @param     mac  STA's mac address"]
    #[doc = " @param[out]  aid  Store the AID corresponding to STA mac"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NOT_FOUND: Requested resource not found"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_aid(mac: *const u8, aid: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi API configuration storage type"]
    #[doc = ""]
    #[doc = " @attention 1. The default value is WIFI_STORAGE_FLASH"]
    #[doc = ""]
    #[doc = " @param     storage : storage type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - ESP_OK: succeed"]
    #[doc = "   - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "   - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_storage(storage: wifi_storage_t) -> esp_err_t;
}
#[doc = " @brief     Function signature for received Vendor-Specific Information Element callback."]
#[doc = " @param     ctx Context argument, as passed to esp_wifi_set_vendor_ie_cb() when registering callback."]
#[doc = " @param     type Information element type, based on frame type received."]
#[doc = " @param     sa Source 802.11 address."]
#[doc = " @param     vnd_ie Pointer to the vendor specific element data received."]
#[doc = " @param     rssi Received signal strength indication."]
pub type esp_vendor_ie_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut c_types::c_void,
        type_: wifi_vendor_ie_type_t,
        sa: *const u8,
        vnd_ie: *const vendor_ie_data_t,
        rssi: c_types::c_int,
    ),
>;
extern "C" {
    #[doc = " @brief     Set 802.11 Vendor-Specific Information Element"]
    #[doc = ""]
    #[doc = " @param     enable If true, specified IE is enabled. If false, specified IE is removed."]
    #[doc = " @param     type Information Element type. Determines the frame type to associate with the IE."]
    #[doc = " @param     idx  Index to set or clear. Each IE type can be associated with up to two elements (indices 0 & 1)."]
    #[doc = " @param     vnd_ie Pointer to vendor specific element data. First 6 bytes should be a header with fields matching vendor_ie_data_t."]
    #[doc = "            If enable is false, this argument is ignored and can be NULL. Data does not need to remain valid after the function returns."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init()"]
    #[doc = "    - ESP_ERR_INVALID_ARG: Invalid argument, including if first byte of vnd_ie is not WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    #[doc = "      or second byte is an invalid length."]
    #[doc = "    - ESP_ERR_NO_MEM: Out of memory"]
    pub fn esp_wifi_set_vendor_ie(
        enable: bool,
        type_: wifi_vendor_ie_type_t,
        idx: wifi_vendor_ie_id_t,
        vnd_ie: *const c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register Vendor-Specific Information Element monitoring callback."]
    #[doc = ""]
    #[doc = " @param     cb   Callback function"]
    #[doc = " @param     ctx  Context argument, passed to callback function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_vendor_ie_cb(
        cb: esp_vendor_ie_cb_t,
        ctx: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set maximum transmitting power after WiFi start."]
    #[doc = ""]
    #[doc = " @attention 1. Maximum power before wifi startup is limited by PHY init data bin."]
    #[doc = " @attention 2. The value set by this API will be mapped to the max_tx_power of the structure wifi_country_t variable."]
    #[doc = " @attention 3. Mapping Table {Power, max_tx_power} = {{8,   2}, {20,  5}, {28,  7}, {34,  8}, {44, 11},"]
    #[doc = "                                                      {52, 13}, {56, 14}, {60, 15}, {66, 16}, {72, 18}, {78, 20}}."]
    #[doc = " @attention 4. Param power unit is 0.25dBm, range is [8, 78] corresponding to 2dBm - 20dBm."]
    #[doc = " @attention 5. Relationship between set value and actual value. As follows:"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              | set value  | actual value |"]
    #[doc = "              +============+==============+"]
    #[doc = "              |  [8,  19]  |      8       |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [20, 27]  |      20      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [28, 33]  |      28      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [34, 43]  |      34      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [44, 51]  |      44      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [52, 55]  |      52      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [56, 59]  |      56      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [60, 65]  |      60      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [66, 71]  |      66      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |  [72, 77]  |      72      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = "              |     78     |      78      |"]
    #[doc = "              +------------+--------------+"]
    #[doc = " @param     power  Maximum WiFi transmitting power."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is out of range"]
    pub fn esp_wifi_set_max_tx_power(power: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get maximum transmiting power after WiFi start"]
    #[doc = ""]
    #[doc = " @param     power Maximum WiFi transmitting power, unit is 0.25dBm."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_max_tx_power(power: *mut i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mask to enable or disable some WiFi events"]
    #[doc = ""]
    #[doc = " @attention 1. Mask can be created by logical OR of various WIFI_EVENT_MASK_ constants."]
    #[doc = "               Events which have corresponding bit set in the mask will not be delivered to the system event handler."]
    #[doc = " @attention 2. Default WiFi event mask is WIFI_EVENT_MASK_AP_PROBEREQRECVED."]
    #[doc = " @attention 3. There may be lots of stations sending probe request data around."]
    #[doc = "               Don't unmask this event unless you need to receive probe request data."]
    #[doc = ""]
    #[doc = " @param     mask  WiFi event mask."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_event_mask(mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mask of WiFi events"]
    #[doc = ""]
    #[doc = " @param     mask  WiFi event mask."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_event_mask(mask: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send raw ieee80211 data"]
    #[doc = ""]
    #[doc = " @attention Currently only support for sending beacon/probe request/probe response/action and non-QoS"]
    #[doc = "            data frame"]
    #[doc = ""]
    #[doc = " @param     ifx interface if the Wi-Fi mode is Station, the ifx should be WIFI_IF_STA. If the Wi-Fi"]
    #[doc = "            mode is SoftAP, the ifx should be WIFI_IF_AP. If the Wi-Fi mode is Station+SoftAP, the"]
    #[doc = "            ifx should be WIFI_IF_STA or WIFI_IF_AP. If the ifx is wrong, the API returns ESP_ERR_WIFI_IF."]
    #[doc = " @param     buffer raw ieee80211 buffer"]
    #[doc = " @param     len the length of raw buffer, the len must be <= 1500 Bytes and >= 24 Bytes"]
    #[doc = " @param     en_sys_seq indicate whether use the internal sequence number. If en_sys_seq is false, the"]
    #[doc = "            sequence in raw buffer is unchanged, otherwise it will be overwritten by WiFi driver with"]
    #[doc = "            the system sequence number."]
    #[doc = "            Generally, if esp_wifi_80211_tx is called before the Wi-Fi connection has been set up, both"]
    #[doc = "            en_sys_seq==true and en_sys_seq==false are fine. However, if the API is called after the Wi-Fi"]
    #[doc = "            connection has been set up, en_sys_seq must be true, otherwise ESP_ERR_WIFI_ARG is returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: success"]
    #[doc = "    - ESP_ERR_WIFI_IF: Invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: Invalid parameter"]
    #[doc = "    - ESP_ERR_WIFI_NO_MEM: out of memory"]
    pub fn esp_wifi_80211_tx(
        ifx: wifi_interface_t,
        buffer: *const c_types::c_void,
        len: c_types::c_int,
        en_sys_seq: bool,
    ) -> esp_err_t;
}
#[doc = " @brief The RX callback function of Channel State Information(CSI)  data."]
#[doc = ""]
#[doc = "        Each time a CSI data is received, the callback function will be called."]
#[doc = ""]
#[doc = " @param ctx context argument, passed to esp_wifi_set_csi_rx_cb() when registering callback function."]
#[doc = " @param data CSI data received. The memory that it points to will be deallocated after callback function returns."]
#[doc = ""]
pub type wifi_csi_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut c_types::c_void, data: *mut wifi_csi_info_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function of CSI data."]
    #[doc = ""]
    #[doc = "        Each time a CSI data is received, the callback function will be called."]
    #[doc = ""]
    #[doc = " @param cb  callback"]
    #[doc = " @param ctx context argument, passed to callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_csi_rx_cb(cb: wifi_csi_cb_t, ctx: *mut c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set CSI data configuration"]
    #[doc = ""]
    #[doc = " @param config configuration"]
    #[doc = ""]
    #[doc = " return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi_config(config: *const wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable CSI"]
    #[doc = ""]
    #[doc = " @param en true - enable, false - disable"]
    #[doc = ""]
    #[doc = " return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna GPIO configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna GPIO configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid GPIO number etc"]
    pub fn esp_wifi_set_ant_gpio(config: *const wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna GPIO configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna GPIO configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant_gpio(config: *mut wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid antenna mode or invalid GPIO number"]
    pub fn esp_wifi_set_ant(config: *const wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant(config: *mut wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the inactive time of the ESP32 STA or AP"]
    #[doc = ""]
    #[doc = " @attention 1. For Station, If the station does not receive a beacon frame from the connected SoftAP during the inactive time,"]
    #[doc = "               disconnect from SoftAP. Default 6s."]
    #[doc = " @attention 2. For SoftAP, If the softAP doesn't receive any data from the connected STA during inactive time,"]
    #[doc = "               the softAP will force deauth the STA. Default is 300s."]
    #[doc = " @attention 3. The inactive time configuration is not stored into flash"]
    #[doc = ""]
    #[doc = " @param     ifx  interface to be configured."]
    #[doc = " @param     sec  Inactive time. Unit seconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, For Station, if sec is less than 3. For SoftAP, if sec is less than 10."]
    pub fn esp_wifi_set_inactive_time(ifx: wifi_interface_t, sec: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get inactive time of specified interface"]
    #[doc = ""]
    #[doc = " @param     ifx  Interface to be configured."]
    #[doc = " @param     sec  Inactive time. Unit seconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_inactive_time(ifx: wifi_interface_t, sec: *mut u16) -> esp_err_t;
}
#[doc = "< Lowlevel init done"]
pub const esp_eth_state_t_ETH_STATE_LLINIT: esp_eth_state_t = 0;
#[doc = "< Deinit done"]
pub const esp_eth_state_t_ETH_STATE_DEINIT: esp_eth_state_t = 1;
#[doc = "< Link status changed"]
pub const esp_eth_state_t_ETH_STATE_LINK: esp_eth_state_t = 2;
#[doc = "< Speed updated"]
pub const esp_eth_state_t_ETH_STATE_SPEED: esp_eth_state_t = 3;
#[doc = "< Duplex updated"]
pub const esp_eth_state_t_ETH_STATE_DUPLEX: esp_eth_state_t = 4;
#[doc = " @brief Ethernet driver state"]
pub type esp_eth_state_t = c_types::c_uint;
#[doc = "< Get MAC address"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_MAC_ADDR: esp_eth_io_cmd_t = 0;
#[doc = "< Set MAC address"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_MAC_ADDR: esp_eth_io_cmd_t = 1;
#[doc = "< Get PHY address"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_PHY_ADDR: esp_eth_io_cmd_t = 2;
#[doc = "< Set PHY address"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_PHY_ADDR: esp_eth_io_cmd_t = 3;
#[doc = "< Get Speed"]
pub const esp_eth_io_cmd_t_ETH_CMD_G_SPEED: esp_eth_io_cmd_t = 4;
#[doc = "< Set promiscuous mode"]
pub const esp_eth_io_cmd_t_ETH_CMD_S_PROMISCUOUS: esp_eth_io_cmd_t = 5;
#[doc = " @brief Command list for ioctl API"]
pub type esp_eth_io_cmd_t = c_types::c_uint;
#[doc = "< Ethernet link is up"]
pub const eth_link_t_ETH_LINK_UP: eth_link_t = 0;
#[doc = "< Ethernet link is down"]
pub const eth_link_t_ETH_LINK_DOWN: eth_link_t = 1;
#[doc = " @brief Ethernet link status"]
pub type eth_link_t = c_types::c_uint;
#[doc = "< Ethernet speed is 10Mbps"]
pub const eth_speed_t_ETH_SPEED_10M: eth_speed_t = 0;
#[doc = "< Ethernet speed is 100Mbps"]
pub const eth_speed_t_ETH_SPEED_100M: eth_speed_t = 1;
#[doc = " @brief Ethernet speed"]
pub type eth_speed_t = c_types::c_uint;
#[doc = "< Ethernet is in half duplex"]
pub const eth_duplex_t_ETH_DUPLEX_HALF: eth_duplex_t = 0;
#[doc = "< Ethernet is in full duplex"]
pub const eth_duplex_t_ETH_DUPLEX_FULL: eth_duplex_t = 1;
#[doc = " @brief Ethernet duplex mode"]
pub type eth_duplex_t = c_types::c_uint;
#[doc = " @brief Ethernet mediator"]
pub type esp_eth_mediator_t = esp_eth_mediator_s;
#[doc = " @brief Ethernet mediator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_eth_mediator_s {
    #[doc = " @brief Read PHY register"]
    #[doc = ""]
    #[doc = " @param[in] eth: mediator of Ethernet driver"]
    #[doc = " @param[in] phy_addr: PHY Chip address (0~31)"]
    #[doc = " @param[in] phy_reg: PHY register index code"]
    #[doc = " @param[out] reg_value: PHY register value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: read PHY register successfully"]
    #[doc = "       - ESP_FAIL: read PHY register failed because some error occurred"]
    #[doc = ""]
    pub phy_reg_read: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: *mut u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Write PHY register"]
    #[doc = ""]
    #[doc = " @param[in] eth: mediator of Ethernet driver"]
    #[doc = " @param[in] phy_addr: PHY Chip address (0~31)"]
    #[doc = " @param[in] phy_reg: PHY register index code"]
    #[doc = " @param[in] reg_value: PHY register value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: write PHY register successfully"]
    #[doc = "       - ESP_FAIL: write PHY register failed because some error occurred"]
    pub phy_reg_write: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Deliver packet to upper stack"]
    #[doc = ""]
    #[doc = " @param[in] eth: mediator of Ethernet driver"]
    #[doc = " @param[in] buffer: packet buffer"]
    #[doc = " @param[in] length: length of the packet"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: deliver packet to upper stack successfully"]
    #[doc = "       - ESP_FAIL: deliver packet failed because some error occurred"]
    #[doc = ""]
    pub stack_input: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            buffer: *mut u8,
            length: u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Callback on Ethernet state changed"]
    #[doc = ""]
    #[doc = " @param[in] eth: mediator of Ethernet driver"]
    #[doc = " @param[in] state: new state"]
    #[doc = " @param[in] args: optional argument for the new state"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: process the new state successfully"]
    #[doc = "       - ESP_FAIL: process the new state failed because some error occurred"]
    #[doc = ""]
    pub on_state_changed: ::core::option::Option<
        unsafe extern "C" fn(
            eth: *mut esp_eth_mediator_t,
            state: esp_eth_state_t,
            args: *mut c_types::c_void,
        ) -> esp_err_t,
    >,
}
#[doc = "< Ethernet driver start"]
pub const eth_event_t_ETHERNET_EVENT_START: eth_event_t = 0;
#[doc = "< Ethernet driver stop"]
pub const eth_event_t_ETHERNET_EVENT_STOP: eth_event_t = 1;
#[doc = "< Ethernet got a valid link"]
pub const eth_event_t_ETHERNET_EVENT_CONNECTED: eth_event_t = 2;
#[doc = "< Ethernet lost a valid link"]
pub const eth_event_t_ETHERNET_EVENT_DISCONNECTED: eth_event_t = 3;
#[doc = " @brief Ethernet event declarations"]
pub type eth_event_t = c_types::c_uint;
extern "C" {
    pub static mut ETH_EVENT: esp_event_base_t;
}
extern "C" {
    #[doc = " @brief Detect PHY address"]
    #[doc = ""]
    #[doc = " @param[in] eth: mediator of Ethernet driver"]
    #[doc = " @param[out] detected_addr: a valid address after detection"]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: detect phy address successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: invalid parameter"]
    #[doc = "       - ESP_ERR_NOT_FOUND: can't detect any PHY device"]
    #[doc = "       - ESP_FAIL: detect phy address failed because some error occurred"]
    pub fn esp_eth_detect_phy_addr(
        eth: *mut esp_eth_mediator_t,
        detected_addr: *mut u32,
    ) -> esp_err_t;
}
#[doc = " @brief Ethernet MAC"]
pub type esp_eth_mac_t = esp_eth_mac_s;
#[doc = " @brief Ethernet MAC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_eth_mac_s {
    #[doc = " @brief Set mediator for Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] eth: Ethernet mediator"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set mediator for Ethernet MAC successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: set mediator for Ethernet MAC failed because of invalid argument"]
    #[doc = ""]
    pub set_mediator: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, eth: *mut esp_eth_mediator_t) -> esp_err_t,
    >,
    #[doc = " @brief Initialize Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: initialize Ethernet MAC successfully"]
    #[doc = "      - ESP_ERR_TIMEOUT: initialize Ethernet MAC failed because of timeout"]
    #[doc = "      - ESP_FAIL: initialize Ethernet MAC failed because some other error occurred"]
    #[doc = ""]
    pub init: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Deinitialize Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: deinitialize Ethernet MAC successfully"]
    #[doc = "      - ESP_FAIL: deinitialize Ethernet MAC failed because some error occurred"]
    #[doc = ""]
    pub deinit: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Start Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: start Ethernet MAC successfully"]
    #[doc = "      - ESP_FAIL: start Ethernet MAC failed because some other error occurred"]
    #[doc = ""]
    pub start: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Stop Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: stop Ethernet MAC successfully"]
    #[doc = "      - ESP_FAIL: stop Ethernet MAC failed because some error occurred"]
    #[doc = ""]
    pub stop: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
    #[doc = " @brief Transmit packet from Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] buf: packet buffer to transmit"]
    #[doc = " @param[in] length: length of packet"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: transmit packet successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: transmit packet failed because of invalid argument"]
    #[doc = "      - ESP_ERR_INVALID_STATE: transmit packet failed because of wrong state of MAC"]
    #[doc = "      - ESP_FAIL: transmit packet failed because some other error occurred"]
    #[doc = ""]
    pub transmit: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, buf: *mut u8, length: u32) -> esp_err_t,
    >,
    #[doc = " @brief Receive packet from Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[out] buf: packet buffer which will preserve the received frame"]
    #[doc = " @param[out] length: length of the received packet"]
    #[doc = ""]
    #[doc = " @note Memory of buf is allocated in the Layer2, make sure it get free after process."]
    #[doc = " @note Before this function got invoked, the value of \"length\" should set by user, equals the size of buffer."]
    #[doc = "       After the function returned, the value of \"length\" means the real length of received data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: receive packet successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: receive packet failed because of invalid argument"]
    #[doc = "      - ESP_ERR_INVALID_SIZE: input buffer size is not enough to hold the incoming data."]
    #[doc = "                              in this case, value of returned \"length\" indicates the real size of incoming data."]
    #[doc = "      - ESP_FAIL: receive packet failed because some other error occurred"]
    #[doc = ""]
    pub receive: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, buf: *mut u8, length: *mut u32) -> esp_err_t,
    >,
    #[doc = " @brief Read PHY register"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] phy_addr: PHY chip address (0~31)"]
    #[doc = " @param[in] phy_reg: PHY register index code"]
    #[doc = " @param[out] reg_value: PHY register value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: read PHY register successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: read PHY register failed because of invalid argument"]
    #[doc = "      - ESP_ERR_INVALID_STATE: read PHY register failed because of wrong state of MAC"]
    #[doc = "      - ESP_ERR_TIMEOUT: read PHY register failed because of timeout"]
    #[doc = "      - ESP_FAIL: read PHY register failed because some other error occurred"]
    #[doc = ""]
    pub read_phy_reg: ::core::option::Option<
        unsafe extern "C" fn(
            mac: *mut esp_eth_mac_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: *mut u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Write PHY register"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] phy_addr: PHY chip address (0~31)"]
    #[doc = " @param[in] phy_reg: PHY register index code"]
    #[doc = " @param[in] reg_value: PHY register value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: write PHY register successfully"]
    #[doc = "      - ESP_ERR_INVALID_STATE: write PHY register failed because of wrong state of MAC"]
    #[doc = "      - ESP_ERR_TIMEOUT: write PHY register failed because of timeout"]
    #[doc = "      - ESP_FAIL: write PHY register failed because some other error occurred"]
    #[doc = ""]
    pub write_phy_reg: ::core::option::Option<
        unsafe extern "C" fn(
            mac: *mut esp_eth_mac_t,
            phy_addr: u32,
            phy_reg: u32,
            reg_value: u32,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Set MAC address"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] addr: MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set MAC address successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: set MAC address failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: set MAC address failed because some other error occurred"]
    #[doc = ""]
    pub set_addr: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, addr: *mut u8) -> esp_err_t,
    >,
    #[doc = " @brief Get MAC address"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[out] addr: MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: get MAC address successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: get MAC address failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: get MAC address failed because some other error occurred"]
    #[doc = ""]
    pub get_addr: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, addr: *mut u8) -> esp_err_t,
    >,
    #[doc = " @brief Set speed of MAC"]
    #[doc = ""]
    #[doc = " @param[in] ma:c Ethernet MAC instance"]
    #[doc = " @param[in] speed: MAC speed"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set MAC speed successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: set MAC speed failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: set MAC speed failed because some other error occurred"]
    #[doc = ""]
    pub set_speed: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, speed: eth_speed_t) -> esp_err_t,
    >,
    #[doc = " @brief Set duplex mode of MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] duplex: MAC duplex"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set MAC duplex mode successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: set MAC duplex failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: set MAC duplex failed because some other error occurred"]
    #[doc = ""]
    pub set_duplex: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, duplex: eth_duplex_t) -> esp_err_t,
    >,
    #[doc = " @brief Set link status of MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] link: Link status"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set link status successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: set link status failed because of invalid argument"]
    #[doc = "      - ESP_FAIL: set link status failed because some other error occurred"]
    #[doc = ""]
    pub set_link: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, link: eth_link_t) -> esp_err_t,
    >,
    #[doc = " @brief Set promiscuous of MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = " @param[in] enable: set true to enable promiscuous mode; set false to disable promiscuous mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set promiscuous mode successfully"]
    #[doc = "      - ESP_FAIL: set promiscuous mode failed because some error occurred"]
    #[doc = ""]
    pub set_promiscuous: ::core::option::Option<
        unsafe extern "C" fn(mac: *mut esp_eth_mac_t, enable: bool) -> esp_err_t,
    >,
    #[doc = " @brief Free memory of Ethernet MAC"]
    #[doc = ""]
    #[doc = " @param[in] mac: Ethernet MAC instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: free Ethernet MAC instance successfully"]
    #[doc = "      - ESP_FAIL: free Ethernet MAC instance failed because some error occurred"]
    #[doc = ""]
    pub del: ::core::option::Option<unsafe extern "C" fn(mac: *mut esp_eth_mac_t) -> esp_err_t>,
}
#[doc = " @brief Configuration of Ethernet MAC object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_mac_config_t {
    #[doc = "< Software reset timeout value (Unit: ms)"]
    pub sw_reset_timeout_ms: u32,
    #[doc = "< Stack size of the receive task"]
    pub rx_task_stack_size: u32,
    #[doc = "< Priority of the receive task"]
    pub rx_task_prio: u32,
    #[doc = "< SMI MDC GPIO number"]
    pub smi_mdc_gpio_num: c_types::c_int,
    #[doc = "< SMI MDIO GPIO number"]
    pub smi_mdio_gpio_num: c_types::c_int,
    #[doc = "< Flags that specify extra capability for mac driver"]
    pub flags: u32,
}
#[doc = " @brief Ethernet PHY"]
pub type esp_eth_phy_t = esp_eth_phy_s;
#[doc = " @brief Ethernet PHY"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_eth_phy_s {
    #[doc = " @brief Set mediator for PHY"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = " @param[in] mediator: mediator of Ethernet driver"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set mediator for Ethernet PHY instance successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: set mediator for Ethernet PHY instance failed because of some invalid arguments"]
    #[doc = ""]
    pub set_mediator: ::core::option::Option<
        unsafe extern "C" fn(
            phy: *mut esp_eth_phy_t,
            mediator: *mut esp_eth_mediator_t,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Software Reset Ethernet PHY"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: reset Ethernet PHY successfully"]
    #[doc = "      - ESP_FAIL: reset Ethernet PHY failed because some error occurred"]
    #[doc = ""]
    pub reset: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Hardware Reset Ethernet PHY"]
    #[doc = ""]
    #[doc = " @note Hardware reset is mostly done by pull down and up PHY's nRST pin"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: reset Ethernet PHY successfully"]
    #[doc = "      - ESP_FAIL: reset Ethernet PHY failed because some error occurred"]
    #[doc = ""]
    pub reset_hw:
        ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Initialize Ethernet PHY"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: initialize Ethernet PHY successfully"]
    #[doc = "      - ESP_FAIL: initialize Ethernet PHY failed because some error occurred"]
    #[doc = ""]
    pub init: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Deinitialize Ethernet PHY"]
    #[doc = ""]
    #[doc = " @param[in] phyL Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: deinitialize Ethernet PHY successfully"]
    #[doc = "      - ESP_FAIL: deinitialize Ethernet PHY failed because some error occurred"]
    #[doc = ""]
    pub deinit: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Start auto negotiation"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: restart auto negotiation successfully"]
    #[doc = "      - ESP_FAIL: restart auto negotiation failed because some error occurred"]
    #[doc = ""]
    pub negotiate:
        ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Get Ethernet PHY link status"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: get Ethernet PHY link status successfully"]
    #[doc = "      - ESP_FAIL: get Ethernet PHY link status failed because some error occurred"]
    #[doc = ""]
    pub get_link:
        ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
    #[doc = " @brief Power control of Ethernet PHY"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = " @param[in] enable: set true to power on Ethernet PHY; ser false to power off Ethernet PHY"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: control Ethernet PHY power successfully"]
    #[doc = "      - ESP_FAIL: control Ethernet PHY power failed because some error occurred"]
    #[doc = ""]
    pub pwrctl: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, enable: bool) -> esp_err_t,
    >,
    #[doc = " @brief Set PHY chip address"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = " @param[in] addr: PHY chip address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: set Ethernet PHY address successfully"]
    #[doc = "      - ESP_FAIL: set Ethernet PHY address failed because some error occurred"]
    #[doc = ""]
    pub set_addr: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, addr: u32) -> esp_err_t,
    >,
    #[doc = " @brief Get PHY chip address"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = " @param[out] addr: PHY chip address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: get Ethernet PHY address successfully"]
    #[doc = "      - ESP_ERR_INVALID_ARG: get Ethernet PHY address failed because of invalid argument"]
    #[doc = ""]
    pub get_addr: ::core::option::Option<
        unsafe extern "C" fn(phy: *mut esp_eth_phy_t, addr: *mut u32) -> esp_err_t,
    >,
    #[doc = " @brief Free memory of Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @param[in] phy: Ethernet PHY instance"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: free PHY instance successfully"]
    #[doc = "      - ESP_FAIL: free PHY instance failed because some error occurred"]
    #[doc = ""]
    pub del: ::core::option::Option<unsafe extern "C" fn(phy: *mut esp_eth_phy_t) -> esp_err_t>,
}
#[doc = " @brief Ethernet PHY configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_phy_config_t {
    #[doc = "< PHY address, set -1 to enable PHY address detection at initialization stage"]
    pub phy_addr: i32,
    #[doc = "< Reset timeout value (Unit: ms)"]
    pub reset_timeout_ms: u32,
    #[doc = "< Auto-negotiation timeout value (Unit: ms)"]
    pub autonego_timeout_ms: u32,
    #[doc = "< Reset GPIO number, -1 means no hardware reset"]
    pub reset_gpio_num: c_types::c_int,
}
extern "C" {
    #[doc = " @brief Create a PHY instance of IP101"]
    #[doc = ""]
    #[doc = " @param[in] config: configuration of PHY"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - instance: create PHY instance successfully"]
    #[doc = "      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_ip101(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
extern "C" {
    #[doc = " @brief Create a PHY instance of RTL8201"]
    #[doc = ""]
    #[doc = " @param[in] config: configuration of PHY"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - instance: create PHY instance successfully"]
    #[doc = "      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_rtl8201(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
extern "C" {
    #[doc = " @brief Create a PHY instance of LAN8720"]
    #[doc = ""]
    #[doc = " @param[in] config: configuration of PHY"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - instance: create PHY instance successfully"]
    #[doc = "      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_lan8720(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
extern "C" {
    #[doc = " @brief Create a PHY instance of DP83848"]
    #[doc = ""]
    #[doc = " @param[in] config: configuration of PHY"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - instance: create PHY instance successfully"]
    #[doc = "      - NULL: create PHY instance failed because some error occurred"]
    pub fn esp_eth_phy_new_dp83848(config: *const eth_phy_config_t) -> *mut esp_eth_phy_t;
}
#[doc = " @brief Handle of Ethernet driver"]
pub type esp_eth_handle_t = *mut c_types::c_void;
#[doc = " @brief Configuration of Ethernet driver"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_eth_config_t {
    #[doc = " @brief Ethernet MAC object"]
    #[doc = ""]
    pub mac: *mut esp_eth_mac_t,
    #[doc = " @brief Ethernet PHY object"]
    #[doc = ""]
    pub phy: *mut esp_eth_phy_t,
    #[doc = " @brief Period time of checking Ethernet link status"]
    #[doc = ""]
    pub check_link_period_ms: u32,
    #[doc = " @brief Input frame buffer to user's stack"]
    #[doc = ""]
    #[doc = " @param[in] eth_handle: handle of Ethernet driver"]
    #[doc = " @param[in] buffer: frame buffer that will get input to upper stack"]
    #[doc = " @param[in] length: length of the frame buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: input frame buffer to upper stack successfully"]
    #[doc = "      - ESP_FAIL: error occurred when inputting buffer to upper stack"]
    #[doc = ""]
    pub stack_input: ::core::option::Option<
        unsafe extern "C" fn(
            eth_handle: esp_eth_handle_t,
            buffer: *mut u8,
            length: u32,
            priv_: *mut c_types::c_void,
        ) -> esp_err_t,
    >,
    #[doc = " @brief Callback function invoked when lowlevel initialization is finished"]
    #[doc = ""]
    #[doc = " @param[in] eth_handle: handle of Ethernet driver"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: process extra lowlevel initialization successfully"]
    #[doc = "       - ESP_FAIL: error occurred when processing extra lowlevel initialization"]
    pub on_lowlevel_init_done:
        ::core::option::Option<unsafe extern "C" fn(eth_handle: esp_eth_handle_t) -> esp_err_t>,
    #[doc = " @brief Callback function invoked when lowlevel deinitialization is finished"]
    #[doc = ""]
    #[doc = " @param[in] eth_handle: handle of Ethernet driver"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: process extra lowlevel deinitialization successfully"]
    #[doc = "       - ESP_FAIL: error occurred when processing extra lowlevel deinitialization"]
    pub on_lowlevel_deinit_done:
        ::core::option::Option<unsafe extern "C" fn(eth_handle: esp_eth_handle_t) -> esp_err_t>,
}
extern "C" {
    #[doc = " @brief Install Ethernet driver"]
    #[doc = ""]
    #[doc = " @param[in]  config: configuration of the Ethernet driver"]
    #[doc = " @param[out] out_hdl: handle of Ethernet driver"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: install esp_eth driver successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: install esp_eth driver failed because of some invalid argument"]
    #[doc = "       - ESP_ERR_NO_MEM: install esp_eth driver failed because there's no memory for driver"]
    #[doc = "       - ESP_FAIL: install esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_driver_install(
        config: *const esp_eth_config_t,
        out_hdl: *mut esp_eth_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall Ethernet driver"]
    #[doc = " @note It's not recommended to uninstall Ethernet driver unless it won't get used any more in application code."]
    #[doc = "       To uninstall Ethernet driver, you have to make sure, all references to the driver are released."]
    #[doc = "       Ethernet driver can only be uninstalled successfully when reference counter equals to one."]
    #[doc = ""]
    #[doc = " @param[in] hdl: handle of Ethernet driver"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: uninstall esp_eth driver successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: uninstall esp_eth driver failed because of some invalid argument"]
    #[doc = "       - ESP_ERR_INVALID_STATE: uninstall esp_eth driver failed because it has more than one reference"]
    #[doc = "       - ESP_FAIL: uninstall esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_driver_uninstall(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start Ethernet driver **ONLY** in standalone mode (i.e. without TCP/IP stack)"]
    #[doc = ""]
    #[doc = " @note This API will start driver state machine and internal software timer (for checking link status)."]
    #[doc = ""]
    #[doc = " @param[in] hdl handle of Ethernet driver"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: start esp_eth driver successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: start esp_eth driver failed because of some invalid argument"]
    #[doc = "       - ESP_ERR_INVALID_STATE: start esp_eth driver failed because driver has started already"]
    #[doc = "       - ESP_FAIL: start esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_start(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop Ethernet driver"]
    #[doc = ""]
    #[doc = " @note This function does the oppsite operation of `esp_eth_start`."]
    #[doc = ""]
    #[doc = " @param[in] hdl handle of Ethernet driver"]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: stop esp_eth driver successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: stop esp_eth driver failed because of some invalid argument"]
    #[doc = "       - ESP_ERR_INVALID_STATE: stop esp_eth driver failed because driver has not started yet"]
    #[doc = "       - ESP_FAIL: stop esp_eth driver failed because some other error occurred"]
    pub fn esp_eth_stop(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Update Ethernet data input path (i.e. specify where to pass the input buffer)"]
    #[doc = ""]
    #[doc = " @note After install driver, Ethernet still don't know where to deliver the input buffer."]
    #[doc = "       In fact, this API registers a callback function which get invoked when Ethernet received new packets."]
    #[doc = ""]
    #[doc = " @param[in] hdl handle of Ethernet driver"]
    #[doc = " @param[in] stack_input function pointer, which does the actual process on incoming packets"]
    #[doc = " @param[in] priv private resource, which gets passed to `stack_input` callback without any modification"]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: update input path successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: update input path failed because of some invalid argument"]
    #[doc = "       - ESP_FAIL: update input path failed because some other error occurred"]
    pub fn esp_eth_update_input_path(
        hdl: esp_eth_handle_t,
        stack_input: ::core::option::Option<
            unsafe extern "C" fn(
                hdl: esp_eth_handle_t,
                buffer: *mut u8,
                length: u32,
                priv_: *mut c_types::c_void,
            ) -> esp_err_t,
        >,
        priv_: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief General Transmit"]
    #[doc = ""]
    #[doc = " @param[in] hdl: handle of Ethernet driver"]
    #[doc = " @param[in] buf: buffer of the packet to transfer"]
    #[doc = " @param[in] length: length of the buffer to transfer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: transmit frame buffer successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: transmit frame buffer failed because of some invalid argument"]
    #[doc = "       - ESP_FAIL: transmit frame buffer failed because some other error occurred"]
    pub fn esp_eth_transmit(
        hdl: esp_eth_handle_t,
        buf: *mut c_types::c_void,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief General Receive"]
    #[doc = ""]
    #[doc = " @param[in] hdl: handle of Ethernet driver"]
    #[doc = " @param[out] buf: buffer to preserve the received packet"]
    #[doc = " @param[out] length: length of the received packet"]
    #[doc = ""]
    #[doc = " @note Before this function got invoked, the value of \"length\" should set by user, equals the size of buffer."]
    #[doc = "       After the function returned, the value of \"length\" means the real length of received data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: receive frame buffer successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: receive frame buffer failed because of some invalid argument"]
    #[doc = "       - ESP_ERR_INVALID_SIZE: input buffer size is not enough to hold the incoming data."]
    #[doc = "                               in this case, value of returned \"length\" indicates the real size of incoming data."]
    #[doc = "       - ESP_FAIL: receive frame buffer failed because some other error occurred"]
    pub fn esp_eth_receive(hdl: esp_eth_handle_t, buf: *mut u8, length: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Misc IO function of Etherent driver"]
    #[doc = ""]
    #[doc = " @param[in] hdl: handle of Ethernet driver"]
    #[doc = " @param[in] cmd: IO control command"]
    #[doc = " @param[in] data: specificed data for command"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: process io command successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: process io command failed because of some invalid argument"]
    #[doc = "       - ESP_FAIL: process io command failed because some other error occurred"]
    pub fn esp_eth_ioctl(
        hdl: esp_eth_handle_t,
        cmd: esp_eth_io_cmd_t,
        data: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Increase Ethernet driver reference"]
    #[doc = " @note Ethernet driver handle can be obtained by os timer, netif, etc."]
    #[doc = "       It's dangerous when thread A is using Ethernet but thread B uninstall the driver."]
    #[doc = "       Using reference counter can prevent such risk, but care should be taken, when you obtain Ethernet driver,"]
    #[doc = "       this API must be invoked so that the driver won't be uninstalled during your using time."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in] hdl: handle of Ethernet driver"]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: increase reference successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: increase reference failed because of some invalid argument"]
    pub fn esp_eth_increase_reference(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Decrease Ethernet driver reference"]
    #[doc = ""]
    #[doc = " @param[in] hdl: handle of Ethernet driver"]
    #[doc = " @return"]
    #[doc = "       - ESP_OK: increase reference successfully"]
    #[doc = "       - ESP_ERR_INVALID_ARG: increase reference failed because of some invalid argument"]
    pub fn esp_eth_decrease_reference(hdl: esp_eth_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create a netif glue for Ethernet driver"]
    #[doc = " @note netif glue is used to attach io driver to TCP/IP netif"]
    #[doc = ""]
    #[doc = " @param eth_hdl Ethernet driver handle"]
    #[doc = " @return glue object, which inherits esp_netif_driver_base_t"]
    pub fn esp_eth_new_netif_glue(eth_hdl: esp_eth_handle_t) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief Delete netif glue of Ethernet driver"]
    #[doc = ""]
    #[doc = " @param glue netif glue"]
    #[doc = " @return -ESP_OK: delete netif glue successfully"]
    pub fn esp_eth_del_netif_glue(glue: *mut c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register default IP layer handlers for Ethernet"]
    #[doc = ""]
    #[doc = " @note: Ethernet handle might not yet properly initialized when setting up these default handlers"]
    #[doc = ""]
    #[doc = " @param[in] esp_netif esp network interface handle created for Ethernet driver"]
    #[doc = " @return"]
    #[doc = "      - ESP_ERR_INVALID_ARG: invalid parameter (esp_netif is NULL)"]
    #[doc = "      - ESP_OK: set default IP layer handlers successfully"]
    #[doc = "      - others: other failure occurred during register esp_event handler"]
    pub fn esp_eth_set_default_handlers(esp_netif: *mut c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister default IP layer handlers for Ethernet"]
    #[doc = ""]
    #[doc = " @param[in] esp_netif esp network interface handle created for Ethernet driver"]
    #[doc = " @return"]
    #[doc = "      - ESP_ERR_INVALID_ARG: invalid parameter (esp_netif is NULL)"]
    #[doc = "      - ESP_OK: clear default IP layer handlers successfully"]
    #[doc = "      - others: other failure occurred during unregister esp_event handler"]
    pub fn esp_eth_clear_default_handlers(esp_netif: *mut c_types::c_void) -> esp_err_t;
}
pub type xt_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>;
pub type xt_exc_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut XtExcFrame)>;
extern "C" {
    pub fn xt_set_exception_handler(n: c_types::c_int, f: xt_exc_handler) -> xt_exc_handler;
}
extern "C" {
    pub fn xt_set_interrupt_handler(
        n: c_types::c_int,
        f: xt_handler,
        arg: *mut c_types::c_void,
    ) -> xt_handler;
}
extern "C" {
    pub fn xt_ints_on(mask: c_types::c_uint);
}
extern "C" {
    pub fn xt_ints_off(mask: c_types::c_uint);
}
extern "C" {
    pub fn xt_get_interrupt_handler_arg(n: c_types::c_int) -> *mut c_types::c_void;
}
pub type intr_handler_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_handle_data_t {
    _unused: [u8; 0],
}
pub type intr_handle_t = *mut intr_handle_data_t;
extern "C" {
    #[doc = " @brief Mark an interrupt as a shared interrupt"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " an interrupt that can be used to hook shared interrupt handlers"]
    #[doc = " to."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = " @param is_in_iram Shared interrupt is for handlers that reside in IRAM and"]
    #[doc = "                   the int can be left enabled while the flash cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_mark_shared(
        intno: c_types::c_int,
        cpu: c_types::c_int,
        is_in_iram: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reserve an interrupt to be used outside of this framework"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " reserved, not to be allocated for any reason."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_reserve(intno: c_types::c_int, cpu: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = " This finds an interrupt that matches the restrictions as given in the flags"]
    #[doc = " parameter, maps the given interrupt source to it and hooks up the given"]
    #[doc = " interrupt handler (with optional argument) as well. If needed, it can return"]
    #[doc = " a handle for the interrupt as well."]
    #[doc = ""]
    #[doc = " The interrupt will always be allocated on the core that runs this function."]
    #[doc = ""]
    #[doc = " If ESP_INTR_FLAG_IRAM flag is used, and handler address is not in IRAM or"]
    #[doc = " RTC_FAST_MEM, then ESP_ERR_INVALID_ARG is returned."]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc(
        source: c_types::c_int,
        flags: c_types::c_int,
        handler: intr_handler_t,
        arg: *mut c_types::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " This essentially does the same as esp_intr_alloc, but allows specifying a register and mask"]
    #[doc = " combo. For shared interrupts, the handler is only called if a read from the specified"]
    #[doc = " register, ANDed with the mask, returns non-zero. By passing an interrupt status register"]
    #[doc = " address and a fitting mask, this can be used to accelerate interrupt handling in the case"]
    #[doc = " a shared interrupt is triggered; by checking the interrupt statuses first, the code can"]
    #[doc = " decide which ISRs can be skipped"]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param intrstatusreg The address of an interrupt status register"]
    #[doc = " @param intrstatusmask A mask. If a read of address intrstatusreg has any of the bits"]
    #[doc = "               that are 1 in the mask set, the ISR will be called. If not, it will be"]
    #[doc = "               skipped."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc_intrstatus(
        source: c_types::c_int,
        flags: c_types::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut c_types::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable and free an interrupt."]
    #[doc = ""]
    #[doc = " Use an interrupt handle to disable the interrupt and release the resources associated with it."]
    #[doc = " If the current core is not the core that registered this interrupt, this routine will be assigned to"]
    #[doc = " the core that allocated this interrupt, blocking and waiting until the resource is successfully released."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " When the handler shares its source with other handlers, the interrupt status"]
    #[doc = " bits it's responsible for should be managed properly before freeing it. see"]
    #[doc = " ``esp_intr_disable`` for more details. Please do not call this function in ``esp_ipc_call_blocking``."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG the handle is NULL"]
    #[doc = "         ESP_FAIL failed to release this handle"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get CPU number an interrupt is tied to"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The core number where the interrupt is allocated"]
    pub fn esp_intr_get_cpu(handle: intr_handle_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get the allocated interrupt for a certain handle"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The interrupt number"]
    pub fn esp_intr_get_intno(handle: intr_handle_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Disable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " 1. For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = " CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = " 2. When several handlers sharing a same interrupt source, interrupt status bits, which are"]
    #[doc = " handled in the handler to be disabled, should be masked before the disabling, or handled"]
    #[doc = " in other enabled interrupts properly. Miss of interrupt status handling will cause infinite"]
    #[doc = " interrupt calls and finally system crash."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_disable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = "       CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_enable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the \"in IRAM\" status of the handler."]
    #[doc = ""]
    #[doc = " @note Does not work on shared interrupts."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = " @param is_in_iram Whether the handler associated with this handle resides in IRAM."]
    #[doc = "                   Handlers residing in IRAM can be called when cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_set_in_iram(handle: intr_handle_t, is_in_iram: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable interrupts that aren't specifically marked as running from IRAM"]
    pub fn esp_intr_noniram_disable();
}
extern "C" {
    #[doc = " @brief Re-enable interrupts disabled by esp_intr_noniram_disable"]
    pub fn esp_intr_noniram_enable();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_dev_s {
    pub bt_select: u32,
    pub out: u32,
    pub out_w1ts: u32,
    pub out_w1tc: u32,
    pub out1: gpio_dev_s__bindgen_ty_1,
    pub out1_w1ts: gpio_dev_s__bindgen_ty_2,
    pub out1_w1tc: gpio_dev_s__bindgen_ty_3,
    pub sdio_select: gpio_dev_s__bindgen_ty_4,
    pub enable: u32,
    pub enable_w1ts: u32,
    pub enable_w1tc: u32,
    pub enable1: gpio_dev_s__bindgen_ty_5,
    pub enable1_w1ts: gpio_dev_s__bindgen_ty_6,
    pub enable1_w1tc: gpio_dev_s__bindgen_ty_7,
    pub strap: gpio_dev_s__bindgen_ty_8,
    pub in_: u32,
    pub in1: gpio_dev_s__bindgen_ty_9,
    pub status: u32,
    pub status_w1ts: u32,
    pub status_w1tc: u32,
    pub status1: gpio_dev_s__bindgen_ty_10,
    pub status1_w1ts: gpio_dev_s__bindgen_ty_11,
    pub status1_w1tc: gpio_dev_s__bindgen_ty_12,
    pub reserved_5c: u32,
    pub acpu_int: u32,
    pub acpu_nmi_int: u32,
    pub pcpu_int: u32,
    pub pcpu_nmi_int: u32,
    pub cpusdio_int: u32,
    pub acpu_int1: gpio_dev_s__bindgen_ty_13,
    pub acpu_nmi_int1: gpio_dev_s__bindgen_ty_14,
    pub pcpu_int1: gpio_dev_s__bindgen_ty_15,
    pub pcpu_nmi_int1: gpio_dev_s__bindgen_ty_16,
    pub cpusdio_int1: gpio_dev_s__bindgen_ty_17,
    pub pin: [gpio_dev_s__bindgen_ty_18; 40usize],
    pub cali_conf: gpio_dev_s__bindgen_ty_19,
    pub cali_data: gpio_dev_s__bindgen_ty_20,
    pub func_in_sel_cfg: [gpio_dev_s__bindgen_ty_21; 256usize],
    pub func_out_sel_cfg: [gpio_dev_s__bindgen_ty_22; 40usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn strapping(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_strapping(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        strapping: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let strapping: u32 = unsafe { ::core::mem::transmute(strapping) };
            strapping as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn config(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_config(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn int_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_int_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pad_driver: u32,
        reserved3: u32,
        int_type: u32,
        wakeup_enable: u32,
        config: u32,
        int_ena: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::core::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::core::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::core::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let config: u32 = unsafe { ::core::mem::transmute(config) };
            config as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let int_ena: u32 = unsafe { ::core::mem::transmute(int_ena) };
            int_ena as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn rtc_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_max: u32,
        reserved10: u32,
        start: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rtc_max: u32 = unsafe { ::core::mem::transmute(rtc_max) };
            rtc_max as u64
        });
        __bindgen_bitfield_unit.set(10usize, 21u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn value_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_value_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_real(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_real(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value_sync2: u32,
        reserved20: u32,
        rdy_real: u32,
        rdy_sync2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let value_sync2: u32 = unsafe { ::core::mem::transmute(value_sync2) };
            value_sync2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rdy_real: u32 = unsafe { ::core::mem::transmute(rdy_real) };
            rdy_real as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rdy_sync2: u32 = unsafe { ::core::mem::transmute(rdy_sync2) };
            rdy_sync2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        sig_in_inv: u32,
        sig_in_sel: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sig_in_inv: u32 = unsafe { ::core::mem::transmute(sig_in_inv) };
            sig_in_inv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sig_in_sel: u32 = unsafe { ::core::mem::transmute(sig_in_sel) };
            sig_in_sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        inv_sel: u32,
        oen_sel: u32,
        oen_inv_sel: u32,
        reserved12: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inv_sel: u32 = unsafe { ::core::mem::transmute(inv_sel) };
            inv_sel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let oen_sel: u32 = unsafe { ::core::mem::transmute(oen_sel) };
            oen_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let oen_inv_sel: u32 = unsafe { ::core::mem::transmute(oen_inv_sel) };
            oen_inv_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpio_dev_t = gpio_dev_s;
extern "C" {
    pub static mut GPIO: gpio_dev_t;
}
extern "C" {
    pub static GPIO_PIN_MUX_REG: [u32; 40usize];
}
extern "C" {
    pub static GPIO_HOLD_MASK: [u32; 40usize];
}
pub const gpio_port_t_GPIO_PORT_0: gpio_port_t = 0;
pub const gpio_port_t_GPIO_PORT_MAX: gpio_port_t = 1;
pub type gpio_port_t = c_types::c_uint;
#[doc = "< Use to signal not connected to S/W"]
pub const gpio_num_t_GPIO_NUM_NC: gpio_num_t = -1;
#[doc = "< GPIO0, input and output"]
pub const gpio_num_t_GPIO_NUM_0: gpio_num_t = 0;
#[doc = "< GPIO1, input and output"]
pub const gpio_num_t_GPIO_NUM_1: gpio_num_t = 1;
#[doc = "< GPIO2, input and output"]
pub const gpio_num_t_GPIO_NUM_2: gpio_num_t = 2;
#[doc = "< GPIO3, input and output"]
pub const gpio_num_t_GPIO_NUM_3: gpio_num_t = 3;
#[doc = "< GPIO4, input and output"]
pub const gpio_num_t_GPIO_NUM_4: gpio_num_t = 4;
#[doc = "< GPIO5, input and output"]
pub const gpio_num_t_GPIO_NUM_5: gpio_num_t = 5;
#[doc = "< GPIO6, input and output"]
pub const gpio_num_t_GPIO_NUM_6: gpio_num_t = 6;
#[doc = "< GPIO7, input and output"]
pub const gpio_num_t_GPIO_NUM_7: gpio_num_t = 7;
#[doc = "< GPIO8, input and output"]
pub const gpio_num_t_GPIO_NUM_8: gpio_num_t = 8;
#[doc = "< GPIO9, input and output"]
pub const gpio_num_t_GPIO_NUM_9: gpio_num_t = 9;
#[doc = "< GPIO10, input and output"]
pub const gpio_num_t_GPIO_NUM_10: gpio_num_t = 10;
#[doc = "< GPIO11, input and output"]
pub const gpio_num_t_GPIO_NUM_11: gpio_num_t = 11;
#[doc = "< GPIO12, input and output"]
pub const gpio_num_t_GPIO_NUM_12: gpio_num_t = 12;
#[doc = "< GPIO13, input and output"]
pub const gpio_num_t_GPIO_NUM_13: gpio_num_t = 13;
#[doc = "< GPIO14, input and output"]
pub const gpio_num_t_GPIO_NUM_14: gpio_num_t = 14;
#[doc = "< GPIO15, input and output"]
pub const gpio_num_t_GPIO_NUM_15: gpio_num_t = 15;
#[doc = "< GPIO16, input and output"]
pub const gpio_num_t_GPIO_NUM_16: gpio_num_t = 16;
#[doc = "< GPIO17, input and output"]
pub const gpio_num_t_GPIO_NUM_17: gpio_num_t = 17;
#[doc = "< GPIO18, input and output"]
pub const gpio_num_t_GPIO_NUM_18: gpio_num_t = 18;
#[doc = "< GPIO19, input and output"]
pub const gpio_num_t_GPIO_NUM_19: gpio_num_t = 19;
#[doc = "< GPIO20, input and output"]
pub const gpio_num_t_GPIO_NUM_20: gpio_num_t = 20;
#[doc = "< GPIO21, input and output"]
pub const gpio_num_t_GPIO_NUM_21: gpio_num_t = 21;
#[doc = "< GPIO26, input and output"]
pub const gpio_num_t_GPIO_NUM_26: gpio_num_t = 26;
#[doc = "< GPIO27, input and output"]
pub const gpio_num_t_GPIO_NUM_27: gpio_num_t = 27;
#[doc = "< GPIO28, input and output"]
pub const gpio_num_t_GPIO_NUM_28: gpio_num_t = 28;
#[doc = "< GPIO29, input and output"]
pub const gpio_num_t_GPIO_NUM_29: gpio_num_t = 29;
#[doc = "< GPIO30, input and output"]
pub const gpio_num_t_GPIO_NUM_30: gpio_num_t = 30;
#[doc = "< GPIO31, input and output"]
pub const gpio_num_t_GPIO_NUM_31: gpio_num_t = 31;
#[doc = "< GPIO32, input and output"]
pub const gpio_num_t_GPIO_NUM_32: gpio_num_t = 32;
#[doc = "< GPIO33, input and output"]
pub const gpio_num_t_GPIO_NUM_33: gpio_num_t = 33;
#[doc = "< GPIO34, input mode only(ESP32) / input and output(ESP32-S2)"]
pub const gpio_num_t_GPIO_NUM_34: gpio_num_t = 34;
#[doc = "< GPIO35, input mode only(ESP32) / input and output(ESP32-S2)"]
pub const gpio_num_t_GPIO_NUM_35: gpio_num_t = 35;
#[doc = "< GPIO36, input mode only(ESP32) / input and output(ESP32-S2)"]
pub const gpio_num_t_GPIO_NUM_36: gpio_num_t = 36;
#[doc = "< GPIO37, input mode only(ESP32) / input and output(ESP32-S2)"]
pub const gpio_num_t_GPIO_NUM_37: gpio_num_t = 37;
#[doc = "< GPIO38, input mode only(ESP32) / input and output(ESP32-S2)"]
pub const gpio_num_t_GPIO_NUM_38: gpio_num_t = 38;
#[doc = "< GPIO39, input mode only(ESP32) / input and output(ESP32-S2)"]
pub const gpio_num_t_GPIO_NUM_39: gpio_num_t = 39;
pub const gpio_num_t_GPIO_NUM_MAX: gpio_num_t = 40;
#[doc = " @endcond"]
pub type gpio_num_t = c_types::c_int;
#[doc = "< Disable GPIO interrupt"]
pub const gpio_int_type_t_GPIO_INTR_DISABLE: gpio_int_type_t = 0;
#[doc = "< GPIO interrupt type : rising edge"]
pub const gpio_int_type_t_GPIO_INTR_POSEDGE: gpio_int_type_t = 1;
#[doc = "< GPIO interrupt type : falling edge"]
pub const gpio_int_type_t_GPIO_INTR_NEGEDGE: gpio_int_type_t = 2;
#[doc = "< GPIO interrupt type : both rising and falling edge"]
pub const gpio_int_type_t_GPIO_INTR_ANYEDGE: gpio_int_type_t = 3;
#[doc = "< GPIO interrupt type : input low level trigger"]
pub const gpio_int_type_t_GPIO_INTR_LOW_LEVEL: gpio_int_type_t = 4;
#[doc = "< GPIO interrupt type : input high level trigger"]
pub const gpio_int_type_t_GPIO_INTR_HIGH_LEVEL: gpio_int_type_t = 5;
pub const gpio_int_type_t_GPIO_INTR_MAX: gpio_int_type_t = 6;
pub type gpio_int_type_t = c_types::c_uint;
#[doc = "< GPIO mode : disable input and output"]
pub const gpio_mode_t_GPIO_MODE_DISABLE: gpio_mode_t = 0;
#[doc = "< GPIO mode : input only"]
pub const gpio_mode_t_GPIO_MODE_INPUT: gpio_mode_t = 1;
#[doc = "< GPIO mode : output only mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT: gpio_mode_t = 2;
#[doc = "< GPIO mode : output only with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT_OD: gpio_mode_t = 6;
#[doc = "< GPIO mode : output and input with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT_OD: gpio_mode_t = 7;
#[doc = "< GPIO mode : output and input mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT: gpio_mode_t = 3;
pub type gpio_mode_t = c_types::c_uint;
#[doc = "< Disable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_DISABLE: gpio_pullup_t = 0;
#[doc = "< Enable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_ENABLE: gpio_pullup_t = 1;
pub type gpio_pullup_t = c_types::c_uint;
#[doc = "< Disable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_DISABLE: gpio_pulldown_t = 0;
#[doc = "< Enable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_ENABLE: gpio_pulldown_t = 1;
pub type gpio_pulldown_t = c_types::c_uint;
#[doc = " @brief Configuration parameters of GPIO pad for gpio_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_config_t {
    #[doc = "< GPIO pin: set with bit mask, each bit maps to a GPIO"]
    pub pin_bit_mask: u64,
    #[doc = "< GPIO mode: set input/output mode"]
    pub mode: gpio_mode_t,
    #[doc = "< GPIO pull-up"]
    pub pull_up_en: gpio_pullup_t,
    #[doc = "< GPIO pull-down"]
    pub pull_down_en: gpio_pulldown_t,
    #[doc = "< GPIO interrupt type"]
    pub intr_type: gpio_int_type_t,
}
#[doc = "< Pad pull up"]
pub const gpio_pull_mode_t_GPIO_PULLUP_ONLY: gpio_pull_mode_t = 0;
#[doc = "< Pad pull down"]
pub const gpio_pull_mode_t_GPIO_PULLDOWN_ONLY: gpio_pull_mode_t = 1;
#[doc = "< Pad pull up + pull down"]
pub const gpio_pull_mode_t_GPIO_PULLUP_PULLDOWN: gpio_pull_mode_t = 2;
#[doc = "< Pad floating"]
pub const gpio_pull_mode_t_GPIO_FLOATING: gpio_pull_mode_t = 3;
pub type gpio_pull_mode_t = c_types::c_uint;
#[doc = "< Pad drive capability: weak"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_0: gpio_drive_cap_t = 0;
#[doc = "< Pad drive capability: stronger"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_1: gpio_drive_cap_t = 1;
#[doc = "< Pad drive capability: medium"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_2: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: medium"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_DEFAULT: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: strongest"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_3: gpio_drive_cap_t = 3;
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_MAX: gpio_drive_cap_t = 4;
pub type gpio_drive_cap_t = c_types::c_uint;
pub type gpio_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>;
pub type gpio_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief GPIO common configuration"]
    #[doc = ""]
    #[doc = "        Configure GPIO's Mode,pull-up,PullDown,IntrType"]
    #[doc = ""]
    #[doc = " @param  pGPIOConfig Pointer to GPIO configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_config(pGPIOConfig: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset an gpio to default state (select gpio function, enable pullup and disable input and output)."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @note This function also configures the IOMUX for this pin to the GPIO"]
    #[doc = "       function, and disconnects any other peripheral output configured via GPIO"]
    #[doc = "       Matrix."]
    #[doc = ""]
    #[doc = " @return Always return ESP_OK."]
    pub fn gpio_reset_pin(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set interrupt trigger type"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  intr_type Interrupt type, select from gpio_int_type_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK  Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Enable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @note Please do not use the interrupt of GPIO36 and GPIO39 when using ADC."]
    #[doc = "       Please refer to the comments of `adc1_get_raw`."]
    #[doc = "       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to enable an interrupt on e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_enable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to disable the interrupt of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set output level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the output level of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  level Output level. 0: low ; 1: high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO number error"]
    #[doc = ""]
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO get input level"]
    #[doc = ""]
    #[doc = " @warning If the pad is not configured for input (or input and output) the returned value is always 0."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to get the logic level of e.g. pin GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 the GPIO input level is 0"]
    #[doc = "     - 1 the GPIO input level is 1"]
    #[doc = ""]
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief\t GPIO set direction"]
    #[doc = ""]
    #[doc = " Configure GPIO direction,such as output_only,input_only,output_and_input"]
    #[doc = ""]
    #[doc = " @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = ""]
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors"]
    #[doc = ""]
    #[doc = " Only pins that support both input & output have integrated pull-up and pull-down resistors. Input-only GPIOs 34-39 do not."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  pull GPIO pull up/down mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG : Parameter error"]
    #[doc = ""]
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register GPIO interrupt handler, the handler is an ISR."]
    #[doc = "          The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " This ISR function is called whenever any GPIO interrupt occurs. See"]
    #[doc = " the alternative gpio_install_isr_service() and"]
    #[doc = " gpio_isr_handler_add() API in order to have the driver support"]
    #[doc = " per-GPIO ISRs."]
    #[doc = ""]
    #[doc = " @param  fn  Interrupt handler function."]
    #[doc = " @param  intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param  arg  Parameter for handler function"]
    #[doc = " @param  handle Pointer to return handle. If non-NULL, a handle for the interrupt will be returned here."]
    #[doc = ""]
    #[doc = " \\verbatim embed:rst:leading-asterisk"]
    #[doc = " To disable or remove the ISR, pass the returned handle to the :doc:`interrupt allocation functions </api-reference/system/intr_alloc>`."]
    #[doc = " \\endverbatim"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    pub fn gpio_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers."]
    #[doc = ""]
    #[doc = " This function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function."]
    #[doc = ""]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM No memory to install this service"]
    #[doc = "     - ESP_ERR_INVALID_STATE ISR service already installed."]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_install_isr_service(intr_alloc_flags: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the driver's GPIO ISR service, freeing related resources."]
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    #[doc = " @brief Add ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " Call this function after using gpio_install_isr_service() to"]
    #[doc = " install the driver's GPIO ISR handler service."]
    #[doc = ""]
    #[doc = " The pin ISR handlers no longer need to be declared with IRAM_ATTR,"]
    #[doc = " unless you pass the ESP_INTR_FLAG_IRAM flag when allocating the"]
    #[doc = " ISR in gpio_install_isr_service()."]
    #[doc = ""]
    #[doc = " This ISR handler will be called from an ISR. So there is a stack"]
    #[doc = " size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = " limit is smaller compared to a global GPIO interrupt handler due"]
    #[doc = " to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = " @param isr_handler ISR handler function for the corresponding GPIO number."]
    #[doc = " @param args parameter for ISR handler."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_set_drive_capability(gpio_num: gpio_num_t, strength: gpio_drive_cap_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Pointer to accept drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_get_drive_capability(
        gpio_num: gpio_num_t,
        strength: *mut gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable gpio pad hold function."]
    #[doc = ""]
    #[doc = " The gpio pad hold function works in both input and output modes, but must be output-capable gpios."]
    #[doc = " If pad hold enabled:"]
    #[doc = "   in output mode: the output level of the pad will be force locked and can not be changed."]
    #[doc = "   in input mode: the input value read will not change, regardless the changes of input signal."]
    #[doc = ""]
    #[doc = " The state of digital gpio cannot be held during Deep-sleep, and it will resume the hold function"]
    #[doc = " when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,"]
    #[doc = " `gpio_deep_sleep_hold_en` should also be called."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable gpio pad hold function."]
    #[doc = ""]
    #[doc = " When the chip is woken up from Deep-sleep, the gpio will be set to the default mode, so, the gpio will output"]
    #[doc = " the default level if this function is called. If you don't want the level changes, the gpio should be configured to"]
    #[doc = " a known state before this function is called."]
    #[doc = "  e.g."]
    #[doc = "     If you hold gpio18 high during Deep-sleep, after the chip is woken up and `gpio_hold_dis` is called,"]
    #[doc = "     gpio18 will output low level(because gpio18 is input mode by default). If you don't want this behavior,"]
    #[doc = "     you should configure gpio18 as output mode and set it to hight level before calling `gpio_hold_dis`."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    #[doc = " When the chip is in Deep-sleep mode, all digital gpio will hold the state before sleep, and when the chip is woken up,"]
    #[doc = " the status of digital gpio will not be held. Note that the pad hold feature only works when the chip is in Deep-sleep mode,"]
    #[doc = " when not in sleep mode, the digital gpio state can be changed even you have called this function."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function, otherwise, the digital gpio hold feature works as long as the chip enter Deep-sleep."]
    pub fn gpio_deep_sleep_hold_en();
}
extern "C" {
    #[doc = " @brief Disable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    pub fn gpio_deep_sleep_hold_dis();
}
extern "C" {
    #[doc = " @brief Set pad input to a peripheral signal through the IOMUX."]
    #[doc = " @param gpio_num GPIO number of the pad."]
    #[doc = " @param signal_idx Peripheral signal id to input. One of the ``*_IN_IDX`` signals in ``soc/gpio_sig_map.h``."]
    pub fn gpio_iomux_in(gpio_num: u32, signal_idx: u32);
}
extern "C" {
    #[doc = " @brief Set peripheral output to an GPIO pad through the IOMUX."]
    #[doc = " @param gpio_num gpio_num GPIO number of the pad."]
    #[doc = " @param func The function number of the peripheral pin to output pin."]
    #[doc = "        One of the ``FUNC_X_*`` of specified pin (X) in ``soc/io_mux_reg.h``."]
    #[doc = " @param oen_inv True if the output enable needs to be inverted, otherwise False."]
    pub fn gpio_iomux_out(gpio_num: u8, func: c_types::c_int, oen_inv: bool);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct syscon_dev_s {
    pub clk_conf: syscon_dev_s__bindgen_ty_1,
    pub xtal_tick_conf: syscon_dev_s__bindgen_ty_2,
    pub pll_tick_conf: syscon_dev_s__bindgen_ty_3,
    pub ck8m_tick_conf: syscon_dev_s__bindgen_ty_4,
    pub saradc_ctrl: syscon_dev_s__bindgen_ty_5,
    pub saradc_ctrl2: syscon_dev_s__bindgen_ty_6,
    pub saradc_fsm: syscon_dev_s__bindgen_ty_7,
    pub saradc_sar1_patt_tab: [u32; 4usize],
    pub saradc_sar2_patt_tab: [u32; 4usize],
    pub apll_tick_conf: syscon_dev_s__bindgen_ty_8,
    pub reserved_40: u32,
    pub reserved_44: u32,
    pub reserved_48: u32,
    pub reserved_4c: u32,
    pub reserved_50: u32,
    pub reserved_54: u32,
    pub reserved_58: u32,
    pub reserved_5c: u32,
    pub reserved_60: u32,
    pub reserved_64: u32,
    pub reserved_68: u32,
    pub reserved_6c: u32,
    pub reserved_70: u32,
    pub reserved_74: u32,
    pub reserved_78: u32,
    pub date: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl syscon_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pre_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_pre_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_320m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_320m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_tick(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_tick(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quick_clk_chng(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quick_clk_chng(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pre_div: u32,
        clk_320m_en: u32,
        clk_en: u32,
        rst_tick: u32,
        quick_clk_chng: u32,
        reserved14: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let pre_div: u32 = unsafe { ::core::mem::transmute(pre_div) };
            pre_div as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let clk_320m_en: u32 = unsafe { ::core::mem::transmute(clk_320m_en) };
            clk_320m_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rst_tick: u32 = unsafe { ::core::mem::transmute(rst_tick) };
            rst_tick as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let quick_clk_chng: u32 = unsafe { ::core::mem::transmute(quick_clk_chng) };
            quick_clk_chng as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl syscon_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn xtal_tick(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xtal_tick(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xtal_tick: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let xtal_tick: u32 = unsafe { ::core::mem::transmute(xtal_tick) };
            xtal_tick as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl syscon_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn pll_tick(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pll_tick(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pll_tick: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let pll_tick: u32 = unsafe { ::core::mem::transmute(pll_tick) };
            pll_tick as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl syscon_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn ck8m_tick(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_tick(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ck8m_tick: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ck8m_tick: u32 = unsafe { ::core::mem::transmute(ck8m_tick) };
            ck8m_tick as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl syscon_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn start_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_mux(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_mux(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn work_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_work_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_clk_gated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar_clk_gated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_clk_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar_clk_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_patt_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_patt_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_patt_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_patt_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_patt_p_clear(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_patt_p_clear(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_patt_p_clear(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_patt_p_clear(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_sar_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_sar_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_to_i2s(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_to_i2s(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        start_force: u32,
        start: u32,
        sar2_mux: u32,
        work_mode: u32,
        sar_sel: u32,
        sar_clk_gated: u32,
        sar_clk_div: u32,
        sar1_patt_len: u32,
        sar2_patt_len: u32,
        sar1_patt_p_clear: u32,
        sar2_patt_p_clear: u32,
        data_sar_sel: u32,
        data_to_i2s: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let start_force: u32 = unsafe { ::core::mem::transmute(start_force) };
            start_force as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sar2_mux: u32 = unsafe { ::core::mem::transmute(sar2_mux) };
            sar2_mux as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let work_mode: u32 = unsafe { ::core::mem::transmute(work_mode) };
            work_mode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sar_sel: u32 = unsafe { ::core::mem::transmute(sar_sel) };
            sar_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sar_clk_gated: u32 = unsafe { ::core::mem::transmute(sar_clk_gated) };
            sar_clk_gated as u64
        });
        __bindgen_bitfield_unit.set(7usize, 8u8, {
            let sar_clk_div: u32 = unsafe { ::core::mem::transmute(sar_clk_div) };
            sar_clk_div as u64
        });
        __bindgen_bitfield_unit.set(15usize, 4u8, {
            let sar1_patt_len: u32 = unsafe { ::core::mem::transmute(sar1_patt_len) };
            sar1_patt_len as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let sar2_patt_len: u32 = unsafe { ::core::mem::transmute(sar2_patt_len) };
            sar2_patt_len as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let sar1_patt_p_clear: u32 = unsafe { ::core::mem::transmute(sar1_patt_p_clear) };
            sar1_patt_p_clear as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sar2_patt_p_clear: u32 = unsafe { ::core::mem::transmute(sar2_patt_p_clear) };
            sar2_patt_p_clear as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let data_sar_sel: u32 = unsafe { ::core::mem::transmute(data_sar_sel) };
            data_sar_sel as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let data_to_i2s: u32 = unsafe { ::core::mem::transmute(data_to_i2s) };
            data_to_i2s as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl syscon_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn meas_num_limit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meas_num_limit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn max_meas_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_meas_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        meas_num_limit: u32,
        max_meas_num: u32,
        sar1_inv: u32,
        sar2_inv: u32,
        reserved11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let meas_num_limit: u32 = unsafe { ::core::mem::transmute(meas_num_limit) };
            meas_num_limit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 8u8, {
            let max_meas_num: u32 = unsafe { ::core::mem::transmute(max_meas_num) };
            max_meas_num as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sar1_inv: u32 = unsafe { ::core::mem::transmute(sar1_inv) };
            sar1_inv as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sar2_inv: u32 = unsafe { ::core::mem::transmute(sar2_inv) };
            sar2_inv as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl syscon_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn rstb_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rstb_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn standby_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_standby_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn start_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_start_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_cycle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_cycle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rstb_wait: u32,
        standby_wait: u32,
        start_wait: u32,
        sample_cycle: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rstb_wait: u32 = unsafe { ::core::mem::transmute(rstb_wait) };
            rstb_wait as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let standby_wait: u32 = unsafe { ::core::mem::transmute(standby_wait) };
            standby_wait as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let start_wait: u32 = unsafe { ::core::mem::transmute(start_wait) };
            start_wait as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let sample_cycle: u32 = unsafe { ::core::mem::transmute(sample_cycle) };
            sample_cycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syscon_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: syscon_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct syscon_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl syscon_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn apll_tick(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_apll_tick(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        apll_tick: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let apll_tick: u32 = unsafe { ::core::mem::transmute(apll_tick) };
            apll_tick as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type syscon_dev_t = syscon_dev_s;
extern "C" {
    pub static mut SYSCON: syscon_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sens_dev_s {
    pub sar_read_ctrl: sens_dev_s__bindgen_ty_1,
    pub sar_read_status1: u32,
    pub sar_meas_wait1: sens_dev_s__bindgen_ty_2,
    pub sar_meas_wait2: sens_dev_s__bindgen_ty_3,
    pub sar_meas_ctrl: sens_dev_s__bindgen_ty_4,
    pub sar_read_status2: u32,
    pub ulp_cp_sleep_cyc0: u32,
    pub ulp_cp_sleep_cyc1: u32,
    pub ulp_cp_sleep_cyc2: u32,
    pub ulp_cp_sleep_cyc3: u32,
    pub ulp_cp_sleep_cyc4: u32,
    pub sar_start_force: sens_dev_s__bindgen_ty_5,
    pub sar_mem_wr_ctrl: sens_dev_s__bindgen_ty_6,
    pub sar_atten1: u32,
    pub sar_atten2: u32,
    pub sar_slave_addr1: sens_dev_s__bindgen_ty_7,
    pub sar_slave_addr2: sens_dev_s__bindgen_ty_8,
    pub sar_slave_addr3: sens_dev_s__bindgen_ty_9,
    pub sar_slave_addr4: sens_dev_s__bindgen_ty_10,
    pub sar_tctrl: sens_dev_s__bindgen_ty_11,
    pub sar_i2c_ctrl: sens_dev_s__bindgen_ty_12,
    pub sar_meas_start1: sens_dev_s__bindgen_ty_13,
    pub sar_touch_ctrl1: sens_dev_s__bindgen_ty_14,
    pub touch_thresh: [sens_dev_s__bindgen_ty_15; 5usize],
    pub touch_meas: [sens_dev_s__bindgen_ty_16; 5usize],
    pub sar_touch_ctrl2: sens_dev_s__bindgen_ty_17,
    pub reserved_88: u32,
    pub sar_touch_enable: sens_dev_s__bindgen_ty_18,
    pub sar_read_ctrl2: sens_dev_s__bindgen_ty_19,
    pub sar_meas_start2: sens_dev_s__bindgen_ty_20,
    pub sar_dac_ctrl1: sens_dev_s__bindgen_ty_21,
    pub sar_dac_ctrl2: sens_dev_s__bindgen_ty_22,
    pub sar_meas_ctrl2: sens_dev_s__bindgen_ty_23,
    pub reserved_a4: u32,
    pub reserved_a8: u32,
    pub reserved_ac: u32,
    pub reserved_b0: u32,
    pub reserved_b4: u32,
    pub reserved_b8: u32,
    pub reserved_bc: u32,
    pub reserved_c0: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub reserved_f0: u32,
    pub reserved_f4: u32,
    pub sar_nouse: u32,
    pub sardate: sens_dev_s__bindgen_ty_24,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl sens_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sar1_clk_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_clk_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_sample_cycle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_sample_cycle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_sample_bit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_sample_bit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_clk_gated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_clk_gated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_sample_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_sample_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_dig_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_dig_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_data_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_data_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar1_clk_div: u32,
        sar1_sample_cycle: u32,
        sar1_sample_bit: u32,
        sar1_clk_gated: u32,
        sar1_sample_num: u32,
        sar1_dig_force: u32,
        sar1_data_inv: u32,
        reserved29: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sar1_clk_div: u32 = unsafe { ::core::mem::transmute(sar1_clk_div) };
            sar1_clk_div as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sar1_sample_cycle: u32 = unsafe { ::core::mem::transmute(sar1_sample_cycle) };
            sar1_sample_cycle as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let sar1_sample_bit: u32 = unsafe { ::core::mem::transmute(sar1_sample_bit) };
            sar1_sample_bit as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sar1_clk_gated: u32 = unsafe { ::core::mem::transmute(sar1_clk_gated) };
            sar1_clk_gated as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let sar1_sample_num: u32 = unsafe { ::core::mem::transmute(sar1_sample_num) };
            sar1_sample_num as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let sar1_dig_force: u32 = unsafe { ::core::mem::transmute(sar1_dig_force) };
            sar1_dig_force as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sar1_data_inv: u32 = unsafe { ::core::mem::transmute(sar1_data_inv) };
            sar1_data_inv as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn sar_amp_wait1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sar_amp_wait1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_amp_wait2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sar_amp_wait2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar_amp_wait1: u32,
        sar_amp_wait2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let sar_amp_wait1: u32 = unsafe { ::core::mem::transmute(sar_amp_wait1) };
            sar_amp_wait1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let sar_amp_wait2: u32 = unsafe { ::core::mem::transmute(sar_amp_wait2) };
            sar_amp_wait2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn sar_amp_wait3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sar_amp_wait3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn force_xpd_amp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_force_xpd_amp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn force_xpd_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_force_xpd_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_rstb_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_rstb_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar_amp_wait3: u32,
        force_xpd_amp: u32,
        force_xpd_sar: u32,
        sar2_rstb_wait: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let sar_amp_wait3: u32 = unsafe { ::core::mem::transmute(sar_amp_wait3) };
            sar_amp_wait3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let force_xpd_amp: u32 = unsafe { ::core::mem::transmute(force_xpd_amp) };
            force_xpd_amp as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let force_xpd_sar: u32 = unsafe { ::core::mem::transmute(force_xpd_sar) };
            force_xpd_sar as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let sar2_rstb_wait: u32 = unsafe { ::core::mem::transmute(sar2_rstb_wait) };
            sar2_rstb_wait as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl sens_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn xpd_sar_amp_fsm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_sar_amp_fsm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_rst_fb_fsm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_amp_rst_fb_fsm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_short_ref_fsm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_amp_short_ref_fsm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_short_ref_gnd_fsm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_amp_short_ref_gnd_fsm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_sar_fsm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_sar_fsm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_rstb_fsm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sar_rstb_fsm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_xpd_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_xpd_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xpd_sar_amp_fsm: u32,
        amp_rst_fb_fsm: u32,
        amp_short_ref_fsm: u32,
        amp_short_ref_gnd_fsm: u32,
        xpd_sar_fsm: u32,
        sar_rstb_fsm: u32,
        sar2_xpd_wait: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let xpd_sar_amp_fsm: u32 = unsafe { ::core::mem::transmute(xpd_sar_amp_fsm) };
            xpd_sar_amp_fsm as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let amp_rst_fb_fsm: u32 = unsafe { ::core::mem::transmute(amp_rst_fb_fsm) };
            amp_rst_fb_fsm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let amp_short_ref_fsm: u32 = unsafe { ::core::mem::transmute(amp_short_ref_fsm) };
            amp_short_ref_fsm as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let amp_short_ref_gnd_fsm: u32 =
                unsafe { ::core::mem::transmute(amp_short_ref_gnd_fsm) };
            amp_short_ref_gnd_fsm as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let xpd_sar_fsm: u32 = unsafe { ::core::mem::transmute(xpd_sar_fsm) };
            xpd_sar_fsm as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let sar_rstb_fsm: u32 = unsafe { ::core::mem::transmute(sar_rstb_fsm) };
            sar_rstb_fsm as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let sar2_xpd_wait: u32 = unsafe { ::core::mem::transmute(sar2_xpd_wait) };
            sar2_xpd_wait as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn sar1_bit_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_bit_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_bit_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_bit_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_en_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_en_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_pwdet_cct(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_pwdet_cct(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ulp_cp_force_start_top(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_force_start_top(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ulp_cp_start_top(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_start_top(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sarclk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sarclk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pc_init(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_pc_init(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_pwdet_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_pwdet_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar1_bit_width: u32,
        sar2_bit_width: u32,
        sar2_en_test: u32,
        sar2_pwdet_cct: u32,
        ulp_cp_force_start_top: u32,
        ulp_cp_start_top: u32,
        sarclk_en: u32,
        pc_init: u32,
        sar2_stop: u32,
        sar1_stop: u32,
        sar2_pwdet_en: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sar1_bit_width: u32 = unsafe { ::core::mem::transmute(sar1_bit_width) };
            sar1_bit_width as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let sar2_bit_width: u32 = unsafe { ::core::mem::transmute(sar2_bit_width) };
            sar2_bit_width as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sar2_en_test: u32 = unsafe { ::core::mem::transmute(sar2_en_test) };
            sar2_en_test as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let sar2_pwdet_cct: u32 = unsafe { ::core::mem::transmute(sar2_pwdet_cct) };
            sar2_pwdet_cct as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ulp_cp_force_start_top: u32 =
                unsafe { ::core::mem::transmute(ulp_cp_force_start_top) };
            ulp_cp_force_start_top as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ulp_cp_start_top: u32 = unsafe { ::core::mem::transmute(ulp_cp_start_top) };
            ulp_cp_start_top as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sarclk_en: u32 = unsafe { ::core::mem::transmute(sarclk_en) };
            sarclk_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let pc_init: u32 = unsafe { ::core::mem::transmute(pc_init) };
            pc_init as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sar2_stop: u32 = unsafe { ::core::mem::transmute(sar2_stop) };
            sar2_stop as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let sar1_stop: u32 = unsafe { ::core::mem::transmute(sar1_stop) };
            sar1_stop as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sar2_pwdet_en: u32 = unsafe { ::core::mem::transmute(sar2_pwdet_en) };
            sar2_pwdet_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn mem_wr_addr_init(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_mem_wr_addr_init(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_wr_addr_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_mem_wr_addr_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_mem_wr_offst_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_mem_wr_offst_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mem_wr_addr_init: u32,
        mem_wr_addr_size: u32,
        rtc_mem_wr_offst_clr: u32,
        reserved23: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let mem_wr_addr_init: u32 = unsafe { ::core::mem::transmute(mem_wr_addr_init) };
            mem_wr_addr_init as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let mem_wr_addr_size: u32 = unsafe { ::core::mem::transmute(mem_wr_addr_size) };
            mem_wr_addr_size as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let rtc_mem_wr_offst_clr: u32 = unsafe { ::core::mem::transmute(rtc_mem_wr_offst_clr) };
            rtc_mem_wr_offst_clr as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let reserved23: u32 = unsafe { ::core::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn i2c_slave_addr1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_slave_addr0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn meas_status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_meas_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        i2c_slave_addr1: u32,
        i2c_slave_addr0: u32,
        meas_status: u32,
        reserved30: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let i2c_slave_addr1: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr1) };
            i2c_slave_addr1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let i2c_slave_addr0: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr0) };
            i2c_slave_addr0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 8u8, {
            let meas_status: u32 = unsafe { ::core::mem::transmute(meas_status) };
            meas_status as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved30: u32 = unsafe { ::core::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn i2c_slave_addr3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_slave_addr2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        i2c_slave_addr3: u32,
        i2c_slave_addr2: u32,
        reserved22: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let i2c_slave_addr3: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr3) };
            i2c_slave_addr3 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let i2c_slave_addr2: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr2) };
            i2c_slave_addr2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved22: u32 = unsafe { ::core::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn i2c_slave_addr5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_slave_addr4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_rdy_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_rdy_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        i2c_slave_addr5: u32,
        i2c_slave_addr4: u32,
        tsens_out: u32,
        tsens_rdy_out: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let i2c_slave_addr5: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr5) };
            i2c_slave_addr5 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let i2c_slave_addr4: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr4) };
            i2c_slave_addr4 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 8u8, {
            let tsens_out: u32 = unsafe { ::core::mem::transmute(tsens_out) };
            tsens_out as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let tsens_rdy_out: u32 = unsafe { ::core::mem::transmute(tsens_rdy_out) };
            tsens_rdy_out as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn i2c_slave_addr7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_slave_addr6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_slave_addr6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_rdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_rdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn i2c_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_i2c_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        i2c_slave_addr7: u32,
        i2c_slave_addr6: u32,
        i2c_rdata: u32,
        i2c_done: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let i2c_slave_addr7: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr7) };
            i2c_slave_addr7 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let i2c_slave_addr6: u32 = unsafe { ::core::mem::transmute(i2c_slave_addr6) };
            i2c_slave_addr6 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 8u8, {
            let i2c_rdata: u32 = unsafe { ::core::mem::transmute(i2c_rdata) };
            i2c_rdata as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let i2c_done: u32 = unsafe { ::core::mem::transmute(i2c_done) };
            i2c_done as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn tsens_xpd_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_xpd_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_xpd_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_xpd_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_clk_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_clk_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_clk_gated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_clk_gated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_clk_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_clk_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_power_up(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_power_up(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_power_up_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_power_up_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsens_dump_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tsens_dump_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tsens_xpd_wait: u32,
        tsens_xpd_force: u32,
        tsens_clk_inv: u32,
        tsens_clk_gated: u32,
        tsens_in_inv: u32,
        tsens_clk_div: u32,
        tsens_power_up: u32,
        tsens_power_up_force: u32,
        tsens_dump_out: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let tsens_xpd_wait: u32 = unsafe { ::core::mem::transmute(tsens_xpd_wait) };
            tsens_xpd_wait as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tsens_xpd_force: u32 = unsafe { ::core::mem::transmute(tsens_xpd_force) };
            tsens_xpd_force as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tsens_clk_inv: u32 = unsafe { ::core::mem::transmute(tsens_clk_inv) };
            tsens_clk_inv as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tsens_clk_gated: u32 = unsafe { ::core::mem::transmute(tsens_clk_gated) };
            tsens_clk_gated as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tsens_in_inv: u32 = unsafe { ::core::mem::transmute(tsens_in_inv) };
            tsens_in_inv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let tsens_clk_div: u32 = unsafe { ::core::mem::transmute(tsens_clk_div) };
            tsens_clk_div as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tsens_power_up: u32 = unsafe { ::core::mem::transmute(tsens_power_up) };
            tsens_power_up as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let tsens_power_up_force: u32 = unsafe { ::core::mem::transmute(tsens_power_up_force) };
            tsens_power_up_force as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let tsens_dump_out: u32 = unsafe { ::core::mem::transmute(tsens_dump_out) };
            tsens_dump_out as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl sens_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn sar_i2c_ctrl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_sar_i2c_ctrl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_i2c_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar_i2c_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_i2c_start_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar_i2c_start_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar_i2c_ctrl: u32,
        sar_i2c_start: u32,
        sar_i2c_start_force: u32,
        reserved30: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let sar_i2c_ctrl: u32 = unsafe { ::core::mem::transmute(sar_i2c_ctrl) };
            sar_i2c_ctrl as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sar_i2c_start: u32 = unsafe { ::core::mem::transmute(sar_i2c_start) };
            sar_i2c_start as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sar_i2c_start_force: u32 = unsafe { ::core::mem::transmute(sar_i2c_start_force) };
            sar_i2c_start_force as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved30: u32 = unsafe { ::core::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn meas1_data_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_meas1_data_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn meas1_done_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meas1_done_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn meas1_start_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meas1_start_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn meas1_start_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meas1_start_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_en_pad(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_en_pad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_en_pad_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_en_pad_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        meas1_data_sar: u32,
        meas1_done_sar: u32,
        meas1_start_sar: u32,
        meas1_start_force: u32,
        sar1_en_pad: u32,
        sar1_en_pad_force: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let meas1_data_sar: u32 = unsafe { ::core::mem::transmute(meas1_data_sar) };
            meas1_data_sar as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let meas1_done_sar: u32 = unsafe { ::core::mem::transmute(meas1_done_sar) };
            meas1_done_sar as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let meas1_start_sar: u32 = unsafe { ::core::mem::transmute(meas1_start_sar) };
            meas1_start_sar as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let meas1_start_force: u32 = unsafe { ::core::mem::transmute(meas1_start_force) };
            meas1_start_force as u64
        });
        __bindgen_bitfield_unit.set(19usize, 12u8, {
            let sar1_en_pad: u32 = unsafe { ::core::mem::transmute(sar1_en_pad) };
            sar1_en_pad as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sar1_en_pad_force: u32 = unsafe { ::core::mem::transmute(sar1_en_pad_force) };
            sar1_en_pad_force as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn touch_meas_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_touch_meas_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_xpd_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_touch_xpd_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_out_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_out_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_out_1en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_out_1en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_hall_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_hall_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hall_phase_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hall_phase_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        touch_meas_delay: u32,
        touch_xpd_wait: u32,
        touch_out_sel: u32,
        touch_out_1en: u32,
        xpd_hall_force: u32,
        hall_phase_force: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let touch_meas_delay: u32 = unsafe { ::core::mem::transmute(touch_meas_delay) };
            touch_meas_delay as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let touch_xpd_wait: u32 = unsafe { ::core::mem::transmute(touch_xpd_wait) };
            touch_xpd_wait as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let touch_out_sel: u32 = unsafe { ::core::mem::transmute(touch_out_sel) };
            touch_out_sel as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let touch_out_1en: u32 = unsafe { ::core::mem::transmute(touch_out_1en) };
            touch_out_1en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let xpd_hall_force: u32 = unsafe { ::core::mem::transmute(xpd_hall_force) };
            xpd_hall_force as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let hall_phase_force: u32 = unsafe { ::core::mem::transmute(hall_phase_force) };
            hall_phase_force as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn l_thresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_l_thresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn h_thresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_h_thresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l_thresh: u32,
        h_thresh: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let l_thresh: u32 = unsafe { ::core::mem::transmute(l_thresh) };
            l_thresh as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let h_thresh: u32 = unsafe { ::core::mem::transmute(h_thresh) };
            h_thresh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn l_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_l_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn h_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_h_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(l_val: u32, h_val: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let l_val: u32 = unsafe { ::core::mem::transmute(l_val) };
            l_val as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let h_val: u32 = unsafe { ::core::mem::transmute(h_val) };
            h_val as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn touch_meas_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_touch_meas_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_meas_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_meas_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_start_fsm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_start_fsm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_start_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_start_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_start_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_start_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_sleep_cycles(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_touch_sleep_cycles(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_meas_en_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_meas_en_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        touch_meas_en: u32,
        touch_meas_done: u32,
        touch_start_fsm_en: u32,
        touch_start_en: u32,
        touch_start_force: u32,
        touch_sleep_cycles: u32,
        touch_meas_en_clr: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let touch_meas_en: u32 = unsafe { ::core::mem::transmute(touch_meas_en) };
            touch_meas_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let touch_meas_done: u32 = unsafe { ::core::mem::transmute(touch_meas_done) };
            touch_meas_done as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let touch_start_fsm_en: u32 = unsafe { ::core::mem::transmute(touch_start_fsm_en) };
            touch_start_fsm_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let touch_start_en: u32 = unsafe { ::core::mem::transmute(touch_start_en) };
            touch_start_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let touch_start_force: u32 = unsafe { ::core::mem::transmute(touch_start_force) };
            touch_start_force as u64
        });
        __bindgen_bitfield_unit.set(14usize, 16u8, {
            let touch_sleep_cycles: u32 = unsafe { ::core::mem::transmute(touch_sleep_cycles) };
            touch_sleep_cycles as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let touch_meas_en_clr: u32 = unsafe { ::core::mem::transmute(touch_meas_en_clr) };
            touch_meas_en_clr as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn touch_pad_worken(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad_worken(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad_outen2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad_outen2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad_outen1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad_outen1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        touch_pad_worken: u32,
        touch_pad_outen2: u32,
        touch_pad_outen1: u32,
        reserved30: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let touch_pad_worken: u32 = unsafe { ::core::mem::transmute(touch_pad_worken) };
            touch_pad_worken as u64
        });
        __bindgen_bitfield_unit.set(10usize, 10u8, {
            let touch_pad_outen2: u32 = unsafe { ::core::mem::transmute(touch_pad_outen2) };
            touch_pad_outen2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let touch_pad_outen1: u32 = unsafe { ::core::mem::transmute(touch_pad_outen1) };
            touch_pad_outen1 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved30: u32 = unsafe { ::core::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl sens_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn sar2_clk_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_clk_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_sample_cycle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_sample_cycle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_sample_bit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_sample_bit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_clk_gated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_clk_gated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_sample_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_sample_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_pwdet_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_pwdet_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_dig_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_dig_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_data_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_data_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar2_clk_div: u32,
        sar2_sample_cycle: u32,
        sar2_sample_bit: u32,
        sar2_clk_gated: u32,
        sar2_sample_num: u32,
        sar2_pwdet_force: u32,
        sar2_dig_force: u32,
        sar2_data_inv: u32,
        reserved30: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sar2_clk_div: u32 = unsafe { ::core::mem::transmute(sar2_clk_div) };
            sar2_clk_div as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sar2_sample_cycle: u32 = unsafe { ::core::mem::transmute(sar2_sample_cycle) };
            sar2_sample_cycle as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let sar2_sample_bit: u32 = unsafe { ::core::mem::transmute(sar2_sample_bit) };
            sar2_sample_bit as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sar2_clk_gated: u32 = unsafe { ::core::mem::transmute(sar2_clk_gated) };
            sar2_clk_gated as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let sar2_sample_num: u32 = unsafe { ::core::mem::transmute(sar2_sample_num) };
            sar2_sample_num as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let sar2_pwdet_force: u32 = unsafe { ::core::mem::transmute(sar2_pwdet_force) };
            sar2_pwdet_force as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sar2_dig_force: u32 = unsafe { ::core::mem::transmute(sar2_dig_force) };
            sar2_dig_force as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sar2_data_inv: u32 = unsafe { ::core::mem::transmute(sar2_data_inv) };
            sar2_data_inv as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved30: u32 = unsafe { ::core::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn meas2_data_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_meas2_data_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn meas2_done_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meas2_done_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn meas2_start_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meas2_start_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn meas2_start_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meas2_start_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_en_pad(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_en_pad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_en_pad_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_en_pad_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        meas2_data_sar: u32,
        meas2_done_sar: u32,
        meas2_start_sar: u32,
        meas2_start_force: u32,
        sar2_en_pad: u32,
        sar2_en_pad_force: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let meas2_data_sar: u32 = unsafe { ::core::mem::transmute(meas2_data_sar) };
            meas2_data_sar as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let meas2_done_sar: u32 = unsafe { ::core::mem::transmute(meas2_done_sar) };
            meas2_done_sar as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let meas2_start_sar: u32 = unsafe { ::core::mem::transmute(meas2_start_sar) };
            meas2_start_sar as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let meas2_start_force: u32 = unsafe { ::core::mem::transmute(meas2_start_force) };
            meas2_start_force as u64
        });
        __bindgen_bitfield_unit.set(19usize, 12u8, {
            let sar2_en_pad: u32 = unsafe { ::core::mem::transmute(sar2_en_pad) };
            sar2_en_pad as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sar2_en_pad_force: u32 = unsafe { ::core::mem::transmute(sar2_en_pad_force) };
            sar2_en_pad_force as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn sw_fstep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sw_fstep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_tone_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_tone_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_bit_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_debug_bit_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_dig_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_dig_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_clk_force_low(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_clk_force_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_clk_force_high(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_clk_force_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_clk_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_clk_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sw_fstep: u32,
        sw_tone_en: u32,
        debug_bit_sel: u32,
        dac_dig_force: u32,
        dac_clk_force_low: u32,
        dac_clk_force_high: u32,
        dac_clk_inv: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let sw_fstep: u32 = unsafe { ::core::mem::transmute(sw_fstep) };
            sw_fstep as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sw_tone_en: u32 = unsafe { ::core::mem::transmute(sw_tone_en) };
            sw_tone_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let debug_bit_sel: u32 = unsafe { ::core::mem::transmute(debug_bit_sel) };
            debug_bit_sel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let dac_dig_force: u32 = unsafe { ::core::mem::transmute(dac_dig_force) };
            dac_dig_force as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let dac_clk_force_low: u32 = unsafe { ::core::mem::transmute(dac_clk_force_low) };
            dac_clk_force_low as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let dac_clk_force_high: u32 = unsafe { ::core::mem::transmute(dac_clk_force_high) };
            dac_clk_force_high as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let dac_clk_inv: u32 = unsafe { ::core::mem::transmute(dac_clk_inv) };
            dac_clk_inv as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl sens_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn dac_dc1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dac_dc1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_dc2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dac_dc2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_scale1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dac_scale1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_scale2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dac_scale2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_inv1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dac_inv1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_inv2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dac_inv2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_cw_en1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_cw_en1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_cw_en2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_cw_en2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dac_dc1: u32,
        dac_dc2: u32,
        dac_scale1: u32,
        dac_scale2: u32,
        dac_inv1: u32,
        dac_inv2: u32,
        dac_cw_en1: u32,
        dac_cw_en2: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let dac_dc1: u32 = unsafe { ::core::mem::transmute(dac_dc1) };
            dac_dc1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let dac_dc2: u32 = unsafe { ::core::mem::transmute(dac_dc2) };
            dac_dc2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let dac_scale1: u32 = unsafe { ::core::mem::transmute(dac_scale1) };
            dac_scale1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let dac_scale2: u32 = unsafe { ::core::mem::transmute(dac_scale2) };
            dac_scale2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let dac_inv1: u32 = unsafe { ::core::mem::transmute(dac_inv1) };
            dac_inv1 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let dac_inv2: u32 = unsafe { ::core::mem::transmute(dac_inv2) };
            dac_inv2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let dac_cw_en1: u32 = unsafe { ::core::mem::transmute(dac_cw_en1) };
            dac_cw_en1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let dac_cw_en2: u32 = unsafe { ::core::mem::transmute(dac_cw_en2) };
            dac_cw_en2 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl sens_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn sar1_dac_xpd_fsm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_dac_xpd_fsm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sar1_dac_xpd_fsm_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar1_dac_xpd_fsm_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_sar_amp_fsm_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_sar_amp_fsm_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_rst_fb_fsm_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_amp_rst_fb_fsm_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_short_ref_fsm_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_amp_short_ref_fsm_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_short_ref_gnd_fsm_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_amp_short_ref_gnd_fsm_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_sar_fsm_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_sar_fsm_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar_rstb_fsm_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sar_rstb_fsm_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sar2_rstb_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sar2_rstb_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_rst_fb_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_amp_rst_fb_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_short_ref_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_amp_short_ref_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn amp_short_ref_gnd_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_amp_short_ref_gnd_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar1_dac_xpd_fsm: u32,
        sar1_dac_xpd_fsm_idle: u32,
        xpd_sar_amp_fsm_idle: u32,
        amp_rst_fb_fsm_idle: u32,
        amp_short_ref_fsm_idle: u32,
        amp_short_ref_gnd_fsm_idle: u32,
        xpd_sar_fsm_idle: u32,
        sar_rstb_fsm_idle: u32,
        sar2_rstb_force: u32,
        amp_rst_fb_force: u32,
        amp_short_ref_force: u32,
        amp_short_ref_gnd_force: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sar1_dac_xpd_fsm: u32 = unsafe { ::core::mem::transmute(sar1_dac_xpd_fsm) };
            sar1_dac_xpd_fsm as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sar1_dac_xpd_fsm_idle: u32 =
                unsafe { ::core::mem::transmute(sar1_dac_xpd_fsm_idle) };
            sar1_dac_xpd_fsm_idle as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let xpd_sar_amp_fsm_idle: u32 = unsafe { ::core::mem::transmute(xpd_sar_amp_fsm_idle) };
            xpd_sar_amp_fsm_idle as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let amp_rst_fb_fsm_idle: u32 = unsafe { ::core::mem::transmute(amp_rst_fb_fsm_idle) };
            amp_rst_fb_fsm_idle as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let amp_short_ref_fsm_idle: u32 =
                unsafe { ::core::mem::transmute(amp_short_ref_fsm_idle) };
            amp_short_ref_fsm_idle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let amp_short_ref_gnd_fsm_idle: u32 =
                unsafe { ::core::mem::transmute(amp_short_ref_gnd_fsm_idle) };
            amp_short_ref_gnd_fsm_idle as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let xpd_sar_fsm_idle: u32 = unsafe { ::core::mem::transmute(xpd_sar_fsm_idle) };
            xpd_sar_fsm_idle as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sar_rstb_fsm_idle: u32 = unsafe { ::core::mem::transmute(sar_rstb_fsm_idle) };
            sar_rstb_fsm_idle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let sar2_rstb_force: u32 = unsafe { ::core::mem::transmute(sar2_rstb_force) };
            sar2_rstb_force as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let amp_rst_fb_force: u32 = unsafe { ::core::mem::transmute(amp_rst_fb_force) };
            amp_rst_fb_force as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let amp_short_ref_force: u32 = unsafe { ::core::mem::transmute(amp_short_ref_force) };
            amp_short_ref_force as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let amp_short_ref_gnd_force: u32 =
                unsafe { ::core::mem::transmute(amp_short_ref_gnd_force) };
            amp_short_ref_gnd_force as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sens_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: sens_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sens_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl sens_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn sar_date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_sar_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sar_date: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let sar_date: u32 = unsafe { ::core::mem::transmute(sar_date) };
            sar_date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type sens_dev_t = sens_dev_s;
extern "C" {
    pub static mut SENS: sens_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_io_dev_s {
    pub out: rtc_io_dev_s__bindgen_ty_1,
    pub out_w1ts: rtc_io_dev_s__bindgen_ty_2,
    pub out_w1tc: rtc_io_dev_s__bindgen_ty_3,
    pub enable: rtc_io_dev_s__bindgen_ty_4,
    pub enable_w1ts: rtc_io_dev_s__bindgen_ty_5,
    pub enable_w1tc: rtc_io_dev_s__bindgen_ty_6,
    pub status: rtc_io_dev_s__bindgen_ty_7,
    pub status_w1ts: rtc_io_dev_s__bindgen_ty_8,
    pub status_w1tc: rtc_io_dev_s__bindgen_ty_9,
    pub in_val: rtc_io_dev_s__bindgen_ty_10,
    pub pin: [rtc_io_dev_s__bindgen_ty_11; 18usize],
    pub debug_sel: rtc_io_dev_s__bindgen_ty_12,
    pub dig_pad_hold: u32,
    pub hall_sens: rtc_io_dev_s__bindgen_ty_13,
    pub sensor_pads: rtc_io_dev_s__bindgen_ty_14,
    pub adc_pad: rtc_io_dev_s__bindgen_ty_15,
    pub pad_dac: [rtc_io_dev_s__bindgen_ty_16; 2usize],
    pub xtal_32k_pad: rtc_io_dev_s__bindgen_ty_17,
    pub touch_cfg: rtc_io_dev_s__bindgen_ty_18,
    pub touch_pad: [rtc_io_dev_s__bindgen_ty_19; 10usize],
    pub ext_wakeup0: rtc_io_dev_s__bindgen_ty_20,
    pub xtl_ext_ctr: rtc_io_dev_s__bindgen_ty_21,
    pub sar_i2c_io: rtc_io_dev_s__bindgen_ty_22,
    pub date: rtc_io_dev_s__bindgen_ty_23,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, data: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1ts: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1ts: u32 = unsafe { ::core::mem::transmute(w1ts) };
            w1ts as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1tc: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1tc: u32 = unsafe { ::core::mem::transmute(w1tc) };
            w1tc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, enable: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let enable: u32 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1ts: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1ts: u32 = unsafe { ::core::mem::transmute(w1ts) };
            w1ts as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1tc: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1tc: u32 = unsafe { ::core::mem::transmute(w1tc) };
            w1tc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, status: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1ts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1ts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1ts: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1ts: u32 = unsafe { ::core::mem::transmute(w1ts) };
            w1ts as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn w1tc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_w1tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, w1tc: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let w1tc: u32 = unsafe { ::core::mem::transmute(w1tc) };
            w1tc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn in_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_in(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, in_: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let in_: u32 = unsafe { ::core::mem::transmute(in_) };
            in_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pad_driver: u32,
        reserved3: u32,
        int_type: u32,
        wakeup_enable: u32,
        reserved11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::core::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::core::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::core::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_io_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn sel0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sel4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn no_gating_12m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_gating_12m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sel0: u32,
        sel1: u32,
        sel2: u32,
        sel3: u32,
        sel4: u32,
        no_gating_12m: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let sel0: u32 = unsafe { ::core::mem::transmute(sel0) };
            sel0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let sel1: u32 = unsafe { ::core::mem::transmute(sel1) };
            sel1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let sel2: u32 = unsafe { ::core::mem::transmute(sel2) };
            sel2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 5u8, {
            let sel3: u32 = unsafe { ::core::mem::transmute(sel3) };
            sel3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let sel4: u32 = unsafe { ::core::mem::transmute(sel4) };
            sel4 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let no_gating_12m: u32 = unsafe { ::core::mem::transmute(no_gating_12m) };
            no_gating_12m as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn hall_phase(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hall_phase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_hall(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_hall(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        hall_phase: u32,
        xpd_hall: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let hall_phase: u32 = unsafe { ::core::mem::transmute(hall_phase) };
            hall_phase as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_hall: u32 = unsafe { ::core::mem::transmute(xpd_hall) };
            xpd_hall as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_io_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sense4_fun_ie: u32,
        sense4_slp_ie: u32,
        sense4_slp_sel: u32,
        sense4_fun_sel: u32,
        sense3_fun_ie: u32,
        sense3_slp_ie: u32,
        sense3_slp_sel: u32,
        sense3_fun_sel: u32,
        sense2_fun_ie: u32,
        sense2_slp_ie: u32,
        sense2_slp_sel: u32,
        sense2_fun_sel: u32,
        sense1_fun_ie: u32,
        sense1_slp_ie: u32,
        sense1_slp_sel: u32,
        sense1_fun_sel: u32,
        sense4_mux_sel: u32,
        sense3_mux_sel: u32,
        sense2_mux_sel: u32,
        sense1_mux_sel: u32,
        sense4_hold: u32,
        sense3_hold: u32,
        sense2_hold: u32,
        sense1_hold: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sense4_fun_ie: u32 = unsafe { ::core::mem::transmute(sense4_fun_ie) };
            sense4_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sense4_slp_ie: u32 = unsafe { ::core::mem::transmute(sense4_slp_ie) };
            sense4_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sense4_slp_sel: u32 = unsafe { ::core::mem::transmute(sense4_slp_sel) };
            sense4_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let sense4_fun_sel: u32 = unsafe { ::core::mem::transmute(sense4_fun_sel) };
            sense4_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sense3_fun_ie: u32 = unsafe { ::core::mem::transmute(sense3_fun_ie) };
            sense3_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sense3_slp_ie: u32 = unsafe { ::core::mem::transmute(sense3_slp_ie) };
            sense3_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sense3_slp_sel: u32 = unsafe { ::core::mem::transmute(sense3_slp_sel) };
            sense3_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let sense3_fun_sel: u32 = unsafe { ::core::mem::transmute(sense3_fun_sel) };
            sense3_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sense2_fun_ie: u32 = unsafe { ::core::mem::transmute(sense2_fun_ie) };
            sense2_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sense2_slp_ie: u32 = unsafe { ::core::mem::transmute(sense2_slp_ie) };
            sense2_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sense2_slp_sel: u32 = unsafe { ::core::mem::transmute(sense2_slp_sel) };
            sense2_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let sense2_fun_sel: u32 = unsafe { ::core::mem::transmute(sense2_fun_sel) };
            sense2_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sense1_fun_ie: u32 = unsafe { ::core::mem::transmute(sense1_fun_ie) };
            sense1_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sense1_slp_ie: u32 = unsafe { ::core::mem::transmute(sense1_slp_ie) };
            sense1_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sense1_slp_sel: u32 = unsafe { ::core::mem::transmute(sense1_slp_sel) };
            sense1_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let sense1_fun_sel: u32 = unsafe { ::core::mem::transmute(sense1_fun_sel) };
            sense1_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sense4_mux_sel: u32 = unsafe { ::core::mem::transmute(sense4_mux_sel) };
            sense4_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let sense3_mux_sel: u32 = unsafe { ::core::mem::transmute(sense3_mux_sel) };
            sense3_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sense2_mux_sel: u32 = unsafe { ::core::mem::transmute(sense2_mux_sel) };
            sense2_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let sense1_mux_sel: u32 = unsafe { ::core::mem::transmute(sense1_mux_sel) };
            sense1_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sense4_hold: u32 = unsafe { ::core::mem::transmute(sense4_hold) };
            sense4_hold as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sense3_hold: u32 = unsafe { ::core::mem::transmute(sense3_hold) };
            sense3_hold as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let sense2_hold: u32 = unsafe { ::core::mem::transmute(sense2_hold) };
            sense2_hold as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sense1_hold: u32 = unsafe { ::core::mem::transmute(sense1_hold) };
            sense1_hold as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc1_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        adc2_fun_ie: u32,
        adc2_slp_ie: u32,
        adc2_slp_sel: u32,
        adc2_fun_sel: u32,
        adc1_fun_ie: u32,
        adc1_slp_ie: u32,
        adc1_slp_sel: u32,
        adc1_fun_sel: u32,
        adc2_mux_sel: u32,
        adc1_mux_sel: u32,
        adc2_hold: u32,
        adc1_hold: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let adc2_fun_ie: u32 = unsafe { ::core::mem::transmute(adc2_fun_ie) };
            adc2_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let adc2_slp_ie: u32 = unsafe { ::core::mem::transmute(adc2_slp_ie) };
            adc2_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let adc2_slp_sel: u32 = unsafe { ::core::mem::transmute(adc2_slp_sel) };
            adc2_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let adc2_fun_sel: u32 = unsafe { ::core::mem::transmute(adc2_fun_sel) };
            adc2_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let adc1_fun_ie: u32 = unsafe { ::core::mem::transmute(adc1_fun_ie) };
            adc1_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let adc1_slp_ie: u32 = unsafe { ::core::mem::transmute(adc1_slp_ie) };
            adc1_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let adc1_slp_sel: u32 = unsafe { ::core::mem::transmute(adc1_slp_sel) };
            adc1_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let adc1_fun_sel: u32 = unsafe { ::core::mem::transmute(adc1_fun_sel) };
            adc1_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let adc2_mux_sel: u32 = unsafe { ::core::mem::transmute(adc2_mux_sel) };
            adc2_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let adc1_mux_sel: u32 = unsafe { ::core::mem::transmute(adc1_mux_sel) };
            adc1_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let adc2_hold: u32 = unsafe { ::core::mem::transmute(adc2_hold) };
            adc2_hold as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let adc1_hold: u32 = unsafe { ::core::mem::transmute(adc1_hold) };
            adc1_hold as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_io_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_xpd_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dac_xpd_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_dac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_dac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dac_xpd_force: u32,
        fun_ie: u32,
        slp_oe: u32,
        slp_ie: u32,
        slp_sel: u32,
        fun_sel: u32,
        mux_sel: u32,
        xpd_dac: u32,
        dac: u32,
        rue: u32,
        rde: u32,
        hold: u32,
        drv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dac_xpd_force: u32 = unsafe { ::core::mem::transmute(dac_xpd_force) };
            dac_xpd_force as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fun_ie: u32 = unsafe { ::core::mem::transmute(fun_ie) };
            fun_ie as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let slp_oe: u32 = unsafe { ::core::mem::transmute(slp_oe) };
            slp_oe as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let slp_ie: u32 = unsafe { ::core::mem::transmute(slp_ie) };
            slp_ie as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let slp_sel: u32 = unsafe { ::core::mem::transmute(slp_sel) };
            slp_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let fun_sel: u32 = unsafe { ::core::mem::transmute(fun_sel) };
            fun_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mux_sel: u32 = unsafe { ::core::mem::transmute(mux_sel) };
            mux_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let xpd_dac: u32 = unsafe { ::core::mem::transmute(xpd_dac) };
            xpd_dac as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let dac: u32 = unsafe { ::core::mem::transmute(dac) };
            dac as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rue: u32 = unsafe { ::core::mem::transmute(rue) };
            rue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rde: u32 = unsafe { ::core::mem::transmute(rde) };
            rde as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let hold: u32 = unsafe { ::core::mem::transmute(hold) };
            hold as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let drv: u32 = unsafe { ::core::mem::transmute(drv) };
            drv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_io_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dbias_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dbias_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dres_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dres_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac_xtal_32k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dac_xtal_32k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dbias_xtal_32k: u32,
        dres_xtal_32k: u32,
        x32p_fun_ie: u32,
        x32p_slp_oe: u32,
        x32p_slp_ie: u32,
        x32p_slp_sel: u32,
        x32p_fun_sel: u32,
        x32n_fun_ie: u32,
        x32n_slp_oe: u32,
        x32n_slp_ie: u32,
        x32n_slp_sel: u32,
        x32n_fun_sel: u32,
        x32p_mux_sel: u32,
        x32n_mux_sel: u32,
        xpd_xtal_32k: u32,
        dac_xtal_32k: u32,
        x32p_rue: u32,
        x32p_rde: u32,
        x32p_hold: u32,
        x32p_drv: u32,
        x32n_rue: u32,
        x32n_rde: u32,
        x32n_hold: u32,
        x32n_drv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let dbias_xtal_32k: u32 = unsafe { ::core::mem::transmute(dbias_xtal_32k) };
            dbias_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let dres_xtal_32k: u32 = unsafe { ::core::mem::transmute(dres_xtal_32k) };
            dres_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let x32p_fun_ie: u32 = unsafe { ::core::mem::transmute(x32p_fun_ie) };
            x32p_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let x32p_slp_oe: u32 = unsafe { ::core::mem::transmute(x32p_slp_oe) };
            x32p_slp_oe as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let x32p_slp_ie: u32 = unsafe { ::core::mem::transmute(x32p_slp_ie) };
            x32p_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let x32p_slp_sel: u32 = unsafe { ::core::mem::transmute(x32p_slp_sel) };
            x32p_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let x32p_fun_sel: u32 = unsafe { ::core::mem::transmute(x32p_fun_sel) };
            x32p_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let x32n_fun_ie: u32 = unsafe { ::core::mem::transmute(x32n_fun_ie) };
            x32n_fun_ie as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let x32n_slp_oe: u32 = unsafe { ::core::mem::transmute(x32n_slp_oe) };
            x32n_slp_oe as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let x32n_slp_ie: u32 = unsafe { ::core::mem::transmute(x32n_slp_ie) };
            x32n_slp_ie as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let x32n_slp_sel: u32 = unsafe { ::core::mem::transmute(x32n_slp_sel) };
            x32n_slp_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let x32n_fun_sel: u32 = unsafe { ::core::mem::transmute(x32n_fun_sel) };
            x32n_fun_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let x32p_mux_sel: u32 = unsafe { ::core::mem::transmute(x32p_mux_sel) };
            x32p_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let x32n_mux_sel: u32 = unsafe { ::core::mem::transmute(x32n_mux_sel) };
            x32n_mux_sel as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let xpd_xtal_32k: u32 = unsafe { ::core::mem::transmute(xpd_xtal_32k) };
            xpd_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let dac_xtal_32k: u32 = unsafe { ::core::mem::transmute(dac_xtal_32k) };
            dac_xtal_32k as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let x32p_rue: u32 = unsafe { ::core::mem::transmute(x32p_rue) };
            x32p_rue as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let x32p_rde: u32 = unsafe { ::core::mem::transmute(x32p_rde) };
            x32p_rde as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let x32p_hold: u32 = unsafe { ::core::mem::transmute(x32p_hold) };
            x32p_hold as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let x32p_drv: u32 = unsafe { ::core::mem::transmute(x32p_drv) };
            x32p_drv as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let x32n_rue: u32 = unsafe { ::core::mem::transmute(x32n_rue) };
            x32n_rue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let x32n_rde: u32 = unsafe { ::core::mem::transmute(x32n_rde) };
            x32n_rde as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let x32n_hold: u32 = unsafe { ::core::mem::transmute(x32n_hold) };
            x32n_hold as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let x32n_drv: u32 = unsafe { ::core::mem::transmute(x32n_drv) };
            x32n_drv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn dcur(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dcur(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drange(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drange(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_bias(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dcur: u32,
        drange: u32,
        drefl: u32,
        drefh: u32,
        xpd_bias: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 2u8, {
            let dcur: u32 = unsafe { ::core::mem::transmute(dcur) };
            dcur as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let drange: u32 = unsafe { ::core::mem::transmute(drange) };
            drange as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let drefl: u32 = unsafe { ::core::mem::transmute(drefl) };
            drefl as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let drefh: u32 = unsafe { ::core::mem::transmute(drefh) };
            drefh as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_bias: u32 = unsafe { ::core::mem::transmute(xpd_bias) };
            xpd_bias as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_io_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn to_gpio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_to_gpio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fun_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_oe(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_oe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_ie(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_ie(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fun_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fun_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mux_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mux_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tie_opt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tie_opt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dac(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dac(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rde(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rde(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        to_gpio: u32,
        fun_ie: u32,
        slp_oe: u32,
        slp_ie: u32,
        slp_sel: u32,
        fun_sel: u32,
        mux_sel: u32,
        xpd: u32,
        tie_opt: u32,
        start: u32,
        dac: u32,
        reserved26: u32,
        rue: u32,
        rde: u32,
        drv: u32,
        hold: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let to_gpio: u32 = unsafe { ::core::mem::transmute(to_gpio) };
            to_gpio as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fun_ie: u32 = unsafe { ::core::mem::transmute(fun_ie) };
            fun_ie as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let slp_oe: u32 = unsafe { ::core::mem::transmute(slp_oe) };
            slp_oe as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let slp_ie: u32 = unsafe { ::core::mem::transmute(slp_ie) };
            slp_ie as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slp_sel: u32 = unsafe { ::core::mem::transmute(slp_sel) };
            slp_sel as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let fun_sel: u32 = unsafe { ::core::mem::transmute(fun_sel) };
            fun_sel as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let mux_sel: u32 = unsafe { ::core::mem::transmute(mux_sel) };
            mux_sel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let xpd: u32 = unsafe { ::core::mem::transmute(xpd) };
            xpd as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tie_opt: u32 = unsafe { ::core::mem::transmute(tie_opt) };
            tie_opt as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let dac: u32 = unsafe { ::core::mem::transmute(dac) };
            dac as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rue: u32 = unsafe { ::core::mem::transmute(rue) };
            rue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rde: u32 = unsafe { ::core::mem::transmute(rde) };
            rde as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let drv: u32 = unsafe { ::core::mem::transmute(drv) };
            drv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let hold: u32 = unsafe { ::core::mem::transmute(hold) };
            hold as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, sel: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, sel: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_bit_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_debug_bit_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn scl_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_scl_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sda_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sda_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        debug_bit_sel: u32,
        scl_sel: u32,
        sda_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let debug_bit_sel: u32 = unsafe { ::core::mem::transmute(debug_bit_sel) };
            debug_bit_sel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let scl_sel: u32 = unsafe { ::core::mem::transmute(scl_sel) };
            scl_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let sda_sel: u32 = unsafe { ::core::mem::transmute(sda_sel) };
            sda_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_io_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: rtc_io_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_io_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rtc_io_dev_t = rtc_io_dev_s;
extern "C" {
    pub static mut RTCIO: rtc_io_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_cntl_dev_s {
    pub options0: rtc_cntl_dev_s__bindgen_ty_1,
    pub slp_timer0: u32,
    pub slp_timer1: rtc_cntl_dev_s__bindgen_ty_2,
    pub time_update: rtc_cntl_dev_s__bindgen_ty_3,
    pub time0: u32,
    pub time1: rtc_cntl_dev_s__bindgen_ty_4,
    pub state0: rtc_cntl_dev_s__bindgen_ty_5,
    pub timer1: rtc_cntl_dev_s__bindgen_ty_6,
    pub timer2: rtc_cntl_dev_s__bindgen_ty_7,
    pub timer3: rtc_cntl_dev_s__bindgen_ty_8,
    pub timer4: rtc_cntl_dev_s__bindgen_ty_9,
    pub timer5: rtc_cntl_dev_s__bindgen_ty_10,
    pub ana_conf: rtc_cntl_dev_s__bindgen_ty_11,
    pub reset_state: rtc_cntl_dev_s__bindgen_ty_12,
    pub wakeup_state: rtc_cntl_dev_s__bindgen_ty_13,
    pub int_ena: rtc_cntl_dev_s__bindgen_ty_14,
    pub int_raw: rtc_cntl_dev_s__bindgen_ty_15,
    pub int_st: rtc_cntl_dev_s__bindgen_ty_16,
    pub int_clr: rtc_cntl_dev_s__bindgen_ty_17,
    pub rtc_store0: u32,
    pub rtc_store1: u32,
    pub rtc_store2: u32,
    pub rtc_store3: u32,
    pub ext_xtl_conf: rtc_cntl_dev_s__bindgen_ty_18,
    pub ext_wakeup_conf: rtc_cntl_dev_s__bindgen_ty_19,
    pub slp_reject_conf: rtc_cntl_dev_s__bindgen_ty_20,
    pub cpu_period_conf: rtc_cntl_dev_s__bindgen_ty_21,
    pub sdio_act_conf: rtc_cntl_dev_s__bindgen_ty_22,
    pub clk_conf: rtc_cntl_dev_s__bindgen_ty_23,
    pub sdio_conf: rtc_cntl_dev_s__bindgen_ty_24,
    pub bias_conf: rtc_cntl_dev_s__bindgen_ty_25,
    pub rtc: rtc_cntl_dev_s__bindgen_ty_26,
    pub rtc_pwc: rtc_cntl_dev_s__bindgen_ty_27,
    pub dig_pwc: rtc_cntl_dev_s__bindgen_ty_28,
    pub dig_iso: rtc_cntl_dev_s__bindgen_ty_29,
    pub wdt_config0: rtc_cntl_dev_s__bindgen_ty_30,
    pub wdt_config1: u32,
    pub wdt_config2: u32,
    pub wdt_config3: u32,
    pub wdt_config4: u32,
    pub wdt_feed: rtc_cntl_dev_s__bindgen_ty_31,
    pub wdt_wprotect: u32,
    pub test_mux: rtc_cntl_dev_s__bindgen_ty_32,
    pub sw_cpu_stall: rtc_cntl_dev_s__bindgen_ty_33,
    pub store4: u32,
    pub store5: u32,
    pub store6: u32,
    pub store7: u32,
    pub diag0: u32,
    pub diag1: u32,
    pub hold_force: rtc_cntl_dev_s__bindgen_ty_34,
    pub ext_wakeup1: rtc_cntl_dev_s__bindgen_ty_35,
    pub ext_wakeup1_status: rtc_cntl_dev_s__bindgen_ty_36,
    pub brown_out: rtc_cntl_dev_s__bindgen_ty_37,
    pub reserved_39: u32,
    pub reserved_3d: u32,
    pub reserved_41: u32,
    pub reserved_45: u32,
    pub reserved_49: u32,
    pub reserved_4d: u32,
    pub date: rtc_cntl_dev_s__bindgen_ty_38,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sw_stall_appcpu_c0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sw_stall_appcpu_c0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_stall_procpu_c0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sw_stall_procpu_c0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_appcpu_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_appcpu_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_procpu_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_procpu_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bb_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bb_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bb_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bb_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_sleep_folw_8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_sleep_folw_8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_force_sleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_force_sleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_force_nosleep(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_force_nosleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_i2c_folw_8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_i2c_folw_8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_i2c_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_i2c_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_i2c_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_i2c_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_core_folw_8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_core_folw_8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_core_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_core_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bias_core_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bias_core_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_analog_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn analog_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_analog_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_norst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_norst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_sys_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_sys_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sw_stall_appcpu_c0: u32,
        sw_stall_procpu_c0: u32,
        sw_appcpu_rst: u32,
        sw_procpu_rst: u32,
        bb_i2c_force_pd: u32,
        bb_i2c_force_pu: u32,
        bbpll_i2c_force_pd: u32,
        bbpll_i2c_force_pu: u32,
        bbpll_force_pd: u32,
        bbpll_force_pu: u32,
        xtl_force_pd: u32,
        xtl_force_pu: u32,
        bias_sleep_folw_8m: u32,
        bias_force_sleep: u32,
        bias_force_nosleep: u32,
        bias_i2c_folw_8m: u32,
        bias_i2c_force_pd: u32,
        bias_i2c_force_pu: u32,
        bias_core_folw_8m: u32,
        bias_core_force_pd: u32,
        bias_core_force_pu: u32,
        xtl_force_iso: u32,
        pll_force_iso: u32,
        analog_force_iso: u32,
        xtl_force_noiso: u32,
        pll_force_noiso: u32,
        analog_force_noiso: u32,
        dg_wrap_force_rst: u32,
        dg_wrap_force_norst: u32,
        sw_sys_rst: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sw_stall_appcpu_c0: u32 = unsafe { ::core::mem::transmute(sw_stall_appcpu_c0) };
            sw_stall_appcpu_c0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let sw_stall_procpu_c0: u32 = unsafe { ::core::mem::transmute(sw_stall_procpu_c0) };
            sw_stall_procpu_c0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sw_appcpu_rst: u32 = unsafe { ::core::mem::transmute(sw_appcpu_rst) };
            sw_appcpu_rst as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sw_procpu_rst: u32 = unsafe { ::core::mem::transmute(sw_procpu_rst) };
            sw_procpu_rst as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bb_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bb_i2c_force_pd) };
            bb_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bb_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bb_i2c_force_pu) };
            bb_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bbpll_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bbpll_i2c_force_pd) };
            bbpll_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let bbpll_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bbpll_i2c_force_pu) };
            bbpll_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bbpll_force_pd: u32 = unsafe { ::core::mem::transmute(bbpll_force_pd) };
            bbpll_force_pd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bbpll_force_pu: u32 = unsafe { ::core::mem::transmute(bbpll_force_pu) };
            bbpll_force_pu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let xtl_force_pd: u32 = unsafe { ::core::mem::transmute(xtl_force_pd) };
            xtl_force_pd as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let xtl_force_pu: u32 = unsafe { ::core::mem::transmute(xtl_force_pu) };
            xtl_force_pu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let bias_sleep_folw_8m: u32 = unsafe { ::core::mem::transmute(bias_sleep_folw_8m) };
            bias_sleep_folw_8m as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let bias_force_sleep: u32 = unsafe { ::core::mem::transmute(bias_force_sleep) };
            bias_force_sleep as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bias_force_nosleep: u32 = unsafe { ::core::mem::transmute(bias_force_nosleep) };
            bias_force_nosleep as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let bias_i2c_folw_8m: u32 = unsafe { ::core::mem::transmute(bias_i2c_folw_8m) };
            bias_i2c_folw_8m as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let bias_i2c_force_pd: u32 = unsafe { ::core::mem::transmute(bias_i2c_force_pd) };
            bias_i2c_force_pd as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let bias_i2c_force_pu: u32 = unsafe { ::core::mem::transmute(bias_i2c_force_pu) };
            bias_i2c_force_pu as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let bias_core_folw_8m: u32 = unsafe { ::core::mem::transmute(bias_core_folw_8m) };
            bias_core_folw_8m as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let bias_core_force_pd: u32 = unsafe { ::core::mem::transmute(bias_core_force_pd) };
            bias_core_force_pd as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let bias_core_force_pu: u32 = unsafe { ::core::mem::transmute(bias_core_force_pu) };
            bias_core_force_pu as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let xtl_force_iso: u32 = unsafe { ::core::mem::transmute(xtl_force_iso) };
            xtl_force_iso as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let pll_force_iso: u32 = unsafe { ::core::mem::transmute(pll_force_iso) };
            pll_force_iso as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let analog_force_iso: u32 = unsafe { ::core::mem::transmute(analog_force_iso) };
            analog_force_iso as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let xtl_force_noiso: u32 = unsafe { ::core::mem::transmute(xtl_force_noiso) };
            xtl_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let pll_force_noiso: u32 = unsafe { ::core::mem::transmute(pll_force_noiso) };
            pll_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let analog_force_noiso: u32 = unsafe { ::core::mem::transmute(analog_force_noiso) };
            analog_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let dg_wrap_force_rst: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_rst) };
            dg_wrap_force_rst as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dg_wrap_force_norst: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_norst) };
            dg_wrap_force_norst as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sw_sys_rst: u32 = unsafe { ::core::mem::transmute(sw_sys_rst) };
            sw_sys_rst as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn slp_val_hi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_slp_val_hi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn main_timer_alarm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_timer_alarm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_val_hi: u32,
        main_timer_alarm_en: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let slp_val_hi: u32 = unsafe { ::core::mem::transmute(slp_val_hi) };
            slp_val_hi as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let main_timer_alarm_en: u32 = unsafe { ::core::mem::transmute(main_timer_alarm_en) };
            main_timer_alarm_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        valid: u32,
        update: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let valid: u32 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let update: u32 = unsafe { ::core::mem::transmute(update) };
            update as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn time_hi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_time_hi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        time_hi: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let time_hi: u32 = unsafe { ::core::mem::transmute(time_hi) };
            time_hi as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_wakeup_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_wakeup_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ulp_cp_wakeup_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_wakeup_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apb2rtc_bridge_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apb2rtc_bridge_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_slp_timer_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_slp_timer_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ulp_cp_slp_timer_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_slp_timer_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_active_ind(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_active_ind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleep_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        touch_wakeup_force_en: u32,
        ulp_cp_wakeup_force_en: u32,
        apb2rtc_bridge_sel: u32,
        touch_slp_timer_en: u32,
        ulp_cp_slp_timer_en: u32,
        reserved25: u32,
        sdio_active_ind: u32,
        slp_wakeup: u32,
        slp_reject: u32,
        sleep_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let touch_wakeup_force_en: u32 =
                unsafe { ::core::mem::transmute(touch_wakeup_force_en) };
            touch_wakeup_force_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ulp_cp_wakeup_force_en: u32 =
                unsafe { ::core::mem::transmute(ulp_cp_wakeup_force_en) };
            ulp_cp_wakeup_force_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let apb2rtc_bridge_sel: u32 = unsafe { ::core::mem::transmute(apb2rtc_bridge_sel) };
            apb2rtc_bridge_sel as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let touch_slp_timer_en: u32 = unsafe { ::core::mem::transmute(touch_slp_timer_en) };
            touch_slp_timer_en as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ulp_cp_slp_timer_en: u32 = unsafe { ::core::mem::transmute(ulp_cp_slp_timer_en) };
            ulp_cp_slp_timer_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let sdio_active_ind: u32 = unsafe { ::core::mem::transmute(sdio_active_ind) };
            sdio_active_ind as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sleep_en: u32 = unsafe { ::core::mem::transmute(sleep_en) };
            sleep_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn cpu_stall_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_stall_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_stall_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_stall_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xtl_buf_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_xtl_buf_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_buf_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pll_buf_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpu_stall_en: u32,
        cpu_stall_wait: u32,
        ck8m_wait: u32,
        xtl_buf_wait: u32,
        pll_buf_wait: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cpu_stall_en: u32 = unsafe { ::core::mem::transmute(cpu_stall_en) };
            cpu_stall_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let cpu_stall_wait: u32 = unsafe { ::core::mem::transmute(cpu_stall_wait) };
            cpu_stall_wait as u64
        });
        __bindgen_bitfield_unit.set(6usize, 8u8, {
            let ck8m_wait: u32 = unsafe { ::core::mem::transmute(ck8m_wait) };
            ck8m_wait as u64
        });
        __bindgen_bitfield_unit.set(14usize, 10u8, {
            let xtl_buf_wait: u32 = unsafe { ::core::mem::transmute(xtl_buf_wait) };
            xtl_buf_wait as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let pll_buf_wait: u32 = unsafe { ::core::mem::transmute(pll_buf_wait) };
            pll_buf_wait as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn ulpcp_touch_start_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ulpcp_touch_start_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn min_time_ck8m_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_min_time_ck8m_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ulpcp_touch_start_wait: u32,
        min_time_ck8m_off: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 9u8, {
            let ulpcp_touch_start_wait: u32 =
                unsafe { ::core::mem::transmute(ulpcp_touch_start_wait) };
            ulpcp_touch_start_wait as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let min_time_ck8m_off: u32 = unsafe { ::core::mem::transmute(min_time_ck8m_off) };
            min_time_ck8m_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn wifi_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rom_ram_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rom_ram_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn rom_ram_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rom_ram_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wifi_wait_timer: u32,
        wifi_powerup_timer: u32,
        rom_ram_wait_timer: u32,
        rom_ram_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let wifi_wait_timer: u32 = unsafe { ::core::mem::transmute(wifi_wait_timer) };
            wifi_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let wifi_powerup_timer: u32 = unsafe { ::core::mem::transmute(wifi_powerup_timer) };
            wifi_powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let rom_ram_wait_timer: u32 = unsafe { ::core::mem::transmute(rom_ram_wait_timer) };
            rom_ram_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let rom_ram_powerup_timer: u32 =
                unsafe { ::core::mem::transmute(rom_ram_powerup_timer) };
            rom_ram_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn rtc_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_wait_timer: u32,
        rtc_powerup_timer: u32,
        dg_wrap_wait_timer: u32,
        dg_wrap_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let rtc_wait_timer: u32 = unsafe { ::core::mem::transmute(rtc_wait_timer) };
            rtc_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let rtc_powerup_timer: u32 = unsafe { ::core::mem::transmute(rtc_powerup_timer) };
            rtc_powerup_timer as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let dg_wrap_wait_timer: u32 = unsafe { ::core::mem::transmute(dg_wrap_wait_timer) };
            dg_wrap_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let dg_wrap_powerup_timer: u32 =
                unsafe { ::core::mem::transmute(dg_wrap_powerup_timer) };
            dg_wrap_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn ulp_cp_subtimer_prediv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ulp_cp_subtimer_prediv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn min_slp_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_min_slp_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rtcmem_wait_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rtcmem_wait_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn rtcmem_powerup_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rtcmem_powerup_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ulp_cp_subtimer_prediv: u32,
        min_slp_val: u32,
        rtcmem_wait_timer: u32,
        rtcmem_powerup_timer: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ulp_cp_subtimer_prediv: u32 =
                unsafe { ::core::mem::transmute(ulp_cp_subtimer_prediv) };
            ulp_cp_subtimer_prediv as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let min_slp_val: u32 = unsafe { ::core::mem::transmute(min_slp_val) };
            min_slp_val as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let rtcmem_wait_timer: u32 = unsafe { ::core::mem::transmute(rtcmem_wait_timer) };
            rtcmem_wait_timer as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let rtcmem_powerup_timer: u32 = unsafe { ::core::mem::transmute(rtcmem_powerup_timer) };
            rtcmem_powerup_timer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn plla_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plla_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plla_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plla_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bbpll_cal_slp_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bbpll_cal_slp_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pvtmon_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pvtmon_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txrf_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txrf_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfrx_pbus_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rfrx_pbus_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ckgen_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ckgen_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pll_i2c_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pll_i2c_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        plla_force_pd: u32,
        plla_force_pu: u32,
        bbpll_cal_slp_start: u32,
        pvtmon_pu: u32,
        txrf_i2c_pu: u32,
        rfrx_pbus_pu: u32,
        reserved29: u32,
        ckgen_i2c_pu: u32,
        pll_i2c_pu: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let plla_force_pd: u32 = unsafe { ::core::mem::transmute(plla_force_pd) };
            plla_force_pd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let plla_force_pu: u32 = unsafe { ::core::mem::transmute(plla_force_pu) };
            plla_force_pu as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bbpll_cal_slp_start: u32 = unsafe { ::core::mem::transmute(bbpll_cal_slp_start) };
            bbpll_cal_slp_start as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let pvtmon_pu: u32 = unsafe { ::core::mem::transmute(pvtmon_pu) };
            pvtmon_pu as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let txrf_i2c_pu: u32 = unsafe { ::core::mem::transmute(txrf_i2c_pu) };
            txrf_i2c_pu as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rfrx_pbus_pu: u32 = unsafe { ::core::mem::transmute(rfrx_pbus_pu) };
            rfrx_pbus_pu as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ckgen_i2c_pu: u32 = unsafe { ::core::mem::transmute(ckgen_i2c_pu) };
            ckgen_i2c_pu as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pll_i2c_pu: u32 = unsafe { ::core::mem::transmute(pll_i2c_pu) };
            pll_i2c_pu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn reset_cause_procpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reset_cause_procpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_cause_appcpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reset_cause_appcpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_stat_vector_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_stat_vector_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_stat_vector_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_stat_vector_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset_cause_procpu: u32,
        reset_cause_appcpu: u32,
        appcpu_stat_vector_sel: u32,
        procpu_stat_vector_sel: u32,
        reserved14: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reset_cause_procpu: u32 = unsafe { ::core::mem::transmute(reset_cause_procpu) };
            reset_cause_procpu as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let reset_cause_appcpu: u32 = unsafe { ::core::mem::transmute(reset_cause_appcpu) };
            reset_cause_appcpu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let appcpu_stat_vector_sel: u32 =
                unsafe { ::core::mem::transmute(appcpu_stat_vector_sel) };
            appcpu_stat_vector_sel as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let procpu_stat_vector_sel: u32 =
                unsafe { ::core::mem::transmute(procpu_stat_vector_sel) };
            procpu_stat_vector_sel as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn wakeup_cause(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_cause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wakeup_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wakeup_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_wakeup_filter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_wakeup_filter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wakeup_cause: u32,
        rtc_wakeup_ena: u32,
        gpio_wakeup_filter: u32,
        reserved23: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let wakeup_cause: u32 = unsafe { ::core::mem::transmute(wakeup_cause) };
            wakeup_cause as u64
        });
        __bindgen_bitfield_unit.set(11usize, 11u8, {
            let rtc_wakeup_ena: u32 = unsafe { ::core::mem::transmute(rtc_wakeup_ena) };
            rtc_wakeup_ena as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let gpio_wakeup_filter: u32 = unsafe { ::core::mem::transmute(gpio_wakeup_filter) };
            gpio_wakeup_filter as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let reserved23: u32 = unsafe { ::core::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_ulp_cp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_ulp_cp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_ulp_cp: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_ulp_cp: u32 = unsafe { ::core::mem::transmute(rtc_ulp_cp) };
            rtc_ulp_cp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_ulp_cp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_ulp_cp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_ulp_cp: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_ulp_cp: u32 = unsafe { ::core::mem::transmute(rtc_ulp_cp) };
            rtc_ulp_cp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_sar: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_sar: u32 = unsafe { ::core::mem::transmute(rtc_sar) };
            rtc_sar as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn slp_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slp_reject(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slp_reject(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_time_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_time_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_sar(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_sar(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_touch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_touch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_brown_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_brown_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_main_timer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_main_timer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slp_wakeup: u32,
        slp_reject: u32,
        sdio_idle: u32,
        rtc_wdt: u32,
        rtc_time_valid: u32,
        rtc_sar: u32,
        rtc_touch: u32,
        rtc_brown_out: u32,
        rtc_main_timer: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slp_wakeup: u32 = unsafe { ::core::mem::transmute(slp_wakeup) };
            slp_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slp_reject: u32 = unsafe { ::core::mem::transmute(slp_reject) };
            slp_reject as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sdio_idle: u32 = unsafe { ::core::mem::transmute(sdio_idle) };
            sdio_idle as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rtc_wdt: u32 = unsafe { ::core::mem::transmute(rtc_wdt) };
            rtc_wdt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_time_valid: u32 = unsafe { ::core::mem::transmute(rtc_time_valid) };
            rtc_time_valid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rtc_sar: u32 = unsafe { ::core::mem::transmute(rtc_sar) };
            rtc_sar as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rtc_touch: u32 = unsafe { ::core::mem::transmute(rtc_touch) };
            rtc_touch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_brown_out: u32 = unsafe { ::core::mem::transmute(rtc_brown_out) };
            rtc_brown_out as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rtc_main_timer: u32 = unsafe { ::core::mem::transmute(rtc_main_timer) };
            rtc_main_timer as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn ctr_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctr_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctr_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ctr_lv: u32,
        ctr_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ctr_lv: u32 = unsafe { ::core::mem::transmute(ctr_lv) };
            ctr_lv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ctr_en: u32 = unsafe { ::core::mem::transmute(ctr_en) };
            ctr_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup0_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup0_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup1_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup1_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        wakeup0_lv: u32,
        wakeup1_lv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let wakeup0_lv: u32 = unsafe { ::core::mem::transmute(wakeup0_lv) };
            wakeup0_lv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let wakeup1_lv: u32 = unsafe { ::core::mem::transmute(wakeup1_lv) };
            wakeup1_lv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn light_slp_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_light_slp_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deep_slp_reject_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deep_slp_reject_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reject_cause(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reject_cause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        gpio_reject_en: u32,
        sdio_reject_en: u32,
        light_slp_reject_en: u32,
        deep_slp_reject_en: u32,
        reject_cause: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let gpio_reject_en: u32 = unsafe { ::core::mem::transmute(gpio_reject_en) };
            gpio_reject_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let sdio_reject_en: u32 = unsafe { ::core::mem::transmute(sdio_reject_en) };
            sdio_reject_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let light_slp_reject_en: u32 = unsafe { ::core::mem::transmute(light_slp_reject_en) };
            light_slp_reject_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let deep_slp_reject_en: u32 = unsafe { ::core::mem::transmute(deep_slp_reject_en) };
            deep_slp_reject_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reject_cause: u32 = unsafe { ::core::mem::transmute(reject_cause) };
            reject_cause as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn cpusel_conf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpusel_conf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpuperiod_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cpuperiod_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        cpusel_conf: u32,
        cpuperiod_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let cpusel_conf: u32 = unsafe { ::core::mem::transmute(cpusel_conf) };
            cpusel_conf as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cpuperiod_sel: u32 = unsafe { ::core::mem::transmute(cpuperiod_sel) };
            cpuperiod_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_act_dnum(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_act_dnum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sdio_act_dnum: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let sdio_act_dnum: u32 = unsafe { ::core::mem::transmute(sdio_act_dnum) };
            sdio_act_dnum as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_ck8m(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_ck8m(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_ck8m_div(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_ck8m_div(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_xtal32k_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_xtal32k_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_clk8m_d256_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_clk8m_d256_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_clk8m_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_clk8m_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_dfreq_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_dfreq_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_div_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_div_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn xtal_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtal_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_nogating(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_nogating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_dfreq(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_dfreq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck8m_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck8m_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn soc_clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_soc_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fast_clk_rtc_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fast_clk_rtc_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_clk_rtc_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ana_clk_rtc_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ck8m_div: u32,
        enb_ck8m: u32,
        enb_ck8m_div: u32,
        dig_xtal32k_en: u32,
        dig_clk8m_d256_en: u32,
        dig_clk8m_en: u32,
        ck8m_dfreq_force: u32,
        ck8m_div_sel: u32,
        xtal_force_nogating: u32,
        ck8m_force_nogating: u32,
        ck8m_dfreq: u32,
        ck8m_force_pd: u32,
        ck8m_force_pu: u32,
        soc_clk_sel: u32,
        fast_clk_rtc_sel: u32,
        ana_clk_rtc_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let ck8m_div: u32 = unsafe { ::core::mem::transmute(ck8m_div) };
            ck8m_div as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enb_ck8m: u32 = unsafe { ::core::mem::transmute(enb_ck8m) };
            enb_ck8m as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let enb_ck8m_div: u32 = unsafe { ::core::mem::transmute(enb_ck8m_div) };
            enb_ck8m_div as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dig_xtal32k_en: u32 = unsafe { ::core::mem::transmute(dig_xtal32k_en) };
            dig_xtal32k_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dig_clk8m_d256_en: u32 = unsafe { ::core::mem::transmute(dig_clk8m_d256_en) };
            dig_clk8m_d256_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dig_clk8m_en: u32 = unsafe { ::core::mem::transmute(dig_clk8m_en) };
            dig_clk8m_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ck8m_dfreq_force: u32 = unsafe { ::core::mem::transmute(ck8m_dfreq_force) };
            ck8m_dfreq_force as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let ck8m_div_sel: u32 = unsafe { ::core::mem::transmute(ck8m_div_sel) };
            ck8m_div_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let xtal_force_nogating: u32 = unsafe { ::core::mem::transmute(xtal_force_nogating) };
            xtal_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ck8m_force_nogating: u32 = unsafe { ::core::mem::transmute(ck8m_force_nogating) };
            ck8m_force_nogating as u64
        });
        __bindgen_bitfield_unit.set(17usize, 8u8, {
            let ck8m_dfreq: u32 = unsafe { ::core::mem::transmute(ck8m_dfreq) };
            ck8m_dfreq as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ck8m_force_pd: u32 = unsafe { ::core::mem::transmute(ck8m_force_pd) };
            ck8m_force_pd as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ck8m_force_pu: u32 = unsafe { ::core::mem::transmute(ck8m_force_pu) };
            ck8m_force_pu as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let soc_clk_sel: u32 = unsafe { ::core::mem::transmute(soc_clk_sel) };
            soc_clk_sel as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let fast_clk_rtc_sel: u32 = unsafe { ::core::mem::transmute(fast_clk_rtc_sel) };
            fast_clk_rtc_sel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let ana_clk_rtc_sel: u32 = unsafe { ::core::mem::transmute(ana_clk_rtc_sel) };
            ana_clk_rtc_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_tieh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_tieh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reg1p8_ready(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reg1p8_ready(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drefl_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefl_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefm_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefm_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn drefh_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_drefh_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn xpd_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xpd_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sdio_pd_en: u32,
        sdio_force: u32,
        sdio_tieh: u32,
        reg1p8_ready: u32,
        drefl_sdio: u32,
        drefm_sdio: u32,
        drefh_sdio: u32,
        xpd_sdio: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 21u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sdio_pd_en: u32 = unsafe { ::core::mem::transmute(sdio_pd_en) };
            sdio_pd_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let sdio_force: u32 = unsafe { ::core::mem::transmute(sdio_force) };
            sdio_force as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let sdio_tieh: u32 = unsafe { ::core::mem::transmute(sdio_tieh) };
            sdio_tieh as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let reg1p8_ready: u32 = unsafe { ::core::mem::transmute(reg1p8_ready) };
            reg1p8_ready as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let drefl_sdio: u32 = unsafe { ::core::mem::transmute(drefl_sdio) };
            drefl_sdio as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let drefm_sdio: u32 = unsafe { ::core::mem::transmute(drefm_sdio) };
            drefm_sdio as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let drefh_sdio: u32 = unsafe { ::core::mem::transmute(drefh_sdio) };
            drefh_sdio as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let xpd_sdio: u32 = unsafe { ::core::mem::transmute(xpd_sdio) };
            xpd_sdio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn dbg_atten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dbg_atten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enb_sck_xtal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enb_sck_xtal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_heartbeat_refresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_heartbeat_refresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_heartbeat_period(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dec_heartbeat_period(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_heartbeat_period(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_heartbeat_period(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_heartbeat_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dec_heartbeat_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_bias_i2c(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_bias_i2c(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dbg_atten: u32,
        enb_sck_xtal: u32,
        inc_heartbeat_refresh: u32,
        dec_heartbeat_period: u32,
        inc_heartbeat_period: u32,
        dec_heartbeat_width: u32,
        rst_bias_i2c: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let dbg_atten: u32 = unsafe { ::core::mem::transmute(dbg_atten) };
            dbg_atten as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let enb_sck_xtal: u32 = unsafe { ::core::mem::transmute(enb_sck_xtal) };
            enb_sck_xtal as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let inc_heartbeat_refresh: u32 =
                unsafe { ::core::mem::transmute(inc_heartbeat_refresh) };
            inc_heartbeat_refresh as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let dec_heartbeat_period: u32 = unsafe { ::core::mem::transmute(dec_heartbeat_period) };
            dec_heartbeat_period as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let inc_heartbeat_period: u32 = unsafe { ::core::mem::transmute(inc_heartbeat_period) };
            inc_heartbeat_period as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dec_heartbeat_width: u32 = unsafe { ::core::mem::transmute(dec_heartbeat_width) };
            dec_heartbeat_width as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rst_bias_i2c: u32 = unsafe { ::core::mem::transmute(rst_bias_i2c) };
            rst_bias_i2c as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn sck_dcap_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sck_dcap_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_dbias_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dig_dbias_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_dbias_wak(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dig_dbias_wak(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sck_dcap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sck_dcap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dbias_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dbias_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dbias_wak(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dbias_wak(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dboost_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dboost_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_dboost_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_dboost_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        sck_dcap_force: u32,
        dig_dbias_slp: u32,
        dig_dbias_wak: u32,
        sck_dcap: u32,
        rtc_dbias_slp: u32,
        rtc_dbias_wak: u32,
        rtc_dboost_force_pd: u32,
        rtc_dboost_force_pu: u32,
        rtc_force_pd: u32,
        rtc_force_pu: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sck_dcap_force: u32 = unsafe { ::core::mem::transmute(sck_dcap_force) };
            sck_dcap_force as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let dig_dbias_slp: u32 = unsafe { ::core::mem::transmute(dig_dbias_slp) };
            dig_dbias_slp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let dig_dbias_wak: u32 = unsafe { ::core::mem::transmute(dig_dbias_wak) };
            dig_dbias_wak as u64
        });
        __bindgen_bitfield_unit.set(14usize, 8u8, {
            let sck_dcap: u32 = unsafe { ::core::mem::transmute(sck_dcap) };
            sck_dcap as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let rtc_dbias_slp: u32 = unsafe { ::core::mem::transmute(rtc_dbias_slp) };
            rtc_dbias_slp as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let rtc_dbias_wak: u32 = unsafe { ::core::mem::transmute(rtc_dbias_wak) };
            rtc_dbias_wak as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let rtc_dboost_force_pd: u32 = unsafe { ::core::mem::transmute(rtc_dboost_force_pd) };
            rtc_dboost_force_pd as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let rtc_dboost_force_pu: u32 = unsafe { ::core::mem::transmute(rtc_dboost_force_pu) };
            rtc_dboost_force_pu as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rtc_force_pd: u32 = unsafe { ::core::mem::transmute(rtc_force_pd) };
            rtc_force_pd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rtc_force_pu: u32 = unsafe { ::core::mem::transmute(rtc_force_pu) };
            rtc_force_pu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn fastmem_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_folw_cpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_folw_cpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_lpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_lpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_lpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_lpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_folw_cpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_folw_cpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_lpd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_lpd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_lpu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_lpu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmem_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastmem_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slowmem_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slowmem_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pwc_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pwc_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pwc_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pwc_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fastmem_force_noiso: u32,
        fastmem_force_iso: u32,
        slowmem_force_noiso: u32,
        slowmem_force_iso: u32,
        rtc_force_iso: u32,
        force_noiso: u32,
        fastmem_folw_cpu: u32,
        fastmem_force_lpd: u32,
        fastmem_force_lpu: u32,
        slowmem_folw_cpu: u32,
        slowmem_force_lpd: u32,
        slowmem_force_lpu: u32,
        fastmem_force_pd: u32,
        fastmem_force_pu: u32,
        fastmem_pd_en: u32,
        slowmem_force_pd: u32,
        slowmem_force_pu: u32,
        slowmem_pd_en: u32,
        pwc_force_pd: u32,
        pwc_force_pu: u32,
        pd_en: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fastmem_force_noiso: u32 = unsafe { ::core::mem::transmute(fastmem_force_noiso) };
            fastmem_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fastmem_force_iso: u32 = unsafe { ::core::mem::transmute(fastmem_force_iso) };
            fastmem_force_iso as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let slowmem_force_noiso: u32 = unsafe { ::core::mem::transmute(slowmem_force_noiso) };
            slowmem_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slowmem_force_iso: u32 = unsafe { ::core::mem::transmute(slowmem_force_iso) };
            slowmem_force_iso as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rtc_force_iso: u32 = unsafe { ::core::mem::transmute(rtc_force_iso) };
            rtc_force_iso as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let force_noiso: u32 = unsafe { ::core::mem::transmute(force_noiso) };
            force_noiso as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fastmem_folw_cpu: u32 = unsafe { ::core::mem::transmute(fastmem_folw_cpu) };
            fastmem_folw_cpu as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fastmem_force_lpd: u32 = unsafe { ::core::mem::transmute(fastmem_force_lpd) };
            fastmem_force_lpd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fastmem_force_lpu: u32 = unsafe { ::core::mem::transmute(fastmem_force_lpu) };
            fastmem_force_lpu as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let slowmem_folw_cpu: u32 = unsafe { ::core::mem::transmute(slowmem_folw_cpu) };
            slowmem_folw_cpu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let slowmem_force_lpd: u32 = unsafe { ::core::mem::transmute(slowmem_force_lpd) };
            slowmem_force_lpd as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let slowmem_force_lpu: u32 = unsafe { ::core::mem::transmute(slowmem_force_lpu) };
            slowmem_force_lpu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fastmem_force_pd: u32 = unsafe { ::core::mem::transmute(fastmem_force_pd) };
            fastmem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fastmem_force_pu: u32 = unsafe { ::core::mem::transmute(fastmem_force_pu) };
            fastmem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fastmem_pd_en: u32 = unsafe { ::core::mem::transmute(fastmem_pd_en) };
            fastmem_pd_en as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let slowmem_force_pd: u32 = unsafe { ::core::mem::transmute(slowmem_force_pd) };
            slowmem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slowmem_force_pu: u32 = unsafe { ::core::mem::transmute(slowmem_force_pu) };
            slowmem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slowmem_pd_en: u32 = unsafe { ::core::mem::transmute(slowmem_pd_en) };
            slowmem_pd_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pwc_force_pd: u32 = unsafe { ::core::mem::transmute(pwc_force_pd) };
            pwc_force_pd as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let pwc_force_pu: u32 = unsafe { ::core::mem::transmute(pwc_force_pu) };
            pwc_force_pu as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let pd_en: u32 = unsafe { ::core::mem::transmute(pd_en) };
            pd_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn lslp_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lslp_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lslp_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lslp_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_pd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_pd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        lslp_mem_force_pd: u32,
        lslp_mem_force_pu: u32,
        rom0_force_pd: u32,
        rom0_force_pu: u32,
        inter_ram0_force_pd: u32,
        inter_ram0_force_pu: u32,
        inter_ram1_force_pd: u32,
        inter_ram1_force_pu: u32,
        inter_ram2_force_pd: u32,
        inter_ram2_force_pu: u32,
        inter_ram3_force_pd: u32,
        inter_ram3_force_pu: u32,
        inter_ram4_force_pd: u32,
        inter_ram4_force_pu: u32,
        wifi_force_pd: u32,
        wifi_force_pu: u32,
        dg_wrap_force_pd: u32,
        dg_wrap_force_pu: u32,
        reserved21: u32,
        rom0_pd_en: u32,
        inter_ram0_pd_en: u32,
        inter_ram1_pd_en: u32,
        inter_ram2_pd_en: u32,
        inter_ram3_pd_en: u32,
        inter_ram4_pd_en: u32,
        wifi_pd_en: u32,
        dg_wrap_pd_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lslp_mem_force_pd: u32 = unsafe { ::core::mem::transmute(lslp_mem_force_pd) };
            lslp_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lslp_mem_force_pu: u32 = unsafe { ::core::mem::transmute(lslp_mem_force_pu) };
            lslp_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rom0_force_pd: u32 = unsafe { ::core::mem::transmute(rom0_force_pd) };
            rom0_force_pd as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rom0_force_pu: u32 = unsafe { ::core::mem::transmute(rom0_force_pu) };
            rom0_force_pu as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inter_ram0_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram0_force_pd) };
            inter_ram0_force_pd as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let inter_ram0_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram0_force_pu) };
            inter_ram0_force_pu as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inter_ram1_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram1_force_pd) };
            inter_ram1_force_pd as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let inter_ram1_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram1_force_pu) };
            inter_ram1_force_pu as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let inter_ram2_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram2_force_pd) };
            inter_ram2_force_pd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let inter_ram2_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram2_force_pu) };
            inter_ram2_force_pu as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let inter_ram3_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram3_force_pd) };
            inter_ram3_force_pd as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let inter_ram3_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram3_force_pu) };
            inter_ram3_force_pu as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let inter_ram4_force_pd: u32 = unsafe { ::core::mem::transmute(inter_ram4_force_pd) };
            inter_ram4_force_pd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let inter_ram4_force_pu: u32 = unsafe { ::core::mem::transmute(inter_ram4_force_pu) };
            inter_ram4_force_pu as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let wifi_force_pd: u32 = unsafe { ::core::mem::transmute(wifi_force_pd) };
            wifi_force_pd as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let wifi_force_pu: u32 = unsafe { ::core::mem::transmute(wifi_force_pu) };
            wifi_force_pu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let dg_wrap_force_pd: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_pd) };
            dg_wrap_force_pd as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let dg_wrap_force_pu: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_pu) };
            dg_wrap_force_pu as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rom0_pd_en: u32 = unsafe { ::core::mem::transmute(rom0_pd_en) };
            rom0_pd_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let inter_ram0_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram0_pd_en) };
            inter_ram0_pd_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let inter_ram1_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram1_pd_en) };
            inter_ram1_pd_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let inter_ram2_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram2_pd_en) };
            inter_ram2_pd_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let inter_ram3_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram3_pd_en) };
            inter_ram3_pd_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let inter_ram4_pd_en: u32 = unsafe { ::core::mem::transmute(inter_ram4_pd_en) };
            inter_ram4_pd_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let wifi_pd_en: u32 = unsafe { ::core::mem::transmute(wifi_pd_en) };
            wifi_pd_en as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dg_wrap_pd_en: u32 = unsafe { ::core::mem::transmute(dg_wrap_pd_en) };
            dg_wrap_pd_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_iso_force_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_iso_force_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dig_iso_force_on(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dig_iso_force_on(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_autohold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_autohold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clr_dg_pad_autohold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clr_dg_pad_autohold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_autohold_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_autohold_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_unhold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_unhold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_pad_force_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_pad_force_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rom0_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rom0_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram0_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram0_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram1_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram1_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram2_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram2_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram3_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram3_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_ram4_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_ram4_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_iso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_iso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dg_wrap_force_noiso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dg_wrap_force_noiso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        dig_iso_force_off: u32,
        dig_iso_force_on: u32,
        dg_pad_autohold: u32,
        clr_dg_pad_autohold: u32,
        dg_pad_autohold_en: u32,
        dg_pad_force_noiso: u32,
        dg_pad_force_iso: u32,
        dg_pad_force_unhold: u32,
        dg_pad_force_hold: u32,
        rom0_force_iso: u32,
        rom0_force_noiso: u32,
        inter_ram0_force_iso: u32,
        inter_ram0_force_noiso: u32,
        inter_ram1_force_iso: u32,
        inter_ram1_force_noiso: u32,
        inter_ram2_force_iso: u32,
        inter_ram2_force_noiso: u32,
        inter_ram3_force_iso: u32,
        inter_ram3_force_noiso: u32,
        inter_ram4_force_iso: u32,
        inter_ram4_force_noiso: u32,
        wifi_force_iso: u32,
        wifi_force_noiso: u32,
        dg_wrap_force_iso: u32,
        dg_wrap_force_noiso: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dig_iso_force_off: u32 = unsafe { ::core::mem::transmute(dig_iso_force_off) };
            dig_iso_force_off as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dig_iso_force_on: u32 = unsafe { ::core::mem::transmute(dig_iso_force_on) };
            dig_iso_force_on as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dg_pad_autohold: u32 = unsafe { ::core::mem::transmute(dg_pad_autohold) };
            dg_pad_autohold as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let clr_dg_pad_autohold: u32 = unsafe { ::core::mem::transmute(clr_dg_pad_autohold) };
            clr_dg_pad_autohold as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dg_pad_autohold_en: u32 = unsafe { ::core::mem::transmute(dg_pad_autohold_en) };
            dg_pad_autohold_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let dg_pad_force_noiso: u32 = unsafe { ::core::mem::transmute(dg_pad_force_noiso) };
            dg_pad_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let dg_pad_force_iso: u32 = unsafe { ::core::mem::transmute(dg_pad_force_iso) };
            dg_pad_force_iso as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dg_pad_force_unhold: u32 = unsafe { ::core::mem::transmute(dg_pad_force_unhold) };
            dg_pad_force_unhold as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dg_pad_force_hold: u32 = unsafe { ::core::mem::transmute(dg_pad_force_hold) };
            dg_pad_force_hold as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rom0_force_iso: u32 = unsafe { ::core::mem::transmute(rom0_force_iso) };
            rom0_force_iso as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rom0_force_noiso: u32 = unsafe { ::core::mem::transmute(rom0_force_noiso) };
            rom0_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let inter_ram0_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram0_force_iso) };
            inter_ram0_force_iso as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let inter_ram0_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram0_force_noiso) };
            inter_ram0_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let inter_ram1_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram1_force_iso) };
            inter_ram1_force_iso as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let inter_ram1_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram1_force_noiso) };
            inter_ram1_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let inter_ram2_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram2_force_iso) };
            inter_ram2_force_iso as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let inter_ram2_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram2_force_noiso) };
            inter_ram2_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let inter_ram3_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram3_force_iso) };
            inter_ram3_force_iso as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let inter_ram3_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram3_force_noiso) };
            inter_ram3_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let inter_ram4_force_iso: u32 = unsafe { ::core::mem::transmute(inter_ram4_force_iso) };
            inter_ram4_force_iso as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let inter_ram4_force_noiso: u32 =
                unsafe { ::core::mem::transmute(inter_ram4_force_noiso) };
            inter_ram4_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let wifi_force_iso: u32 = unsafe { ::core::mem::transmute(wifi_force_iso) };
            wifi_force_iso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let wifi_force_noiso: u32 = unsafe { ::core::mem::transmute(wifi_force_noiso) };
            wifi_force_noiso as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let dg_wrap_force_iso: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_iso) };
            dg_wrap_force_iso as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let dg_wrap_force_noiso: u32 = unsafe { ::core::mem::transmute(dg_wrap_force_noiso) };
            dg_wrap_force_noiso as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rtc_cntl_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn pause_in_slp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pause_in_slp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_reset_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_reset_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flashboot_mod_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flashboot_mod_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sys_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sys_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn level_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edge_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edge_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stg3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn stg0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_stg0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pause_in_slp: u32,
        appcpu_reset_en: u32,
        procpu_reset_en: u32,
        flashboot_mod_en: u32,
        sys_reset_length: u32,
        cpu_reset_length: u32,
        level_int_en: u32,
        edge_int_en: u32,
        stg3: u32,
        stg2: u32,
        stg1: u32,
        stg0: u32,
        en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pause_in_slp: u32 = unsafe { ::core::mem::transmute(pause_in_slp) };
            pause_in_slp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let appcpu_reset_en: u32 = unsafe { ::core::mem::transmute(appcpu_reset_en) };
            appcpu_reset_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let procpu_reset_en: u32 = unsafe { ::core::mem::transmute(procpu_reset_en) };
            procpu_reset_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let flashboot_mod_en: u32 = unsafe { ::core::mem::transmute(flashboot_mod_en) };
            flashboot_mod_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let sys_reset_length: u32 = unsafe { ::core::mem::transmute(sys_reset_length) };
            sys_reset_length as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let cpu_reset_length: u32 = unsafe { ::core::mem::transmute(cpu_reset_length) };
            cpu_reset_length as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let level_int_en: u32 = unsafe { ::core::mem::transmute(level_int_en) };
            level_int_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let edge_int_en: u32 = unsafe { ::core::mem::transmute(edge_int_en) };
            edge_int_en as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let stg3: u32 = unsafe { ::core::mem::transmute(stg3) };
            stg3 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 3u8, {
            let stg2: u32 = unsafe { ::core::mem::transmute(stg2) };
            stg2 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let stg1: u32 = unsafe { ::core::mem::transmute(stg1) };
            stg1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let stg0: u32 = unsafe { ::core::mem::transmute(stg0) };
            stg0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn feed(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_feed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, feed: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let feed: u32 = unsafe { ::core::mem::transmute(feed) };
            feed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_32 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_32__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn ent_rtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ent_rtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dtest_rtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dtest_rtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        ent_rtc: u32,
        dtest_rtc: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ent_rtc: u32 = unsafe { ::core::mem::transmute(ent_rtc) };
            ent_rtc as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let dtest_rtc: u32 = unsafe { ::core::mem::transmute(dtest_rtc) };
            dtest_rtc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_33 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_33__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn appcpu_c1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_appcpu_c1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn procpu_c1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_procpu_c1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        appcpu_c1: u32,
        procpu_c1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 6u8, {
            let appcpu_c1: u32 = unsafe { ::core::mem::transmute(appcpu_c1) };
            appcpu_c1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let procpu_c1: u32 = unsafe { ::core::mem::transmute(procpu_c1) };
            procpu_c1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_34 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_34__bindgen_ty_1 {
    #[inline]
    pub fn adc1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adc2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adc2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdac1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdac1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdac2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdac2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense3_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense3_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sense4_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sense4_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad0_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad0_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad1_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad1_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad2_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad2_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad3_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad3_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad4_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad4_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad5_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad5_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad6_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad6_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn touch_pad7_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_touch_pad7_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32p_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32p_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn x32n_hold_force(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_x32n_hold_force(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        adc1_hold_force: u32,
        adc2_hold_force: u32,
        pdac1_hold_force: u32,
        pdac2_hold_force: u32,
        sense1_hold_force: u32,
        sense2_hold_force: u32,
        sense3_hold_force: u32,
        sense4_hold_force: u32,
        touch_pad0_hold_force: u32,
        touch_pad1_hold_force: u32,
        touch_pad2_hold_force: u32,
        touch_pad3_hold_force: u32,
        touch_pad4_hold_force: u32,
        touch_pad5_hold_force: u32,
        touch_pad6_hold_force: u32,
        touch_pad7_hold_force: u32,
        x32p_hold_force: u32,
        x32n_hold_force: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let adc1_hold_force: u32 = unsafe { ::core::mem::transmute(adc1_hold_force) };
            adc1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let adc2_hold_force: u32 = unsafe { ::core::mem::transmute(adc2_hold_force) };
            adc2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pdac1_hold_force: u32 = unsafe { ::core::mem::transmute(pdac1_hold_force) };
            pdac1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pdac2_hold_force: u32 = unsafe { ::core::mem::transmute(pdac2_hold_force) };
            pdac2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sense1_hold_force: u32 = unsafe { ::core::mem::transmute(sense1_hold_force) };
            sense1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sense2_hold_force: u32 = unsafe { ::core::mem::transmute(sense2_hold_force) };
            sense2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sense3_hold_force: u32 = unsafe { ::core::mem::transmute(sense3_hold_force) };
            sense3_hold_force as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sense4_hold_force: u32 = unsafe { ::core::mem::transmute(sense4_hold_force) };
            sense4_hold_force as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let touch_pad0_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad0_hold_force) };
            touch_pad0_hold_force as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let touch_pad1_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad1_hold_force) };
            touch_pad1_hold_force as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let touch_pad2_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad2_hold_force) };
            touch_pad2_hold_force as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let touch_pad3_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad3_hold_force) };
            touch_pad3_hold_force as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let touch_pad4_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad4_hold_force) };
            touch_pad4_hold_force as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let touch_pad5_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad5_hold_force) };
            touch_pad5_hold_force as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let touch_pad6_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad6_hold_force) };
            touch_pad6_hold_force as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let touch_pad7_hold_force: u32 =
                unsafe { ::core::mem::transmute(touch_pad7_hold_force) };
            touch_pad7_hold_force as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let x32p_hold_force: u32 = unsafe { ::core::mem::transmute(x32p_hold_force) };
            x32p_hold_force as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let x32n_hold_force: u32 = unsafe { ::core::mem::transmute(x32n_hold_force) };
            x32n_hold_force as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_35 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_35__bindgen_ty_1 {
    #[inline]
    pub fn ext_wakeup1_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_ext_wakeup1_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_wakeup1_status_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_wakeup1_status_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ext_wakeup1_sel: u32,
        ext_wakeup1_status_clr: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let ext_wakeup1_sel: u32 = unsafe { ::core::mem::transmute(ext_wakeup1_sel) };
            ext_wakeup1_sel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ext_wakeup1_status_clr: u32 =
                unsafe { ::core::mem::transmute(ext_wakeup1_status_clr) };
            ext_wakeup1_status_clr as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_36 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_36__bindgen_ty_1 {
    #[inline]
    pub fn ext_wakeup1_status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_ext_wakeup1_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ext_wakeup1_status: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let ext_wakeup1_status: u32 = unsafe { ::core::mem::transmute(ext_wakeup1_status) };
            ext_wakeup1_status as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_37 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rtc_cntl_dev_s__bindgen_ty_37__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn close_flash_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_flash_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pd_rf_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pd_rf_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_wait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rst_wait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_thres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        close_flash_ena: u32,
        pd_rf_ena: u32,
        rst_wait: u32,
        rst_ena: u32,
        thres: u32,
        ena: u32,
        det: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let close_flash_ena: u32 = unsafe { ::core::mem::transmute(close_flash_ena) };
            close_flash_ena as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pd_rf_ena: u32 = unsafe { ::core::mem::transmute(pd_rf_ena) };
            pd_rf_ena as u64
        });
        __bindgen_bitfield_unit.set(16usize, 10u8, {
            let rst_wait: u32 = unsafe { ::core::mem::transmute(rst_wait) };
            rst_wait as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rst_ena: u32 = unsafe { ::core::mem::transmute(rst_ena) };
            rst_ena as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let thres: u32 = unsafe { ::core::mem::transmute(thres) };
            thres as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ena: u32 = unsafe { ::core::mem::transmute(ena) };
            ena as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let det: u32 = unsafe { ::core::mem::transmute(det) };
            det as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtc_cntl_dev_s__bindgen_ty_38 {
    pub __bindgen_anon_1: rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rtc_cntl_dev_s__bindgen_ty_38__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rtc_cntl_dev_t = rtc_cntl_dev_s;
extern "C" {
    pub static mut RTCCNTL: rtc_cntl_dev_t;
}
extern "C" {
    pub static mut adc_channel_io_map: [[c_types::c_int; 10usize]; 2usize];
}
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_0: adc_channel_t = 0;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_1: adc_channel_t = 1;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_2: adc_channel_t = 2;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_3: adc_channel_t = 3;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_4: adc_channel_t = 4;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_5: adc_channel_t = 5;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_6: adc_channel_t = 6;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_7: adc_channel_t = 7;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_8: adc_channel_t = 8;
#[doc = "< ADC channel"]
pub const adc_channel_t_ADC_CHANNEL_9: adc_channel_t = 9;
pub const adc_channel_t_ADC_CHANNEL_MAX: adc_channel_t = 10;
pub type adc_channel_t = c_types::c_uint;
#[doc = "<The input voltage of ADC will be reduced to about 1/1"]
pub const adc_atten_t_ADC_ATTEN_DB_0: adc_atten_t = 0;
#[doc = "<The input voltage of ADC will be reduced to about 1/1.34"]
pub const adc_atten_t_ADC_ATTEN_DB_2_5: adc_atten_t = 1;
#[doc = "<The input voltage of ADC will be reduced to about 1/2"]
pub const adc_atten_t_ADC_ATTEN_DB_6: adc_atten_t = 2;
#[doc = "<The input voltage of ADC will be reduced to about 1/3.6"]
pub const adc_atten_t_ADC_ATTEN_DB_11: adc_atten_t = 3;
pub const adc_atten_t_ADC_ATTEN_MAX: adc_atten_t = 4;
pub type adc_atten_t = c_types::c_uint;
#[doc = "< I2S data from GPIO matrix signal"]
pub const adc_i2s_source_t_ADC_I2S_DATA_SRC_IO_SIG: adc_i2s_source_t = 0;
#[doc = "< I2S data from ADC"]
pub const adc_i2s_source_t_ADC_I2S_DATA_SRC_ADC: adc_i2s_source_t = 1;
pub const adc_i2s_source_t_ADC_I2S_DATA_SRC_MAX: adc_i2s_source_t = 2;
pub type adc_i2s_source_t = c_types::c_uint;
#[doc = "< ADC capture width is 9Bit"]
pub const adc_bits_width_t_ADC_WIDTH_BIT_9: adc_bits_width_t = 0;
#[doc = "< ADC capture width is 10Bit"]
pub const adc_bits_width_t_ADC_WIDTH_BIT_10: adc_bits_width_t = 1;
#[doc = "< ADC capture width is 11Bit"]
pub const adc_bits_width_t_ADC_WIDTH_BIT_11: adc_bits_width_t = 2;
#[doc = "< ADC capture width is 12Bit"]
pub const adc_bits_width_t_ADC_WIDTH_BIT_12: adc_bits_width_t = 3;
pub const adc_bits_width_t_ADC_WIDTH_MAX: adc_bits_width_t = 4;
pub type adc_bits_width_t = c_types::c_uint;
#[doc = "< ADC1 channel 0 is GPIO36 (ESP32), GPIO1 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_0: adc1_channel_t = 0;
#[doc = "< ADC1 channel 1 is GPIO37 (ESP32), GPIO2 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_1: adc1_channel_t = 1;
#[doc = "< ADC1 channel 2 is GPIO38 (ESP32), GPIO3 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_2: adc1_channel_t = 2;
#[doc = "< ADC1 channel 3 is GPIO39 (ESP32), GPIO4 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_3: adc1_channel_t = 3;
#[doc = "< ADC1 channel 4 is GPIO32 (ESP32), GPIO5 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_4: adc1_channel_t = 4;
#[doc = "< ADC1 channel 5 is GPIO33 (ESP32), GPIO6 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_5: adc1_channel_t = 5;
#[doc = "< ADC1 channel 6 is GPIO34 (ESP32), GPIO7 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_6: adc1_channel_t = 6;
#[doc = "< ADC1 channel 7 is GPIO35 (ESP32), GPIO8 (ESP32-S2)"]
pub const adc1_channel_t_ADC1_CHANNEL_7: adc1_channel_t = 7;
#[doc = " `adc1_channel_t` will be deprecated functions, combine into `adc_channel_t`"]
pub type adc1_channel_t = c_types::c_uint;
#[doc = "< ADC2 channel 0 is GPIO4  (ESP32), GPIO11 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_0: adc2_channel_t = 0;
#[doc = "< ADC2 channel 1 is GPIO0  (ESP32), GPIO12 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_1: adc2_channel_t = 1;
#[doc = "< ADC2 channel 2 is GPIO2  (ESP32), GPIO13 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_2: adc2_channel_t = 2;
#[doc = "< ADC2 channel 3 is GPIO15 (ESP32), GPIO14 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_3: adc2_channel_t = 3;
#[doc = "< ADC2 channel 4 is GPIO13 (ESP32), GPIO15 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_4: adc2_channel_t = 4;
#[doc = "< ADC2 channel 5 is GPIO12 (ESP32), GPIO16 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_5: adc2_channel_t = 5;
#[doc = "< ADC2 channel 6 is GPIO14 (ESP32), GPIO17 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_6: adc2_channel_t = 6;
#[doc = "< ADC2 channel 7 is GPIO27 (ESP32), GPIO18 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_7: adc2_channel_t = 7;
#[doc = "< ADC2 channel 8 is GPIO25 (ESP32), GPIO19 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_8: adc2_channel_t = 8;
#[doc = "< ADC2 channel 9 is GPIO26 (ESP32), GPIO20 (ESP32-S2)"]
pub const adc2_channel_t_ADC2_CHANNEL_9: adc2_channel_t = 9;
pub const adc2_channel_t_ADC2_CHANNEL_MAX: adc2_channel_t = 10;
#[doc = " `adc2_channel_t` will be deprecated functions, combine into `adc_channel_t`"]
pub type adc2_channel_t = c_types::c_uint;
#[doc = "< SAR ADC 1"]
pub const adc_unit_t_ADC_UNIT_1: adc_unit_t = 1;
#[doc = "< SAR ADC 2, not supported yet"]
pub const adc_unit_t_ADC_UNIT_2: adc_unit_t = 2;
#[doc = "< SAR ADC 1 and 2, not supported yet"]
pub const adc_unit_t_ADC_UNIT_BOTH: adc_unit_t = 3;
#[doc = "< SAR ADC 1 and 2 alternative mode, not supported yet"]
pub const adc_unit_t_ADC_UNIT_ALTER: adc_unit_t = 7;
pub const adc_unit_t_ADC_UNIT_MAX: adc_unit_t = 8;
pub type adc_unit_t = c_types::c_uint;
#[doc = "< ADC to I2S data format, [15:12]-channel [11:0]-12 bits ADC data"]
pub const adc_i2s_encode_t_ADC_ENCODE_12BIT: adc_i2s_encode_t = 0;
#[doc = "< ADC to I2S data format, [15]-1 [14:11]-channel [10:0]-11 bits ADC data"]
pub const adc_i2s_encode_t_ADC_ENCODE_11BIT: adc_i2s_encode_t = 1;
pub const adc_i2s_encode_t_ADC_ENCODE_MAX: adc_i2s_encode_t = 2;
pub type adc_i2s_encode_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Get the GPIO number of a specific ADC1 channel."]
    #[doc = ""]
    #[doc = " @param channel Channel to get the GPIO number"]
    #[doc = ""]
    #[doc = " @param gpio_num output buffer to hold the GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - ESP_OK if success"]
    #[doc = "   - ESP_ERR_INVALID_ARG if channel not valid"]
    pub fn adc1_pad_get_io_num(channel: adc1_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure ADC1 capture width, meanwhile enable output invert for ADC1."]
    #[doc = " The configuration is for all channels of ADC1"]
    #[doc = " @param width_bit Bit capture width for ADC1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc1_config_width(width_bit: adc_bits_width_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure ADC capture width."]
    #[doc = " @param adc_unit ADC unit index"]
    #[doc = " @param width_bit Bit capture width for ADC unit."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc_set_data_width(adc_unit: adc_unit_t, width_bit: adc_bits_width_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the attenuation of a particular channel on ADC1, and configure its"]
    #[doc = " associated GPIO pin mux."]
    #[doc = ""]
    #[doc = " @note For any given channel, this function must be called before the first time"]
    #[doc = " adc1_get_raw() is called for that channel."]
    #[doc = ""]
    #[doc = " @note This function can be called multiple times to configure multiple"]
    #[doc = " ADC channels simultaneously. adc1_get_raw() can then be called for any configured"]
    #[doc = " channel."]
    #[doc = ""]
    #[doc = " The default ADC full-scale voltage is 1.1 V. To read higher voltages (up to the pin maximum voltage,"]
    #[doc = " usually 3.3 V) requires setting >0 dB signal attenuation for that ADC channel."]
    #[doc = ""]
    #[doc = " When VDD_A is 3.3 V:"]
    #[doc = ""]
    #[doc = " - 0 dB attenuation (ADC_ATTEN_DB_0) gives full-scale voltage 1.1 V"]
    #[doc = " - 2.5 dB attenuation (ADC_ATTEN_DB_2_5) gives full-scale voltage 1.5 V"]
    #[doc = " - 6 dB attenuation (ADC_ATTEN_DB_6) gives full-scale voltage 2.2 V"]
    #[doc = " - 11 dB attenuation (ADC_ATTEN_DB_11) gives full-scale voltage 3.9 V (see note below)"]
    #[doc = ""]
    #[doc = " @note The full-scale voltage is the voltage corresponding to a maximum reading (depending on ADC1 configured"]
    #[doc = " bit width, this value is: 4095 for 12-bits, 2047 for 11-bits, 1023 for 10-bits, 511 for 9 bits.)"]
    #[doc = ""]
    #[doc = " @note At 11 dB attenuation the maximum voltage is limited by VDD_A, not the full scale voltage."]
    #[doc = ""]
    #[doc = " Due to ADC characteristics, most accurate results are obtained within the following approximate voltage ranges:"]
    #[doc = ""]
    #[doc = " - 0 dB attenuation (ADC_ATTEN_DB_0) between 100 and 950 mV"]
    #[doc = " - 2.5 dB attenuation (ADC_ATTEN_DB_2_5) between 100 and 1250 mV"]
    #[doc = " - 6 dB attenuation (ADC_ATTEN_DB_6) between 150 to 1750 mV"]
    #[doc = " - 11 dB attenuation (ADC_ATTEN_DB_11) between 150 to 2450 mV"]
    #[doc = ""]
    #[doc = " For maximum accuracy, use the ADC calibration APIs and measure voltages within these recommended ranges."]
    #[doc = ""]
    #[doc = " @param channel ADC1 channel to configure"]
    #[doc = " @param atten  Attenuation level"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc1_config_channel_atten(channel: adc1_channel_t, atten: adc_atten_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Take an ADC1 reading from a single channel."]
    #[doc = " @note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,"]
    #[doc = "       the input of GPIO36 and GPIO39 will be pulled down for about 80ns."]
    #[doc = "       When enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39."]
    #[doc = "       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue."]
    #[doc = ""]
    #[doc = " @note Call adc1_config_width() before the first time this"]
    #[doc = " function is called."]
    #[doc = ""]
    #[doc = " @note For any given channel, adc1_config_channel_atten(channel)"]
    #[doc = " must be called before the first time this function is called. Configuring"]
    #[doc = " a new channel does not prevent a previously configured channel from being read."]
    #[doc = ""]
    #[doc = " @param  channel ADC1 channel to read"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - -1: Parameter error"]
    #[doc = "     -  Other: ADC1 channel reading."]
    pub fn adc1_get_raw(channel: adc1_channel_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Enable ADC power"]
    pub fn adc_power_on();
}
extern "C" {
    #[doc = " @brief Power off SAR ADC"]
    #[doc = " This function will force power down for ADC"]
    pub fn adc_power_off();
}
extern "C" {
    #[doc = " @brief Initialize ADC pad"]
    #[doc = " @param adc_unit ADC unit index"]
    #[doc = " @param channel ADC channel index"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc_gpio_init(adc_unit: adc_unit_t, channel: adc_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set ADC data invert"]
    #[doc = " @param adc_unit ADC unit index"]
    #[doc = " @param inv_en whether enable data invert"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc_set_data_inv(adc_unit: adc_unit_t, inv_en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set ADC source clock"]
    #[doc = " @param clk_div ADC clock divider, ADC clock is divided from APB clock"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn adc_set_clk_div(clk_div: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set I2S data source"]
    #[doc = " @param src I2S DMA data source, I2S DMA can get data from digital signals or from ADC."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn adc_set_i2s_data_source(src: adc_i2s_source_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize I2S ADC mode"]
    #[doc = " @param adc_unit ADC unit index"]
    #[doc = " @param channel ADC channel index"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc_i2s_mode_init(adc_unit: adc_unit_t, channel: adc_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure ADC1 to be usable by the ULP"]
    #[doc = ""]
    #[doc = " This function reconfigures ADC1 to be controlled by the ULP."]
    #[doc = " Effect of this function can be reverted using adc1_get_raw function."]
    #[doc = ""]
    #[doc = " Note that adc1_config_channel_atten, adc1_config_width functions need"]
    #[doc = " to be called to configure ADC1 channels, before ADC1 is used by the ULP."]
    pub fn adc1_ulp_enable();
}
extern "C" {
    #[doc = " @brief Read Hall Sensor"]
    #[doc = ""]
    #[doc = " @note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,"]
    #[doc = "       the input of GPIO36 and GPIO39 will be pulled down for about 80ns."]
    #[doc = "       When enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39."]
    #[doc = "       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue."]
    #[doc = ""]
    #[doc = " @note The Hall Sensor uses channels 0 and 3 of ADC1. Do not configure"]
    #[doc = " these channels for use as ADC channels."]
    #[doc = ""]
    #[doc = " @note The ADC1 module must be enabled by calling"]
    #[doc = "       adc1_config_width() before calling hall_sensor_read(). ADC1"]
    #[doc = "       should be configured for 12 bit readings, as the hall sensor"]
    #[doc = "       readings are low values and do not cover the full range of the"]
    #[doc = "       ADC."]
    #[doc = ""]
    #[doc = " @return The hall sensor reading."]
    pub fn hall_sensor_read() -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get the GPIO number of a specific ADC2 channel."]
    #[doc = ""]
    #[doc = " @param channel Channel to get the GPIO number"]
    #[doc = ""]
    #[doc = " @param gpio_num output buffer to hold the GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - ESP_OK if success"]
    #[doc = "   - ESP_ERR_INVALID_ARG if channel not valid"]
    pub fn adc2_pad_get_io_num(channel: adc2_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure the ADC2 channel, including setting attenuation."]
    #[doc = ""]
    #[doc = " @note This function also configures the input GPIO pin mux to"]
    #[doc = " connect it to the ADC2 channel. It must be called before calling"]
    #[doc = " ``adc2_get_raw()`` for this channel."]
    #[doc = ""]
    #[doc = " The default ADC full-scale voltage is 1.1 V. To read higher voltages (up to the pin maximum voltage,"]
    #[doc = " usually 3.3 V) requires setting >0 dB signal attenuation for that ADC channel."]
    #[doc = ""]
    #[doc = " When VDD_A is 3.3 V:"]
    #[doc = ""]
    #[doc = " - 0 dB attenuation (ADC_ATTEN_0db) gives full-scale voltage 1.1 V"]
    #[doc = " - 2.5 dB attenuation (ADC_ATTEN_2_5db) gives full-scale voltage 1.5 V"]
    #[doc = " - 6 dB attenuation (ADC_ATTEN_6db) gives full-scale voltage 2.2 V"]
    #[doc = " - 11 dB attenuation (ADC_ATTEN_11db) gives full-scale voltage 3.9 V (see note below)"]
    #[doc = ""]
    #[doc = " @note The full-scale voltage is the voltage corresponding to a maximum reading"]
    #[doc = " (depending on ADC2 configured bit width, this value is: 4095 for 12-bits, 2047"]
    #[doc = " for 11-bits, 1023 for 10-bits, 511 for 9 bits.)"]
    #[doc = ""]
    #[doc = " @note At 11 dB attenuation the maximum voltage is limited by VDD_A, not the full scale voltage."]
    #[doc = ""]
    #[doc = " @param channel ADC2 channel to configure"]
    #[doc = " @param atten  Attenuation level"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn adc2_config_channel_atten(channel: adc2_channel_t, atten: adc_atten_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Take an ADC2 reading on a single channel"]
    #[doc = ""]
    #[doc = " @note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,"]
    #[doc = "       the input of GPIO36 and GPIO39 will be pulled down for about 80ns."]
    #[doc = "       When enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39."]
    #[doc = "       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue."]
    #[doc = ""]
    #[doc = " @note For a given channel, ``adc2_config_channel_atten()``"]
    #[doc = " must be called before the first time this function is called. If Wi-Fi is started via ``esp_wifi_start()``, this"]
    #[doc = " function will always fail with ``ESP_ERR_TIMEOUT``."]
    #[doc = ""]
    #[doc = " @param  channel ADC2 channel to read"]
    #[doc = ""]
    #[doc = " @param width_bit Bit capture width for ADC2"]
    #[doc = ""]
    #[doc = " @param raw_out the variable to hold the output data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK if success"]
    #[doc = "     - ESP_ERR_TIMEOUT the WIFI is started, using the ADC2"]
    pub fn adc2_get_raw(
        channel: adc2_channel_t,
        width_bit: adc_bits_width_t,
        raw_out: *mut c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "  @brief Output ADC2 reference voltage to GPIO 25 or 26 or 27"]
    #[doc = ""]
    #[doc = "  This function utilizes the testing mux exclusive to ADC 2 to route the"]
    #[doc = "  reference voltage one of ADC2's channels. Supported GPIOs are GPIOs"]
    #[doc = "  25, 26, and 27. This refernce voltage can be manually read from the pin"]
    #[doc = "  and used in the esp_adc_cal component."]
    #[doc = ""]
    #[doc = "  @param[in]  gpio    GPIO number (GPIOs 25, 26 and 27 are supported)"]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "                  - ESP_OK: v_ref successfully routed to selected GPIO"]
    #[doc = "                  - ESP_ERR_INVALID_ARG: Unsupported GPIO"]
    pub fn adc2_vref_to_gpio(gpio: gpio_num_t) -> esp_err_t;
}
#[doc = "< Characterization based on reference voltage stored in eFuse"]
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_EFUSE_VREF: esp_adc_cal_value_t = 0;
#[doc = "< Characterization based on Two Point values stored in eFuse"]
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_EFUSE_TP: esp_adc_cal_value_t = 1;
#[doc = "< Characterization based on default reference voltage"]
pub const esp_adc_cal_value_t_ESP_ADC_CAL_VAL_DEFAULT_VREF: esp_adc_cal_value_t = 2;
#[doc = " @brief Type of calibration value used in characterization"]
pub type esp_adc_cal_value_t = c_types::c_uint;
#[doc = " @brief Structure storing characteristics of an ADC"]
#[doc = ""]
#[doc = " @note Call esp_adc_cal_characterize() to initialize the structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_adc_cal_characteristics_t {
    #[doc = "< ADC number"]
    pub adc_num: adc_unit_t,
    #[doc = "< ADC attenuation"]
    pub atten: adc_atten_t,
    #[doc = "< ADC bit width"]
    pub bit_width: adc_bits_width_t,
    #[doc = "< Gradient of ADC-Voltage curve"]
    pub coeff_a: u32,
    #[doc = "< Offset of ADC-Voltage curve"]
    pub coeff_b: u32,
    #[doc = "< Vref used by lookup table"]
    pub vref: u32,
    #[doc = "< Pointer to low Vref curve of lookup table (NULL if unused)"]
    pub low_curve: *const u32,
    #[doc = "< Pointer to high Vref curve of lookup table (NULL if unused)"]
    pub high_curve: *const u32,
}
extern "C" {
    #[doc = " @brief Checks if ADC calibration values are burned into eFuse"]
    #[doc = ""]
    #[doc = " This function checks if ADC reference voltage or Two Point values have been"]
    #[doc = " burned to the eFuse of the current ESP32"]
    #[doc = ""]
    #[doc = " @param   value_type  Type of calibration value (ESP_ADC_CAL_VAL_EFUSE_VREF or ESP_ADC_CAL_VAL_EFUSE_TP)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: The calibration mode is supported in eFuse"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED: Error, eFuse values are not burned"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Error, invalid argument (ESP_ADC_CAL_VAL_DEFAULT_VREF)"]
    pub fn esp_adc_cal_check_efuse(value_type: esp_adc_cal_value_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Characterize an ADC at a particular attenuation"]
    #[doc = ""]
    #[doc = " This function will characterize the ADC at a particular attenuation and generate"]
    #[doc = " the ADC-Voltage curve in the form of [y = coeff_a * x + coeff_b]."]
    #[doc = " Characterization can be based on Two Point values, eFuse Vref, or default Vref"]
    #[doc = " and the calibration values will be prioritized in that order."]
    #[doc = ""]
    #[doc = " @note Two Point values and eFuse Vref can be enabled/disabled using menuconfig."]
    #[doc = ""]
    #[doc = " @param[in]   adc_num         ADC to characterize (ADC_UNIT_1 or ADC_UNIT_2)"]
    #[doc = " @param[in]   atten           Attenuation to characterize"]
    #[doc = " @param[in]   bit_width       Bit width configuration of ADC"]
    #[doc = " @param[in]   default_vref    Default ADC reference voltage in mV (used if eFuse values is not available)"]
    #[doc = " @param[out]  chars           Pointer to empty structure used to store ADC characteristics"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_ADC_CAL_VAL_EFUSE_VREF: eFuse Vref used for characterization"]
    #[doc = "      - ESP_ADC_CAL_VAL_EFUSE_TP: Two Point value used for characterization (only in Linear Mode)"]
    #[doc = "      - ESP_ADC_CAL_VAL_DEFAULT_VREF: Default Vref used for characterization"]
    pub fn esp_adc_cal_characterize(
        adc_num: adc_unit_t,
        atten: adc_atten_t,
        bit_width: adc_bits_width_t,
        default_vref: u32,
        chars: *mut esp_adc_cal_characteristics_t,
    ) -> esp_adc_cal_value_t;
}
extern "C" {
    #[doc = " @brief   Convert an ADC reading to voltage in mV"]
    #[doc = ""]
    #[doc = " This function converts an ADC reading to a voltage in mV based on the ADC's"]
    #[doc = " characteristics."]
    #[doc = ""]
    #[doc = " @note    Characteristics structure must be initialized before this function"]
    #[doc = "          is called (call esp_adc_cal_characterize())"]
    #[doc = ""]
    #[doc = " @param[in]   adc_reading     ADC reading"]
    #[doc = " @param[in]   chars           Pointer to initialized structure containing ADC characteristics"]
    #[doc = ""]
    #[doc = " @return      Voltage in mV"]
    pub fn esp_adc_cal_raw_to_voltage(
        adc_reading: u32,
        chars: *const esp_adc_cal_characteristics_t,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief   Reads an ADC and converts the reading to a voltage in mV"]
    #[doc = ""]
    #[doc = " This function reads an ADC then converts the raw reading to a voltage in mV"]
    #[doc = " based on the characteristics provided. The ADC that is read is also"]
    #[doc = " determined by the characteristics."]
    #[doc = ""]
    #[doc = " @note    The Characteristics structure must be initialized before this"]
    #[doc = "          function is called (call esp_adc_cal_characterize())"]
    #[doc = ""]
    #[doc = " @param[in]   channel     ADC Channel to read"]
    #[doc = " @param[in]   chars       Pointer to initialized ADC characteristics structure"]
    #[doc = " @param[out]  voltage     Pointer to store converted voltage"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: ADC read and converted to mV"]
    #[doc = "      - ESP_ERR_TIMEOUT: Error, timed out attempting to read ADC"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Error due to invalid arguments"]
    pub fn esp_adc_cal_get_voltage(
        channel: adc_channel_t,
        chars: *const esp_adc_cal_characteristics_t,
        voltage: *mut u32,
    ) -> esp_err_t;
}
#[doc = " Opaque pointer type representing non-volatile storage handle"]
pub type nvs_handle_t = u32;
pub type nvs_handle = nvs_handle_t;
#[doc = "< Read only"]
pub const nvs_open_mode_t_NVS_READONLY: nvs_open_mode_t = 0;
#[doc = "< Read and write"]
pub const nvs_open_mode_t_NVS_READWRITE: nvs_open_mode_t = 1;
#[doc = " @brief Mode of opening the non-volatile storage"]
pub type nvs_open_mode_t = c_types::c_uint;
pub use self::nvs_open_mode_t as nvs_open_mode;
#[doc = "< Type uint8_t"]
pub const nvs_type_t_NVS_TYPE_U8: nvs_type_t = 1;
#[doc = "< Type int8_t"]
pub const nvs_type_t_NVS_TYPE_I8: nvs_type_t = 17;
#[doc = "< Type uint16_t"]
pub const nvs_type_t_NVS_TYPE_U16: nvs_type_t = 2;
#[doc = "< Type int16_t"]
pub const nvs_type_t_NVS_TYPE_I16: nvs_type_t = 18;
#[doc = "< Type uint32_t"]
pub const nvs_type_t_NVS_TYPE_U32: nvs_type_t = 4;
#[doc = "< Type int32_t"]
pub const nvs_type_t_NVS_TYPE_I32: nvs_type_t = 20;
#[doc = "< Type uint64_t"]
pub const nvs_type_t_NVS_TYPE_U64: nvs_type_t = 8;
#[doc = "< Type int64_t"]
pub const nvs_type_t_NVS_TYPE_I64: nvs_type_t = 24;
#[doc = "< Type string"]
pub const nvs_type_t_NVS_TYPE_STR: nvs_type_t = 33;
#[doc = "< Type blob"]
pub const nvs_type_t_NVS_TYPE_BLOB: nvs_type_t = 66;
#[doc = "< Must be last"]
pub const nvs_type_t_NVS_TYPE_ANY: nvs_type_t = 255;
#[doc = " @brief Types of variables"]
#[doc = ""]
pub type nvs_type_t = c_types::c_uint;
#[doc = " @brief information about entry obtained from nvs_entry_info function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_entry_info_t {
    #[doc = "< Namespace to which key-value belong"]
    pub namespace_name: [c_types::c_char; 16usize],
    #[doc = "< Key of stored key-value pair"]
    pub key: [c_types::c_char; 16usize],
    #[doc = "< Type of stored key-value pair"]
    pub type_: nvs_type_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_opaque_iterator_t {
    _unused: [u8; 0],
}
#[doc = " Opaque pointer type representing iterator to nvs entries"]
pub type nvs_iterator_t = *mut nvs_opaque_iterator_t;
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from the default NVS partition"]
    #[doc = ""]
    #[doc = " Multiple internal ESP-IDF and third party application modules can store"]
    #[doc = " their key-value pairs in the NVS module. In order to reduce possible"]
    #[doc = " conflicts on key names, each module can use its own namespace."]
    #[doc = " The default NVS partition is the one that is labelled \"nvs\" in the partition"]
    #[doc = " table."]
    #[doc = ""]
    #[doc = " @param[in]  name        Namespace name. Maximal length is determined by the"]
    #[doc = "                         underlying implementation, but is guaranteed to be"]
    #[doc = "                         at least 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  open_mode   NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will"]
    #[doc = "                         open a handle for reading only. All write requests will"]
    #[doc = "             be rejected for this handle."]
    #[doc = " @param[out] out_handle  If successful (return code is zero), handle will be"]
    #[doc = "                         returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if storage handle was opened successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized"]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with label \"nvs\" is not found"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and"]
    #[doc = "               mode is NVS_READONLY"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_open(
        name: *const c_types::c_char,
        open_mode: nvs_open_mode_t,
        out_handle: *mut nvs_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from specified partition"]
    #[doc = ""]
    #[doc = " The behaviour is same as nvs_open() API. However this API can operate on a specified NVS"]
    #[doc = " partition instead of default NVS partition. Note that the specified partition must be registered"]
    #[doc = " with NVS using nvs_flash_init_partition() API."]
    #[doc = ""]
    #[doc = " @param[in]  part_name   Label (name) of the partition of interest for object read/write/erase"]
    #[doc = " @param[in]  name        Namespace name. Maximal length is determined by the"]
    #[doc = "                         underlying implementation, but is guaranteed to be"]
    #[doc = "                         at least 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  open_mode   NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will"]
    #[doc = "                         open a handle for reading only. All write requests will"]
    #[doc = "             be rejected for this handle."]
    #[doc = " @param[out] out_handle  If successful (return code is zero), handle will be"]
    #[doc = "                         returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if storage handle was opened successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized"]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with specified name is not found"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and"]
    #[doc = "               mode is NVS_READONLY"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_open_from_partition(
        part_name: *const c_types::c_char,
        name: *const c_types::c_char,
        open_mode: nvs_open_mode_t,
        out_handle: *mut nvs_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " @brief      set value for given key"]
    #[doc = ""]
    #[doc = " This family of functions set value for the key, given its name. Note that"]
    #[doc = " actual storage will not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle obtained from nvs_open function."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = " @param[in]  key     Key name. Maximal length is determined by the underlying"]
    #[doc = "                     implementation, but is guaranteed to be at least"]
    #[doc = "                     15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  value   The value to set."]
    #[doc = "                     For strings, the maximum length (including null character) is"]
    #[doc = "                     4000 bytes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if value was set successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the"]
    #[doc = "               underlying storage to save the value"]
    #[doc = "             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash"]
    #[doc = "               write operation has failed. The value was written however, and"]
    #[doc = "               update will be finished after re-initialization of nvs, provided that"]
    #[doc = "               flash operation doesn't fail again."]
    #[doc = "             - ESP_ERR_NVS_VALUE_TOO_LONG if the string value is too long"]
    pub fn nvs_set_i8(handle: nvs_handle_t, key: *const c_types::c_char, value: i8) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u8(handle: nvs_handle_t, key: *const c_types::c_char, value: u8) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i16(handle: nvs_handle_t, key: *const c_types::c_char, value: i16) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u16(handle: nvs_handle_t, key: *const c_types::c_char, value: u16) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i32(handle: nvs_handle_t, key: *const c_types::c_char, value: i32) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u32(handle: nvs_handle_t, key: *const c_types::c_char, value: u32) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i64(handle: nvs_handle_t, key: *const c_types::c_char, value: i64) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u64(handle: nvs_handle_t, key: *const c_types::c_char, value: u64) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_str(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        value: *const c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       set variable length binary value for given key"]
    #[doc = ""]
    #[doc = " This family of functions set value for the key, given its name. Note that"]
    #[doc = " actual storage will not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle obtained from nvs_open function."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = " @param[in]  key     Key name. Maximal length is 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  value   The value to set."]
    #[doc = " @param[in]  length  length of binary value to set, in bytes; Maximum length is"]
    #[doc = "                     508000 bytes or (97.6% of the partition size - 4000) bytes"]
    #[doc = "                     whichever is lower."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if value was set successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the"]
    #[doc = "               underlying storage to save the value"]
    #[doc = "             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash"]
    #[doc = "               write operation has failed. The value was written however, and"]
    #[doc = "               update will be finished after re-initialization of nvs, provided that"]
    #[doc = "               flash operation doesn't fail again."]
    #[doc = "             - ESP_ERR_NVS_VALUE_TOO_LONG if the value is too long"]
    pub fn nvs_set_blob(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        value: *const c_types::c_void,
        length: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " @brief      get value for given key"]
    #[doc = ""]
    #[doc = " These functions retrieve value for the key, given its name. If key does not"]
    #[doc = " exist, or the requested variable type doesn't match the type which was used"]
    #[doc = " when setting a value, an error is returned."]
    #[doc = ""]
    #[doc = " In case of any error, out_value is not modified."]
    #[doc = ""]
    #[doc = " All functions expect out_value to be a pointer to an already allocated variable"]
    #[doc = " of the given type."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of using nvs_get_i32:"]
    #[doc = " int32_t max_buffer_size = 4096; // default value"]
    #[doc = " esp_err_t err = nvs_get_i32(my_handle, \"max_buffer_size\", &max_buffer_size);"]
    #[doc = " assert(err == ESP_OK || err == ESP_ERR_NVS_NOT_FOUND);"]
    #[doc = " // if ESP_ERR_NVS_NOT_FOUND was returned, max_buffer_size will still"]
    #[doc = " // have its default value."]
    #[doc = ""]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]     handle     Handle obtained from nvs_open function."]
    #[doc = " @param[in]     key        Key name. Maximal length is determined by the underlying"]
    #[doc = "                           implementation, but is guaranteed to be at least"]
    #[doc = "                           15 characters. Shouldn't be empty."]
    #[doc = " @param         out_value  Pointer to the output value."]
    #[doc = "                           May be NULL for nvs_get_str and nvs_get_blob, in this"]
    #[doc = "                           case required length will be returned in length argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the value was retrieved successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data"]
    pub fn nvs_get_i8(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut i8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u8(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i16(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut i16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u16(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut u16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i32(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut i32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u32(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i64(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut i64,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u64(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get value for given key"]
    #[doc = ""]
    #[doc = " These functions retrieve the data of an entry, given its key. If key does not"]
    #[doc = " exist, or the requested variable type doesn't match the type which was used"]
    #[doc = " when setting a value, an error is returned."]
    #[doc = ""]
    #[doc = " In case of any error, out_value is not modified."]
    #[doc = ""]
    #[doc = " All functions expect out_value to be a pointer to an already allocated variable"]
    #[doc = " of the given type."]
    #[doc = ""]
    #[doc = " nvs_get_str and nvs_get_blob functions support WinAPI-style length queries."]
    #[doc = " To get the size necessary to store the value, call nvs_get_str or nvs_get_blob"]
    #[doc = " with zero out_value and non-zero pointer to length. Variable pointed to"]
    #[doc = " by length argument will be set to the required length. For nvs_get_str,"]
    #[doc = " this length includes the zero terminator. When calling nvs_get_str and"]
    #[doc = " nvs_get_blob with non-zero out_value, length has to be non-zero and has to"]
    #[doc = " point to the length available in out_value."]
    #[doc = " It is suggested that nvs_get/set_str is used for zero-terminated C strings, and"]
    #[doc = " nvs_get/set_blob used for arbitrary data structures."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example (without error checking) of using nvs_get_str to get a string into dynamic array:"]
    #[doc = " size_t required_size;"]
    #[doc = " nvs_get_str(my_handle, \"server_name\", NULL, &required_size);"]
    #[doc = " char* server_name = malloc(required_size);"]
    #[doc = " nvs_get_str(my_handle, \"server_name\", server_name, &required_size);"]
    #[doc = ""]
    #[doc = " // Example (without error checking) of using nvs_get_blob to get a binary data"]
    #[doc = " into a static array:"]
    #[doc = " uint8_t mac_addr[6];"]
    #[doc = " size_t size = sizeof(mac_addr);"]
    #[doc = " nvs_get_blob(my_handle, \"dst_mac_addr\", mac_addr, &size);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]     handle     Handle obtained from nvs_open function."]
    #[doc = " @param[in]     key        Key name. Maximal length is determined by the underlying"]
    #[doc = "                           implementation, but is guaranteed to be at least"]
    #[doc = "                           15 characters. Shouldn't be empty."]
    #[doc = " @param         out_value  Pointer to the output value."]
    #[doc = "                           May be NULL for nvs_get_str and nvs_get_blob, in this"]
    #[doc = "                           case required length will be returned in length argument."]
    #[doc = " @param[inout]  length     A non-zero pointer to the variable holding the length of out_value."]
    #[doc = "                           In case out_value a zero, will be set to the length"]
    #[doc = "                           required to hold the value. In case out_value is not"]
    #[doc = "                           zero, will be set to the actual length of the value"]
    #[doc = "                           written. For nvs_get_str this includes zero terminator."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the value was retrieved successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data"]
    pub fn nvs_get_str(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut c_types::c_char,
        length: *mut size_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_blob(
        handle: nvs_handle_t,
        key: *const c_types::c_char,
        out_value: *mut c_types::c_void,
        length: *mut size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase key-value pair with given key name."]
    #[doc = ""]
    #[doc = " Note that actual storage may not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @param[in]  key     Key name. Maximal length is determined by the underlying"]
    #[doc = "                     implementation, but is guaranteed to be at least"]
    #[doc = "                     15 characters. Shouldn't be empty."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "              - ESP_OK if erase operation was successful"]
    #[doc = "              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only"]
    #[doc = "              - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_key(handle: nvs_handle_t, key: *const c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase all key-value pairs in a namespace"]
    #[doc = ""]
    #[doc = " Note that actual storage may not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "              - ESP_OK if erase operation was successful"]
    #[doc = "              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only"]
    #[doc = "              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_all(handle: nvs_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Write any pending changes to non-volatile storage"]
    #[doc = ""]
    #[doc = " After setting any values, nvs_commit() must be called to ensure changes are written"]
    #[doc = " to non-volatile storage. Individual implementations may write to storage at other times,"]
    #[doc = " but this is not guaranteed."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the changes have been written successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_commit(handle: nvs_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Close the storage handle and free any allocated resources"]
    #[doc = ""]
    #[doc = " This function should be called for each handle opened with nvs_open once"]
    #[doc = " the handle is not in use any more. Closing the handle may not automatically"]
    #[doc = " write the changes to nonvolatile storage. This has to be done explicitly using"]
    #[doc = " nvs_commit function."]
    #[doc = " Once this function is called on a handle, the handle should no longer be used."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle to close"]
    pub fn nvs_close(handle: nvs_handle_t);
}
#[doc = " @note Info about storage space NVS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_stats_t {
    #[doc = "< Amount of used entries."]
    pub used_entries: size_t,
    #[doc = "< Amount of free entries."]
    pub free_entries: size_t,
    #[doc = "< Amount all available entries."]
    pub total_entries: size_t,
    #[doc = "< Amount name space."]
    pub namespace_count: size_t,
}
extern "C" {
    #[doc = " @brief      Fill structure nvs_stats_t. It provides info about used memory the partition."]
    #[doc = ""]
    #[doc = " This function calculates to runtime the number of used entries, free entries, total entries,"]
    #[doc = " and amount namespace in partition."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of nvs_get_stats() to get the number of used entries and free entries:"]
    #[doc = " nvs_stats_t nvs_stats;"]
    #[doc = " nvs_get_stats(NULL, &nvs_stats);"]
    #[doc = " printf(\"Count: UsedEntries = (%d), FreeEntries = (%d), AllEntries = (%d)\\n\","]
    #[doc = "nvs_stats.used_entries, nvs_stats.free_entries, nvs_stats.total_entries);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]   part_name   Partition name NVS in the partition table."]
    #[doc = "                          If pass a NULL than will use NVS_DEFAULT_PART_NAME (\"nvs\")."]
    #[doc = ""]
    #[doc = " @param[out]  nvs_stats   Returns filled structure nvs_states_t."]
    #[doc = "                          It provides info about used memory the partition."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the changes have been written successfully."]
    #[doc = "               Return param nvs_stats will be filled."]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with label \"name\" is not found."]
    #[doc = "               Return param nvs_stats will be filled 0."]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized."]
    #[doc = "               Return param nvs_stats will be filled 0."]
    #[doc = "             - ESP_ERR_INVALID_ARG if nvs_stats equal to NULL."]
    #[doc = "             - ESP_ERR_INVALID_STATE if there is page with the status of INVALID."]
    #[doc = "               Return param nvs_stats will be filled not with correct values because"]
    #[doc = "               not all pages will be counted. Counting will be interrupted at the first INVALID page."]
    pub fn nvs_get_stats(
        part_name: *const c_types::c_char,
        nvs_stats: *mut nvs_stats_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Calculate all entries in a namespace."]
    #[doc = ""]
    #[doc = " Note that to find out the total number of records occupied by the namespace,"]
    #[doc = " add one to the returned value used_entries (if err is equal to ESP_OK)."]
    #[doc = " Because the name space entry takes one entry."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of nvs_get_used_entry_count() to get amount of all key-value pairs in one namespace:"]
    #[doc = " nvs_handle_t handle;"]
    #[doc = " nvs_open(\"namespace1\", NVS_READWRITE, &handle);"]
    #[doc = " ..."]
    #[doc = " size_t used_entries;"]
    #[doc = " size_t total_entries_namespace;"]
    #[doc = " if(nvs_get_used_entry_count(handle, &used_entries) == ESP_OK){"]
    #[doc = "     // the total number of records occupied by the namespace"]
    #[doc = "     total_entries_namespace = used_entries + 1;"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]   handle              Handle obtained from nvs_open function."]
    #[doc = ""]
    #[doc = " @param[out]  used_entries        Returns amount of used entries from a namespace."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the changes have been written successfully."]
    #[doc = "               Return param used_entries will be filled valid value."]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized."]
    #[doc = "               Return param used_entries will be filled 0."]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL."]
    #[doc = "               Return param used_entries will be filled 0."]
    #[doc = "             - ESP_ERR_INVALID_ARG if used_entries equal to NULL."]
    #[doc = "             - Other error codes from the underlying storage driver."]
    #[doc = "               Return param used_entries will be filled 0."]
    pub fn nvs_get_used_entry_count(handle: nvs_handle_t, used_entries: *mut size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       Create an iterator to enumerate NVS entries based on one or more parameters"]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of listing all the key-value pairs of any type under specified partition and namespace"]
    #[doc = " nvs_iterator_t it = nvs_entry_find(partition, namespace, NVS_TYPE_ANY);"]
    #[doc = " while (it != NULL) {"]
    #[doc = "         nvs_entry_info_t info;"]
    #[doc = "         nvs_entry_info(it, &info);"]
    #[doc = "         it = nvs_entry_next(it);"]
    #[doc = "         printf(\"key '%s', type '%d' \\n\", info.key, info.type);"]
    #[doc = " };"]
    #[doc = " // Note: no need to release iterator obtained from nvs_entry_find function when"]
    #[doc = " //       nvs_entry_find or nvs_entry_next function return NULL, indicating no other"]
    #[doc = " //       element for specified criteria was found."]
    #[doc = " }"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]   part_name       Partition name"]
    #[doc = ""]
    #[doc = " @param[in]   namespace_name  Set this value if looking for entries with"]
    #[doc = "                              a specific namespace. Pass NULL otherwise."]
    #[doc = ""]
    #[doc = " @param[in]   type            One of nvs_type_t values."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          Iterator used to enumerate all the entries found,"]
    #[doc = "          or NULL if no entry satisfying criteria was found."]
    #[doc = "          Iterator obtained through this function has to be released"]
    #[doc = "          using nvs_release_iterator when not used any more."]
    pub fn nvs_entry_find(
        part_name: *const c_types::c_char,
        namespace_name: *const c_types::c_char,
        type_: nvs_type_t,
    ) -> nvs_iterator_t;
}
extern "C" {
    #[doc = " @brief       Returns next item matching the iterator criteria, NULL if no such item exists."]
    #[doc = ""]
    #[doc = " Note that any copies of the iterator will be invalid after this call."]
    #[doc = ""]
    #[doc = " @param[in]   iterator     Iterator obtained from nvs_entry_find function. Must be non-NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          NULL if no entry was found, valid nvs_iterator_t otherwise."]
    pub fn nvs_entry_next(iterator: nvs_iterator_t) -> nvs_iterator_t;
}
extern "C" {
    #[doc = " @brief       Fills nvs_entry_info_t structure with information about entry pointed to by the iterator."]
    #[doc = ""]
    #[doc = " @param[in]   iterator     Iterator obtained from nvs_entry_find or nvs_entry_next function. Must be non-NULL."]
    #[doc = ""]
    #[doc = " @param[out]  out_info     Structure to which entry information is copied."]
    pub fn nvs_entry_info(iterator: nvs_iterator_t, out_info: *mut nvs_entry_info_t);
}
extern "C" {
    #[doc = " @brief       Release iterator"]
    #[doc = ""]
    #[doc = " @param[in]   iterator    Release iterator obtained from nvs_entry_find function. NULL argument is allowed."]
    #[doc = ""]
    pub fn nvs_release_iterator(iterator: nvs_iterator_t);
}
#[doc = "< The chip doesn't have enough space for the current partition table"]
pub const ESP_ERR_FLASH_SIZE_NOT_MATCH: c_types::c_uint = 260;
#[doc = "< Chip did not respond to the command, or timed out."]
pub const ESP_ERR_FLASH_NO_RESPONSE: c_types::c_uint = 264;
pub type _bindgen_ty_1 = c_types::c_uint;
#[doc = " Definition of a common transaction. Also holds the return value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_trans_t {
    #[doc = "< Command to send, always 8bits"]
    pub command: u8,
    #[doc = "< Output data length, in bytes"]
    pub mosi_len: u8,
    #[doc = "< Input data length, in bytes"]
    pub miso_len: u8,
    #[doc = "< Length of address in bits, set to 0 if command does not need an address"]
    pub address_bitlen: u8,
    #[doc = "< Address to perform operation on"]
    pub address: u32,
    #[doc = "< Output data to salve"]
    pub mosi_data: *const u8,
    #[doc = "< [out] Input data from slave, little endian"]
    pub miso_data: *mut u8,
}
#[doc = "< The flash runs under 5MHz"]
pub const esp_flash_speed_t_ESP_FLASH_5MHZ: esp_flash_speed_t = 0;
#[doc = "< The flash runs under 10MHz"]
pub const esp_flash_speed_t_ESP_FLASH_10MHZ: esp_flash_speed_t = 1;
#[doc = "< The flash runs under 20MHz"]
pub const esp_flash_speed_t_ESP_FLASH_20MHZ: esp_flash_speed_t = 2;
#[doc = "< The flash runs under 26MHz"]
pub const esp_flash_speed_t_ESP_FLASH_26MHZ: esp_flash_speed_t = 3;
#[doc = "< The flash runs under 40MHz"]
pub const esp_flash_speed_t_ESP_FLASH_40MHZ: esp_flash_speed_t = 4;
#[doc = "< The flash runs under 80MHz"]
pub const esp_flash_speed_t_ESP_FLASH_80MHZ: esp_flash_speed_t = 5;
#[doc = "< The maximum frequency supported by the host is ``ESP_FLASH_SPEED_MAX-1``."]
pub const esp_flash_speed_t_ESP_FLASH_SPEED_MAX: esp_flash_speed_t = 6;
#[doc = " @brief SPI flash clock speed values, always refer to them by the enum rather"]
#[doc = " than the actual value (more speed may be appended into the list)."]
#[doc = ""]
#[doc = " A strategy to select the maximum allowed speed is to enumerate from the"]
#[doc = " ``ESP_FLSH_SPEED_MAX-1`` or highest frequency supported by your flash, and"]
#[doc = " decrease the speed until the probing success."]
pub type esp_flash_speed_t = c_types::c_uint;
#[doc = "< Data read using single I/O, some limits on speed"]
pub const esp_flash_io_mode_t_SPI_FLASH_SLOWRD: esp_flash_io_mode_t = 0;
#[doc = "< Data read using single I/O, no limit on speed"]
pub const esp_flash_io_mode_t_SPI_FLASH_FASTRD: esp_flash_io_mode_t = 1;
#[doc = "< Data read using dual I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_DOUT: esp_flash_io_mode_t = 2;
#[doc = "< Both address & data transferred using dual I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_DIO: esp_flash_io_mode_t = 3;
#[doc = "< Data read using quad I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_QOUT: esp_flash_io_mode_t = 4;
#[doc = "< Both address & data transferred using quad I/O"]
pub const esp_flash_io_mode_t_SPI_FLASH_QIO: esp_flash_io_mode_t = 5;
#[doc = "< The fastest io mode supported by the host is ``ESP_FLASH_READ_MODE_MAX-1``."]
pub const esp_flash_io_mode_t_SPI_FLASH_READ_MODE_MAX: esp_flash_io_mode_t = 6;
#[doc = " @brief Mode used for reading from SPI flash"]
pub type esp_flash_io_mode_t = c_types::c_uint;
#[doc = " Host driver configuration and context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_host_driver_t {
    #[doc = " Configuration and static data used by the specific host driver. The type"]
    #[doc = " is determined by the host driver."]
    pub driver_data: *mut c_types::c_void,
    #[doc = " Configure the device-related register before transactions. This saves"]
    #[doc = " some time to re-configure those registers when we send continuously"]
    pub dev_config: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t) -> esp_err_t,
    >,
    #[doc = " Send an user-defined spi transaction to the device."]
    pub common_command: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            t: *mut spi_flash_trans_t,
        ) -> esp_err_t,
    >,
    #[doc = " Read flash ID."]
    pub read_id: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, id: *mut u32) -> esp_err_t,
    >,
    #[doc = " Erase whole flash chip."]
    pub erase_chip:
        ::core::option::Option<unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t)>,
    #[doc = " Erase a specific sector by its start address."]
    pub erase_sector: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, start_address: u32),
    >,
    #[doc = " Erase a specific block by its start address."]
    pub erase_block: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, start_address: u32),
    >,
    #[doc = " Read the status of the flash chip."]
    pub read_status: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, out_sr: *mut u8) -> esp_err_t,
    >,
    #[doc = " Disable write protection."]
    pub set_write_protect: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t, wp: bool) -> esp_err_t,
    >,
    #[doc = " Program a page of the flash. Check ``max_write_bytes`` for the maximum allowed writing length."]
    pub program_page: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            buffer: *const c_types::c_void,
            address: u32,
            length: u32,
        ),
    >,
    #[doc = " Check whether need to allocate new buffer to write"]
    pub supports_direct_write: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            p: *const c_types::c_void,
        ) -> bool,
    >,
    #[doc = " Check whether need to allocate new buffer to read"]
    pub supports_direct_read: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            p: *const c_types::c_void,
        ) -> bool,
    >,
    #[doc = " maximum length of program_page"]
    pub max_write_bytes: c_types::c_int,
    #[doc = " Read data from the flash. Check ``max_read_bytes`` for the maximum allowed reading length."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            buffer: *mut c_types::c_void,
            address: u32,
            read_len: u32,
        ) -> esp_err_t,
    >,
    #[doc = " maximum length of read"]
    pub max_read_bytes: c_types::c_int,
    #[doc = " Check whether the host is idle to perform new operations."]
    pub host_idle:
        ::core::option::Option<unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t) -> bool>,
    #[doc = " Configure the host to work at different read mode. Responsible to compensate the timing and set IO mode."]
    pub configure_host_io_mode: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            command: u32,
            addr_bitlen: u32,
            dummy_bitlen_base: c_types::c_int,
            io_mode: esp_flash_io_mode_t,
        ) -> esp_err_t,
    >,
    #[doc = "  Internal use, poll the HW until the last operation is done."]
    pub poll_cmd_done:
        ::core::option::Option<unsafe extern "C" fn(driver: *mut spi_flash_host_driver_t)>,
    #[doc = " For some host (SPI1), they are shared with a cache. When the data is"]
    #[doc = " modified, the cache needs to be flushed. Left NULL if not supported."]
    pub flush_cache: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut spi_flash_host_driver_t,
            addr: u32,
            size: u32,
        ) -> esp_err_t,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_chip_t {
    _unused: [u8; 0],
}
#[doc = " @brief Structure for describing a region of flash"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_flash_region_t {
    #[doc = "< Start address of this region"]
    pub offset: u32,
    #[doc = "< Size of the region"]
    pub size: u32,
}
#[doc = " OS-level integration hooks for accessing flash chips inside a running OS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_flash_os_functions_t {
    #[doc = " Called before commencing any flash operation. Does not need to be"]
    #[doc = " recursive (ie is called at most once for each call to 'end')."]
    pub start: ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void) -> esp_err_t>,
    #[doc = " Called after completing any flash operation."]
    pub end: ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void) -> esp_err_t>,
    #[doc = " Called before any erase/write operations to check whether the region is limited by the OS"]
    pub region_protected: ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut c_types::c_void,
            start_addr: size_t,
            size: size_t,
        ) -> esp_err_t,
    >,
    #[doc = " Delay for at least 'us' microseconds. Called in between 'start' and 'end'."]
    pub delay_us: ::core::option::Option<
        unsafe extern "C" fn(arg: *mut c_types::c_void, us: c_types::c_uint) -> esp_err_t,
    >,
    #[doc = " Yield to other tasks. Called during erase operations."]
    pub yield_:
        ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void) -> esp_err_t>,
}
#[doc = " @brief Structure to describe a SPI flash chip connected to the system."]
#[doc = ""]
#[doc = "Structure must be initialized before use (passed to esp_flash_init())."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_flash_t {
    #[doc = "< Pointer to hardware-specific \"host_driver\" structure. Must be initialized before used."]
    pub host: *mut spi_flash_host_driver_t,
    #[doc = "< Pointer to chip-model-specific \"adapter\" structure. If NULL, will be detected during initialisation."]
    pub chip_drv: *const spi_flash_chip_t,
    #[doc = "< Pointer to os-specific hook structure. Call ``esp_flash_init_os_functions()`` to setup this field, after the host is properly initialized."]
    pub os_func: *const esp_flash_os_functions_t,
    #[doc = "< Pointer to argument for os-specific hooks. Left NULL and will be initialized with ``os_func``."]
    pub os_func_data: *mut c_types::c_void,
    #[doc = "< Configured SPI flash read mode. Set before ``esp_flash_init`` is called."]
    pub read_mode: esp_flash_io_mode_t,
    #[doc = "< Size of SPI flash in bytes. If 0, size will be detected during initialisation."]
    pub size: u32,
    #[doc = "< Detected chip id."]
    pub chip_id: u32,
}
extern "C" {
    #[doc = " @brief Initialise SPI flash chip interface."]
    #[doc = ""]
    #[doc = " This function must be called before any other API functions are called for this chip."]
    #[doc = ""]
    #[doc = " @note Only the ``host`` and ``read_mode`` fields of the chip structure must"]
    #[doc = "       be initialised before this function is called. Other fields may be"]
    #[doc = "       auto-detected if left set to zero or NULL."]
    #[doc = ""]
    #[doc = " @note If the chip->drv pointer is NULL, chip chip_drv will be auto-detected"]
    #[doc = "       based on its manufacturer & product IDs. See"]
    #[doc = "       ``esp_flash_registered_flash_drivers`` pointer for details of this process."]
    #[doc = ""]
    #[doc = " @param chip Pointer to SPI flash chip to use. If NULL, esp_flash_default_chip is substituted."]
    #[doc = " @return ESP_OK on success, or a flash error code if initialisation fails."]
    pub fn esp_flash_init(chip: *mut esp_flash_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Check if appropriate chip driver is set."]
    #[doc = ""]
    #[doc = " @param chip Pointer to SPI flash chip to use. If NULL, esp_flash_default_chip is substituted."]
    #[doc = ""]
    #[doc = " @return true if set, otherwise false."]
    pub fn esp_flash_chip_driver_initialized(chip: *const esp_flash_t) -> bool;
}
extern "C" {
    #[doc = " @brief Read flash ID via the common \"RDID\" SPI flash command."]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param[out] out_id Pointer to receive ID value."]
    #[doc = ""]
    #[doc = " ID is a 24-bit value. Lower 16 bits of 'id' are the chip ID, upper 8 bits are the manufacturer ID."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_read_id(chip: *mut esp_flash_t, out_id: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Detect flash size based on flash ID."]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param[out] out_size Detected size in bytes."]
    #[doc = ""]
    #[doc = " @note Most flash chips use a common format for flash ID, where the lower 4 bits specify the size as a power of 2. If"]
    #[doc = " the manufacturer doesn't follow this convention, the size may be incorrectly detected."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_size(chip: *mut esp_flash_t, out_size: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase flash chip contents"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_erase_chip(chip: *mut esp_flash_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase a region of the flash chip"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param start Address to start erasing flash. Must be sector aligned."]
    #[doc = " @param len Length of region to erase. Must also be sector aligned."]
    #[doc = ""]
    #[doc = " Sector size is specifyed in chip->drv->sector_size field (typically 4096 bytes.) ESP_ERR_INVALID_ARG will be"]
    #[doc = " returned if the start & length are not a multiple of this size."]
    #[doc = ""]
    #[doc = " Erase is performed using block (multi-sector) erases where possible (block size is specified in"]
    #[doc = " chip->drv->block_erase_size field, typically 65536 bytes). Remaining sectors are erased using individual sector erase"]
    #[doc = " commands."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_erase_region(chip: *mut esp_flash_t, start: u32, len: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read if the entire chip is write protected"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param[out] write_protected Pointer to boolean, set to the value of the write protect flag."]
    #[doc = ""]
    #[doc = " @note A correct result for this flag depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'"]
    #[doc = " field)."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_chip_write_protect(
        chip: *mut esp_flash_t,
        write_protected: *mut bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set write protection for the SPI flash chip"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param write_protect Boolean value for the write protect flag"]
    #[doc = ""]
    #[doc = " @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'"]
    #[doc = " field)."]
    #[doc = ""]
    #[doc = " Some SPI flash chips may require a power cycle before write protect status can be cleared. Otherwise,"]
    #[doc = " write protection can be removed via a follow-up call to this function."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_set_chip_write_protect(
        chip: *mut esp_flash_t,
        write_protect: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read the list of individually protectable regions of this SPI flash chip."]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param[out] out_regions Pointer to receive a pointer to the array of protectable regions of the chip."]
    #[doc = " @param[out] out_num_regions Pointer to an integer receiving the count of protectable regions in the array returned in 'regions'."]
    #[doc = ""]
    #[doc = " @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'"]
    #[doc = " field)."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_protectable_regions(
        chip: *const esp_flash_t,
        out_regions: *mut *const esp_flash_region_t,
        out_num_regions: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Detect if a region of the SPI flash chip is protected"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param region Pointer to a struct describing a protected region. This must match one of the regions returned from esp_flash_get_protectable_regions(...)."]
    #[doc = " @param[out] out_protected Pointer to a flag which is set based on the protected status for this region."]
    #[doc = ""]
    #[doc = " @note It is possible for this result to be false and write operations to still fail, if protection is enabled for the entire chip."]
    #[doc = ""]
    #[doc = " @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'"]
    #[doc = " field)."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_get_protected_region(
        chip: *mut esp_flash_t,
        region: *const esp_flash_region_t,
        out_protected: *mut bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Update the protected status for a region of the SPI flash chip"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param region Pointer to a struct describing a protected region. This must match one of the regions returned from esp_flash_get_protectable_regions(...)."]
    #[doc = " @param protect Write protection flag to set."]
    #[doc = ""]
    #[doc = " @note It is possible for the region protection flag to be cleared and write operations to still fail, if protection is enabled for the entire chip."]
    #[doc = ""]
    #[doc = " @note Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the 'chip->drv'"]
    #[doc = " field)."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_set_protected_region(
        chip: *mut esp_flash_t,
        region: *const esp_flash_region_t,
        protect: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read data from the SPI flash chip"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param buffer Pointer to a buffer where the data will be read. To get better performance, this should be in the DRAM and word aligned."]
    #[doc = " @param address Address on flash to read from. Must be less than chip->size field."]
    #[doc = " @param length Length (in bytes) of data to read."]
    #[doc = ""]
    #[doc = " There are no alignment constraints on buffer, address or length."]
    #[doc = ""]
    #[doc = " @note If on-chip flash encryption is used, this function returns raw (ie encrypted) data. Use the flash cache"]
    #[doc = " to transparently decrypt data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: success"]
    #[doc = "      - ESP_ERR_NO_MEM: Buffer is in external PSRAM which cannot be concurrently accessed, and a temporary internal buffer could not be allocated."]
    #[doc = "      - or a flash error code if operation failed."]
    pub fn esp_flash_read(
        chip: *mut esp_flash_t,
        buffer: *mut c_types::c_void,
        address: u32,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to the SPI flash chip"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must have been successfully initialised via esp_flash_init()"]
    #[doc = " @param address Address on flash to write to. Must be previously erased (SPI NOR flash can only write bits 1->0)."]
    #[doc = " @param buffer Pointer to a buffer with the data to write. To get better performance, this should be in the DRAM and word aligned."]
    #[doc = " @param length Length (in bytes) of data to write."]
    #[doc = ""]
    #[doc = " There are no alignment constraints on buffer, address or length."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, or a flash error code if operation failed."]
    pub fn esp_flash_write(
        chip: *mut esp_flash_t,
        buffer: *const c_types::c_void,
        address: u32,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Encrypted and write data to the SPI flash chip using on-chip hardware flash encryption"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must be NULL (the main flash chip). For other chips, encrypted write is not supported."]
    #[doc = " @param address Address on flash to write to. 16 byte aligned. Must be previously erased (SPI NOR flash can only write bits 1->0)."]
    #[doc = " @param buffer Pointer to a buffer with the data to write."]
    #[doc = " @param length Length (in bytes) of data to write. 16 byte aligned."]
    #[doc = ""]
    #[doc = " @note Both address & length must be 16 byte aligned, as this is the encryption block size"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: on success"]
    #[doc = "  - ESP_ERR_NOT_SUPPORTED: encrypted write not supported for this chip."]
    #[doc = "  - ESP_ERR_INVALID_ARG: Either the address, buffer or length is invalid."]
    #[doc = "  - or other flash error code from spi_flash_write_encrypted()."]
    pub fn esp_flash_write_encrypted(
        chip: *mut esp_flash_t,
        address: u32,
        buffer: *const c_types::c_void,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read and decrypt data from the SPI flash chip using on-chip hardware flash encryption"]
    #[doc = ""]
    #[doc = " @param chip Pointer to identify flash chip. Must be NULL (the main flash chip). For other chips, encrypted read is not supported."]
    #[doc = " @param address Address on flash to read from."]
    #[doc = " @param out_buffer Pointer to a buffer for the data to read to."]
    #[doc = " @param length Length (in bytes) of data to read."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: on success"]
    #[doc = "  - ESP_ERR_NOT_SUPPORTED: encrypted read not supported for this chip."]
    #[doc = "  - or other flash error code from spi_flash_read_encrypted()."]
    pub fn esp_flash_read_encrypted(
        chip: *mut esp_flash_t,
        address: u32,
        out_buffer: *mut c_types::c_void,
        length: u32,
    ) -> esp_err_t;
}
extern "C" {
    pub static mut esp_flash_default_chip: *mut esp_flash_t;
}
#[doc = "!< Application partition type"]
pub const esp_partition_type_t_ESP_PARTITION_TYPE_APP: esp_partition_type_t = 0;
#[doc = "!< Data partition type"]
pub const esp_partition_type_t_ESP_PARTITION_TYPE_DATA: esp_partition_type_t = 1;
#[doc = " @brief Partition type"]
#[doc = " @note Keep this enum in sync with PartitionDefinition class gen_esp32part.py"]
pub type esp_partition_type_t = c_types::c_uint;
#[doc = "!< Factory application partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_FACTORY: esp_partition_subtype_t = 0;
#[doc = "!< Base for OTA partition subtypes"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_MIN: esp_partition_subtype_t = 16;
#[doc = "!< OTA partition 0"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_0: esp_partition_subtype_t = 16;
#[doc = "!< OTA partition 1"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_1: esp_partition_subtype_t = 17;
#[doc = "!< OTA partition 2"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_2: esp_partition_subtype_t = 18;
#[doc = "!< OTA partition 3"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_3: esp_partition_subtype_t = 19;
#[doc = "!< OTA partition 4"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_4: esp_partition_subtype_t = 20;
#[doc = "!< OTA partition 5"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_5: esp_partition_subtype_t = 21;
#[doc = "!< OTA partition 6"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_6: esp_partition_subtype_t = 22;
#[doc = "!< OTA partition 7"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_7: esp_partition_subtype_t = 23;
#[doc = "!< OTA partition 8"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_8: esp_partition_subtype_t = 24;
#[doc = "!< OTA partition 9"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_9: esp_partition_subtype_t = 25;
#[doc = "!< OTA partition 10"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_10: esp_partition_subtype_t = 26;
#[doc = "!< OTA partition 11"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_11: esp_partition_subtype_t = 27;
#[doc = "!< OTA partition 12"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_12: esp_partition_subtype_t = 28;
#[doc = "!< OTA partition 13"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_13: esp_partition_subtype_t = 29;
#[doc = "!< OTA partition 14"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_14: esp_partition_subtype_t = 30;
#[doc = "!< OTA partition 15"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_15: esp_partition_subtype_t = 31;
#[doc = "!< Max subtype of OTA partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_MAX: esp_partition_subtype_t = 32;
#[doc = "!< Test application partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_TEST: esp_partition_subtype_t = 32;
#[doc = "!< OTA selection partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_OTA: esp_partition_subtype_t = 0;
#[doc = "!< PHY init data partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_PHY: esp_partition_subtype_t = 1;
#[doc = "!< NVS partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_NVS: esp_partition_subtype_t = 2;
#[doc = "!< COREDUMP partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_COREDUMP: esp_partition_subtype_t = 3;
#[doc = "!< Partition for NVS keys"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS: esp_partition_subtype_t = 4;
#[doc = "!< Partition for emulate eFuse bits"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM: esp_partition_subtype_t = 5;
#[doc = "!< ESPHTTPD partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD: esp_partition_subtype_t =
    128;
#[doc = "!< FAT partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_FAT: esp_partition_subtype_t = 129;
#[doc = "!< SPIFFS partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_SPIFFS: esp_partition_subtype_t = 130;
#[doc = "!< Used to search for partitions with any subtype"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_ANY: esp_partition_subtype_t = 255;
#[doc = " @brief Partition subtype"]
#[doc = " @note Keep this enum in sync with PartitionDefinition class gen_esp32part.py"]
pub type esp_partition_subtype_t = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_partition_iterator_opaque_ {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque partition iterator type"]
pub type esp_partition_iterator_t = *mut esp_partition_iterator_opaque_;
#[doc = " @brief partition information structure"]
#[doc = ""]
#[doc = " This is not the format in flash, that format is esp_partition_info_t."]
#[doc = ""]
#[doc = " However, this is the format used by this API."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_partition_t {
    #[doc = "< SPI flash chip on which the partition resides"]
    pub flash_chip: *mut esp_flash_t,
    #[doc = "< partition type (app/data)"]
    pub type_: esp_partition_type_t,
    #[doc = "< partition subtype"]
    pub subtype: esp_partition_subtype_t,
    #[doc = "< starting address of the partition in flash"]
    pub address: u32,
    #[doc = "< size of the partition, in bytes"]
    pub size: u32,
    #[doc = "< partition label, zero-terminated ASCII string"]
    pub label: [c_types::c_char; 17usize],
    #[doc = "< flag is set to true if partition is encrypted"]
    pub encrypted: bool,
}
extern "C" {
    #[doc = " @brief Find partition based on one or more parameters"]
    #[doc = ""]
    #[doc = " @param type Partition type, one of esp_partition_type_t values"]
    #[doc = " @param subtype Partition subtype, one of esp_partition_subtype_t values."]
    #[doc = "                To find all partitions of given type, use"]
    #[doc = "                ESP_PARTITION_SUBTYPE_ANY."]
    #[doc = " @param label (optional) Partition label. Set this value if looking"]
    #[doc = "             for partition with a specific name. Pass NULL otherwise."]
    #[doc = ""]
    #[doc = " @return iterator which can be used to enumerate all the partitions found,"]
    #[doc = "         or NULL if no partitions were found."]
    #[doc = "         Iterator obtained through this function has to be released"]
    #[doc = "         using esp_partition_iterator_release when not used any more."]
    pub fn esp_partition_find(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const c_types::c_char,
    ) -> esp_partition_iterator_t;
}
extern "C" {
    #[doc = " @brief Find first partition based on one or more parameters"]
    #[doc = ""]
    #[doc = " @param type Partition type, one of esp_partition_type_t values"]
    #[doc = " @param subtype Partition subtype, one of esp_partition_subtype_t values."]
    #[doc = "                To find all partitions of given type, use"]
    #[doc = "                ESP_PARTITION_SUBTYPE_ANY."]
    #[doc = " @param label (optional) Partition label. Set this value if looking"]
    #[doc = "             for partition with a specific name. Pass NULL otherwise."]
    #[doc = ""]
    #[doc = " @return pointer to esp_partition_t structure, or NULL if no partition is found."]
    #[doc = "         This pointer is valid for the lifetime of the application."]
    pub fn esp_partition_find_first(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const c_types::c_char,
    ) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Get esp_partition_t structure for given partition"]
    #[doc = ""]
    #[doc = " @param iterator  Iterator obtained using esp_partition_find. Must be non-NULL."]
    #[doc = ""]
    #[doc = " @return pointer to esp_partition_t structure. This pointer is valid for the lifetime"]
    #[doc = "         of the application."]
    pub fn esp_partition_get(iterator: esp_partition_iterator_t) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Move partition iterator to the next partition found"]
    #[doc = ""]
    #[doc = " Any copies of the iterator will be invalid after this call."]
    #[doc = ""]
    #[doc = " @param iterator Iterator obtained using esp_partition_find. Must be non-NULL."]
    #[doc = ""]
    #[doc = " @return NULL if no partition was found, valid esp_partition_iterator_t otherwise."]
    pub fn esp_partition_next(iterator: esp_partition_iterator_t) -> esp_partition_iterator_t;
}
extern "C" {
    #[doc = " @brief Release partition iterator"]
    #[doc = ""]
    #[doc = " @param iterator Iterator obtained using esp_partition_find. Must be non-NULL."]
    #[doc = ""]
    pub fn esp_partition_iterator_release(iterator: esp_partition_iterator_t);
}
extern "C" {
    #[doc = " @brief Verify partition data"]
    #[doc = ""]
    #[doc = " Given a pointer to partition data, verify this partition exists in the partition table (all fields match.)"]
    #[doc = ""]
    #[doc = " This function is also useful to take partition data which may be in a RAM buffer and convert it to a pointer to the"]
    #[doc = " permanent partition data stored in flash."]
    #[doc = ""]
    #[doc = " Pointers returned from this function can be compared directly to the address of any pointer returned from"]
    #[doc = " esp_partition_get(), as a test for equality."]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition data to verify. Must be non-NULL. All fields of this structure must match the"]
    #[doc = " partition table entry in flash for this function to return a successful match."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - If partition not found, returns NULL."]
    #[doc = " - If found, returns a pointer to the esp_partition_t structure in flash. This pointer is always valid for the lifetime of the application."]
    pub fn esp_partition_verify(partition: *const esp_partition_t) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Read data from the partition"]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param dst Pointer to the buffer where data should be stored."]
    #[doc = "            Pointer must be non-NULL and buffer must be at least 'size' bytes long."]
    #[doc = " @param src_offset Address of the data to be read, relative to the"]
    #[doc = "                   beginning of the partition."]
    #[doc = " @param size Size of data to be read, in bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK, if data was read successfully;"]
    #[doc = "         ESP_ERR_INVALID_ARG, if src_offset exceeds partition size;"]
    #[doc = "         ESP_ERR_INVALID_SIZE, if read would go out of bounds of the partition;"]
    #[doc = "         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_read(
        partition: *const esp_partition_t,
        src_offset: size_t,
        dst: *mut c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to the partition"]
    #[doc = ""]
    #[doc = " Before writing data to flash, corresponding region of flash needs to be erased."]
    #[doc = " This can be done using esp_partition_erase_range function."]
    #[doc = ""]
    #[doc = " Partitions marked with an encryption flag will automatically be"]
    #[doc = " written via the spi_flash_write_encrypted() function. If writing to"]
    #[doc = " an encrypted partition, all write offsets and lengths must be"]
    #[doc = " multiples of 16 bytes. See the spi_flash_write_encrypted() function"]
    #[doc = " for more details. Unencrypted partitions do not have this"]
    #[doc = " restriction."]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param dst_offset Address where the data should be written, relative to the"]
    #[doc = "                   beginning of the partition."]
    #[doc = " @param src Pointer to the source buffer.  Pointer must be non-NULL and"]
    #[doc = "            buffer must be at least 'size' bytes long."]
    #[doc = " @param size Size of data to be written, in bytes."]
    #[doc = ""]
    #[doc = " @note Prior to writing to flash memory, make sure it has been erased with"]
    #[doc = "       esp_partition_erase_range call."]
    #[doc = ""]
    #[doc = " @return ESP_OK, if data was written successfully;"]
    #[doc = "         ESP_ERR_INVALID_ARG, if dst_offset exceeds partition size;"]
    #[doc = "         ESP_ERR_INVALID_SIZE, if write would go out of bounds of the partition;"]
    #[doc = "         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_write(
        partition: *const esp_partition_t,
        dst_offset: size_t,
        src: *const c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase part of the partition"]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param offset Offset from the beginning of partition where erase operation"]
    #[doc = "               should start. Must be aligned to 4 kilobytes."]
    #[doc = " @param size Size of the range which should be erased, in bytes."]
    #[doc = "                   Must be divisible by 4 kilobytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK, if the range was erased successfully;"]
    #[doc = "         ESP_ERR_INVALID_ARG, if iterator or dst are NULL;"]
    #[doc = "         ESP_ERR_INVALID_SIZE, if erase would go out of bounds of the partition;"]
    #[doc = "         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_erase_range(
        partition: *const esp_partition_t,
        offset: size_t,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure MMU to map partition into data memory"]
    #[doc = ""]
    #[doc = " Unlike spi_flash_mmap function, which requires a 64kB aligned base address,"]
    #[doc = " this function doesn't impose such a requirement."]
    #[doc = " If offset results in a flash address which is not aligned to 64kB boundary,"]
    #[doc = " address will be rounded to the lower 64kB boundary, so that mapped region"]
    #[doc = " includes requested range."]
    #[doc = " Pointer returned via out_ptr argument will be adjusted to point to the"]
    #[doc = " requested offset (not necessarily to the beginning of mmap-ed region)."]
    #[doc = ""]
    #[doc = " To release mapped memory, pass handle returned via out_handle argument to"]
    #[doc = " spi_flash_munmap function."]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param offset Offset from the beginning of partition where mapping should start."]
    #[doc = " @param size Size of the area to be mapped."]
    #[doc = " @param memory  Memory space where the region should be mapped"]
    #[doc = " @param out_ptr  Output, pointer to the mapped memory region"]
    #[doc = " @param out_handle  Output, handle which should be used for spi_flash_munmap call"]
    #[doc = ""]
    #[doc = " @return ESP_OK, if successful"]
    pub fn esp_partition_mmap(
        partition: *const esp_partition_t,
        offset: size_t,
        size: size_t,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const c_types::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get SHA-256 digest for required partition."]
    #[doc = ""]
    #[doc = " For apps with SHA-256 appended to the app image, the result is the appended SHA-256 value for the app image content."]
    #[doc = " The hash is verified before returning, if app content is invalid then the function returns ESP_ERR_IMAGE_INVALID."]
    #[doc = " For apps without SHA-256 appended to the image, the result is the SHA-256 of all bytes in the app image."]
    #[doc = " For other partition types, the result is the SHA-256 of the entire partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition    Pointer to info for partition containing app or data. (fields: address, size and type, are required to be filled)."]
    #[doc = " @param[out] sha_256      Returned SHA-256 digest for a given partition."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK: In case of successful operation."]
    #[doc = "          - ESP_ERR_INVALID_ARG: The size was 0 or the sha_256 was NULL."]
    #[doc = "          - ESP_ERR_NO_MEM: Cannot allocate memory for sha256 operation."]
    #[doc = "          - ESP_ERR_IMAGE_INVALID: App partition doesn't contain a valid app image."]
    #[doc = "          - ESP_FAIL: An allocation error occurred."]
    pub fn esp_partition_get_sha256(
        partition: *const esp_partition_t,
        sha_256: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Check for the identity of two partitions by SHA-256 digest."]
    #[doc = ""]
    #[doc = " @param[in] partition_1 Pointer to info for partition 1 containing app or data. (fields: address, size and type, are required to be filled)."]
    #[doc = " @param[in] partition_2 Pointer to info for partition 2 containing app or data. (fields: address, size and type, are required to be filled)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - True:  In case of the two firmware is equal."]
    #[doc = "         - False: Otherwise"]
    pub fn esp_partition_check_identity(
        partition_1: *const esp_partition_t,
        partition_2: *const esp_partition_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Register a partition on an external flash chip"]
    #[doc = ""]
    #[doc = " This API allows designating certain areas of external flash chips (identified by the esp_flash_t structure)"]
    #[doc = " as partitions. This allows using them with components which access SPI flash through the esp_partition API."]
    #[doc = ""]
    #[doc = " @param flash_chip  Pointer to the structure identifying the flash chip"]
    #[doc = " @param offset  Address in bytes, where the partition starts"]
    #[doc = " @param size  Size of the partition in bytes"]
    #[doc = " @param label  Partition name"]
    #[doc = " @param type  One of the partition types (ESP_PARTITION_TYPE_*). Note that applications can not be booted from external flash"]
    #[doc = "              chips, so using ESP_PARTITION_TYPE_APP is not supported."]
    #[doc = " @param subtype  One of the partition subtypes (ESP_PARTITION_SUBTYPE_*)"]
    #[doc = " @param[out] out_partition  Output, if non-NULL, receives the pointer to the resulting esp_partition_t structure"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if CONFIG_CONFIG_SPI_FLASH_USE_LEGACY_IMPL is enabled"]
    #[doc = "      - ESP_ERR_NO_MEM if memory allocation has failed"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the new partition overlaps another partition on the same flash chip"]
    #[doc = "      - ESP_ERR_INVALID_SIZE if the partition doesn't fit into the flash chip size"]
    pub fn esp_partition_register_external(
        flash_chip: *mut esp_flash_t,
        offset: size_t,
        size: size_t,
        label: *const c_types::c_char,
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        out_partition: *mut *const esp_partition_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deregister the partition previously registered using esp_partition_register_external"]
    #[doc = " @param partition  pointer to the partition structure obtained from esp_partition_register_external,"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if the partition pointer is not found"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the partition comes from the partition table"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the partition was not registered using"]
    #[doc = "        esp_partition_register_external function."]
    pub fn esp_partition_deregister_external(partition: *const esp_partition_t) -> esp_err_t;
}
#[doc = " @brief Key for encryption and decryption"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_sec_cfg_t {
    #[doc = "<  XTS encryption and decryption key"]
    pub eky: [u8; 32usize],
    #[doc = "<  XTS tweak key"]
    pub tky: [u8; 32usize],
}
extern "C" {
    #[doc = " @brief Initialize the default NVS partition."]
    #[doc = ""]
    #[doc = " This API initialises the default NVS partition. The default NVS partition"]
    #[doc = " is the one that is labeled \"nvs\" in the partition table."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the specified partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition. Must be no longer than 16 characters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if specified partition is not found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init_partition(partition_label: *const c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the partition specified by partition pointer."]
    #[doc = ""]
    #[doc = " @param[in] partition pointer to a partition obtained by the ESP partition API."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized"]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_INVALID_ARG in case partition is NULL"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init_partition_ptr(partition: *const esp_partition_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the default NVS partition"]
    #[doc = ""]
    #[doc = " Default NVS partition is the partition with \"nvs\" label in the partition table."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success (storage was deinitialized)"]
    #[doc = "      - ESP_ERR_NVS_NOT_INITIALIZED if the storage was not initialized prior to this call"]
    pub fn nvs_flash_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the given NVS partition"]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NVS_NOT_INITIALIZED if the storage for given partition was not"]
    #[doc = "        initialized prior to this call"]
    pub fn nvs_flash_deinit_partition(partition_label: *const c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase the default NVS partition"]
    #[doc = ""]
    #[doc = " This function erases all contents of the default NVS partition (one with label \"nvs\")"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if there is no NVS partition labeled \"nvs\" in the"]
    #[doc = "        partition table"]
    pub fn nvs_flash_erase() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase specified NVS partition"]
    #[doc = ""]
    #[doc = " This function erases all contents of specified NVS partition"]
    #[doc = ""]
    #[doc = " @param[in]  part_name    Name (label) of the partition to be erased"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if there is no NVS partition with the specified name"]
    #[doc = "        in the partition table"]
    pub fn nvs_flash_erase_partition(part_name: *const c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase custom partition."]
    #[doc = ""]
    #[doc = " Erase all content of specified custom partition."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "  If the partition is initialized, this function first de-initializes it."]
    #[doc = "  Afterwards, the partition has to be initialized again to be used."]
    #[doc = ""]
    #[doc = " @param[in] partition pointer to a partition obtained by the ESP partition API."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if there is no partition with the specified"]
    #[doc = "        parameters in the partition table"]
    #[doc = "      - ESP_ERR_INVALID_ARG in case partition is NULL"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_erase_partition_ptr(partition: *const esp_partition_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the default NVS partition."]
    #[doc = ""]
    #[doc = " This API initialises the default NVS partition. The default NVS partition"]
    #[doc = " is the one that is labeled \"nvs\" in the partition table."]
    #[doc = ""]
    #[doc = " @param[in]  cfg Security configuration (keys) to be used for NVS encryption/decryption."]
    #[doc = "                              If cfg is NULL, no encryption is used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_secure_init(cfg: *mut nvs_sec_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the specified partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition. Note that internally a reference to"]
    #[doc = "                               passed value is kept and it should be accessible for future operations"]
    #[doc = ""]
    #[doc = " @param[in]  cfg Security configuration (keys) to be used for NVS encryption/decryption."]
    #[doc = "                              If cfg is null, no encryption/decryption is used."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if specified partition is not found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_secure_init_partition(
        partition_label: *const c_types::c_char,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Generate and store NVS keys in the provided esp partition"]
    #[doc = ""]
    #[doc = " @param[in]  partition Pointer to partition structure obtained using"]
    #[doc = "                       esp_partition_find_first or esp_partition_get."]
    #[doc = "                       Must be non-NULL."]
    #[doc = " @param[out] cfg       Pointer to nvs security configuration structure."]
    #[doc = "                       Pointer must be non-NULL."]
    #[doc = "                       Generated keys will be populated in this structure."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      -ESP_OK, if cfg was read successfully;"]
    #[doc = "      -or error codes from esp_partition_write/erase APIs."]
    pub fn nvs_flash_generate_keys(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read NVS security configuration from a partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition Pointer to partition structure obtained using"]
    #[doc = "                       esp_partition_find_first or esp_partition_get."]
    #[doc = "                       Must be non-NULL."]
    #[doc = " @param[out] cfg       Pointer to nvs security configuration structure."]
    #[doc = "                       Pointer must be non-NULL."]
    #[doc = ""]
    #[doc = " @note  Provided parition is assumed to be marked 'encrypted'."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      -ESP_OK, if cfg was read successfully;"]
    #[doc = "      -ESP_ERR_NVS_KEYS_NOT_INITIALIZED, if the partition is not yet written with keys."]
    #[doc = "      -ESP_ERR_NVS_CORRUPT_KEY_PART, if the partition containing keys is found to be corrupt"]
    #[doc = "      -or error codes from esp_partition_read API."]
    pub fn nvs_flash_read_security_cfg(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldesc_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub buf: *mut u8,
    pub __bindgen_anon_1: lldesc_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lldesc_s__bindgen_ty_1 {
    pub empty: u32,
    pub qe: lldesc_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldesc_s__bindgen_ty_1__bindgen_ty_1 {
    pub stqe_next: *mut lldesc_s,
}
impl lldesc_s {
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn offset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sosf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sosf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        size: u32,
        length: u32,
        offset: u32,
        sosf: u32,
        eof: u32,
        owner: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let length: u32 = unsafe { ::core::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sosf: u32 = unsafe { ::core::mem::transmute(sosf) };
            sosf as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let eof: u32 = unsafe { ::core::mem::transmute(eof) };
            eof as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let owner: u32 = unsafe { ::core::mem::transmute(owner) };
            owner as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lldesc_t = lldesc_s;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct tx_ampdu_entry_s {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl tx_ampdu_entry_s {
    #[inline]
    pub fn sub_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sub_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn dili_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_dili_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn null_byte(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_null_byte(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seq(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_seq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sub_len: u32,
        dili_num: u32,
        null_byte: u32,
        data: u32,
        enc: u32,
        seq: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let sub_len: u32 = unsafe { ::core::mem::transmute(sub_len) };
            sub_len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 7u8, {
            let dili_num: u32 = unsafe { ::core::mem::transmute(dili_num) };
            dili_num as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let null_byte: u32 = unsafe { ::core::mem::transmute(null_byte) };
            null_byte as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let enc: u32 = unsafe { ::core::mem::transmute(enc) };
            enc as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let seq: u32 = unsafe { ::core::mem::transmute(seq) };
            seq as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type tx_ampdu_entry_t = tx_ampdu_entry_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldesc_chain_s {
    pub head: *mut lldesc_t,
    pub tail: *mut lldesc_t,
}
pub type lldesc_chain_t = lldesc_chain_s;
extern "C" {
    pub fn lldesc_build_chain(
        descptr: *mut u8,
        desclen: u32,
        mblkptr: *mut u8,
        buflen: u32,
        blksz: u32,
        owner: u8,
        head: *mut *mut lldesc_t,
        tail: *mut *mut lldesc_t,
    );
}
extern "C" {
    pub fn lldesc_num2link(head: *mut lldesc_t, nblks: u16) -> *mut lldesc_t;
}
extern "C" {
    pub fn lldesc_set_owner(head: *mut lldesc_t, nblks: u16, owner: u8) -> *mut lldesc_t;
}
#[doc = "< Normal operating mode where CAN controller can send/receive/acknowledge messages"]
pub const can_mode_t_CAN_MODE_NORMAL: can_mode_t = 0;
#[doc = "< Transmission does not require acknowledgment. Use this mode for self testing"]
pub const can_mode_t_CAN_MODE_NO_ACK: can_mode_t = 1;
#[doc = "< The CAN controller will not influence the bus (No transmissions or acknowledgments) but can receive messages"]
pub const can_mode_t_CAN_MODE_LISTEN_ONLY: can_mode_t = 2;
#[doc = " @brief   CAN Controller operating modes"]
pub type can_mode_t = c_types::c_uint;
#[doc = " @brief   Structure to store a CAN message"]
#[doc = ""]
#[doc = " @note"]
#[doc = " @note    The flags member is deprecated"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct can_message_t {
    pub __bindgen_anon_1: can_message_t__bindgen_ty_1,
    #[doc = "< 11 or 29 bit identifier"]
    pub identifier: u32,
    #[doc = "< Data length code"]
    pub data_length_code: u8,
    #[doc = "< Data bytes (not relevant in RTR frame)"]
    pub data: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union can_message_t__bindgen_ty_1 {
    pub __bindgen_anon_1: can_message_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Alternate way to set message flags using message flag macros (see documentation)"]
    pub flags: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct can_message_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl can_message_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn extd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ss(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ss(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn self_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_self(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dlc_non_comp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dlc_non_comp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        extd: u32,
        rtr: u32,
        ss: u32,
        self_: u32,
        dlc_non_comp: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let extd: u32 = unsafe { ::core::mem::transmute(extd) };
            extd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rtr: u32 = unsafe { ::core::mem::transmute(rtr) };
            rtr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ss: u32 = unsafe { ::core::mem::transmute(ss) };
            ss as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let self_: u32 = unsafe { ::core::mem::transmute(self_) };
            self_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dlc_non_comp: u32 = unsafe { ::core::mem::transmute(dlc_non_comp) };
            dlc_non_comp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief   Structure for bit timing configuration of the CAN driver"]
#[doc = ""]
#[doc = " @note    Macro initializers are available for this structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_timing_config_t {
    #[doc = "< Baudrate prescaler (i.e., APB clock divider) can be any even number from 2 to 128."]
    #[doc = "For ESP32 Rev 2 or later, multiples of 4 from 132 to 256 are also supported"]
    pub brp: u32,
    #[doc = "< Timing segment 1 (Number of time quanta, between 1 to 16)"]
    pub tseg_1: u8,
    #[doc = "< Timing segment 2 (Number of time quanta, 1 to 8)"]
    pub tseg_2: u8,
    #[doc = "< Synchronization Jump Width (Max time quanta jump for synchronize from 1 to 4)"]
    pub sjw: u8,
    #[doc = "< Enables triple sampling when the CAN controller samples a bit"]
    pub triple_sampling: bool,
}
#[doc = " @brief   Structure for acceptance filter configuration of the CAN driver (see documentation)"]
#[doc = ""]
#[doc = " @note    Macro initializers are available for this structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_filter_config_t {
    #[doc = "< 32-bit acceptance code"]
    pub acceptance_code: u32,
    #[doc = "< 32-bit acceptance mask"]
    pub acceptance_mask: u32,
    #[doc = "< Use Single Filter Mode (see documentation)"]
    pub single_filter: bool,
}
#[doc = "< Stopped state. The CAN controller will not participate in any CAN bus activities"]
pub const can_state_t_CAN_STATE_STOPPED: can_state_t = 0;
#[doc = "< Running state. The CAN controller can transmit and receive messages"]
pub const can_state_t_CAN_STATE_RUNNING: can_state_t = 1;
#[doc = "< Bus-off state. The CAN controller cannot participate in bus activities until it has recovered"]
pub const can_state_t_CAN_STATE_BUS_OFF: can_state_t = 2;
#[doc = "< Recovering state. The CAN controller is undergoing bus recovery"]
pub const can_state_t_CAN_STATE_RECOVERING: can_state_t = 3;
#[doc = " @brief   CAN driver states"]
pub type can_state_t = c_types::c_uint;
#[doc = " @brief   Structure for general configuration of the CAN driver"]
#[doc = ""]
#[doc = " @note    Macro initializers are available for this structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_general_config_t {
    #[doc = "< Mode of CAN controller"]
    pub mode: can_mode_t,
    #[doc = "< Transmit GPIO number"]
    pub tx_io: gpio_num_t,
    #[doc = "< Receive GPIO number"]
    pub rx_io: gpio_num_t,
    #[doc = "< CLKOUT GPIO number (optional, set to -1 if unused)"]
    pub clkout_io: gpio_num_t,
    #[doc = "< Bus off indicator GPIO number (optional, set to -1 if unused)"]
    pub bus_off_io: gpio_num_t,
    #[doc = "< Number of messages TX queue can hold (set to 0 to disable TX Queue)"]
    pub tx_queue_len: u32,
    #[doc = "< Number of messages RX queue can hold"]
    pub rx_queue_len: u32,
    #[doc = "< Bit field of alerts to enable (see documentation)"]
    pub alerts_enabled: u32,
    #[doc = "< CLKOUT divider. Can be 1 or any even number from 2 to 14 (optional, set to 0 if unused)"]
    pub clkout_divider: u32,
}
#[doc = " @brief   Structure to store status information of CAN driver"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_status_info_t {
    #[doc = "< Current state of CAN controller (Stopped/Running/Bus-Off/Recovery)"]
    pub state: can_state_t,
    #[doc = "< Number of messages queued for transmission or awaiting transmission completion"]
    pub msgs_to_tx: u32,
    #[doc = "< Number of messages in RX queue waiting to be read"]
    pub msgs_to_rx: u32,
    #[doc = "< Current value of Transmit Error Counter"]
    pub tx_error_counter: u32,
    #[doc = "< Current value of Receive Error Counter"]
    pub rx_error_counter: u32,
    #[doc = "< Number of messages that failed transmissions"]
    pub tx_failed_count: u32,
    #[doc = "< Number of messages that were lost due to a full RX queue"]
    pub rx_missed_count: u32,
    #[doc = "< Number of instances arbitration was lost"]
    pub arb_lost_count: u32,
    #[doc = "< Number of instances a bus error has occurred"]
    pub bus_error_count: u32,
}
extern "C" {
    #[doc = " @brief   Install CAN driver"]
    #[doc = ""]
    #[doc = " This function installs the CAN driver using three configuration structures."]
    #[doc = " The required memory is allocated and the CAN driver is placed in the stopped"]
    #[doc = " state after running this function."]
    #[doc = ""]
    #[doc = " @param[in]   g_config    General configuration structure"]
    #[doc = " @param[in]   t_config    Timing configuration structure"]
    #[doc = " @param[in]   f_config    Filter configuration structure"]
    #[doc = ""]
    #[doc = " @note    Macro initializers are available for the configuration structures (see documentation)"]
    #[doc = ""]
    #[doc = " @note    To reinstall the CAN driver, call can_driver_uninstall() first"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Successfully installed CAN driver"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Arguments are invalid"]
    #[doc = "      - ESP_ERR_NO_MEM: Insufficient memory"]
    #[doc = "      - ESP_ERR_INVALID_STATE: Driver is already installed"]
    pub fn can_driver_install(
        g_config: *const can_general_config_t,
        t_config: *const can_timing_config_t,
        f_config: *const can_filter_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Uninstall the CAN driver"]
    #[doc = ""]
    #[doc = " This function uninstalls the CAN driver, freeing the memory utilized by the"]
    #[doc = " driver. This function can only be called when the driver is in the stopped"]
    #[doc = " state or the bus-off state."]
    #[doc = ""]
    #[doc = " @warning The application must ensure that no tasks are blocked on TX/RX"]
    #[doc = "          queues or alerts when this function is called."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Successfully uninstalled CAN driver"]
    #[doc = "      - ESP_ERR_INVALID_STATE: Driver is not in stopped/bus-off state, or is not installed"]
    pub fn can_driver_uninstall() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Start the CAN driver"]
    #[doc = ""]
    #[doc = " This function starts the CAN driver, putting the CAN driver into the running"]
    #[doc = " state. This allows the CAN driver to participate in CAN bus activities such"]
    #[doc = " as transmitting/receiving messages. The RX queue is reset in this function,"]
    #[doc = " clearing any unread messages. This function can only be called when the CAN"]
    #[doc = " driver is in the stopped state."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: CAN driver is now running"]
    #[doc = "      - ESP_ERR_INVALID_STATE: Driver is not in stopped state, or is not installed"]
    pub fn can_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Stop the CAN driver"]
    #[doc = ""]
    #[doc = " This function stops the CAN driver, preventing any further message from being"]
    #[doc = " transmitted or received until can_start() is called. Any messages in the TX"]
    #[doc = " queue are cleared. Any messages in the RX queue should be read by the"]
    #[doc = " application after this function is called. This function can only be called"]
    #[doc = " when the CAN driver is in the running state."]
    #[doc = ""]
    #[doc = " @warning A message currently being transmitted/received on the CAN bus will"]
    #[doc = "          be ceased immediately. This may lead to other CAN nodes interpreting"]
    #[doc = "          the unfinished message as an error."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: CAN driver is now Stopped"]
    #[doc = "      - ESP_ERR_INVALID_STATE: Driver is not in running state, or is not installed"]
    pub fn can_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Transmit a CAN message"]
    #[doc = ""]
    #[doc = " This function queues a CAN message for transmission. Transmission will start"]
    #[doc = " immediately if no other messages are queued for transmission. If the TX queue"]
    #[doc = " is full, this function will block until more space becomes available or until"]
    #[doc = " it timesout. If the TX queue is disabled (TX queue length = 0 in configuration),"]
    #[doc = " this function will return immediately if another message is undergoing"]
    #[doc = " transmission. This function can only be called when the CAN driver is in the"]
    #[doc = " running state and cannot be called under Listen Only Mode."]
    #[doc = ""]
    #[doc = " @param[in]   message         Message to transmit"]
    #[doc = " @param[in]   ticks_to_wait   Number of FreeRTOS ticks to block on the TX queue"]
    #[doc = ""]
    #[doc = " @note    This function does not guarantee that the transmission is successful."]
    #[doc = "          The TX_SUCCESS/TX_FAILED alert can be enabled to alert the application"]
    #[doc = "          upon the success/failure of a transmission."]
    #[doc = ""]
    #[doc = " @note    The TX_IDLE alert can be used to alert the application when no other"]
    #[doc = "          messages are awaiting transmission."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Transmission successfully queued/initiated"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Arguments are invalid"]
    #[doc = "      - ESP_ERR_TIMEOUT: Timed out waiting for space on TX queue"]
    #[doc = "      - ESP_FAIL: TX queue is disabled and another message is currently transmitting"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not in running state, or is not installed"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED: Listen Only Mode does not support transmissions"]
    pub fn can_transmit(message: *const can_message_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Receive a CAN message"]
    #[doc = ""]
    #[doc = " This function receives a message from the RX queue. The flags field of the"]
    #[doc = " message structure will indicate the type of message received. This function"]
    #[doc = " will block if there are no messages in the RX queue"]
    #[doc = ""]
    #[doc = " @param[out]  message         Received message"]
    #[doc = " @param[in]   ticks_to_wait   Number of FreeRTOS ticks to block on RX queue"]
    #[doc = ""]
    #[doc = " @warning The flags field of the received message should be checked to determine"]
    #[doc = "          if the received message contains any data bytes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Message successfully received from RX queue"]
    #[doc = "      - ESP_ERR_TIMEOUT: Timed out waiting for message"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Arguments are invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not installed"]
    pub fn can_receive(message: *mut can_message_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Read CAN driver alerts"]
    #[doc = ""]
    #[doc = " This function will read the alerts raised by the CAN driver. If no alert has"]
    #[doc = " been when this function is called, this function will block until an alert"]
    #[doc = " occurs or until it timeouts."]
    #[doc = ""]
    #[doc = " @param[out]  alerts          Bit field of raised alerts (see documentation for alert flags)"]
    #[doc = " @param[in]   ticks_to_wait   Number of FreeRTOS ticks to block for alert"]
    #[doc = ""]
    #[doc = " @note    Multiple alerts can be raised simultaneously. The application should"]
    #[doc = "          check for all alerts that have been enabled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Alerts read"]
    #[doc = "      - ESP_ERR_TIMEOUT: Timed out waiting for alerts"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Arguments are invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not installed"]
    pub fn can_read_alerts(alerts: *mut u32, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Reconfigure which alerts are enabled"]
    #[doc = ""]
    #[doc = " This function reconfigures which alerts are enabled. If there are alerts"]
    #[doc = " which have not been read whilst reconfiguring, this function can read those"]
    #[doc = " alerts."]
    #[doc = ""]
    #[doc = " @param[in]   alerts_enabled  Bit field of alerts to enable (see documentation for alert flags)"]
    #[doc = " @param[out]  current_alerts  Bit field of currently raised alerts. Set to NULL if unused"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Alerts reconfigured"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not installed"]
    pub fn can_reconfigure_alerts(alerts_enabled: u32, current_alerts: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Start the bus recovery process"]
    #[doc = ""]
    #[doc = " This function initiates the bus recovery process when the CAN driver is in"]
    #[doc = " the bus-off state. Once initiated, the CAN driver will enter the recovering"]
    #[doc = " state and wait for 128 occurrences of the bus-free signal on the CAN bus"]
    #[doc = " before returning to the stopped state. This function will reset the TX queue,"]
    #[doc = " clearing any messages pending transmission."]
    #[doc = ""]
    #[doc = " @note    The BUS_RECOVERED alert can be enabled to alert the application when"]
    #[doc = "          the bus recovery process completes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Bus recovery started"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not in the bus-off state, or is not installed"]
    pub fn can_initiate_recovery() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get current status information of the CAN driver"]
    #[doc = ""]
    #[doc = " @param[out]  status_info     Status information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Status information retrieved"]
    #[doc = "      - ESP_ERR_INVALID_ARG: Arguments are invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not installed"]
    pub fn can_get_status_info(status_info: *mut can_status_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Clear the transmit queue"]
    #[doc = ""]
    #[doc = " This function will clear the transmit queue of all messages."]
    #[doc = ""]
    #[doc = " @note    The transmit queue is automatically cleared when can_stop() or"]
    #[doc = "          can_initiate_recovery() is called."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Transmit queue cleared"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not installed or TX queue is disabled"]
    pub fn can_clear_transmit_queue() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Clear the receive queue"]
    #[doc = ""]
    #[doc = " This function will clear the receive queue of all messages."]
    #[doc = ""]
    #[doc = " @note    The receive queue is automatically cleared when can_start() is"]
    #[doc = "          called."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: Transmit queue cleared"]
    #[doc = "      - ESP_ERR_INVALID_STATE: CAN driver is not installed"]
    pub fn can_clear_receive_queue() -> esp_err_t;
}
#[doc = "< DAC channel 1 is GPIO25(ESP32) / GPIO17(ESP32S2BETA)"]
pub const dac_channel_t_DAC_CHANNEL_1: dac_channel_t = 0;
#[doc = "< DAC channel 2 is GPIO26(ESP32) / GPIO18(ESP32S2BETA)"]
pub const dac_channel_t_DAC_CHANNEL_2: dac_channel_t = 1;
pub const dac_channel_t_DAC_CHANNEL_MAX: dac_channel_t = 2;
pub type dac_channel_t = c_types::c_uint;
#[doc = "< 1/1. Default."]
pub const dac_cw_scale_t_DAC_CW_SCALE_1: dac_cw_scale_t = 0;
#[doc = "< 1/2."]
pub const dac_cw_scale_t_DAC_CW_SCALE_2: dac_cw_scale_t = 1;
#[doc = "< 1/4."]
pub const dac_cw_scale_t_DAC_CW_SCALE_4: dac_cw_scale_t = 2;
#[doc = "< 1/8."]
pub const dac_cw_scale_t_DAC_CW_SCALE_8: dac_cw_scale_t = 3;
#[doc = " The multiple of the amplitude of the cosine wave generator. The max amplitude is VDD3P3_RTC."]
pub type dac_cw_scale_t = c_types::c_uint;
#[doc = "< Phase shift +0"]
pub const dac_cw_phase_t_DAC_CW_PHASE_0: dac_cw_phase_t = 2;
#[doc = "< Phase shift +180"]
pub const dac_cw_phase_t_DAC_CW_PHASE_180: dac_cw_phase_t = 3;
#[doc = " Set the phase of the cosine wave generator output."]
pub type dac_cw_phase_t = c_types::c_uint;
#[doc = " Config the cosine wave generator function in DAC module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dac_cw_config_t {
    #[doc = "< Enable the cosine wave generator of DAC channel."]
    pub en_ch: dac_channel_t,
    #[doc = "< Set the amplitude of the cosine wave generator output."]
    pub scale: dac_cw_scale_t,
    #[doc = "< Set the phase of the cosine wave generator output."]
    pub phase: dac_cw_phase_t,
    #[doc = "< Set frequency of cosine wave generator output. Range: 130(130Hz) ~ 55000(100KHz)."]
    pub freq: u32,
    #[doc = "< Set the voltage value of the DC component of the cosine wave generator output."]
    #[doc = "Note: Unreasonable settings can cause waveform to be oversaturated. Range: -128 ~ 127."]
    pub offset: i8,
}
extern "C" {
    #[doc = " @brief Get the gpio number of a specific DAC channel."]
    #[doc = ""]
    #[doc = " @param channel Channel to get the gpio number"]
    #[doc = " @param gpio_num output buffer to hold the gpio number"]
    #[doc = " @return"]
    #[doc = "   - ESP_OK if success"]
    pub fn dac_pad_get_io_num(channel: dac_channel_t, gpio_num: *mut gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set DAC output voltage."]
    #[doc = "        DAC output is 8-bit. Maximum (255) corresponds to VDD3P3_RTC."]
    #[doc = ""]
    #[doc = " @note Need to configure DAC pad before calling this function."]
    #[doc = "       DAC channel 1 is attached to GPIO25, DAC channel 2 is attached to GPIO26"]
    #[doc = " @param channel DAC channel"]
    #[doc = " @param dac_value DAC output value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn dac_output_voltage(channel: dac_channel_t, dac_value: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief DAC pad output enable"]
    #[doc = ""]
    #[doc = " @param channel DAC channel"]
    #[doc = " @note DAC channel 1 is attached to GPIO25, DAC channel 2 is attached to GPIO26"]
    #[doc = "       I2S left channel will be mapped to DAC channel 2"]
    #[doc = "       I2S right channel will be mapped to DAC channel 1"]
    pub fn dac_output_enable(channel: dac_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief DAC pad output disable"]
    #[doc = ""]
    #[doc = " @param channel DAC channel"]
    #[doc = " @note DAC channel 1 is attached to GPIO25, DAC channel 2 is attached to GPIO26"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn dac_output_disable(channel: dac_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable DAC output data from I2S"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn dac_i2s_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable DAC output data from I2S"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn dac_i2s_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable cosine wave generator output."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn dac_cw_generator_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable cosine wave generator output."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn dac_cw_generator_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Config the cosine wave generator function in DAC module."]
    #[doc = ""]
    #[doc = " @param cw Configuration."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    pub fn dac_cw_generator_config(cw: *mut dac_cw_config_t) -> esp_err_t;
}
#[doc = " Type by which ring buffers are referenced. For example, a call to xRingbufferCreate()"]
#[doc = " returns a RingbufHandle_t variable that can then be used as a parameter to"]
#[doc = " xRingbufferSend(), xRingbufferReceive(), etc."]
pub type RingbufHandle_t = *mut c_types::c_void;
#[doc = " No-split buffers will only store an item in contiguous memory and will"]
#[doc = " never split an item. Each item requires an 8 byte overhead for a header"]
#[doc = " and will always internally occupy a 32-bit aligned size of space."]
pub const RingbufferType_t_RINGBUF_TYPE_NOSPLIT: RingbufferType_t = 0;
#[doc = " Allow-split buffers will split an item into two parts if necessary in"]
#[doc = " order to store it. Each item requires an 8 byte overhead for a header,"]
#[doc = " splitting incurs an extra header. Each item will always internally occupy"]
#[doc = " a 32-bit aligned size of space."]
pub const RingbufferType_t_RINGBUF_TYPE_ALLOWSPLIT: RingbufferType_t = 1;
#[doc = " Byte buffers store data as a sequence of bytes and do not maintain separate"]
#[doc = " items, therefore byte buffers have no overhead. All data is stored as a"]
#[doc = " sequence of byte and any number of bytes can be sent or retrieved each"]
#[doc = " time."]
pub const RingbufferType_t_RINGBUF_TYPE_BYTEBUF: RingbufferType_t = 2;
#[doc = " Byte buffers store data as a sequence of bytes and do not maintain separate"]
#[doc = " items, therefore byte buffers have no overhead. All data is stored as a"]
#[doc = " sequence of byte and any number of bytes can be sent or retrieved each"]
#[doc = " time."]
pub const RingbufferType_t_RINGBUF_TYPE_MAX: RingbufferType_t = 3;
pub type RingbufferType_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief       Create a ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xBufferSize Size of the buffer in bytes. Note that items require"]
    #[doc = "              space for overhead in no-split/allow-split buffers"]
    #[doc = " @param[in]   xBufferType Type of ring buffer, see documentation."]
    #[doc = ""]
    #[doc = " @note    xBufferSize of no-split/allow-split buffers will be rounded up to the nearest 32-bit aligned size."]
    #[doc = ""]
    #[doc = " @return  A handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreate(xBufferSize: size_t, xBufferType: RingbufferType_t)
        -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief Create a ring buffer of type RINGBUF_TYPE_NOSPLIT for a fixed item_size"]
    #[doc = ""]
    #[doc = " This API is similar to xRingbufferCreate(), but it will internally allocate"]
    #[doc = " additional space for the headers."]
    #[doc = ""]
    #[doc = " @param[in]   xItemSize   Size of each item to be put into the ring buffer"]
    #[doc = " @param[in]   xItemNum    Maximum number of items the buffer needs to hold simultaneously"]
    #[doc = ""]
    #[doc = " @return  A RingbufHandle_t handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreateNoSplit(xItemSize: size_t, xItemNum: size_t) -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to insert an item into the ring buffer. This function will block until"]
    #[doc = " enough free space is available or until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem          Pointer to data to insert. NULL is allowed if xItemSize is 0."]
    #[doc = " @param[in]   xItemSize       Size of data to insert."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for room in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    For no-split/allow-split ring buffers, the actual size of memory that"]
    #[doc = "          the item will occupy will be rounded up to the nearest 32-bit aligned"]
    #[doc = "          size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "          aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer"]
    pub fn xRingbufferSend(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const c_types::c_void,
        xItemSize: size_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to insert an item into the ring buffer from an ISR. This function"]
    #[doc = " will return immediately if there is insufficient free space in the buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem      Pointer to data to insert. NULL is allowed if xItemSize is 0."]
    #[doc = " @param[in]   xItemSize   Size of data to insert."]
    #[doc = " @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE if the function woke up a higher priority task."]
    #[doc = ""]
    #[doc = " @note    For no-split/allow-split ring buffers, the actual size of memory that"]
    #[doc = "          the item will occupy will be rounded up to the nearest 32-bit aligned"]
    #[doc = "          size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "          aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE when the ring buffer does not have space."]
    pub fn xRingbufferSendFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const c_types::c_void,
        xItemSize: size_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief Acquire memory from the ring buffer to be written to by an external"]
    #[doc = "        source and to be sent later."]
    #[doc = ""]
    #[doc = " Attempt to allocate buffer for an item to be sent into the ring buffer. This"]
    #[doc = " function will block until enough free space is available or until it"]
    #[doc = " timesout."]
    #[doc = ""]
    #[doc = " The item, as well as the following items ``SendAcquire`` or ``Send`` after it,"]
    #[doc = " will not be able to be read from the ring buffer until this item is actually"]
    #[doc = " sent into the ring buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to allocate the memory"]
    #[doc = " @param[out]  ppvItem         Double pointer to memory acquired (set to NULL if no memory were retrieved)"]
    #[doc = " @param[in]   xItemSize       Size of item to acquire."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for room in the ring buffer."]
    #[doc = ""]
    #[doc = " @note Only applicable for no-split ring buffers now, the actual size of"]
    #[doc = "       memory that the item will occupy will be rounded up to the nearest 32-bit"]
    #[doc = "       aligned size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "       aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer"]
    pub fn xRingbufferSendAcquire(
        xRingbuffer: RingbufHandle_t,
        ppvItem: *mut *mut c_types::c_void,
        xItemSize: size_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief       Actually send an item into the ring buffer allocated before by"]
    #[doc = "              ``xRingbufferSendAcquire``."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem          Pointer to item in allocated memory to insert."]
    #[doc = ""]
    #[doc = " @note Only applicable for no-split ring buffers. Only call for items"]
    #[doc = "       allocated by ``xRingbufferSendAcquire``."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE if fail for some reason."]
    pub fn xRingbufferSendComplete(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut c_types::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to retrieve an item from the ring buffer. This function will block"]
    #[doc = " until an item is available or until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItem() is required after this to free the item retrieved."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item."]
    #[doc = "      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceive(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
        xTicksToWait: TickType_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to retrieve an item from the ring buffer. This function returns immediately"]
    #[doc = " if there are no items available for retrieval"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the"]
    #[doc = "                              retrieved item will be written."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItemFromISR() is required after this to free the item retrieved."]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item."]
    #[doc = "      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to retrieve a split item from an allow-split ring buffer. If the item"]
    #[doc = " is not split, only a single item is retried. If the item is split, both parts"]
    #[doc = " will be retrieved. This function will block until an item is available or"]
    #[doc = " until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)"]
    #[doc = " @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)"]
    #[doc = " @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)"]
    #[doc = " @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)"]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    Call(s) to vRingbufferReturnItem() is required after this to free up the item(s) retrieved."]
    #[doc = " @note    This function should only be called on allow-split buffers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if an item (split or unsplit) was retrieved"]
    #[doc = "      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplit(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut c_types::c_void,
        ppvTailItem: *mut *mut c_types::c_void,
        pxHeadItemSize: *mut size_t,
        pxTailItemSize: *mut size_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to retrieve a split item from an allow-split ring buffer. If the item"]
    #[doc = " is not split, only a single item is retried. If the item is split, both parts"]
    #[doc = " will be retrieved. This function returns immediately if there are no items"]
    #[doc = " available for retrieval"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)"]
    #[doc = " @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)"]
    #[doc = " @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)"]
    #[doc = " @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)"]
    #[doc = ""]
    #[doc = " @note    Calls to vRingbufferReturnItemFromISR() is required after this to free up the item(s) retrieved."]
    #[doc = " @note    This function should only be called on allow-split buffers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if an item (split or unsplit) was retrieved"]
    #[doc = "      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplitFromISR(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut c_types::c_void,
        ppvTailItem: *mut *mut c_types::c_void,
        pxHeadItemSize: *mut size_t,
        pxTailItemSize: *mut size_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of bytes to retrieve"]
    #[doc = ""]
    #[doc = " Attempt to retrieve data from a byte buffer whilst specifying a maximum number"]
    #[doc = " of bytes to retrieve. This function will block until there is data available"]
    #[doc = " for retrieval or until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = " @param[in]   xMaxSize        Maximum number of bytes to return."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItem() is required after this to free up the data retrieved."]
    #[doc = " @note    This function should only be called on byte buffers"]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with"]
    #[doc = "        the length of the item."]
    #[doc = "      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpTo(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
        xTicksToWait: TickType_t,
        xMaxSize: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of"]
    #[doc = "          bytes to retrieve. Call this from an ISR."]
    #[doc = ""]
    #[doc = " Attempt to retrieve bytes from a byte buffer whilst specifying a maximum number"]
    #[doc = " of bytes to retrieve. This function will return immediately if there is no data"]
    #[doc = " available for retrieval."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize  Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xMaxSize    Maximum number of bytes to return."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItemFromISR() is required after this to free up the data received."]
    #[doc = " @note    This function should only be called on byte buffers"]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with"]
    #[doc = "        the length of the item."]
    #[doc = "      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpToFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
        xMaxSize: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer the item was retrieved from"]
    #[doc = " @param[in]   pvItem      Item that was received earlier"]
    #[doc = ""]
    #[doc = " @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItem(xRingbuffer: RingbufHandle_t, pvItem: *mut c_types::c_void);
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer from an ISR"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer the item was retrieved from"]
    #[doc = " @param[in]   pvItem      Item that was received earlier"]
    #[doc = " @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE"]
    #[doc = "                                          if the function woke up a higher priority task."]
    #[doc = ""]
    #[doc = " @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItemFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut c_types::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Delete a ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to delete"]
    #[doc = ""]
    #[doc = " @note    This function will not deallocate any memory if the ring buffer was"]
    #[doc = "          created using xRingbufferCreateStatic(). Deallocation must be done"]
    #[doc = "          manually be the user."]
    pub fn vRingbufferDelete(xRingbuffer: RingbufHandle_t);
}
extern "C" {
    #[doc = " @brief   Get maximum size of an item that can be placed in the ring buffer"]
    #[doc = ""]
    #[doc = " This function returns the maximum size an item can have if it was placed in"]
    #[doc = " an empty ring buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to query"]
    #[doc = ""]
    #[doc = " @note    The max item size for a no-split buffer is limited to"]
    #[doc = "          ((buffer_size/2)-header_size). This limit is imposed so that an item"]
    #[doc = "          of max item size can always be sent to the an empty no-split buffer"]
    #[doc = "          regardless of the internal positions of the buffer's read/write/free"]
    #[doc = "          pointers."]
    #[doc = ""]
    #[doc = " @return  Maximum size, in bytes, of an item that can be placed in a ring buffer."]
    pub fn xRingbufferGetMaxItemSize(xRingbuffer: RingbufHandle_t) -> size_t;
}
extern "C" {
    #[doc = " @brief   Get current free size available for an item/data in the buffer"]
    #[doc = ""]
    #[doc = " This gives the real time free space available for an item/data in the ring"]
    #[doc = " buffer. This represents the maximum size an item/data can have if it was"]
    #[doc = " currently sent to the ring buffer."]
    #[doc = ""]
    #[doc = " @warning This API is not thread safe. So, if multiple threads are accessing"]
    #[doc = "          the same ring buffer, it is the application's responsibility to"]
    #[doc = "          ensure atomic access to this API and the subsequent Send"]
    #[doc = ""]
    #[doc = " @note    An empty no-split buffer has a max current free size for an item"]
    #[doc = "          that is limited to ((buffer_size/2)-header_size). See API reference"]
    #[doc = "          for xRingbufferGetMaxItemSize()."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to query"]
    #[doc = ""]
    #[doc = " @return  Current free size, in bytes, available for an entry"]
    pub fn xRingbufferGetCurFreeSize(xRingbuffer: RingbufHandle_t) -> size_t;
}
extern "C" {
    #[doc = " @brief   Add the ring buffer's read semaphore to a queue set."]
    #[doc = ""]
    #[doc = " The ring buffer's read semaphore indicates that data has been written"]
    #[doc = " to the ring buffer. This function adds the ring buffer's read semaphore to"]
    #[doc = " a queue set."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to add to the queue set"]
    #[doc = " @param[in]   xQueueSet       Queue set to add the ring buffer's read semaphore to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE on success, pdFALSE otherwise"]
    pub fn xRingbufferAddToQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Check if the selected queue set member is the ring buffer's read semaphore"]
    #[doc = ""]
    #[doc = " This API checks if queue set member returned from xQueueSelectFromSet()"]
    #[doc = " is the read semaphore of this ring buffer. If so, this indicates the ring buffer"]
    #[doc = " has items waiting to be retrieved."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer which should be checked"]
    #[doc = " @param[in]   xMember         Member returned from xQueueSelectFromSet"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE when semaphore belongs to ring buffer"]
    #[doc = "      - pdFALSE otherwise."]
    pub fn xRingbufferCanRead(
        xRingbuffer: RingbufHandle_t,
        xMember: QueueSetMemberHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Remove the ring buffer's read semaphore from a queue set."]
    #[doc = ""]
    #[doc = " This specifically removes a ring buffer's read semaphore from a queue set. The"]
    #[doc = " read semaphore is used to indicate when data has been written to the ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to remove from the queue set"]
    #[doc = " @param[in]   xQueueSet       Queue set to remove the ring buffer's read semaphore from"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE on success"]
    #[doc = "      - pdFALSE otherwise"]
    pub fn xRingbufferRemoveFromQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Get information about ring buffer status"]
    #[doc = ""]
    #[doc = " Get information of the a ring buffer's current status such as"]
    #[doc = " free/read/write pointer positions, and number of items waiting to be retrieved."]
    #[doc = " Arguments can be set to NULL if they are not required."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to remove from the queue set"]
    #[doc = " @param[out]  uxFree          Pointer use to store free pointer position"]
    #[doc = " @param[out]  uxRead          Pointer use to store read pointer position"]
    #[doc = " @param[out]  uxWrite         Pointer use to store write pointer position"]
    #[doc = " @param[out]  uxAcquire       Pointer use to store acquire pointer position"]
    #[doc = " @param[out]  uxItemsWaiting  Pointer use to store number of items (bytes for byte buffer) waiting to be retrieved"]
    pub fn vRingbufferGetInfo(
        xRingbuffer: RingbufHandle_t,
        uxFree: *mut UBaseType_t,
        uxRead: *mut UBaseType_t,
        uxWrite: *mut UBaseType_t,
        uxAcquire: *mut UBaseType_t,
        uxItemsWaiting: *mut UBaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Debugging function to print the internal pointers in the ring buffer"]
    #[doc = ""]
    #[doc = " @param   xRingbuffer Ring buffer to show"]
    pub fn xRingbufferPrintInfo(xRingbuffer: RingbufHandle_t);
}
#[doc = " @brief I2C port number, can be I2C_NUM_0 ~ (I2C_NUM_MAX-1)."]
pub type i2c_port_t = c_types::c_int;
#[doc = "< I2C slave mode"]
pub const i2c_mode_t_I2C_MODE_SLAVE: i2c_mode_t = 0;
#[doc = "< I2C master mode"]
pub const i2c_mode_t_I2C_MODE_MASTER: i2c_mode_t = 1;
pub const i2c_mode_t_I2C_MODE_MAX: i2c_mode_t = 2;
pub type i2c_mode_t = c_types::c_uint;
#[doc = "< I2C write data"]
pub const i2c_rw_t_I2C_MASTER_WRITE: i2c_rw_t = 0;
#[doc = "< I2C read data"]
pub const i2c_rw_t_I2C_MASTER_READ: i2c_rw_t = 1;
pub type i2c_rw_t = c_types::c_uint;
#[doc = "<I2C restart command"]
pub const i2c_opmode_t_I2C_CMD_RESTART: i2c_opmode_t = 0;
#[doc = "<I2C write command"]
pub const i2c_opmode_t_I2C_CMD_WRITE: i2c_opmode_t = 1;
#[doc = "<I2C read command"]
pub const i2c_opmode_t_I2C_CMD_READ: i2c_opmode_t = 2;
#[doc = "<I2C stop command"]
pub const i2c_opmode_t_I2C_CMD_STOP: i2c_opmode_t = 3;
#[doc = "<I2C end command"]
pub const i2c_opmode_t_I2C_CMD_END: i2c_opmode_t = 4;
pub type i2c_opmode_t = c_types::c_uint;
#[doc = "< I2C data msb first"]
pub const i2c_trans_mode_t_I2C_DATA_MODE_MSB_FIRST: i2c_trans_mode_t = 0;
#[doc = "< I2C data lsb first"]
pub const i2c_trans_mode_t_I2C_DATA_MODE_LSB_FIRST: i2c_trans_mode_t = 1;
pub const i2c_trans_mode_t_I2C_DATA_MODE_MAX: i2c_trans_mode_t = 2;
pub type i2c_trans_mode_t = c_types::c_uint;
#[doc = "< I2C 7bit address for slave mode"]
pub const i2c_addr_mode_t_I2C_ADDR_BIT_7: i2c_addr_mode_t = 0;
#[doc = "< I2C 10bit address for slave mode"]
pub const i2c_addr_mode_t_I2C_ADDR_BIT_10: i2c_addr_mode_t = 1;
pub const i2c_addr_mode_t_I2C_ADDR_BIT_MAX: i2c_addr_mode_t = 2;
pub type i2c_addr_mode_t = c_types::c_uint;
#[doc = "< I2C ack for each byte read"]
pub const i2c_ack_type_t_I2C_MASTER_ACK: i2c_ack_type_t = 0;
#[doc = "< I2C nack for each byte read"]
pub const i2c_ack_type_t_I2C_MASTER_NACK: i2c_ack_type_t = 1;
#[doc = "< I2C nack for the last byte"]
pub const i2c_ack_type_t_I2C_MASTER_LAST_NACK: i2c_ack_type_t = 2;
pub const i2c_ack_type_t_I2C_MASTER_ACK_MAX: i2c_ack_type_t = 3;
pub type i2c_ack_type_t = c_types::c_uint;
#[doc = "< I2C source clock from REF_TICK"]
pub const i2c_sclk_t_I2C_SCLK_REF_TICK: i2c_sclk_t = 0;
#[doc = "< I2C source clock from APB"]
pub const i2c_sclk_t_I2C_SCLK_APB: i2c_sclk_t = 1;
pub type i2c_sclk_t = c_types::c_uint;
#[doc = " @brief I2C initialization parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i2c_config_t {
    #[doc = "< I2C mode"]
    pub mode: i2c_mode_t,
    #[doc = "< GPIO number for I2C sda signal"]
    pub sda_io_num: c_types::c_int,
    #[doc = "< GPIO number for I2C scl signal"]
    pub scl_io_num: c_types::c_int,
    #[doc = "< Internal GPIO pull mode for I2C sda signal"]
    pub sda_pullup_en: bool,
    #[doc = "< Internal GPIO pull mode for I2C scl signal"]
    pub scl_pullup_en: bool,
    pub __bindgen_anon_1: i2c_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2c_config_t__bindgen_ty_1 {
    pub master: i2c_config_t__bindgen_ty_1__bindgen_ty_1,
    pub slave: i2c_config_t__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_config_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< I2C clock frequency for master mode, (no higher than 1MHz for now)"]
    pub clk_speed: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_config_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< I2C 10bit address mode enable for slave mode"]
    pub addr_10bit_en: u8,
    #[doc = "< I2C address for slave mode"]
    pub slave_addr: u16,
}
pub type i2c_cmd_handle_t = *mut c_types::c_void;
extern "C" {
    #[doc = " @brief I2C driver install"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param mode I2C mode( master or slave )"]
    #[doc = " @param slv_rx_buf_len receiving buffer size for slave mode"]
    #[doc = "        @note"]
    #[doc = "        Only slave mode will use this value, driver will ignore this value in master mode."]
    #[doc = " @param slv_tx_buf_len sending buffer size for slave mode"]
    #[doc = "        @note"]
    #[doc = "        Only slave mode will use this value, driver will ignore this value in master mode."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = "        @note"]
    #[doc = "        In master mode, if the cache is likely to be disabled(such as write flash) and the slave is time-sensitive,"]
    #[doc = "        `ESP_INTR_FLAG_IRAM` is suggested to be used. In this case, please use the memory allocated from internal RAM in i2c read and write function,"]
    #[doc = "        because we can not access the psram(if psram is enabled) in interrupt handle function when cache is disabled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Driver install error"]
    pub fn i2c_driver_install(
        i2c_num: i2c_port_t,
        mode: i2c_mode_t,
        slv_rx_buf_len: size_t,
        slv_tx_buf_len: size_t,
        intr_alloc_flags: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C driver delete"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_driver_delete(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C parameter initialization"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param i2c_conf pointer to I2C parameter settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_param_config(i2c_num: i2c_port_t, i2c_conf: *const i2c_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief reset I2C tx hardware fifo"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_reset_tx_fifo(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief reset I2C rx fifo"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_reset_rx_fifo(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C isr handler register"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param fn isr handler function"]
    #[doc = " @param arg parameter for isr handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle handle return from esp_intr_alloc."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_isr_register(
        i2c_num: i2c_port_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief to delete and free I2C isr."]
    #[doc = ""]
    #[doc = " @param handle handle of isr."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_isr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure GPIO signal for I2C sck and sda"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param sda_io_num GPIO number for I2C sda signal"]
    #[doc = " @param scl_io_num GPIO number for I2C scl signal"]
    #[doc = " @param sda_pullup_en Whether to enable the internal pullup for sda pin"]
    #[doc = " @param scl_pullup_en Whether to enable the internal pullup for scl pin"]
    #[doc = " @param mode I2C mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_pin(
        i2c_num: i2c_port_t,
        sda_io_num: c_types::c_int,
        scl_io_num: c_types::c_int,
        sda_pullup_en: bool,
        scl_pullup_en: bool,
        mode: i2c_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create and init I2C command link"]
    #[doc = "        @note"]
    #[doc = "        Before we build I2C command link, we need to call i2c_cmd_link_create() to create"]
    #[doc = "        a command link."]
    #[doc = "        After we finish sending the commands, we need to call i2c_cmd_link_delete() to"]
    #[doc = "        release and return the resources."]
    #[doc = ""]
    #[doc = " @return i2c command link handler"]
    pub fn i2c_cmd_link_create() -> i2c_cmd_handle_t;
}
extern "C" {
    #[doc = " @brief Free I2C command link"]
    #[doc = "        @note"]
    #[doc = "        Before we build I2C command link, we need to call i2c_cmd_link_create() to create"]
    #[doc = "        a command link."]
    #[doc = "        After we finish sending the commands, we need to call i2c_cmd_link_delete() to"]
    #[doc = "        release and return the resources."]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C command handle"]
    pub fn i2c_cmd_link_delete(cmd_handle: i2c_cmd_handle_t);
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to generate a start signal"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_start(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to write one byte to I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data I2C one byte command to write to bus"]
    #[doc = " @param ack_en enable ack check for master"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_write_byte(cmd_handle: i2c_cmd_handle_t, data: u8, ack_en: bool)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to write buffer to I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data data to send"]
    #[doc = "        @note"]
    #[doc = "        If the psram is enabled and intr_flag is `ESP_INTR_FLAG_IRAM`, please use the memory allocated from internal RAM."]
    #[doc = " @param data_len data length"]
    #[doc = " @param ack_en enable ack check for master"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_write(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        data_len: size_t,
        ack_en: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to read one byte from I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data pointer accept the data byte"]
    #[doc = "        @note"]
    #[doc = "        If the psram is enabled and intr_flag is `ESP_INTR_FLAG_IRAM`, please use the memory allocated from internal RAM."]
    #[doc = " @param ack ack value for read command"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_read_byte(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to read data from I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data data buffer to accept the data from bus"]
    #[doc = "        @note"]
    #[doc = "        If the psram is enabled and intr_flag is `ESP_INTR_FLAG_IRAM`, please use the memory allocated from internal RAM."]
    #[doc = " @param data_len read data length"]
    #[doc = " @param ack ack value for read command"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_read(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        data_len: size_t,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to generate a stop signal"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_stop(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C master send queued commands."]
    #[doc = "        This function will trigger sending all queued commands."]
    #[doc = "        The task will be blocked until all the commands have been sent out."]
    #[doc = "        The I2C APIs are not thread-safe, if you want to use one I2C port in different tasks,"]
    #[doc = "        you need to take care of the multi-thread issue."]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param cmd_handle I2C command handler"]
    #[doc = " @param ticks_to_wait maximum wait ticks."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Sending command error, slave doesn't ACK the transfer."]
    #[doc = "     - ESP_ERR_INVALID_STATE I2C driver not installed or not in master mode."]
    #[doc = "     - ESP_ERR_TIMEOUT Operation timeout because the bus is busy."]
    pub fn i2c_master_cmd_begin(
        i2c_num: i2c_port_t,
        cmd_handle: i2c_cmd_handle_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C slave write data to internal ringbuffer, when tx fifo empty, isr will fill the hardware"]
    #[doc = "        fifo from the internal ringbuffer"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C slave mode"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param data data pointer to write into internal buffer"]
    #[doc = " @param size data size"]
    #[doc = " @param ticks_to_wait Maximum waiting ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL(-1) Parameter error"]
    #[doc = "     - Others(>=0) The number of data bytes that pushed to the I2C slave buffer."]
    pub fn i2c_slave_write_buffer(
        i2c_num: i2c_port_t,
        data: *mut u8,
        size: c_types::c_int,
        ticks_to_wait: TickType_t,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief I2C slave read data from internal buffer. When I2C slave receive data, isr will copy received data"]
    #[doc = "        from hardware rx fifo to internal ringbuffer. Then users can read from internal ringbuffer."]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C slave mode"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param data data pointer to accept data from internal buffer"]
    #[doc = " @param max_size Maximum data size to read"]
    #[doc = " @param ticks_to_wait Maximum waiting ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL(-1) Parameter error"]
    #[doc = "     - Others(>=0) The number of data bytes that read from I2C slave buffer."]
    pub fn i2c_slave_read_buffer(
        i2c_num: i2c_port_t,
        data: *mut u8,
        max_size: size_t,
        ticks_to_wait: TickType_t,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief set I2C master clock period"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param high_period clock cycle number during SCL is high level, high_period is a 14 bit value"]
    #[doc = " @param low_period clock cycle number during SCL is low level, low_period is a 14 bit value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_period(
        i2c_num: i2c_port_t,
        high_period: c_types::c_int,
        low_period: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C master clock period"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param high_period pointer to get clock cycle number during SCL is high level, will get a 14 bit value"]
    #[doc = " @param low_period pointer to get clock cycle number during SCL is low level, will get a 14 bit value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_period(
        i2c_num: i2c_port_t,
        high_period: *mut c_types::c_int,
        low_period: *mut c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief enable hardware filter on I2C bus"]
    #[doc = "        Sometimes the I2C bus is disturbed by high frequency noise(about 20ns), or the rising edge of"]
    #[doc = "        the SCL clock is very slow, these may cause the master state machine broken. enable hardware"]
    #[doc = "        filter can filter out high frequency interference and make the master more stable."]
    #[doc = "        @note"]
    #[doc = "        Enable filter will slow the SCL clock."]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param cyc_num the APB cycles need to be filtered(0<= cyc_num <=7)."]
    #[doc = "        When the period of a pulse is less than cyc_num * APB_cycle, the I2C controller will ignore this pulse."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_filter_enable(i2c_num: i2c_port_t, cyc_num: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief disable filter on I2C bus"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_filter_disable(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C master start signal timing"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param setup_time clock number between the falling-edge of SDA and rising-edge of SCL for start mark, it's a 10-bit value."]
    #[doc = " @param hold_time clock num between the falling-edge of SDA and falling-edge of SCL for start mark, it's a 10-bit value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_start_timing(
        i2c_num: i2c_port_t,
        setup_time: c_types::c_int,
        hold_time: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C master start signal timing"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param setup_time pointer to get setup time"]
    #[doc = " @param hold_time pointer to get hold time"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_start_timing(
        i2c_num: i2c_port_t,
        setup_time: *mut c_types::c_int,
        hold_time: *mut c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C master stop signal timing"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param setup_time clock num between the rising-edge of SCL and the rising-edge of SDA, it's a 10-bit value."]
    #[doc = " @param hold_time clock number after the STOP bit's rising-edge, it's a 14-bit value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_stop_timing(
        i2c_num: i2c_port_t,
        setup_time: c_types::c_int,
        hold_time: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C master stop signal timing"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param setup_time pointer to get setup time."]
    #[doc = " @param hold_time pointer to get hold time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_stop_timing(
        i2c_num: i2c_port_t,
        setup_time: *mut c_types::c_int,
        hold_time: *mut c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C data signal timing"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param sample_time clock number I2C used to sample data on SDA after the rising-edge of SCL, it's a 10-bit value"]
    #[doc = " @param hold_time clock number I2C used to hold the data after the falling-edge of SCL, it's a 10-bit value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_data_timing(
        i2c_num: i2c_port_t,
        sample_time: c_types::c_int,
        hold_time: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C data signal timing"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param sample_time pointer to get sample time"]
    #[doc = " @param hold_time pointer to get hold time"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_data_timing(
        i2c_num: i2c_port_t,
        sample_time: *mut c_types::c_int,
        hold_time: *mut c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C timeout value"]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param timeout timeout value for I2C bus (unit: APB 80Mhz clock cycle)"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_timeout(i2c_num: i2c_port_t, timeout: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C timeout value"]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param timeout pointer to get timeout value"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_timeout(i2c_num: i2c_port_t, timeout: *mut c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set I2C data transfer mode"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param tx_trans_mode I2C sending data mode"]
    #[doc = " @param rx_trans_mode I2C receving data mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_data_mode(
        i2c_num: i2c_port_t,
        tx_trans_mode: i2c_trans_mode_t,
        rx_trans_mode: i2c_trans_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get I2C data transfer mode"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param tx_trans_mode pointer to get I2C sending data mode"]
    #[doc = " @param rx_trans_mode pointer to get I2C receiving data mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_get_data_mode(
        i2c_num: i2c_port_t,
        tx_trans_mode: *mut i2c_trans_mode_t,
        rx_trans_mode: *mut i2c_trans_mode_t,
    ) -> esp_err_t;
}
pub const periph_module_t_PERIPH_LEDC_MODULE: periph_module_t = 0;
pub const periph_module_t_PERIPH_UART0_MODULE: periph_module_t = 1;
pub const periph_module_t_PERIPH_UART1_MODULE: periph_module_t = 2;
pub const periph_module_t_PERIPH_UART2_MODULE: periph_module_t = 3;
pub const periph_module_t_PERIPH_I2C0_MODULE: periph_module_t = 4;
pub const periph_module_t_PERIPH_I2C1_MODULE: periph_module_t = 5;
pub const periph_module_t_PERIPH_I2S0_MODULE: periph_module_t = 6;
pub const periph_module_t_PERIPH_I2S1_MODULE: periph_module_t = 7;
pub const periph_module_t_PERIPH_TIMG0_MODULE: periph_module_t = 8;
pub const periph_module_t_PERIPH_TIMG1_MODULE: periph_module_t = 9;
pub const periph_module_t_PERIPH_PWM0_MODULE: periph_module_t = 10;
pub const periph_module_t_PERIPH_PWM1_MODULE: periph_module_t = 11;
pub const periph_module_t_PERIPH_PWM2_MODULE: periph_module_t = 12;
pub const periph_module_t_PERIPH_PWM3_MODULE: periph_module_t = 13;
pub const periph_module_t_PERIPH_UHCI0_MODULE: periph_module_t = 14;
pub const periph_module_t_PERIPH_UHCI1_MODULE: periph_module_t = 15;
pub const periph_module_t_PERIPH_RMT_MODULE: periph_module_t = 16;
pub const periph_module_t_PERIPH_PCNT_MODULE: periph_module_t = 17;
pub const periph_module_t_PERIPH_SPI_MODULE: periph_module_t = 18;
pub const periph_module_t_PERIPH_HSPI_MODULE: periph_module_t = 19;
pub const periph_module_t_PERIPH_VSPI_MODULE: periph_module_t = 20;
pub const periph_module_t_PERIPH_SPI_DMA_MODULE: periph_module_t = 21;
pub const periph_module_t_PERIPH_SDMMC_MODULE: periph_module_t = 22;
pub const periph_module_t_PERIPH_SDIO_SLAVE_MODULE: periph_module_t = 23;
pub const periph_module_t_PERIPH_CAN_MODULE: periph_module_t = 24;
pub const periph_module_t_PERIPH_EMAC_MODULE: periph_module_t = 25;
pub const periph_module_t_PERIPH_RNG_MODULE: periph_module_t = 26;
pub const periph_module_t_PERIPH_WIFI_MODULE: periph_module_t = 27;
pub const periph_module_t_PERIPH_BT_MODULE: periph_module_t = 28;
pub const periph_module_t_PERIPH_WIFI_BT_COMMON_MODULE: periph_module_t = 29;
pub const periph_module_t_PERIPH_BT_BASEBAND_MODULE: periph_module_t = 30;
pub const periph_module_t_PERIPH_BT_LC_MODULE: periph_module_t = 31;
pub const periph_module_t_PERIPH_AES_MODULE: periph_module_t = 32;
pub const periph_module_t_PERIPH_SHA_MODULE: periph_module_t = 33;
pub const periph_module_t_PERIPH_RSA_MODULE: periph_module_t = 34;
pub type periph_module_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i2s_dev_s {
    pub reserved_0: u32,
    pub reserved_4: u32,
    pub conf: i2s_dev_s__bindgen_ty_1,
    pub int_raw: i2s_dev_s__bindgen_ty_2,
    pub int_st: i2s_dev_s__bindgen_ty_3,
    pub int_ena: i2s_dev_s__bindgen_ty_4,
    pub int_clr: i2s_dev_s__bindgen_ty_5,
    pub timing: i2s_dev_s__bindgen_ty_6,
    pub fifo_conf: i2s_dev_s__bindgen_ty_7,
    pub rx_eof_num: u32,
    pub conf_single_data: u32,
    pub conf_chan: i2s_dev_s__bindgen_ty_8,
    pub out_link: i2s_dev_s__bindgen_ty_9,
    pub in_link: i2s_dev_s__bindgen_ty_10,
    pub out_eof_des_addr: u32,
    pub in_eof_des_addr: u32,
    pub out_eof_bfr_des_addr: u32,
    pub ahb_test: i2s_dev_s__bindgen_ty_11,
    pub in_link_dscr: u32,
    pub in_link_dscr_bf0: u32,
    pub in_link_dscr_bf1: u32,
    pub out_link_dscr: u32,
    pub out_link_dscr_bf0: u32,
    pub out_link_dscr_bf1: u32,
    pub lc_conf: i2s_dev_s__bindgen_ty_12,
    pub out_fifo_push: i2s_dev_s__bindgen_ty_13,
    pub in_fifo_pop: i2s_dev_s__bindgen_ty_14,
    pub lc_state0: u32,
    pub lc_state1: u32,
    pub lc_hung_conf: i2s_dev_s__bindgen_ty_15,
    pub reserved_78: u32,
    pub reserved_7c: u32,
    pub cvsd_conf0: i2s_dev_s__bindgen_ty_16,
    pub cvsd_conf1: i2s_dev_s__bindgen_ty_17,
    pub cvsd_conf2: i2s_dev_s__bindgen_ty_18,
    pub plc_conf0: i2s_dev_s__bindgen_ty_19,
    pub plc_conf1: i2s_dev_s__bindgen_ty_20,
    pub plc_conf2: i2s_dev_s__bindgen_ty_21,
    pub esco_conf0: i2s_dev_s__bindgen_ty_22,
    pub sco_conf0: i2s_dev_s__bindgen_ty_23,
    pub conf1: i2s_dev_s__bindgen_ty_24,
    pub pd_conf: i2s_dev_s__bindgen_ty_25,
    pub conf2: i2s_dev_s__bindgen_ty_26,
    pub clkm_conf: i2s_dev_s__bindgen_ty_27,
    pub sample_rate_conf: i2s_dev_s__bindgen_ty_28,
    pub pdm_conf: i2s_dev_s__bindgen_ty_29,
    pub pdm_freq_conf: i2s_dev_s__bindgen_ty_30,
    pub state: i2s_dev_s__bindgen_ty_31,
    pub reserved_c0: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub reserved_f0: u32,
    pub reserved_f4: u32,
    pub reserved_f8: u32,
    pub date: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn tx_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_slave_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_slave_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_slave_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_slave_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_right_first(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_right_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_right_first(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_right_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_msb_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_msb_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_msb_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_msb_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_short_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_short_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_short_sync(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_short_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mono(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mono(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_mono(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_mono(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_msb_right(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_msb_right(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_msb_right(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_msb_right(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_loopback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_loopback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_reset: u32,
        rx_reset: u32,
        tx_fifo_reset: u32,
        rx_fifo_reset: u32,
        tx_start: u32,
        rx_start: u32,
        tx_slave_mod: u32,
        rx_slave_mod: u32,
        tx_right_first: u32,
        rx_right_first: u32,
        tx_msb_shift: u32,
        rx_msb_shift: u32,
        tx_short_sync: u32,
        rx_short_sync: u32,
        tx_mono: u32,
        rx_mono: u32,
        tx_msb_right: u32,
        rx_msb_right: u32,
        sig_loopback: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_reset: u32 = unsafe { ::core::mem::transmute(tx_reset) };
            tx_reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rx_reset: u32 = unsafe { ::core::mem::transmute(rx_reset) };
            rx_reset as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tx_fifo_reset: u32 = unsafe { ::core::mem::transmute(tx_fifo_reset) };
            tx_fifo_reset as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_fifo_reset: u32 = unsafe { ::core::mem::transmute(rx_fifo_reset) };
            rx_fifo_reset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tx_slave_mod: u32 = unsafe { ::core::mem::transmute(tx_slave_mod) };
            tx_slave_mod as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_slave_mod: u32 = unsafe { ::core::mem::transmute(rx_slave_mod) };
            rx_slave_mod as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tx_right_first: u32 = unsafe { ::core::mem::transmute(tx_right_first) };
            tx_right_first as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let rx_right_first: u32 = unsafe { ::core::mem::transmute(rx_right_first) };
            rx_right_first as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let tx_msb_shift: u32 = unsafe { ::core::mem::transmute(tx_msb_shift) };
            tx_msb_shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rx_msb_shift: u32 = unsafe { ::core::mem::transmute(rx_msb_shift) };
            rx_msb_shift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_short_sync: u32 = unsafe { ::core::mem::transmute(tx_short_sync) };
            tx_short_sync as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_short_sync: u32 = unsafe { ::core::mem::transmute(rx_short_sync) };
            rx_short_sync as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_mono: u32 = unsafe { ::core::mem::transmute(tx_mono) };
            tx_mono as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rx_mono: u32 = unsafe { ::core::mem::transmute(rx_mono) };
            rx_mono as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tx_msb_right: u32 = unsafe { ::core::mem::transmute(tx_msb_right) };
            tx_msb_right as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_msb_right: u32 = unsafe { ::core::mem::transmute(rx_msb_right) };
            rx_msb_right as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sig_loopback: u32 = unsafe { ::core::mem::transmute(sig_loopback) };
            sig_loopback as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn rx_take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_take_data: u32,
        tx_put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_take_data: u32 = unsafe { ::core::mem::transmute(rx_take_data) };
            rx_take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_put_data: u32 = unsafe { ::core::mem::transmute(tx_put_data) };
            tx_put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn rx_take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_take_data: u32,
        tx_put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_take_data: u32 = unsafe { ::core::mem::transmute(rx_take_data) };
            rx_take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_put_data: u32 = unsafe { ::core::mem::transmute(tx_put_data) };
            tx_put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn rx_take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_take_data: u32,
        tx_put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_take_data: u32 = unsafe { ::core::mem::transmute(rx_take_data) };
            rx_take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_put_data: u32 = unsafe { ::core::mem::transmute(tx_put_data) };
            tx_put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn take_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_take_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn put_data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_put_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_wfull(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_wfull(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rempty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rempty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hung(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hung(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        take_data: u32,
        put_data: u32,
        rx_wfull: u32,
        rx_rempty: u32,
        tx_wfull: u32,
        tx_rempty: u32,
        rx_hung: u32,
        tx_hung: u32,
        in_done: u32,
        in_suc_eof: u32,
        in_err_eof: u32,
        out_done: u32,
        out_eof: u32,
        in_dscr_err: u32,
        out_dscr_err: u32,
        in_dscr_empty: u32,
        out_total_eof: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let take_data: u32 = unsafe { ::core::mem::transmute(take_data) };
            take_data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let put_data: u32 = unsafe { ::core::mem::transmute(put_data) };
            put_data as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_wfull: u32 = unsafe { ::core::mem::transmute(rx_wfull) };
            rx_wfull as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rx_rempty: u32 = unsafe { ::core::mem::transmute(rx_rempty) };
            rx_rempty as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tx_wfull: u32 = unsafe { ::core::mem::transmute(tx_wfull) };
            tx_wfull as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tx_rempty: u32 = unsafe { ::core::mem::transmute(tx_rempty) };
            tx_rempty as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rx_hung: u32 = unsafe { ::core::mem::transmute(rx_hung) };
            rx_hung as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tx_hung: u32 = unsafe { ::core::mem::transmute(tx_hung) };
            tx_hung as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let in_dscr_err: u32 = unsafe { ::core::mem::transmute(in_dscr_err) };
            in_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let out_dscr_err: u32 = unsafe { ::core::mem::transmute(out_dscr_err) };
            out_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let in_dscr_empty: u32 = unsafe { ::core::mem::transmute(in_dscr_empty) };
            in_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn tx_bck_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ws_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ws_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bck_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bck_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_ws_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_ws_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sd_in_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sd_in_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_bck_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ws_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ws_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sd_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sd_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_ws_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_ws_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bck_out_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bck_out_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dsync_sw(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dsync_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dsync_sw(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dsync_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_enable_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_data_enable_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_bck_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_bck_in_delay: u32,
        tx_ws_in_delay: u32,
        rx_bck_in_delay: u32,
        rx_ws_in_delay: u32,
        rx_sd_in_delay: u32,
        tx_bck_out_delay: u32,
        tx_ws_out_delay: u32,
        tx_sd_out_delay: u32,
        rx_ws_out_delay: u32,
        rx_bck_out_delay: u32,
        tx_dsync_sw: u32,
        rx_dsync_sw: u32,
        data_enable_delay: u32,
        tx_bck_in_inv: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tx_bck_in_delay: u32 = unsafe { ::core::mem::transmute(tx_bck_in_delay) };
            tx_bck_in_delay as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let tx_ws_in_delay: u32 = unsafe { ::core::mem::transmute(tx_ws_in_delay) };
            tx_ws_in_delay as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let rx_bck_in_delay: u32 = unsafe { ::core::mem::transmute(rx_bck_in_delay) };
            rx_bck_in_delay as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let rx_ws_in_delay: u32 = unsafe { ::core::mem::transmute(rx_ws_in_delay) };
            rx_ws_in_delay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let rx_sd_in_delay: u32 = unsafe { ::core::mem::transmute(rx_sd_in_delay) };
            rx_sd_in_delay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let tx_bck_out_delay: u32 = unsafe { ::core::mem::transmute(tx_bck_out_delay) };
            tx_bck_out_delay as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let tx_ws_out_delay: u32 = unsafe { ::core::mem::transmute(tx_ws_out_delay) };
            tx_ws_out_delay as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let tx_sd_out_delay: u32 = unsafe { ::core::mem::transmute(tx_sd_out_delay) };
            tx_sd_out_delay as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let rx_ws_out_delay: u32 = unsafe { ::core::mem::transmute(rx_ws_out_delay) };
            rx_ws_out_delay as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let rx_bck_out_delay: u32 = unsafe { ::core::mem::transmute(rx_bck_out_delay) };
            rx_bck_out_delay as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let tx_dsync_sw: u32 = unsafe { ::core::mem::transmute(tx_dsync_sw) };
            tx_dsync_sw as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let rx_dsync_sw: u32 = unsafe { ::core::mem::transmute(rx_dsync_sw) };
            rx_dsync_sw as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let data_enable_delay: u32 = unsafe { ::core::mem::transmute(data_enable_delay) };
            data_enable_delay as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_bck_in_inv: u32 = unsafe { ::core::mem::transmute(tx_bck_in_inv) };
            tx_bck_in_inv as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn rx_data_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rx_data_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_data_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_tx_data_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn dscr_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dscr_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_mod_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_mod_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_mod_force_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_mod_force_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_data_num: u32,
        tx_data_num: u32,
        dscr_en: u32,
        tx_fifo_mod: u32,
        rx_fifo_mod: u32,
        tx_fifo_mod_force_en: u32,
        rx_fifo_mod_force_en: u32,
        reserved21: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let rx_data_num: u32 = unsafe { ::core::mem::transmute(rx_data_num) };
            rx_data_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let tx_data_num: u32 = unsafe { ::core::mem::transmute(tx_data_num) };
            tx_data_num as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let dscr_en: u32 = unsafe { ::core::mem::transmute(dscr_en) };
            dscr_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let tx_fifo_mod: u32 = unsafe { ::core::mem::transmute(tx_fifo_mod) };
            tx_fifo_mod as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let rx_fifo_mod: u32 = unsafe { ::core::mem::transmute(rx_fifo_mod) };
            rx_fifo_mod as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_fifo_mod_force_en: u32 = unsafe { ::core::mem::transmute(tx_fifo_mod_force_en) };
            tx_fifo_mod_force_en as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_fifo_mod_force_en: u32 = unsafe { ::core::mem::transmute(rx_fifo_mod_force_en) };
            rx_fifo_mod_force_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn tx_chan_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_chan_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_chan_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rx_chan_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_chan_mod: u32,
        rx_chan_mod: u32,
        reserved5: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let tx_chan_mod: u32 = unsafe { ::core::mem::transmute(tx_chan_mod) };
            tx_chan_mod as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let rx_chan_mod: u32 = unsafe { ::core::mem::transmute(rx_chan_mod) };
            rx_chan_mod as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: u32,
        reserved3: u32,
        addr: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let mode: u32 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn in_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_fifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_fifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_auto_wrback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_auto_wrback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_no_restart_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_no_restart_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_indscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_data_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_data_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn check_owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_check_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_trans_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_trans_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_rst: u32,
        out_rst: u32,
        ahbm_fifo_rst: u32,
        ahbm_rst: u32,
        out_loop_test: u32,
        in_loop_test: u32,
        out_auto_wrback: u32,
        out_no_restart_clr: u32,
        out_eof_mode: u32,
        outdscr_burst_en: u32,
        indscr_burst_en: u32,
        out_data_burst_en: u32,
        check_owner: u32,
        mem_trans_en: u32,
        reserved14: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_rst: u32 = unsafe { ::core::mem::transmute(in_rst) };
            in_rst as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let out_rst: u32 = unsafe { ::core::mem::transmute(out_rst) };
            out_rst as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ahbm_fifo_rst: u32 = unsafe { ::core::mem::transmute(ahbm_fifo_rst) };
            ahbm_fifo_rst as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ahbm_rst: u32 = unsafe { ::core::mem::transmute(ahbm_rst) };
            ahbm_rst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let out_loop_test: u32 = unsafe { ::core::mem::transmute(out_loop_test) };
            out_loop_test as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_loop_test: u32 = unsafe { ::core::mem::transmute(in_loop_test) };
            in_loop_test as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_auto_wrback: u32 = unsafe { ::core::mem::transmute(out_auto_wrback) };
            out_auto_wrback as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_no_restart_clr: u32 = unsafe { ::core::mem::transmute(out_no_restart_clr) };
            out_no_restart_clr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_eof_mode: u32 = unsafe { ::core::mem::transmute(out_eof_mode) };
            out_eof_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outdscr_burst_en: u32 = unsafe { ::core::mem::transmute(outdscr_burst_en) };
            outdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let indscr_burst_en: u32 = unsafe { ::core::mem::transmute(indscr_burst_en) };
            indscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let out_data_burst_en: u32 = unsafe { ::core::mem::transmute(out_data_burst_en) };
            out_data_burst_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let check_owner: u32 = unsafe { ::core::mem::transmute(check_owner) };
            check_owner as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let mem_trans_en: u32 = unsafe { ::core::mem::transmute(mem_trans_en) };
            mem_trans_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 18u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn push(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_push(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wdata: u32,
        reserved9: u32,
        push: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let wdata: u32 = unsafe { ::core::mem::transmute(wdata) };
            wdata as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let push: u32 = unsafe { ::core::mem::transmute(push) };
            push as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn rdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_rdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdata: u32,
        reserved12: u32,
        pop: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let rdata: u32 = unsafe { ::core::mem::transmute(rdata) };
            rdata as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pop: u32 = unsafe { ::core::mem::transmute(pop) };
            pop as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn fifo_timeout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_timeout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_timeout_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_timeout_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_timeout_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_timeout_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fifo_timeout: u32,
        fifo_timeout_shift: u32,
        fifo_timeout_ena: u32,
        reserved12: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let fifo_timeout: u32 = unsafe { ::core::mem::transmute(fifo_timeout) };
            fifo_timeout as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let fifo_timeout_shift: u32 = unsafe { ::core::mem::transmute(fifo_timeout_shift) };
            fifo_timeout_shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fifo_timeout_ena: u32 = unsafe { ::core::mem::transmute(fifo_timeout_ena) };
            fifo_timeout_ena as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn y_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_y_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn y_min(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_y_min(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(y_max: u32, y_min: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let y_max: u32 = unsafe { ::core::mem::transmute(y_max) };
            y_max as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let y_min: u32 = unsafe { ::core::mem::transmute(y_min) };
            y_min as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn sigma_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sigma_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn sigma_min(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sigma_min(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sigma_max: u32,
        sigma_min: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let sigma_max: u32 = unsafe { ::core::mem::transmute(sigma_max) };
            sigma_max as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let sigma_min: u32 = unsafe { ::core::mem::transmute(sigma_min) };
            sigma_min as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn cvsd_k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_j(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_j(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_beta(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_beta(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_h(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_h(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cvsd_k: u32,
        cvsd_j: u32,
        cvsd_beta: u32,
        cvsd_h: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let cvsd_k: u32 = unsafe { ::core::mem::transmute(cvsd_k) };
            cvsd_k as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let cvsd_j: u32 = unsafe { ::core::mem::transmute(cvsd_j) };
            cvsd_j as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let cvsd_beta: u32 = unsafe { ::core::mem::transmute(cvsd_beta) };
            cvsd_beta as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let cvsd_h: u32 = unsafe { ::core::mem::transmute(cvsd_h) };
            cvsd_h as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn good_pack_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_good_pack_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn n_err_seg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_n_err_seg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn shift_rate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_shift_rate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn max_slide_sample(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_slide_sample(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pack_len_8k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pack_len_8k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn n_min_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_n_min_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        good_pack_max: u32,
        n_err_seg: u32,
        shift_rate: u32,
        max_slide_sample: u32,
        pack_len_8k: u32,
        n_min_err: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let good_pack_max: u32 = unsafe { ::core::mem::transmute(good_pack_max) };
            good_pack_max as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let n_err_seg: u32 = unsafe { ::core::mem::transmute(n_err_seg) };
            n_err_seg as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let shift_rate: u32 = unsafe { ::core::mem::transmute(shift_rate) };
            shift_rate as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let max_slide_sample: u32 = unsafe { ::core::mem::transmute(max_slide_sample) };
            max_slide_sample as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let pack_len_8k: u32 = unsafe { ::core::mem::transmute(pack_len_8k) };
            pack_len_8k as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let n_min_err: u32 = unsafe { ::core::mem::transmute(n_min_err) };
            n_min_err as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn bad_cef_atten_para(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_bad_cef_atten_para(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn bad_cef_atten_para_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bad_cef_atten_para_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bad_ola_win2_para_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bad_ola_win2_para_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bad_ola_win2_para(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_bad_ola_win2_para(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn slide_win_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_slide_win_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bad_cef_atten_para: u32,
        bad_cef_atten_para_shift: u32,
        bad_ola_win2_para_shift: u32,
        bad_ola_win2_para: u32,
        slide_win_len: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let bad_cef_atten_para: u32 = unsafe { ::core::mem::transmute(bad_cef_atten_para) };
            bad_cef_atten_para as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let bad_cef_atten_para_shift: u32 =
                unsafe { ::core::mem::transmute(bad_cef_atten_para_shift) };
            bad_cef_atten_para_shift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let bad_ola_win2_para_shift: u32 =
                unsafe { ::core::mem::transmute(bad_ola_win2_para_shift) };
            bad_ola_win2_para_shift as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let bad_ola_win2_para: u32 = unsafe { ::core::mem::transmute(bad_ola_win2_para) };
            bad_ola_win2_para as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let slide_win_len: u32 = unsafe { ::core::mem::transmute(slide_win_len) };
            slide_win_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn cvsd_seg_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_seg_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn min_period(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_min_period(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cvsd_seg_mod: u32,
        min_period: u32,
        reserved7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cvsd_seg_mod: u32 = unsafe { ::core::mem::transmute(cvsd_seg_mod) };
            cvsd_seg_mod as u64
        });
        __bindgen_bitfield_unit.set(2usize, 5u8, {
            let min_period: u32 = unsafe { ::core::mem::transmute(min_period) };
            min_period as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chan_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chan_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_dec_pack_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_dec_pack_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_pack_len_8k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_pack_len_8k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_inf_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_inf_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_dec_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_dec_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_dec_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_dec_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc2dma_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc2dma_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        chan_mod: u32,
        cvsd_dec_pack_err: u32,
        cvsd_pack_len_8k: u32,
        cvsd_inf_en: u32,
        cvsd_dec_start: u32,
        cvsd_dec_reset: u32,
        plc_en: u32,
        plc2dma_en: u32,
        reserved13: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chan_mod: u32 = unsafe { ::core::mem::transmute(chan_mod) };
            chan_mod as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cvsd_dec_pack_err: u32 = unsafe { ::core::mem::transmute(cvsd_dec_pack_err) };
            cvsd_dec_pack_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let cvsd_pack_len_8k: u32 = unsafe { ::core::mem::transmute(cvsd_pack_len_8k) };
            cvsd_pack_len_8k as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cvsd_inf_en: u32 = unsafe { ::core::mem::transmute(cvsd_inf_en) };
            cvsd_inf_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cvsd_dec_start: u32 = unsafe { ::core::mem::transmute(cvsd_dec_start) };
            cvsd_dec_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cvsd_dec_reset: u32 = unsafe { ::core::mem::transmute(cvsd_dec_reset) };
            cvsd_dec_reset as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let plc_en: u32 = unsafe { ::core::mem::transmute(plc_en) };
            plc_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let plc2dma_en: u32 = unsafe { ::core::mem::transmute(plc2dma_en) };
            plc2dma_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reserved13: u32 = unsafe { ::core::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn with_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_with_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_enc_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_enc_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_enc_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cvsd_enc_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        with_en: u32,
        no_en: u32,
        cvsd_enc_start: u32,
        cvsd_enc_reset: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let with_en: u32 = unsafe { ::core::mem::transmute(with_en) };
            with_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_en: u32 = unsafe { ::core::mem::transmute(no_en) };
            no_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cvsd_enc_start: u32 = unsafe { ::core::mem::transmute(cvsd_enc_start) };
            cvsd_enc_start as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cvsd_enc_reset: u32 = unsafe { ::core::mem::transmute(cvsd_enc_reset) };
            cvsd_enc_reset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn tx_pcm_conf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pcm_conf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_pcm_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pcm_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pcm_conf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pcm_conf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pcm_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pcm_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_stop_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_stop_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_zeros_rm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_zeros_rm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_pcm_conf: u32,
        tx_pcm_bypass: u32,
        rx_pcm_conf: u32,
        rx_pcm_bypass: u32,
        tx_stop_en: u32,
        tx_zeros_rm_en: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let tx_pcm_conf: u32 = unsafe { ::core::mem::transmute(tx_pcm_conf) };
            tx_pcm_conf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tx_pcm_bypass: u32 = unsafe { ::core::mem::transmute(tx_pcm_bypass) };
            tx_pcm_bypass as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let rx_pcm_conf: u32 = unsafe { ::core::mem::transmute(rx_pcm_conf) };
            rx_pcm_conf as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_pcm_bypass: u32 = unsafe { ::core::mem::transmute(rx_pcm_bypass) };
            rx_pcm_bypass as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tx_stop_en: u32 = unsafe { ::core::mem::transmute(tx_stop_en) };
            tx_stop_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_zeros_rm_en: u32 = unsafe { ::core::mem::transmute(tx_zeros_rm_en) };
            tx_zeros_rm_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn fifo_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc_mem_force_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc_mem_force_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc_mem_force_pu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plc_mem_force_pu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fifo_force_pd: u32,
        fifo_force_pu: u32,
        plc_mem_force_pd: u32,
        plc_mem_force_pu: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fifo_force_pd: u32 = unsafe { ::core::mem::transmute(fifo_force_pd) };
            fifo_force_pd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fifo_force_pu: u32 = unsafe { ::core::mem::transmute(fifo_force_pu) };
            fifo_force_pu as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let plc_mem_force_pd: u32 = unsafe { ::core::mem::transmute(plc_mem_force_pd) };
            plc_mem_force_pd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let plc_mem_force_pu: u32 = unsafe { ::core::mem::transmute(plc_mem_force_pu) };
            plc_mem_force_pu as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn camera_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_camera_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lcd_tx_wrx2_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lcd_tx_wrx2_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lcd_tx_sdx2_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lcd_tx_sdx2_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_enable_test_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_enable_test_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_data_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lcd_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lcd_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_adc_start_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_adc_start_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_valid_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inter_valid_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        camera_en: u32,
        lcd_tx_wrx2_en: u32,
        lcd_tx_sdx2_en: u32,
        data_enable_test_en: u32,
        data_enable: u32,
        lcd_en: u32,
        ext_adc_start_en: u32,
        inter_valid_en: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let camera_en: u32 = unsafe { ::core::mem::transmute(camera_en) };
            camera_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lcd_tx_wrx2_en: u32 = unsafe { ::core::mem::transmute(lcd_tx_wrx2_en) };
            lcd_tx_wrx2_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lcd_tx_sdx2_en: u32 = unsafe { ::core::mem::transmute(lcd_tx_sdx2_en) };
            lcd_tx_sdx2_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let data_enable_test_en: u32 = unsafe { ::core::mem::transmute(data_enable_test_en) };
            data_enable_test_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let data_enable: u32 = unsafe { ::core::mem::transmute(data_enable) };
            data_enable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let lcd_en: u32 = unsafe { ::core::mem::transmute(lcd_en) };
            lcd_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ext_adc_start_en: u32 = unsafe { ::core::mem::transmute(ext_adc_start_en) };
            ext_adc_start_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inter_valid_en: u32 = unsafe { ::core::mem::transmute(inter_valid_en) };
            inter_valid_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn clkm_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_clkm_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn clkm_div_b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkm_div_b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkm_div_a(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkm_div_a(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clka_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clka_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved22(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved22(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clkm_div_num: u32,
        clkm_div_b: u32,
        clkm_div_a: u32,
        clk_en: u32,
        clka_en: u32,
        reserved22: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let clkm_div_num: u32 = unsafe { ::core::mem::transmute(clkm_div_num) };
            clkm_div_num as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let clkm_div_b: u32 = unsafe { ::core::mem::transmute(clkm_div_b) };
            clkm_div_b as u64
        });
        __bindgen_bitfield_unit.set(14usize, 6u8, {
            let clkm_div_a: u32 = unsafe { ::core::mem::transmute(clkm_div_a) };
            clkm_div_a as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let clka_en: u32 = unsafe { ::core::mem::transmute(clka_en) };
            clka_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved22: u32 = unsafe { ::core::mem::transmute(reserved22) };
            reserved22 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn tx_bck_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bck_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bck_div_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bck_div_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_bits_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_tx_bits_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_bits_mod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rx_bits_mod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_bck_div_num: u32,
        rx_bck_div_num: u32,
        tx_bits_mod: u32,
        rx_bits_mod: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let tx_bck_div_num: u32 = unsafe { ::core::mem::transmute(tx_bck_div_num) };
            tx_bck_div_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let rx_bck_div_num: u32 = unsafe { ::core::mem::transmute(rx_bck_div_num) };
            rx_bck_div_num as u64
        });
        __bindgen_bitfield_unit.set(12usize, 6u8, {
            let tx_bits_mod: u32 = unsafe { ::core::mem::transmute(tx_bits_mod) };
            tx_bits_mod as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let rx_bits_mod: u32 = unsafe { ::core::mem::transmute(rx_bits_mod) };
            rx_bits_mod as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl i2s_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn tx_pdm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pdm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pdm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pdm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pcm2pdm_conv_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pcm2pdm_conv_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdm2pcm_conv_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdm2pcm_conv_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sinc_osr2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sinc_osr2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_prescale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tx_prescale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_hp_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_hp_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_lp_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_lp_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sinc_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sinc_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_sigmadelta_in_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_sigmadelta_in_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sinc_dsr_16_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sinc_dsr_16_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txhp_bypass(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txhp_bypass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_pdm_en: u32,
        rx_pdm_en: u32,
        pcm2pdm_conv_en: u32,
        pdm2pcm_conv_en: u32,
        tx_sinc_osr2: u32,
        tx_prescale: u32,
        tx_hp_in_shift: u32,
        tx_lp_in_shift: u32,
        tx_sinc_in_shift: u32,
        tx_sigmadelta_in_shift: u32,
        rx_sinc_dsr_16_en: u32,
        txhp_bypass: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_pdm_en: u32 = unsafe { ::core::mem::transmute(tx_pdm_en) };
            tx_pdm_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rx_pdm_en: u32 = unsafe { ::core::mem::transmute(rx_pdm_en) };
            rx_pdm_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pcm2pdm_conv_en: u32 = unsafe { ::core::mem::transmute(pcm2pdm_conv_en) };
            pcm2pdm_conv_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pdm2pcm_conv_en: u32 = unsafe { ::core::mem::transmute(pdm2pcm_conv_en) };
            pdm2pcm_conv_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tx_sinc_osr2: u32 = unsafe { ::core::mem::transmute(tx_sinc_osr2) };
            tx_sinc_osr2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let tx_prescale: u32 = unsafe { ::core::mem::transmute(tx_prescale) };
            tx_prescale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let tx_hp_in_shift: u32 = unsafe { ::core::mem::transmute(tx_hp_in_shift) };
            tx_hp_in_shift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let tx_lp_in_shift: u32 = unsafe { ::core::mem::transmute(tx_lp_in_shift) };
            tx_lp_in_shift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let tx_sinc_in_shift: u32 = unsafe { ::core::mem::transmute(tx_sinc_in_shift) };
            tx_sinc_in_shift as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let tx_sigmadelta_in_shift: u32 =
                unsafe { ::core::mem::transmute(tx_sigmadelta_in_shift) };
            tx_sigmadelta_in_shift as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rx_sinc_dsr_16_en: u32 = unsafe { ::core::mem::transmute(rx_sinc_dsr_16_en) };
            rx_sinc_dsr_16_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let txhp_bypass: u32 = unsafe { ::core::mem::transmute(txhp_bypass) };
            txhp_bypass as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl i2s_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn tx_pdm_fs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pdm_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_pdm_fp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pdm_fp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_pdm_fs: u32,
        tx_pdm_fp: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let tx_pdm_fs: u32 = unsafe { ::core::mem::transmute(tx_pdm_fs) };
            tx_pdm_fs as u64
        });
        __bindgen_bitfield_unit.set(10usize, 10u8, {
            let tx_pdm_fp: u32 = unsafe { ::core::mem::transmute(tx_pdm_fp) };
            tx_pdm_fp as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union i2s_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: i2s_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct i2s_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl i2s_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn tx_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_fifo_reset_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_fifo_reset_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_fifo_reset_back(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_fifo_reset_back(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_idle: u32,
        tx_fifo_reset_back: u32,
        rx_fifo_reset_back: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_idle: u32 = unsafe { ::core::mem::transmute(tx_idle) };
            tx_idle as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_fifo_reset_back: u32 = unsafe { ::core::mem::transmute(tx_fifo_reset_back) };
            tx_fifo_reset_back as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rx_fifo_reset_back: u32 = unsafe { ::core::mem::transmute(rx_fifo_reset_back) };
            rx_fifo_reset_back as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type i2s_dev_t = i2s_dev_s;
extern "C" {
    pub static mut I2S0: i2s_dev_t;
}
extern "C" {
    pub static mut I2S1: i2s_dev_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_signal_conn_t {
    pub o_bck_in_sig: u8,
    pub o_ws_in_sig: u8,
    pub o_bck_out_sig: u8,
    pub o_ws_out_sig: u8,
    pub o_data_out_sig: u8,
    pub i_bck_in_sig: u8,
    pub i_ws_in_sig: u8,
    pub i_bck_out_sig: u8,
    pub i_ws_out_sig: u8,
    pub i_data_in_sig: u8,
    pub irq: u8,
    pub module: periph_module_t,
}
extern "C" {
    pub static i2s_periph_signal: [i2s_signal_conn_t; 2usize];
}
#[doc = " @brief Pin function information for a single RTCIO pad's."]
#[doc = ""]
#[doc = " This is an internal function of the driver, and is not usually useful"]
#[doc = " for external use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtc_io_desc_t {
    #[doc = "< Register of RTC pad, or 0 if not an RTC GPIO"]
    pub reg: u32,
    #[doc = "< Bit mask for selecting digital pad or RTC pad"]
    pub mux: u32,
    #[doc = "< Shift of pad function (FUN_SEL) field"]
    pub func: u32,
    #[doc = "< Mask of input enable"]
    pub ie: u32,
    #[doc = "< Mask of pullup enable"]
    pub pullup: u32,
    #[doc = "< Mask of pulldown enable"]
    pub pulldown: u32,
    #[doc = "< If slpsel bit is set, slpie will be used as pad input enabled signal in sleep mode"]
    pub slpsel: u32,
    #[doc = "< Mask of input enable in sleep mode"]
    pub slpie: u32,
    #[doc = "< Mask of output enable in sleep mode"]
    pub slpoe: u32,
    #[doc = "< Mask of hold enable"]
    pub hold: u32,
    #[doc = "< Mask of hold_force bit for RTC IO in RTC_CNTL_HOLD_REG"]
    pub hold_force: u32,
    #[doc = "< Mask of drive capability"]
    pub drv_v: u32,
    #[doc = "< Offset of drive capability"]
    pub drv_s: u32,
    #[doc = "< GPIO number (corresponds to RTC pad)"]
    pub rtc_num: c_types::c_int,
}
extern "C" {
    pub static rtc_io_desc: [rtc_io_desc_t; 18usize];
}
extern "C" {
    pub static rtc_io_num_map: [c_types::c_int; 40usize];
}
extern "C" {
    #[doc = " @brief      enable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be ungated, and reset de-asserted."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_enable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      disable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be gated, reset asserted."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_disable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      reset peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Reset will asserted then de-assrted for the peripheral."]
    #[doc = ""]
    #[doc = " Calling this function does not enable or disable the clock for the module."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_reset(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      enable wifi bt common module"]
    #[doc = ""]
    #[doc = " @note If wifi_bt_common_module_enable is called a number of times,"]
    #[doc = "       wifi_bt_common_module_disable has to be called the same number of times"]
    #[doc = "       in order to put the peripheral into disabled state."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn wifi_bt_common_module_enable();
}
extern "C" {
    #[doc = " @brief      disable wifi bt common module"]
    #[doc = ""]
    #[doc = " @note If wifi_bt_common_module_enable is called a number of times,"]
    #[doc = "       wifi_bt_common_module_disable has to be called the same number of times"]
    #[doc = "       in order to put the peripheral into disabled state."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn wifi_bt_common_module_disable();
}
#[doc = " @brief I2S port number, the max port number is (I2S_NUM_MAX -1)."]
pub type i2s_port_t = c_types::c_int;
#[doc = "< I2S bits per sample: 8-bits"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_8BIT: i2s_bits_per_sample_t = 8;
#[doc = "< I2S bits per sample: 16-bits"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_16BIT: i2s_bits_per_sample_t = 16;
#[doc = "< I2S bits per sample: 24-bits"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_24BIT: i2s_bits_per_sample_t = 24;
#[doc = "< I2S bits per sample: 32-bits"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_32BIT: i2s_bits_per_sample_t = 32;
#[doc = " @brief I2S bit width per sample."]
#[doc = ""]
pub type i2s_bits_per_sample_t = c_types::c_uint;
#[doc = "< I2S 1 channel (mono)"]
pub const i2s_channel_t_I2S_CHANNEL_MONO: i2s_channel_t = 1;
#[doc = "< I2S 2 channel (stereo)"]
pub const i2s_channel_t_I2S_CHANNEL_STEREO: i2s_channel_t = 2;
#[doc = " @brief I2S channel."]
#[doc = ""]
pub type i2s_channel_t = c_types::c_uint;
#[doc = "< I2S communication format I2S"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S: i2s_comm_format_t = 1;
#[doc = "< I2S format MSB"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S_MSB: i2s_comm_format_t = 2;
#[doc = "< I2S format LSB"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S_LSB: i2s_comm_format_t = 4;
#[doc = "< I2S communication format PCM"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_PCM: i2s_comm_format_t = 8;
#[doc = "< PCM Short"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_PCM_SHORT: i2s_comm_format_t = 16;
#[doc = "< PCM Long"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_PCM_LONG: i2s_comm_format_t = 32;
#[doc = " @brief I2S communication standard format"]
#[doc = ""]
pub type i2s_comm_format_t = c_types::c_uint;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_RIGHT_LEFT: i2s_channel_fmt_t = 0;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ALL_RIGHT: i2s_channel_fmt_t = 1;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ALL_LEFT: i2s_channel_fmt_t = 2;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ONLY_RIGHT: i2s_channel_fmt_t = 3;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ONLY_LEFT: i2s_channel_fmt_t = 4;
#[doc = " @brief I2S channel format type"]
pub type i2s_channel_fmt_t = c_types::c_uint;
pub const pdm_sample_rate_ratio_t_PDM_SAMPLE_RATE_RATIO_64: pdm_sample_rate_ratio_t = 0;
pub const pdm_sample_rate_ratio_t_PDM_SAMPLE_RATE_RATIO_128: pdm_sample_rate_ratio_t = 1;
#[doc = " @brief PDM sample rate ratio, measured in Hz."]
#[doc = ""]
pub type pdm_sample_rate_ratio_t = c_types::c_uint;
pub const pdm_pcm_conv_t_PDM_PCM_CONV_ENABLE: pdm_pcm_conv_t = 0;
pub const pdm_pcm_conv_t_PDM_PCM_CONV_DISABLE: pdm_pcm_conv_t = 1;
#[doc = " @brief PDM PCM convter enable/disable."]
#[doc = ""]
pub type pdm_pcm_conv_t = c_types::c_uint;
pub const i2s_mode_t_I2S_MODE_MASTER: i2s_mode_t = 1;
pub const i2s_mode_t_I2S_MODE_SLAVE: i2s_mode_t = 2;
pub const i2s_mode_t_I2S_MODE_TX: i2s_mode_t = 4;
pub const i2s_mode_t_I2S_MODE_RX: i2s_mode_t = 8;
#[doc = "< Output I2S data to built-in DAC, no matter the data format is 16bit or 32 bit, the DAC module will only take the 8bits from MSB"]
pub const i2s_mode_t_I2S_MODE_DAC_BUILT_IN: i2s_mode_t = 16;
#[doc = "< Input I2S data from built-in ADC, each data can be 12-bit width at most"]
pub const i2s_mode_t_I2S_MODE_ADC_BUILT_IN: i2s_mode_t = 32;
pub const i2s_mode_t_I2S_MODE_PDM: i2s_mode_t = 64;
#[doc = " @brief I2S Mode, defaut is I2S_MODE_MASTER | I2S_MODE_TX"]
#[doc = ""]
#[doc = " @note PDM and built-in DAC functions are only supported on I2S0 for current ESP32 chip."]
#[doc = ""]
pub type i2s_mode_t = c_types::c_uint;
#[doc = " @brief I2S configuration parameters for i2s_param_config function"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_config_t {
    #[doc = "< I2S work mode"]
    pub mode: i2s_mode_t,
    #[doc = "< I2S sample rate"]
    pub sample_rate: c_types::c_int,
    #[doc = "< I2S bits per sample"]
    pub bits_per_sample: i2s_bits_per_sample_t,
    #[doc = "< I2S channel format"]
    pub channel_format: i2s_channel_fmt_t,
    #[doc = "< I2S communication format"]
    pub communication_format: i2s_comm_format_t,
    #[doc = "< Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info"]
    pub intr_alloc_flags: c_types::c_int,
    #[doc = "< I2S DMA Buffer Count"]
    pub dma_buf_count: c_types::c_int,
    #[doc = "< I2S DMA Buffer Length"]
    pub dma_buf_len: c_types::c_int,
    #[doc = "< I2S using APLL as main I2S clock, enable it to get accurate clock"]
    pub use_apll: bool,
    #[doc = "< I2S auto clear tx descriptor if there is underflow condition (helps in avoiding noise in case of data unavailability)"]
    pub tx_desc_auto_clear: bool,
    #[doc = "< I2S using fixed MCLK output. If use_apll = true and fixed_mclk > 0, then the clock output for i2s is fixed and equal to the fixed_mclk value."]
    pub fixed_mclk: c_types::c_int,
}
pub const i2s_event_type_t_I2S_EVENT_DMA_ERROR: i2s_event_type_t = 0;
#[doc = "< I2S DMA finish sent 1 buffer"]
pub const i2s_event_type_t_I2S_EVENT_TX_DONE: i2s_event_type_t = 1;
#[doc = "< I2S DMA finish received 1 buffer"]
pub const i2s_event_type_t_I2S_EVENT_RX_DONE: i2s_event_type_t = 2;
#[doc = "< I2S event max index"]
pub const i2s_event_type_t_I2S_EVENT_MAX: i2s_event_type_t = 3;
#[doc = " @brief I2S event types"]
#[doc = ""]
pub type i2s_event_type_t = c_types::c_uint;
#[doc = "< Disable I2S built-in DAC signals"]
pub const i2s_dac_mode_t_I2S_DAC_CHANNEL_DISABLE: i2s_dac_mode_t = 0;
#[doc = "< Enable I2S built-in DAC right channel, maps to DAC channel 1 on GPIO25"]
pub const i2s_dac_mode_t_I2S_DAC_CHANNEL_RIGHT_EN: i2s_dac_mode_t = 1;
#[doc = "< Enable I2S built-in DAC left  channel, maps to DAC channel 2 on GPIO26"]
pub const i2s_dac_mode_t_I2S_DAC_CHANNEL_LEFT_EN: i2s_dac_mode_t = 2;
#[doc = "< Enable both of the I2S built-in DAC channels."]
pub const i2s_dac_mode_t_I2S_DAC_CHANNEL_BOTH_EN: i2s_dac_mode_t = 3;
#[doc = "< I2S built-in DAC mode max index"]
pub const i2s_dac_mode_t_I2S_DAC_CHANNEL_MAX: i2s_dac_mode_t = 4;
#[doc = " @brief I2S DAC mode for i2s_set_dac_mode."]
#[doc = ""]
#[doc = " @note PDM and built-in DAC functions are only supported on I2S0 for current ESP32 chip."]
pub type i2s_dac_mode_t = c_types::c_uint;
#[doc = " @brief Event structure used in I2S event queue"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_event_t {
    #[doc = "< I2S event type"]
    pub type_: i2s_event_type_t,
    #[doc = "< I2S data size for I2S_DATA event"]
    pub size: size_t,
}
#[doc = " @brief I2S pin number for i2s_set_pin"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_pin_config_t {
    #[doc = "< BCK in out pin"]
    pub bck_io_num: c_types::c_int,
    #[doc = "< WS in out pin"]
    pub ws_io_num: c_types::c_int,
    #[doc = "< DATA out pin"]
    pub data_out_num: c_types::c_int,
    #[doc = "< DATA in pin"]
    pub data_in_num: c_types::c_int,
}
#[doc = "< downsampling number is 8 for PDM RX mode"]
pub const i2s_pdm_dsr_t_I2S_PDM_DSR_8S: i2s_pdm_dsr_t = 0;
#[doc = "< downsampling number is 16 for PDM RX mode"]
pub const i2s_pdm_dsr_t_I2S_PDM_DSR_16S: i2s_pdm_dsr_t = 1;
pub const i2s_pdm_dsr_t_I2S_PDM_DSR_MAX: i2s_pdm_dsr_t = 2;
#[doc = " @brief I2S PDM RX downsample mode"]
pub type i2s_pdm_dsr_t = c_types::c_uint;
pub const i2s_clock_src_t_I2S_CLK_D2CLK: i2s_clock_src_t = 0;
pub const i2s_clock_src_t_I2S_CLK_APLL: i2s_clock_src_t = 1;
pub type i2s_clock_src_t = c_types::c_uint;
pub type i2s_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Set I2S pin number"]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " The I2S peripheral output signals can be connected to multiple GPIO pads."]
    #[doc = " However, the I2S peripheral input signal can only be connected to one GPIO pad."]
    #[doc = ""]
    #[doc = " @param   i2s_num     I2S_NUM_0 or I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @param   pin         I2S Pin structure, or NULL to set 2-channel 8-bit internal DAC pin configuration (GPIO25 & GPIO26)"]
    #[doc = ""]
    #[doc = " Inside the pin configuration structure, set I2S_PIN_NO_CHANGE for any pin where"]
    #[doc = " the current configuration should not be changed."]
    #[doc = ""]
    #[doc = " @note if *pin is set as NULL, this function will initialize both of the built-in DAC channels by default."]
    #[doc = "       if you don't want this to happen and you want to initialize only one of the DAC channels, you can call i2s_set_dac_mode instead."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL            IO error"]
    pub fn i2s_set_pin(i2s_num: i2s_port_t, pin: *const i2s_pin_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set PDM mode down-sample rate"]
    #[doc = "        In PDM RX mode, there would be 2 rounds of downsample process in hardware."]
    #[doc = "        In the first downsample process, the sampling number can be 16 or 8."]
    #[doc = "        In the second downsample process, the sampling number is fixed as 8."]
    #[doc = "        So the clock frequency in PDM RX mode would be (fpcm * 64) or (fpcm * 128) accordingly."]
    #[doc = " @param i2s_num I2S_NUM_0, I2S_NUM_1"]
    #[doc = " @param dsr i2s RX down sample rate for PDM mode."]
    #[doc = ""]
    #[doc = " @note After calling this function, it would call i2s_set_clk inside to update the clock frequency."]
    #[doc = "       Please call this function after I2S driver has been initialized."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_pdm_rx_down_sample(i2s_num: i2s_port_t, dsr: i2s_pdm_dsr_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set I2S dac mode, I2S built-in DAC is disabled by default"]
    #[doc = ""]
    #[doc = " @param dac_mode DAC mode configurations - see i2s_dac_mode_t"]
    #[doc = ""]
    #[doc = " @note Built-in DAC functions are only supported on I2S0 for current ESP32 chip."]
    #[doc = "       If either of the built-in DAC channel are enabled, the other one can not"]
    #[doc = "       be used as RTC DAC function at the same time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK               Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn i2s_set_dac_mode(dac_mode: i2s_dac_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install and start I2S driver."]
    #[doc = ""]
    #[doc = " @param i2s_num         I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @param i2s_config      I2S configurations - see i2s_config_t struct"]
    #[doc = ""]
    #[doc = " @param queue_size      I2S event queue size/depth."]
    #[doc = ""]
    #[doc = " @param i2s_queue       I2S event queue handle, if set NULL, driver will not use an event queue."]
    #[doc = ""]
    #[doc = " This function must be called before any I2S driver read/write operations."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_driver_install(
        i2s_num: i2s_port_t,
        i2s_config: *const i2s_config_t,
        queue_size: c_types::c_int,
        i2s_queue: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall I2S driver."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_driver_uninstall(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to I2S DMA transmit buffer."]
    #[doc = ""]
    #[doc = " @param i2s_num             I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @param src                 Source address to write from"]
    #[doc = ""]
    #[doc = " @param size                Size of data in bytes"]
    #[doc = ""]
    #[doc = " @param[out] bytes_written  Number of bytes written, if timeout, the result will be less than the size passed in."]
    #[doc = ""]
    #[doc = " @param ticks_to_wait       TX buffer wait timeout in RTOS ticks. If this"]
    #[doc = " many ticks pass without space becoming available in the DMA"]
    #[doc = " transmit buffer, then the function will return (note that if the"]
    #[doc = " data is written to the DMA buffer in pieces, the overall operation"]
    #[doc = " may still take longer than this timeout.) Pass portMAX_DELAY for no"]
    #[doc = " timeout."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK               Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn i2s_write(
        i2s_num: i2s_port_t,
        src: *const c_types::c_void,
        size: size_t,
        bytes_written: *mut size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to I2S DMA transmit buffer while expanding the number of bits per sample. For example, expanding 16-bit PCM to 32-bit PCM."]
    #[doc = ""]
    #[doc = " @param i2s_num             I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @param src                 Source address to write from"]
    #[doc = ""]
    #[doc = " @param size                Size of data in bytes"]
    #[doc = ""]
    #[doc = " @param src_bits            Source audio bit"]
    #[doc = ""]
    #[doc = " @param aim_bits            Bit wanted, no more than 32, and must be greater than src_bits"]
    #[doc = ""]
    #[doc = " @param[out] bytes_written  Number of bytes written, if timeout, the result will be less than the size passed in."]
    #[doc = ""]
    #[doc = " @param ticks_to_wait       TX buffer wait timeout in RTOS ticks. If this"]
    #[doc = " many ticks pass without space becoming available in the DMA"]
    #[doc = " transmit buffer, then the function will return (note that if the"]
    #[doc = " data is written to the DMA buffer in pieces, the overall operation"]
    #[doc = " may still take longer than this timeout.) Pass portMAX_DELAY for no"]
    #[doc = " timeout."]
    #[doc = ""]
    #[doc = " Format of the data in source buffer is determined by the I2S"]
    #[doc = " configuration (see i2s_config_t)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_write_expand(
        i2s_num: i2s_port_t,
        src: *const c_types::c_void,
        size: size_t,
        src_bits: size_t,
        aim_bits: size_t,
        bytes_written: *mut size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read data from I2S DMA receive buffer"]
    #[doc = ""]
    #[doc = " @param i2s_num         I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @param dest            Destination address to read into"]
    #[doc = ""]
    #[doc = " @param size            Size of data in bytes"]
    #[doc = ""]
    #[doc = " @param[out] bytes_read Number of bytes read, if timeout, bytes read will be less than the size passed in."]
    #[doc = ""]
    #[doc = " @param ticks_to_wait   RX buffer wait timeout in RTOS ticks. If this many ticks pass without bytes becoming available in the DMA receive buffer, then the function will return (note that if data is read from the DMA buffer in pieces, the overall operation may still take longer than this timeout.) Pass portMAX_DELAY for no timeout."]
    #[doc = ""]
    #[doc = " @note If the built-in ADC mode is enabled, we should call i2s_adc_start and i2s_adc_stop around the whole reading process,"]
    #[doc = "       to prevent the data getting corrupted."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK               Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn i2s_read(
        i2s_num: i2s_port_t,
        dest: *mut c_types::c_void,
        size: size_t,
        bytes_read: *mut size_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set sample rate used for I2S RX and TX."]
    #[doc = ""]
    #[doc = " The bit clock rate is determined by the sample rate and i2s_config_t configuration parameters (number of channels, bits_per_sample)."]
    #[doc = ""]
    #[doc = " `bit_clock = rate * (number of channels) * bits_per_sample`"]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @param rate I2S sample rate (ex: 8000, 44100...)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_sample_rates(i2s_num: i2s_port_t, rate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop I2S driver"]
    #[doc = ""]
    #[doc = " There is no need to call i2s_stop() before calling i2s_driver_uninstall()."]
    #[doc = ""]
    #[doc = " Disables I2S TX/RX, until i2s_start() is called."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_stop(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start I2S driver"]
    #[doc = ""]
    #[doc = " It is not necessary to call this function after i2s_driver_install() (it is started automatically), however it is necessary to call it after i2s_stop()."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_start(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Zero the contents of the TX DMA buffer."]
    #[doc = ""]
    #[doc = " Pushes zero-byte samples into the TX DMA buffer, until it is full."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_zero_dma_buffer(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set clock & bit width used for I2S RX and TX."]
    #[doc = ""]
    #[doc = " Similar to i2s_set_sample_rates(), but also sets bit width."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @param rate I2S sample rate (ex: 8000, 44100...)"]
    #[doc = ""]
    #[doc = " @param bits I2S bit width (I2S_BITS_PER_SAMPLE_16BIT, I2S_BITS_PER_SAMPLE_24BIT, I2S_BITS_PER_SAMPLE_32BIT)"]
    #[doc = ""]
    #[doc = " @param ch I2S channel, (I2S_CHANNEL_MONO, I2S_CHANNEL_STEREO)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_clk(
        i2s_num: i2s_port_t,
        rate: u32,
        bits: i2s_bits_per_sample_t,
        ch: i2s_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get clock set on particular port number."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0, I2S_NUM_1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - actual clock set by i2s driver"]
    pub fn i2s_get_clk(i2s_num: i2s_port_t) -> f32;
}
extern "C" {
    #[doc = " @brief Set built-in ADC mode for I2S DMA, this function will initialize ADC pad,"]
    #[doc = "        and set ADC parameters."]
    #[doc = " @param adc_unit    SAR ADC unit index"]
    #[doc = " @param adc_channel ADC channel index"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_set_adc_mode(adc_unit: adc_unit_t, adc_channel: adc1_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start to use I2S built-in ADC mode"]
    #[doc = " @note This function would acquire the lock of ADC to prevent the data getting corrupted"]
    #[doc = "       during the I2S peripheral is being used to do fully continuous ADC sampling."]
    #[doc = ""]
    #[doc = " @param i2s_num i2s port index"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK                Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG   Parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver state error"]
    pub fn i2s_adc_enable(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop to use I2S built-in ADC mode"]
    #[doc = " @param i2s_num i2s port index"]
    #[doc = " @note This function would release the lock of ADC so that other tasks can use ADC."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK                 Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG    Parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE  Driver state error"]
    pub fn i2s_adc_disable(i2s_num: i2s_port_t) -> esp_err_t;
}
#[doc = "< LEDC high speed speed_mode"]
pub const ledc_mode_t_LEDC_HIGH_SPEED_MODE: ledc_mode_t = 0;
#[doc = "< LEDC low speed speed_mode"]
pub const ledc_mode_t_LEDC_LOW_SPEED_MODE: ledc_mode_t = 1;
#[doc = "< LEDC speed limit"]
pub const ledc_mode_t_LEDC_SPEED_MODE_MAX: ledc_mode_t = 2;
pub type ledc_mode_t = c_types::c_uint;
#[doc = "< Disable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_DISABLE: ledc_intr_type_t = 0;
#[doc = "< Enable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_FADE_END: ledc_intr_type_t = 1;
pub const ledc_intr_type_t_LEDC_INTR_MAX: ledc_intr_type_t = 2;
pub type ledc_intr_type_t = c_types::c_uint;
#[doc = "< LEDC duty decrease direction"]
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_DECREASE: ledc_duty_direction_t = 0;
#[doc = "< LEDC duty increase direction"]
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_INCREASE: ledc_duty_direction_t = 1;
pub const ledc_duty_direction_t_LEDC_DUTY_DIR_MAX: ledc_duty_direction_t = 2;
pub type ledc_duty_direction_t = c_types::c_uint;
#[doc = "< LEDC low speed timer clock source is 8MHz RTC clock"]
pub const ledc_slow_clk_sel_t_LEDC_SLOW_CLK_RTC8M: ledc_slow_clk_sel_t = 0;
#[doc = "< LEDC low speed timer clock source is 80MHz APB clock"]
pub const ledc_slow_clk_sel_t_LEDC_SLOW_CLK_APB: ledc_slow_clk_sel_t = 1;
pub type ledc_slow_clk_sel_t = c_types::c_uint;
#[doc = "< The driver will automatically select the source clock(REF_TICK or APB) based on the giving resolution and duty parameter when init the timer"]
pub const ledc_clk_cfg_t_LEDC_AUTO_CLK: ledc_clk_cfg_t = 0;
#[doc = "< LEDC timer select REF_TICK clock as source clock"]
pub const ledc_clk_cfg_t_LEDC_USE_REF_TICK: ledc_clk_cfg_t = 1;
#[doc = "< LEDC timer select APB clock as source clock"]
pub const ledc_clk_cfg_t_LEDC_USE_APB_CLK: ledc_clk_cfg_t = 2;
#[doc = "< LEDC timer select RTC8M_CLK as source clock. Only for low speed channels and this parameter must be the same for all low speed channels"]
pub const ledc_clk_cfg_t_LEDC_USE_RTC8M_CLK: ledc_clk_cfg_t = 3;
pub type ledc_clk_cfg_t = c_types::c_uint;
#[doc = "< LEDC timer clock divided from reference tick (1Mhz)"]
pub const ledc_clk_src_t_LEDC_REF_TICK: ledc_clk_src_t = 1;
#[doc = "< LEDC timer clock divided from APB clock (80Mhz)"]
pub const ledc_clk_src_t_LEDC_APB_CLK: ledc_clk_src_t = 2;
pub type ledc_clk_src_t = c_types::c_uint;
#[doc = "< LEDC timer 0"]
pub const ledc_timer_t_LEDC_TIMER_0: ledc_timer_t = 0;
#[doc = "< LEDC timer 1"]
pub const ledc_timer_t_LEDC_TIMER_1: ledc_timer_t = 1;
#[doc = "< LEDC timer 2"]
pub const ledc_timer_t_LEDC_TIMER_2: ledc_timer_t = 2;
#[doc = "< LEDC timer 3"]
pub const ledc_timer_t_LEDC_TIMER_3: ledc_timer_t = 3;
pub const ledc_timer_t_LEDC_TIMER_MAX: ledc_timer_t = 4;
pub type ledc_timer_t = c_types::c_uint;
#[doc = "< LEDC channel 0"]
pub const ledc_channel_t_LEDC_CHANNEL_0: ledc_channel_t = 0;
#[doc = "< LEDC channel 1"]
pub const ledc_channel_t_LEDC_CHANNEL_1: ledc_channel_t = 1;
#[doc = "< LEDC channel 2"]
pub const ledc_channel_t_LEDC_CHANNEL_2: ledc_channel_t = 2;
#[doc = "< LEDC channel 3"]
pub const ledc_channel_t_LEDC_CHANNEL_3: ledc_channel_t = 3;
#[doc = "< LEDC channel 4"]
pub const ledc_channel_t_LEDC_CHANNEL_4: ledc_channel_t = 4;
#[doc = "< LEDC channel 5"]
pub const ledc_channel_t_LEDC_CHANNEL_5: ledc_channel_t = 5;
#[doc = "< LEDC channel 6"]
pub const ledc_channel_t_LEDC_CHANNEL_6: ledc_channel_t = 6;
#[doc = "< LEDC channel 7"]
pub const ledc_channel_t_LEDC_CHANNEL_7: ledc_channel_t = 7;
pub const ledc_channel_t_LEDC_CHANNEL_MAX: ledc_channel_t = 8;
pub type ledc_channel_t = c_types::c_uint;
#[doc = "< LEDC PWM duty resolution of  1 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_1_BIT: ledc_timer_bit_t = 1;
#[doc = "< LEDC PWM duty resolution of  2 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_2_BIT: ledc_timer_bit_t = 2;
#[doc = "< LEDC PWM duty resolution of  3 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_3_BIT: ledc_timer_bit_t = 3;
#[doc = "< LEDC PWM duty resolution of  4 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_4_BIT: ledc_timer_bit_t = 4;
#[doc = "< LEDC PWM duty resolution of  5 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_5_BIT: ledc_timer_bit_t = 5;
#[doc = "< LEDC PWM duty resolution of  6 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_6_BIT: ledc_timer_bit_t = 6;
#[doc = "< LEDC PWM duty resolution of  7 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_7_BIT: ledc_timer_bit_t = 7;
#[doc = "< LEDC PWM duty resolution of  8 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_8_BIT: ledc_timer_bit_t = 8;
#[doc = "< LEDC PWM duty resolution of  9 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_9_BIT: ledc_timer_bit_t = 9;
#[doc = "< LEDC PWM duty resolution of 10 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_10_BIT: ledc_timer_bit_t = 10;
#[doc = "< LEDC PWM duty resolution of 11 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_11_BIT: ledc_timer_bit_t = 11;
#[doc = "< LEDC PWM duty resolution of 12 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_12_BIT: ledc_timer_bit_t = 12;
#[doc = "< LEDC PWM duty resolution of 13 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_13_BIT: ledc_timer_bit_t = 13;
#[doc = "< LEDC PWM duty resolution of 14 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_14_BIT: ledc_timer_bit_t = 14;
#[doc = "< LEDC PWM duty resolution of 15 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_15_BIT: ledc_timer_bit_t = 15;
#[doc = "< LEDC PWM duty resolution of 16 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_16_BIT: ledc_timer_bit_t = 16;
#[doc = "< LEDC PWM duty resolution of 17 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_17_BIT: ledc_timer_bit_t = 17;
#[doc = "< LEDC PWM duty resolution of 18 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_18_BIT: ledc_timer_bit_t = 18;
#[doc = "< LEDC PWM duty resolution of 19 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_19_BIT: ledc_timer_bit_t = 19;
#[doc = "< LEDC PWM duty resolution of 20 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_20_BIT: ledc_timer_bit_t = 20;
pub const ledc_timer_bit_t_LEDC_TIMER_BIT_MAX: ledc_timer_bit_t = 21;
pub type ledc_timer_bit_t = c_types::c_uint;
#[doc = "< LEDC fade function will return immediately"]
pub const ledc_fade_mode_t_LEDC_FADE_NO_WAIT: ledc_fade_mode_t = 0;
#[doc = "< LEDC fade function will block until fading to the target duty"]
pub const ledc_fade_mode_t_LEDC_FADE_WAIT_DONE: ledc_fade_mode_t = 1;
pub const ledc_fade_mode_t_LEDC_FADE_MAX: ledc_fade_mode_t = 2;
pub type ledc_fade_mode_t = c_types::c_uint;
#[doc = " @brief Configuration parameters of LEDC channel for ledc_channel_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ledc_channel_config_t {
    #[doc = "< the LEDC output gpio_num, if you want to use gpio16, gpio_num = 16"]
    pub gpio_num: c_types::c_int,
    #[doc = "< LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    #[doc = "< LEDC channel (0 - 7)"]
    pub channel: ledc_channel_t,
    #[doc = "< configure interrupt, Fade interrupt enable  or Fade interrupt disable"]
    pub intr_type: ledc_intr_type_t,
    #[doc = "< Select the timer source of channel (0 - 3)"]
    pub timer_sel: ledc_timer_t,
    #[doc = "< LEDC channel duty, the range of duty setting is [0, (2**duty_resolution)]"]
    pub duty: u32,
    #[doc = "< LEDC channel hpoint value, the max value is 0xfffff"]
    pub hpoint: c_types::c_int,
}
#[doc = " @brief Configuration parameters of LEDC Timer timer for ledc_timer_config function"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ledc_timer_config_t {
    #[doc = "< LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    pub __bindgen_anon_1: ledc_timer_config_t__bindgen_ty_1,
    #[doc = "< The timer source of channel (0 - 3)"]
    pub timer_num: ledc_timer_t,
    #[doc = "< LEDC timer frequency (Hz)"]
    pub freq_hz: u32,
    #[doc = "< Configure LEDC source clock."]
    #[doc = "For low speed channels and high speed channels, you can specify the source clock using LEDC_USE_REF_TICK, LEDC_USE_APB_CLK or LEDC_AUTO_CLK."]
    #[doc = "For low speed channels, you can also specify the source clock using LEDC_USE_RTC8M_CLK, in this case, all low speed channel's source clock must be RTC8M_CLK"]
    pub clk_cfg: ledc_clk_cfg_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ledc_timer_config_t__bindgen_ty_1 {
    #[doc = "< LEDC channel duty resolution"]
    pub duty_resolution: ledc_timer_bit_t,
    #[doc = "< Deprecated in ESP-IDF 3.0. This is an alias to 'duty_resolution' for backward compatibility with ESP-IDF 2.1"]
    pub bit_num: ledc_timer_bit_t,
    _bindgen_union_align: u32,
}
pub type ledc_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief LEDC channel configuration"]
    #[doc = "        Configure LEDC channel with the given channel/output gpio_num/interrupt/source timer/frequency(Hz)/LEDC duty resolution"]
    #[doc = ""]
    #[doc = " @param ledc_conf Pointer of LEDC channel configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_channel_config(ledc_conf: *const ledc_channel_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC timer configuration"]
    #[doc = "        Configure LEDC timer with the given source timer/frequency(Hz)/duty_resolution"]
    #[doc = ""]
    #[doc = " @param  timer_conf Pointer of LEDC timer configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Can not find a proper pre-divider number base on the given frequency and the current duty_resolution."]
    pub fn ledc_timer_config(timer_conf: *const ledc_timer_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC update channel parameters"]
    #[doc = " @note  Call this function to activate the LEDC updated parameters."]
    #[doc = "        After ledc_set_duty, we need to call this function to update the settings."]
    #[doc = " @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_duty_and_update"]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode,"]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn ledc_update_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC output gpio."]
    #[doc = ""]
    #[doc = " @param  gpio_num The LEDC output gpio"]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param  ledc_channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_pin(
        gpio_num: c_types::c_int,
        speed_mode: ledc_mode_t,
        ledc_channel: ledc_channel_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC stop."]
    #[doc = "        Disable LEDC output, and set idle level"]
    #[doc = ""]
    #[doc = " @param  speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param  channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param  idle_level Set output idle level after LEDC stops."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_stop(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        idle_level: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC set channel frequency (Hz)"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param  timer_num LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = " @param  freq_hz Set the LEDC frequency"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Can not find a proper pre-divider number base on the given frequency and the current duty_resolution."]
    pub fn ledc_set_freq(
        speed_mode: ledc_mode_t,
        timer_num: ledc_timer_t,
        freq_hz: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      LEDC get channel frequency (Hz)"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param timer_num LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0  error"]
    #[doc = "     - Others Current LEDC frequency"]
    pub fn ledc_get_freq(speed_mode: ledc_mode_t, timer_num: ledc_timer_t) -> u32;
}
extern "C" {
    #[doc = " @brief LEDC set duty and hpoint value"]
    #[doc = "        Only after calling ledc_update_duty will the duty update."]
    #[doc = " @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_duty_and_update"]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = " @param hpoint Set the LEDC hpoint value(max: 0xfffff)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_duty_with_hpoint(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC get hpoint value, the counter value when the output is set high level."]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @return"]
    #[doc = "     - LEDC_ERR_VAL if parameter error"]
    #[doc = "     - Others Current hpoint value of LEDC channel"]
    pub fn ledc_get_hpoint(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief LEDC set duty"]
    #[doc = "        This function do not change the hpoint value of this channel. if needed, please call ledc_set_duty_with_hpoint."]
    #[doc = "        only after calling ledc_update_duty will the duty update."]
    #[doc = " @note  ledc_set_duty, ledc_set_duty_with_hpoint and ledc_update_duty are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_duty_and_update."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t, duty: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC get duty"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - LEDC_ERR_DUTY if parameter error"]
    #[doc = "     - Others Current LEDC duty"]
    pub fn ledc_get_duty(speed_mode: ledc_mode_t, channel: ledc_channel_t) -> u32;
}
extern "C" {
    #[doc = " @brief LEDC set gradient"]
    #[doc = "        Set LEDC gradient, After the function calls the ledc_update_duty function, the function can take effect."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the start of the gradient duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = " @param fade_direction Set the direction of the gradient"]
    #[doc = " @param step_num Set the number of the gradient"]
    #[doc = " @param duty_cycle_num Set how many LEDC tick each time the gradient lasts"]
    #[doc = " @param duty_scale Set gradient change amplitude"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_fade(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        fade_direction: ledc_duty_direction_t,
        step_num: u32,
        duty_cycle_num: u32,
        duty_scale: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register LEDC interrupt handler, the handler is an ISR."]
    #[doc = "        The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @param fn Interrupt handler function."]
    #[doc = " @param arg User-supplied argument passed to the handler function."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Function pointer error."]
    pub fn ledc_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut ledc_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure LEDC settings"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param timer_sel  Timer index (0-3), there are 4 timers in LEDC module"]
    #[doc = " @param clock_divider Timer clock divide value, the timer clock is divided from the selected clock source"]
    #[doc = " @param duty_resolution Resolution of duty setting in number of bits. The range of duty values is [0, (2**duty_resolution)]"]
    #[doc = " @param clk_src Select LEDC source clock."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - Other Current LEDC duty"]
    pub fn ledc_timer_set(
        speed_mode: ledc_mode_t,
        timer_sel: ledc_timer_t,
        clock_divider: u32,
        duty_resolution: u32,
        clk_src: ledc_clk_src_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset LEDC timer"]
    #[doc = ""]
    #[doc = " @param  speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param  timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn ledc_timer_rst(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Pause LEDC timer counter"]
    #[doc = ""]
    #[doc = " @param  speed_mode  Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param  timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = ""]
    pub fn ledc_timer_pause(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Resume LEDC timer"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn ledc_timer_resume(speed_mode: ledc_mode_t, timer_sel: ledc_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Bind LEDC channel with the selected timer"]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param timer_sel LEDC timer index (0-3), select from ledc_timer_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn ledc_bind_channel_timer(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        timer_sel: ledc_timer_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC fade function."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = "        Call ledc_fade_start() after this to start fading."]
    #[doc = " @note  ledc_set_fade_with_step, ledc_set_fade_with_time and ledc_fade_start are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_fade_step_and_start"]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode,"]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]"]
    #[doc = " @param scale Controls the increase or decrease step scale."]
    #[doc = " @param cycle_num increase or decrease the duty every cycle_num cycles"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_with_step(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set LEDC fade function, with a limited time."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = "        Call ledc_fade_start() after this to start fading."]
    #[doc = " @note  ledc_set_fade_with_step, ledc_set_fade_with_time and ledc_fade_start are not thread-safe, do not call these functions to"]
    #[doc = "        control one LEDC channel in different tasks at the same time."]
    #[doc = "        A thread-safe version of API is ledc_set_fade_step_and_start"]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode,"]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading.( 0 - (2 ** duty_resolution - 1)))"]
    #[doc = " @param max_fade_time_ms The maximum time of the fading ( ms )."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_with_time(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install LEDC fade function. This function will occupy interrupt of LEDC module."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function already installed."]
    pub fn ledc_fade_func_install(intr_alloc_flags: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall LEDC fade function."]
    #[doc = ""]
    pub fn ledc_fade_func_uninstall();
}
extern "C" {
    #[doc = " @brief Start LEDC fading."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = "        Call this API right after ledc_set_fade_with_time or ledc_set_fade_with_step before to start fading."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel number"]
    #[doc = " @param fade_mode Whether to block until fading done."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error."]
    pub fn ledc_fade_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set duty for LEDC channel and return when duty updated."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = ""]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param duty Set the LEDC duty, the range of duty setting is [0, (2**duty_resolution)]"]
    #[doc = " @param hpoint Set the LEDC hpoint value(max: 0xfffff)"]
    #[doc = ""]
    pub fn ledc_set_duty_and_update(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        duty: u32,
        hpoint: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set and start LEDC fade function, with a limited time."]
    #[doc = " @note  Call ledc_fade_func_install() once, before calling this function."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode,"]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading.( 0 - (2 ** duty_resolution - 1)))"]
    #[doc = " @param max_fade_time_ms The maximum time of the fading ( ms )."]
    #[doc = " @param fade_mode choose blocking or non-blocking mode"]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_time_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        max_fade_time_ms: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief A thread-safe API to set and start LEDC fade function."]
    #[doc = " @note  Call ledc_fade_func_install() once before calling this function."]
    #[doc = " @note  If a fade operation is running in progress on that channel, the driver would not allow it to be stopped."]
    #[doc = "        Other duty operations will have to wait until the fade operation has finished."]
    #[doc = " @param speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode,"]
    #[doc = " @param channel LEDC channel index (0-7), select from ledc_channel_t"]
    #[doc = " @param target_duty Target duty of fading [0, (2**duty_resolution) - 1]"]
    #[doc = " @param scale Controls the increase or decrease step scale."]
    #[doc = " @param cycle_num increase or decrease the duty every cycle_num cycles"]
    #[doc = " @param fade_mode choose blocking or non-blocking mode"]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function not installed."]
    #[doc = "     - ESP_FAIL Fade function init error"]
    pub fn ledc_set_fade_step_and_start(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        target_duty: u32,
        scale: u32,
        cycle_num: u32,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
#[doc = "< Capture 0 happened"]
pub const mcpwm_intr_t_MCPWM_LL_INTR_CAP0: mcpwm_intr_t = 134217728;
#[doc = "< Capture 1 happened"]
pub const mcpwm_intr_t_MCPWM_LL_INTR_CAP1: mcpwm_intr_t = 268435456;
#[doc = "< Capture 2 happened"]
pub const mcpwm_intr_t_MCPWM_LL_INTR_CAP2: mcpwm_intr_t = 536870912;
#[doc = " Interrupts for MCPWM"]
pub type mcpwm_intr_t = c_types::c_uint;
#[doc = "<For asymmetric MCPWM"]
pub const mcpwm_counter_type_t_MCPWM_UP_COUNTER: mcpwm_counter_type_t = 1;
#[doc = "<For asymmetric MCPWM"]
pub const mcpwm_counter_type_t_MCPWM_DOWN_COUNTER: mcpwm_counter_type_t = 2;
#[doc = "<For symmetric MCPWM, frequency is half of MCPWM frequency set"]
pub const mcpwm_counter_type_t_MCPWM_UP_DOWN_COUNTER: mcpwm_counter_type_t = 3;
#[doc = "<Maximum counter mode"]
pub const mcpwm_counter_type_t_MCPWM_COUNTER_MAX: mcpwm_counter_type_t = 4;
#[doc = " @brief Select type of MCPWM counter"]
pub type mcpwm_counter_type_t = c_types::c_uint;
#[doc = "<Active high duty, i.e. duty cycle proportional to high time for asymmetric MCPWM"]
pub const mcpwm_duty_type_t_MCPWM_DUTY_MODE_0: mcpwm_duty_type_t = 0;
#[doc = "<Active low duty,  i.e. duty cycle proportional to low  time for asymmetric MCPWM, out of phase(inverted) MCPWM"]
pub const mcpwm_duty_type_t_MCPWM_DUTY_MODE_1: mcpwm_duty_type_t = 1;
pub const mcpwm_duty_type_t_MCPWM_HAL_GENERATOR_MODE_FORCE_LOW: mcpwm_duty_type_t = 2;
pub const mcpwm_duty_type_t_MCPWM_HAL_GENERATOR_MODE_FORCE_HIGH: mcpwm_duty_type_t = 3;
#[doc = "<Num of duty cycle modes"]
pub const mcpwm_duty_type_t_MCPWM_DUTY_MODE_MAX: mcpwm_duty_type_t = 4;
#[doc = " @brief Select type of MCPWM duty cycle mode"]
pub type mcpwm_duty_type_t = c_types::c_uint;
#[doc = "<No change in the output"]
pub const mcpwm_output_action_t_MCPWM_ACTION_NO_CHANGE: mcpwm_output_action_t = 0;
#[doc = "<Make output low"]
pub const mcpwm_output_action_t_MCPWM_ACTION_FORCE_LOW: mcpwm_output_action_t = 1;
#[doc = "<Make output high"]
pub const mcpwm_output_action_t_MCPWM_ACTION_FORCE_HIGH: mcpwm_output_action_t = 2;
#[doc = "<Make output toggle"]
pub const mcpwm_output_action_t_MCPWM_ACTION_TOGGLE: mcpwm_output_action_t = 3;
#[doc = " @brief MCPWM select action to be taken on the output when event happens"]
pub type mcpwm_output_action_t = c_types::c_uint;
#[doc = "<Bypass the deadtime"]
pub const mcpwm_deadtime_type_t_MCPWM_DEADTIME_BYPASS: mcpwm_deadtime_type_t = 0;
#[doc = "<MCPWMXA = no change, MCPWMXB = falling edge delay"]
pub const mcpwm_deadtime_type_t_MCPWM_BYPASS_RED: mcpwm_deadtime_type_t = 1;
#[doc = "<MCPWMXA = rising edge delay, MCPWMXB = no change"]
pub const mcpwm_deadtime_type_t_MCPWM_BYPASS_FED: mcpwm_deadtime_type_t = 2;
#[doc = "<MCPWMXA = rising edge delay,  MCPWMXB = falling edge delay"]
pub const mcpwm_deadtime_type_t_MCPWM_ACTIVE_HIGH_MODE: mcpwm_deadtime_type_t = 3;
#[doc = "<MCPWMXA = compliment of rising edge delay,  MCPWMXB = compliment of falling edge delay"]
pub const mcpwm_deadtime_type_t_MCPWM_ACTIVE_LOW_MODE: mcpwm_deadtime_type_t = 4;
#[doc = "<MCPWMXA = rising edge delay,  MCPWMXB = compliment of falling edge delay"]
pub const mcpwm_deadtime_type_t_MCPWM_ACTIVE_HIGH_COMPLIMENT_MODE: mcpwm_deadtime_type_t = 5;
#[doc = "<MCPWMXA = compliment of rising edge delay,  MCPWMXB = falling edge delay"]
pub const mcpwm_deadtime_type_t_MCPWM_ACTIVE_LOW_COMPLIMENT_MODE: mcpwm_deadtime_type_t = 6;
#[doc = "<MCPWMXA = MCPWMXB = rising edge delay as well as falling edge delay, generated from MCPWMXA"]
pub const mcpwm_deadtime_type_t_MCPWM_ACTIVE_RED_FED_FROM_PWMXA: mcpwm_deadtime_type_t = 7;
#[doc = "<MCPWMXA = MCPWMXB = rising edge delay as well as falling edge delay, generated from MCPWMXB"]
pub const mcpwm_deadtime_type_t_MCPWM_ACTIVE_RED_FED_FROM_PWMXB: mcpwm_deadtime_type_t = 8;
pub const mcpwm_deadtime_type_t_MCPWM_DEADTIME_TYPE_MAX: mcpwm_deadtime_type_t = 9;
#[doc = " @brief MCPWM deadtime types, used to generate deadtime, RED refers to rising edge delay and FED refers to falling edge delay"]
pub type mcpwm_deadtime_type_t = c_types::c_uint;
#[doc = "<Select SYNC0 as input"]
pub const mcpwm_sync_signal_t_MCPWM_SELECT_SYNC0: mcpwm_sync_signal_t = 4;
#[doc = "<Select SYNC1 as input"]
pub const mcpwm_sync_signal_t_MCPWM_SELECT_SYNC1: mcpwm_sync_signal_t = 5;
#[doc = "<Select SYNC2 as input"]
pub const mcpwm_sync_signal_t_MCPWM_SELECT_SYNC2: mcpwm_sync_signal_t = 6;
#[doc = " @brief MCPWM select sync signal input"]
pub type mcpwm_sync_signal_t = c_types::c_uint;
#[doc = "<Capture the negative edge"]
pub const mcpwm_capture_on_edge_t_MCPWM_NEG_EDGE: mcpwm_capture_on_edge_t = 1;
#[doc = "<Capture the positive edge"]
pub const mcpwm_capture_on_edge_t_MCPWM_POS_EDGE: mcpwm_capture_on_edge_t = 2;
#[doc = " @brief MCPWM select capture starts from which edge"]
pub type mcpwm_capture_on_edge_t = c_types::c_uint;
#[doc = "<PWM0A output pin"]
pub const mcpwm_io_signals_t_MCPWM0A: mcpwm_io_signals_t = 0;
#[doc = "<PWM0B output pin"]
pub const mcpwm_io_signals_t_MCPWM0B: mcpwm_io_signals_t = 1;
#[doc = "<PWM1A output pin"]
pub const mcpwm_io_signals_t_MCPWM1A: mcpwm_io_signals_t = 2;
#[doc = "<PWM1B output pin"]
pub const mcpwm_io_signals_t_MCPWM1B: mcpwm_io_signals_t = 3;
#[doc = "<PWM2A output pin"]
pub const mcpwm_io_signals_t_MCPWM2A: mcpwm_io_signals_t = 4;
#[doc = "<PWM2B output pin"]
pub const mcpwm_io_signals_t_MCPWM2B: mcpwm_io_signals_t = 5;
#[doc = "<SYNC0  input pin"]
pub const mcpwm_io_signals_t_MCPWM_SYNC_0: mcpwm_io_signals_t = 6;
#[doc = "<SYNC1  input pin"]
pub const mcpwm_io_signals_t_MCPWM_SYNC_1: mcpwm_io_signals_t = 7;
#[doc = "<SYNC2  input pin"]
pub const mcpwm_io_signals_t_MCPWM_SYNC_2: mcpwm_io_signals_t = 8;
#[doc = "<FAULT0 input pin"]
pub const mcpwm_io_signals_t_MCPWM_FAULT_0: mcpwm_io_signals_t = 9;
#[doc = "<FAULT1 input pin"]
pub const mcpwm_io_signals_t_MCPWM_FAULT_1: mcpwm_io_signals_t = 10;
#[doc = "<FAULT2 input pin"]
pub const mcpwm_io_signals_t_MCPWM_FAULT_2: mcpwm_io_signals_t = 11;
#[doc = "<CAP0   input pin"]
pub const mcpwm_io_signals_t_MCPWM_CAP_0: mcpwm_io_signals_t = 84;
#[doc = "<CAP1   input pin"]
pub const mcpwm_io_signals_t_MCPWM_CAP_1: mcpwm_io_signals_t = 85;
#[doc = "<CAP2   input pin"]
pub const mcpwm_io_signals_t_MCPWM_CAP_2: mcpwm_io_signals_t = 86;
#[doc = " @brief IO signals for the MCPWM"]
#[doc = ""]
#[doc = "        - 6 MCPWM output pins that generate PWM signals"]
#[doc = "        - 3 MCPWM fault input pins to detect faults like overcurrent, overvoltage, etc."]
#[doc = "        - 3 MCPWM sync input pins to synchronize MCPWM outputs signals"]
#[doc = "        - 3 MCPWM capture input pins to gather feedback from controlled motors, using e.g. hall sensors"]
pub type mcpwm_io_signals_t = c_types::c_uint;
#[doc = " @brief MCPWM pin number for"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_pin_config_t {
    #[doc = "<MCPWM0A out pin"]
    pub mcpwm0a_out_num: c_types::c_int,
    #[doc = "<MCPWM0A out pin"]
    pub mcpwm0b_out_num: c_types::c_int,
    #[doc = "<MCPWM0A out pin"]
    pub mcpwm1a_out_num: c_types::c_int,
    #[doc = "<MCPWM0A out pin"]
    pub mcpwm1b_out_num: c_types::c_int,
    #[doc = "<MCPWM0A out pin"]
    pub mcpwm2a_out_num: c_types::c_int,
    #[doc = "<MCPWM0A out pin"]
    pub mcpwm2b_out_num: c_types::c_int,
    #[doc = "<SYNC0  in pin"]
    pub mcpwm_sync0_in_num: c_types::c_int,
    #[doc = "<SYNC1  in pin"]
    pub mcpwm_sync1_in_num: c_types::c_int,
    #[doc = "<SYNC2  in pin"]
    pub mcpwm_sync2_in_num: c_types::c_int,
    #[doc = "<FAULT0 in pin"]
    pub mcpwm_fault0_in_num: c_types::c_int,
    #[doc = "<FAULT1 in pin"]
    pub mcpwm_fault1_in_num: c_types::c_int,
    #[doc = "<FAULT2 in pin"]
    pub mcpwm_fault2_in_num: c_types::c_int,
    #[doc = "<CAP0   in pin"]
    pub mcpwm_cap0_in_num: c_types::c_int,
    #[doc = "<CAP1   in pin"]
    pub mcpwm_cap1_in_num: c_types::c_int,
    #[doc = "<CAP2   in pin"]
    pub mcpwm_cap2_in_num: c_types::c_int,
}
#[doc = "<MCPWM unit0 selected"]
pub const mcpwm_unit_t_MCPWM_UNIT_0: mcpwm_unit_t = 0;
#[doc = "<MCPWM unit1 selected"]
pub const mcpwm_unit_t_MCPWM_UNIT_1: mcpwm_unit_t = 1;
#[doc = "<Num of MCPWM units on ESP32"]
pub const mcpwm_unit_t_MCPWM_UNIT_MAX: mcpwm_unit_t = 2;
#[doc = " @brief Select MCPWM unit"]
pub type mcpwm_unit_t = c_types::c_uint;
#[doc = "<Select MCPWM timer0"]
pub const mcpwm_timer_t_MCPWM_TIMER_0: mcpwm_timer_t = 0;
#[doc = "<Select MCPWM timer1"]
pub const mcpwm_timer_t_MCPWM_TIMER_1: mcpwm_timer_t = 1;
#[doc = "<Select MCPWM timer2"]
pub const mcpwm_timer_t_MCPWM_TIMER_2: mcpwm_timer_t = 2;
#[doc = "<Num of MCPWM timers on ESP32"]
pub const mcpwm_timer_t_MCPWM_TIMER_MAX: mcpwm_timer_t = 3;
#[doc = " @brief Select MCPWM timer"]
pub type mcpwm_timer_t = c_types::c_uint;
#[doc = "<Select MCPWMXA, where 'X' is operator number"]
pub const mcpwm_generator_t_MCPWM_GEN_A: mcpwm_generator_t = 0;
#[doc = "<Select MCPWMXB, where 'X' is operator number"]
pub const mcpwm_generator_t_MCPWM_GEN_B: mcpwm_generator_t = 1;
#[doc = "<Num of generators to each operator of MCPWM"]
pub const mcpwm_generator_t_MCPWM_GEN_MAX: mcpwm_generator_t = 2;
#[doc = " @brief Select MCPWM operator"]
pub type mcpwm_generator_t = c_types::c_uint;
pub use self::mcpwm_generator_t as mcpwm_operator_t;
#[doc = "<Enable oneshot mode"]
pub const mcpwm_carrier_os_t_MCPWM_ONESHOT_MODE_DIS: mcpwm_carrier_os_t = 0;
#[doc = "<Disable oneshot mode"]
pub const mcpwm_carrier_os_t_MCPWM_ONESHOT_MODE_EN: mcpwm_carrier_os_t = 1;
#[doc = " @brief MCPWM carrier oneshot mode, in this mode the width of the first pulse of carrier can be programmed"]
pub type mcpwm_carrier_os_t = c_types::c_uint;
#[doc = "<Enable  carrier output inversion"]
pub const mcpwm_carrier_out_ivt_t_MCPWM_CARRIER_OUT_IVT_DIS: mcpwm_carrier_out_ivt_t = 0;
#[doc = "<Disable carrier output inversion"]
pub const mcpwm_carrier_out_ivt_t_MCPWM_CARRIER_OUT_IVT_EN: mcpwm_carrier_out_ivt_t = 1;
#[doc = " @brief MCPWM carrier output inversion, high frequency carrier signal active with MCPWM signal is high"]
pub type mcpwm_carrier_out_ivt_t = c_types::c_uint;
#[doc = "<Select F0 as input"]
pub const mcpwm_fault_signal_t_MCPWM_SELECT_F0: mcpwm_fault_signal_t = 0;
#[doc = "<Select F1 as input"]
pub const mcpwm_fault_signal_t_MCPWM_SELECT_F1: mcpwm_fault_signal_t = 1;
#[doc = "<Select F2 as input"]
pub const mcpwm_fault_signal_t_MCPWM_SELECT_F2: mcpwm_fault_signal_t = 2;
#[doc = " @brief MCPWM select fault signal input"]
pub type mcpwm_fault_signal_t = c_types::c_uint;
#[doc = "<Fault condition occurs when fault input signal goes from high to low, currently not supported"]
pub const mcpwm_fault_input_level_t_MCPWM_LOW_LEVEL_TGR: mcpwm_fault_input_level_t = 0;
#[doc = "<Fault condition occurs when fault input signal goes low to high"]
pub const mcpwm_fault_input_level_t_MCPWM_HIGH_LEVEL_TGR: mcpwm_fault_input_level_t = 1;
#[doc = " @brief MCPWM select triggering level of fault signal"]
pub type mcpwm_fault_input_level_t = c_types::c_uint;
#[doc = " @deprecated MCPWM select action to be taken on MCPWMXA when fault occurs"]
pub use self::mcpwm_output_action_t as mcpwm_action_on_pwmxa_t;
#[doc = " @deprecated MCPWM select action to be taken on MCPWMXB when fault occurs"]
pub use self::mcpwm_output_action_t as mcpwm_action_on_pwmxb_t;
#[doc = "<Select CAP0 as input"]
pub const mcpwm_capture_signal_t_MCPWM_SELECT_CAP0: mcpwm_capture_signal_t = 0;
#[doc = "<Select CAP1 as input"]
pub const mcpwm_capture_signal_t_MCPWM_SELECT_CAP1: mcpwm_capture_signal_t = 1;
#[doc = "<Select CAP2 as input"]
pub const mcpwm_capture_signal_t_MCPWM_SELECT_CAP2: mcpwm_capture_signal_t = 2;
#[doc = " @brief MCPWM select capture signal input"]
pub type mcpwm_capture_signal_t = c_types::c_uint;
#[doc = " @brief MCPWM config structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_config_t {
    #[doc = "<Set frequency of MCPWM in Hz"]
    pub frequency: u32,
    #[doc = "<Set % duty cycle for operator a(MCPWMXA), i.e for 62.3% duty cycle, duty_a = 62.3"]
    pub cmpr_a: f32,
    #[doc = "<Set % duty cycle for operator b(MCPWMXB), i.e for 48% duty cycle, duty_b = 48.0"]
    pub cmpr_b: f32,
    #[doc = "<Set type of duty cycle"]
    pub duty_mode: mcpwm_duty_type_t,
    #[doc = "<Set  type of MCPWM counter"]
    pub counter_mode: mcpwm_counter_type_t,
}
#[doc = " @brief MCPWM config carrier structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcpwm_carrier_config_t {
    #[doc = "<Set carrier period = (carrier_period + 1)*800ns, carrier_period should be < 16"]
    pub carrier_period: u8,
    #[doc = "<Set carrier duty cycle, carrier_duty should be less than 8 (increment every 12.5%)"]
    pub carrier_duty: u8,
    #[doc = "<Set pulse width of first pulse in one shot mode = (carrier period)*(pulse_width_in_os + 1), should be less then 16"]
    pub pulse_width_in_os: u8,
    #[doc = "<Enable or disable carrier oneshot mode"]
    pub carrier_os_mode: mcpwm_carrier_os_t,
    #[doc = "<Invert output of carrier"]
    pub carrier_ivt_mode: mcpwm_carrier_out_ivt_t,
}
extern "C" {
    #[doc = " @brief This function initializes each gpio signal for MCPWM"]
    #[doc = "        @note"]
    #[doc = "        This function initializes one gpio at a time."]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param io_signal set MCPWM signals, each MCPWM unit has 6 output(MCPWMXA, MCPWMXB) and 9 input(SYNC_X, FAULT_X, CAP_X)"]
    #[doc = "                  'X' is timer_num(0-2)"]
    #[doc = " @param gpio_num set this to configure gpio for MCPWM, if you want to use gpio16, gpio_num = 16"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_gpio_init(
        mcpwm_num: mcpwm_unit_t,
        io_signal: mcpwm_io_signals_t,
        gpio_num: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize MCPWM gpio structure"]
    #[doc = "        @note"]
    #[doc = "        This function can be used to initialize more then one gpio at a time."]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param mcpwm_pin MCPWM pin structure"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_set_pin(
        mcpwm_num: mcpwm_unit_t,
        mcpwm_pin: *const mcpwm_pin_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize MCPWM parameters"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers."]
    #[doc = " @param mcpwm_conf configure structure mcpwm_config_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_init(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        mcpwm_conf: *const mcpwm_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set frequency(in Hz) of MCPWM timer"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param frequency set the frequency in Hz of each timer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_set_frequency(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        frequency: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set duty cycle of each operator(MCPWMXA/MCPWMXB)"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param gen set the generator(MCPWMXA/MCPWMXB), 'X' is operator number selected"]
    #[doc = " @param duty set duty cycle in %(i.e for 62.3% duty cycle, duty = 62.3) of each operator"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_set_duty(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        gen: mcpwm_generator_t,
        duty: f32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set duty cycle of each operator(MCPWMXA/MCPWMXB) in us"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param gen set the generator(MCPWMXA/MCPWMXB), 'x' is operator number selected"]
    #[doc = " @param duty_in_us set duty value in microseconds of each operator"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_set_duty_in_us(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        gen: mcpwm_generator_t,
        duty_in_us: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set duty either active high or active low(out of phase/inverted)"]
    #[doc = "        @note"]
    #[doc = "        Call this function every time after mcpwm_set_signal_high or mcpwm_set_signal_low to resume with previously set duty cycle"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param gen set the generator(MCPWMXA/MCPWMXB), 'x' is operator number selected"]
    #[doc = " @param duty_type set active low or active high duty type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_set_duty_type(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        gen: mcpwm_generator_t,
        duty_type: mcpwm_duty_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get frequency of timer"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - frequency of timer"]
    pub fn mcpwm_get_frequency(mcpwm_num: mcpwm_unit_t, timer_num: mcpwm_timer_t) -> u32;
}
extern "C" {
    #[doc = " @brief Get duty cycle of each operator"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param gen set the generator(MCPWMXA/MCPWMXB), 'x' is operator number selected"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - duty cycle in % of each operator(56.7 means duty is 56.7%)"]
    pub fn mcpwm_get_duty(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        gen: mcpwm_operator_t,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Use this function to set MCPWM signal high"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param gen set the operator(MCPWMXA/MCPWMXB), 'x' is timer number selected"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_set_signal_high(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        gen: mcpwm_generator_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Use this function to set MCPWM signal low"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param gen set the operator(MCPWMXA/MCPWMXB), 'x' is timer number selected"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_set_signal_low(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        gen: mcpwm_generator_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start MCPWM signal on timer 'x'"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_start(mcpwm_num: mcpwm_unit_t, timer_num: mcpwm_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start MCPWM signal on timer 'x'"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_stop(mcpwm_num: mcpwm_unit_t, timer_num: mcpwm_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Initialize carrier configuration"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param carrier_conf configure structure mcpwm_carrier_config_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_init(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        carrier_conf: *const mcpwm_carrier_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable MCPWM carrier submodule, for respective timer"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_enable(mcpwm_num: mcpwm_unit_t, timer_num: mcpwm_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable MCPWM carrier submodule, for respective timer"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_disable(mcpwm_num: mcpwm_unit_t, timer_num: mcpwm_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set period of carrier"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param carrier_period set the carrier period of each timer, carrier period = (carrier_period + 1)*800ns"]
    #[doc = "                    (carrier_period <= 15)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_set_period(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        carrier_period: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set duty_cycle of carrier"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param carrier_duty set duty_cycle of carrier , carrier duty cycle = carrier_duty*12.5%"]
    #[doc = "                  (chop_duty <= 7)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_set_duty_cycle(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        carrier_duty: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable and set width of first pulse in carrier oneshot mode"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param pulse_width set pulse width of first pulse in oneshot mode, width = (carrier period)*(pulse_width +1)"]
    #[doc = "                    (pulse_width <= 15)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_oneshot_mode_enable(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        pulse_width: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable oneshot mode, width of first pulse = carrier period"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_oneshot_mode_disable(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable carrier output inversion"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param carrier_ivt_mode enable or disable carrier output inversion"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_carrier_output_invert(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        carrier_ivt_mode: mcpwm_carrier_out_ivt_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable and initialize deadtime for each MCPWM timer"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param dt_mode set deadtime mode"]
    #[doc = " @param red set rising edge delay = red*100ns"]
    #[doc = " @param fed set rising edge delay = fed*100ns"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_deadtime_enable(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        dt_mode: mcpwm_deadtime_type_t,
        red: u32,
        fed: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable deadtime on MCPWM timer"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_deadtime_disable(mcpwm_num: mcpwm_unit_t, timer_num: mcpwm_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize fault submodule, currently low level triggering is not supported"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param intput_level set fault signal level, which will cause fault to occur"]
    #[doc = " @param fault_sig set the fault pin, which needs to be enabled"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_fault_init(
        mcpwm_num: mcpwm_unit_t,
        intput_level: mcpwm_fault_input_level_t,
        fault_sig: mcpwm_fault_signal_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set oneshot mode on fault detection, once fault occur in oneshot mode reset is required to resume MCPWM signals"]
    #[doc = "        @note"]
    #[doc = "        currently low level triggering is not supported"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param fault_sig set the fault pin, which needs to be enabled for oneshot mode"]
    #[doc = " @param action_on_pwmxa action to be taken on MCPWMXA when fault occurs, either no change or high or low or toggle"]
    #[doc = " @param action_on_pwmxb action to be taken on MCPWMXB when fault occurs, either no change or high or low or toggle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_fault_set_oneshot_mode(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        fault_sig: mcpwm_fault_signal_t,
        action_on_pwmxa: mcpwm_output_action_t,
        action_on_pwmxb: mcpwm_output_action_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set cycle-by-cycle mode on fault detection, once fault occur in cyc mode MCPWM signal resumes as soon as fault signal becomes inactive"]
    #[doc = "        @note"]
    #[doc = "        currently low level triggering is not supported"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param fault_sig set the fault pin, which needs to be enabled for cyc mode"]
    #[doc = " @param action_on_pwmxa action to be taken on MCPWMXA when fault occurs, either no change or high or low or toggle"]
    #[doc = " @param action_on_pwmxb action to be taken on MCPWMXB when fault occurs, either no change or high or low or toggle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_fault_set_cyc_mode(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        fault_sig: mcpwm_fault_signal_t,
        action_on_pwmxa: mcpwm_output_action_t,
        action_on_pwmxb: mcpwm_output_action_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable fault signal"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param fault_sig fault pin, which needs to be disabled"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_fault_deinit(
        mcpwm_num: mcpwm_unit_t,
        fault_sig: mcpwm_fault_signal_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize capture submodule"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param cap_edge set capture edge, BIT(0) - negative edge, BIT(1) - positive edge"]
    #[doc = " @param cap_sig capture pin, which needs to be enabled"]
    #[doc = " @param num_of_pulse count time between rising/falling edge between 2 *(pulses mentioned), counter uses APB_CLK"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_capture_enable(
        mcpwm_num: mcpwm_unit_t,
        cap_sig: mcpwm_capture_signal_t,
        cap_edge: mcpwm_capture_on_edge_t,
        num_of_pulse: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable capture signal"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param cap_sig capture pin, which needs to be disabled"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_capture_disable(
        mcpwm_num: mcpwm_unit_t,
        cap_sig: mcpwm_capture_signal_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get capture value"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param cap_sig capture pin on which value is to be measured"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     Captured value"]
    pub fn mcpwm_capture_signal_get_value(
        mcpwm_num: mcpwm_unit_t,
        cap_sig: mcpwm_capture_signal_t,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Get edge of capture signal"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param cap_sig capture pin of whose edge is to be determined"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     Capture signal edge: 1 - positive edge, 2 - negtive edge"]
    pub fn mcpwm_capture_signal_get_edge(
        mcpwm_num: mcpwm_unit_t,
        cap_sig: mcpwm_capture_signal_t,
    ) -> u32;
}
extern "C" {
    #[doc = " @brief Initialize sync submodule"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = " @param sync_sig set the synchronization pin, which needs to be enabled"]
    #[doc = " @param phase_val phase value in 1/1000 (for 86.7%, phase_val = 867) which timer moves to on sync signal"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_sync_enable(
        mcpwm_num: mcpwm_unit_t,
        timer_num: mcpwm_timer_t,
        sync_sig: mcpwm_sync_signal_t,
        phase_val: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable sync submodule on given timer"]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param timer_num set timer number(0-2) of MCPWM, each MCPWM unit has 3 timers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn mcpwm_sync_disable(mcpwm_num: mcpwm_unit_t, timer_num: mcpwm_timer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register MCPWM interrupt handler, the handler is an ISR."]
    #[doc = "        the handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @param mcpwm_num set MCPWM unit(0-1)"]
    #[doc = " @param fn interrupt handler function."]
    #[doc = " @param arg user-supplied argument passed to the handler function."]
    #[doc = " @param intr_alloc_flags flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. see esp_intr_alloc.h for more info."]
    #[doc = " @param handle pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Function pointer error."]
    pub fn mcpwm_isr_register(
        mcpwm_num: mcpwm_unit_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
#[doc = " @brief PCNT port number, the max port number is (PCNT_PORT_MAX - 1)."]
pub type pcnt_port_t = c_types::c_int;
#[doc = " @brief Selection of all available PCNT units"]
pub type pcnt_unit_t = c_types::c_int;
#[doc = "< Control mode: won't change counter mode"]
pub const pcnt_ctrl_mode_t_PCNT_MODE_KEEP: pcnt_ctrl_mode_t = 0;
#[doc = "< Control mode: invert counter mode(increase -> decrease, decrease -> increase)"]
pub const pcnt_ctrl_mode_t_PCNT_MODE_REVERSE: pcnt_ctrl_mode_t = 1;
#[doc = "< Control mode: Inhibit counter(counter value will not change in this condition)"]
pub const pcnt_ctrl_mode_t_PCNT_MODE_DISABLE: pcnt_ctrl_mode_t = 2;
pub const pcnt_ctrl_mode_t_PCNT_MODE_MAX: pcnt_ctrl_mode_t = 3;
#[doc = " @brief Selection of available modes that determine the counter's action depending on the state of the control signal's input GPIO"]
#[doc = " @note  Configuration covers two actions, one for high, and one for low level on the control input"]
pub type pcnt_ctrl_mode_t = c_types::c_uint;
#[doc = "< Counter mode: Inhibit counter(counter value will not change in this condition)"]
pub const pcnt_count_mode_t_PCNT_COUNT_DIS: pcnt_count_mode_t = 0;
#[doc = "< Counter mode: Increase counter value"]
pub const pcnt_count_mode_t_PCNT_COUNT_INC: pcnt_count_mode_t = 1;
#[doc = "< Counter mode: Decrease counter value"]
pub const pcnt_count_mode_t_PCNT_COUNT_DEC: pcnt_count_mode_t = 2;
pub const pcnt_count_mode_t_PCNT_COUNT_MAX: pcnt_count_mode_t = 3;
#[doc = " @brief Selection of available modes that determine the counter's action on the edge of the pulse signal's input GPIO"]
#[doc = " @note  Configuration covers two actions, one for positive, and one for negative edge on the pulse input"]
pub type pcnt_count_mode_t = c_types::c_uint;
#[doc = "< PCNT channel 0"]
pub const pcnt_channel_t_PCNT_CHANNEL_0: pcnt_channel_t = 0;
#[doc = "< PCNT channel 1"]
pub const pcnt_channel_t_PCNT_CHANNEL_1: pcnt_channel_t = 1;
pub const pcnt_channel_t_PCNT_CHANNEL_MAX: pcnt_channel_t = 2;
#[doc = " @brief Selection of channels available for a single PCNT unit"]
pub type pcnt_channel_t = c_types::c_uint;
#[doc = "< PCNT watch point event: threshold1 value event"]
pub const pcnt_evt_type_t_PCNT_EVT_THRES_1: pcnt_evt_type_t = 4;
#[doc = "< PCNT watch point event: threshold0 value event"]
pub const pcnt_evt_type_t_PCNT_EVT_THRES_0: pcnt_evt_type_t = 8;
#[doc = "< PCNT watch point event: Minimum counter value"]
pub const pcnt_evt_type_t_PCNT_EVT_L_LIM: pcnt_evt_type_t = 16;
#[doc = "< PCNT watch point event: Maximum counter value"]
pub const pcnt_evt_type_t_PCNT_EVT_H_LIM: pcnt_evt_type_t = 32;
#[doc = "< PCNT watch point event: counter value zero event"]
pub const pcnt_evt_type_t_PCNT_EVT_ZERO: pcnt_evt_type_t = 64;
pub const pcnt_evt_type_t_PCNT_EVT_MAX: pcnt_evt_type_t = 65;
#[doc = " @brief Selection of counter's events the may trigger an interrupt"]
pub type pcnt_evt_type_t = c_types::c_uint;
#[doc = " @brief Pulse Counter configuration for a single channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_config_t {
    #[doc = "< Pulse input GPIO number, if you want to use GPIO16, enter pulse_gpio_num = 16, a negative value will be ignored"]
    pub pulse_gpio_num: c_types::c_int,
    #[doc = "< Control signal input GPIO number, a negative value will be ignored"]
    pub ctrl_gpio_num: c_types::c_int,
    #[doc = "< PCNT low control mode"]
    pub lctrl_mode: pcnt_ctrl_mode_t,
    #[doc = "< PCNT high control mode"]
    pub hctrl_mode: pcnt_ctrl_mode_t,
    #[doc = "< PCNT positive edge count mode"]
    pub pos_mode: pcnt_count_mode_t,
    #[doc = "< PCNT negative edge count mode"]
    pub neg_mode: pcnt_count_mode_t,
    #[doc = "< Maximum counter value"]
    pub counter_h_lim: i16,
    #[doc = "< Minimum counter value"]
    pub counter_l_lim: i16,
    #[doc = "< PCNT unit number"]
    pub unit: pcnt_unit_t,
    #[doc = "< the PCNT channel"]
    pub channel: pcnt_channel_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcnt_dev_s {
    pub conf_unit: [pcnt_dev_s__bindgen_ty_1; 8usize],
    pub cnt_unit: [pcnt_dev_s__bindgen_ty_2; 8usize],
    pub int_raw: pcnt_dev_s__bindgen_ty_3,
    pub int_st: pcnt_dev_s__bindgen_ty_4,
    pub int_ena: pcnt_dev_s__bindgen_ty_5,
    pub int_clr: pcnt_dev_s__bindgen_ty_6,
    pub status_unit: [pcnt_dev_s__bindgen_ty_7; 8usize],
    pub ctrl: pcnt_dev_s__bindgen_ty_8,
    pub reserved_b4: u32,
    pub reserved_b8: u32,
    pub reserved_bc: u32,
    pub reserved_c0: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub reserved_f0: u32,
    pub reserved_f4: u32,
    pub reserved_f8: u32,
    pub date: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_1 {
    pub conf0: pcnt_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub conf1: pcnt_dev_s__bindgen_ty_1__bindgen_ty_2,
    pub conf2: pcnt_dev_s__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl pcnt_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn filter_thres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_filter_thres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thr_zero_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thr_zero_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thr_h_lim_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thr_h_lim_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thr_l_lim_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thr_l_lim_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thr_thres0_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thr_thres0_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thr_thres1_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thr_thres1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_neg_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_neg_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_pos_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_pos_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_hctrl_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_hctrl_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_lctrl_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_lctrl_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_neg_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_neg_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_pos_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_pos_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_hctrl_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_hctrl_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_lctrl_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_lctrl_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        filter_thres: u32,
        filter_en: u32,
        thr_zero_en: u32,
        thr_h_lim_en: u32,
        thr_l_lim_en: u32,
        thr_thres0_en: u32,
        thr_thres1_en: u32,
        ch0_neg_mode: u32,
        ch0_pos_mode: u32,
        ch0_hctrl_mode: u32,
        ch0_lctrl_mode: u32,
        ch1_neg_mode: u32,
        ch1_pos_mode: u32,
        ch1_hctrl_mode: u32,
        ch1_lctrl_mode: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let filter_thres: u32 = unsafe { ::core::mem::transmute(filter_thres) };
            filter_thres as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let filter_en: u32 = unsafe { ::core::mem::transmute(filter_en) };
            filter_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let thr_zero_en: u32 = unsafe { ::core::mem::transmute(thr_zero_en) };
            thr_zero_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let thr_h_lim_en: u32 = unsafe { ::core::mem::transmute(thr_h_lim_en) };
            thr_h_lim_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let thr_l_lim_en: u32 = unsafe { ::core::mem::transmute(thr_l_lim_en) };
            thr_l_lim_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let thr_thres0_en: u32 = unsafe { ::core::mem::transmute(thr_thres0_en) };
            thr_thres0_en as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let thr_thres1_en: u32 = unsafe { ::core::mem::transmute(thr_thres1_en) };
            thr_thres1_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ch0_neg_mode: u32 = unsafe { ::core::mem::transmute(ch0_neg_mode) };
            ch0_neg_mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let ch0_pos_mode: u32 = unsafe { ::core::mem::transmute(ch0_pos_mode) };
            ch0_pos_mode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let ch0_hctrl_mode: u32 = unsafe { ::core::mem::transmute(ch0_hctrl_mode) };
            ch0_hctrl_mode as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let ch0_lctrl_mode: u32 = unsafe { ::core::mem::transmute(ch0_lctrl_mode) };
            ch0_lctrl_mode as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let ch1_neg_mode: u32 = unsafe { ::core::mem::transmute(ch1_neg_mode) };
            ch1_neg_mode as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let ch1_pos_mode: u32 = unsafe { ::core::mem::transmute(ch1_pos_mode) };
            ch1_pos_mode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let ch1_hctrl_mode: u32 = unsafe { ::core::mem::transmute(ch1_hctrl_mode) };
            ch1_hctrl_mode as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let ch1_lctrl_mode: u32 = unsafe { ::core::mem::transmute(ch1_lctrl_mode) };
            ch1_lctrl_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_1__bindgen_ty_2 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl pcnt_dev_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn cnt_thres0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thres0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thres1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thres1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_thres0: u32,
        cnt_thres1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let cnt_thres0: u32 = unsafe { ::core::mem::transmute(cnt_thres0) };
            cnt_thres0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let cnt_thres1: u32 = unsafe { ::core::mem::transmute(cnt_thres1) };
            cnt_thres1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_1__bindgen_ty_3 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl pcnt_dev_s__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn cnt_h_lim(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_h_lim(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_l_lim(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_l_lim(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_h_lim: u32,
        cnt_l_lim: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let cnt_h_lim: u32 = unsafe { ::core::mem::transmute(cnt_h_lim) };
            cnt_h_lim as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let cnt_l_lim: u32 = unsafe { ::core::mem::transmute(cnt_l_lim) };
            cnt_l_lim as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl pcnt_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn cnt_val(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_val(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_val: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let cnt_val: u32 = unsafe { ::core::mem::transmute(cnt_val) };
            cnt_val as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl pcnt_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn cnt_thr_event_u0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_thr_event_u0: u32,
        cnt_thr_event_u1: u32,
        cnt_thr_event_u2: u32,
        cnt_thr_event_u3: u32,
        cnt_thr_event_u4: u32,
        cnt_thr_event_u5: u32,
        cnt_thr_event_u6: u32,
        cnt_thr_event_u7: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnt_thr_event_u0: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u0) };
            cnt_thr_event_u0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnt_thr_event_u1: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u1) };
            cnt_thr_event_u1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnt_thr_event_u2: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u2) };
            cnt_thr_event_u2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnt_thr_event_u3: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u3) };
            cnt_thr_event_u3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cnt_thr_event_u4: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u4) };
            cnt_thr_event_u4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cnt_thr_event_u5: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u5) };
            cnt_thr_event_u5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cnt_thr_event_u6: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u6) };
            cnt_thr_event_u6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cnt_thr_event_u7: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u7) };
            cnt_thr_event_u7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl pcnt_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn cnt_thr_event_u0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_thr_event_u0: u32,
        cnt_thr_event_u1: u32,
        cnt_thr_event_u2: u32,
        cnt_thr_event_u3: u32,
        cnt_thr_event_u4: u32,
        cnt_thr_event_u5: u32,
        cnt_thr_event_u6: u32,
        cnt_thr_event_u7: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnt_thr_event_u0: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u0) };
            cnt_thr_event_u0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnt_thr_event_u1: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u1) };
            cnt_thr_event_u1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnt_thr_event_u2: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u2) };
            cnt_thr_event_u2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnt_thr_event_u3: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u3) };
            cnt_thr_event_u3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cnt_thr_event_u4: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u4) };
            cnt_thr_event_u4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cnt_thr_event_u5: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u5) };
            cnt_thr_event_u5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cnt_thr_event_u6: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u6) };
            cnt_thr_event_u6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cnt_thr_event_u7: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u7) };
            cnt_thr_event_u7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl pcnt_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn cnt_thr_event_u0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_thr_event_u0: u32,
        cnt_thr_event_u1: u32,
        cnt_thr_event_u2: u32,
        cnt_thr_event_u3: u32,
        cnt_thr_event_u4: u32,
        cnt_thr_event_u5: u32,
        cnt_thr_event_u6: u32,
        cnt_thr_event_u7: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnt_thr_event_u0: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u0) };
            cnt_thr_event_u0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnt_thr_event_u1: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u1) };
            cnt_thr_event_u1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnt_thr_event_u2: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u2) };
            cnt_thr_event_u2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnt_thr_event_u3: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u3) };
            cnt_thr_event_u3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cnt_thr_event_u4: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u4) };
            cnt_thr_event_u4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cnt_thr_event_u5: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u5) };
            cnt_thr_event_u5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cnt_thr_event_u6: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u6) };
            cnt_thr_event_u6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cnt_thr_event_u7: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u7) };
            cnt_thr_event_u7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl pcnt_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn cnt_thr_event_u0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_thr_event_u7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_thr_event_u7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_thr_event_u0: u32,
        cnt_thr_event_u1: u32,
        cnt_thr_event_u2: u32,
        cnt_thr_event_u3: u32,
        cnt_thr_event_u4: u32,
        cnt_thr_event_u5: u32,
        cnt_thr_event_u6: u32,
        cnt_thr_event_u7: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnt_thr_event_u0: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u0) };
            cnt_thr_event_u0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnt_thr_event_u1: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u1) };
            cnt_thr_event_u1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnt_thr_event_u2: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u2) };
            cnt_thr_event_u2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnt_thr_event_u3: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u3) };
            cnt_thr_event_u3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cnt_thr_event_u4: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u4) };
            cnt_thr_event_u4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cnt_thr_event_u5: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u5) };
            cnt_thr_event_u5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cnt_thr_event_u6: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u6) };
            cnt_thr_event_u6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cnt_thr_event_u7: u32 = unsafe { ::core::mem::transmute(cnt_thr_event_u7) };
            cnt_thr_event_u7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl pcnt_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn cnt_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn thres1_lat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thres1_lat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thres0_lat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thres0_lat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l_lim_lat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l_lim_lat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn h_lim_lat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_h_lim_lat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zero_lat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero_lat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_mode: u32,
        thres1_lat: u32,
        thres0_lat: u32,
        l_lim_lat: u32,
        h_lim_lat: u32,
        zero_lat: u32,
        reserved7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cnt_mode: u32 = unsafe { ::core::mem::transmute(cnt_mode) };
            cnt_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let thres1_lat: u32 = unsafe { ::core::mem::transmute(thres1_lat) };
            thres1_lat as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let thres0_lat: u32 = unsafe { ::core::mem::transmute(thres0_lat) };
            thres0_lat as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let l_lim_lat: u32 = unsafe { ::core::mem::transmute(l_lim_lat) };
            l_lim_lat as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let h_lim_lat: u32 = unsafe { ::core::mem::transmute(h_lim_lat) };
            h_lim_lat as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let zero_lat: u32 = unsafe { ::core::mem::transmute(zero_lat) };
            zero_lat as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pcnt_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: pcnt_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pcnt_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl pcnt_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn cnt_rst_u0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_rst_u1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_rst_u2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_rst_u3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_rst_u4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_rst_u5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_rst_u6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_rst_u7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_rst_u7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_pause_u7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_pause_u7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cnt_rst_u0: u32,
        cnt_pause_u0: u32,
        cnt_rst_u1: u32,
        cnt_pause_u1: u32,
        cnt_rst_u2: u32,
        cnt_pause_u2: u32,
        cnt_rst_u3: u32,
        cnt_pause_u3: u32,
        cnt_rst_u4: u32,
        cnt_pause_u4: u32,
        cnt_rst_u5: u32,
        cnt_pause_u5: u32,
        cnt_rst_u6: u32,
        cnt_pause_u6: u32,
        cnt_rst_u7: u32,
        cnt_pause_u7: u32,
        clk_en: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cnt_rst_u0: u32 = unsafe { ::core::mem::transmute(cnt_rst_u0) };
            cnt_rst_u0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cnt_pause_u0: u32 = unsafe { ::core::mem::transmute(cnt_pause_u0) };
            cnt_pause_u0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cnt_rst_u1: u32 = unsafe { ::core::mem::transmute(cnt_rst_u1) };
            cnt_rst_u1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cnt_pause_u1: u32 = unsafe { ::core::mem::transmute(cnt_pause_u1) };
            cnt_pause_u1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cnt_rst_u2: u32 = unsafe { ::core::mem::transmute(cnt_rst_u2) };
            cnt_rst_u2 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cnt_pause_u2: u32 = unsafe { ::core::mem::transmute(cnt_pause_u2) };
            cnt_pause_u2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cnt_rst_u3: u32 = unsafe { ::core::mem::transmute(cnt_rst_u3) };
            cnt_rst_u3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cnt_pause_u3: u32 = unsafe { ::core::mem::transmute(cnt_pause_u3) };
            cnt_pause_u3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cnt_rst_u4: u32 = unsafe { ::core::mem::transmute(cnt_rst_u4) };
            cnt_rst_u4 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cnt_pause_u4: u32 = unsafe { ::core::mem::transmute(cnt_pause_u4) };
            cnt_pause_u4 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cnt_rst_u5: u32 = unsafe { ::core::mem::transmute(cnt_rst_u5) };
            cnt_rst_u5 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let cnt_pause_u5: u32 = unsafe { ::core::mem::transmute(cnt_pause_u5) };
            cnt_pause_u5 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cnt_rst_u6: u32 = unsafe { ::core::mem::transmute(cnt_rst_u6) };
            cnt_rst_u6 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let cnt_pause_u6: u32 = unsafe { ::core::mem::transmute(cnt_pause_u6) };
            cnt_pause_u6 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let cnt_rst_u7: u32 = unsafe { ::core::mem::transmute(cnt_rst_u7) };
            cnt_rst_u7 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cnt_pause_u7: u32 = unsafe { ::core::mem::transmute(cnt_pause_u7) };
            cnt_pause_u7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type pcnt_dev_t = pcnt_dev_s;
extern "C" {
    pub static mut PCNT: pcnt_dev_t;
}
pub type pcnt_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Configure Pulse Counter unit"]
    #[doc = "        @note"]
    #[doc = "        This function will disable three events: PCNT_EVT_L_LIM, PCNT_EVT_H_LIM, PCNT_EVT_ZERO."]
    #[doc = ""]
    #[doc = " @param pcnt_config Pointer of Pulse Counter unit configure parameter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver already initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_unit_config(pcnt_config: *const pcnt_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get pulse counter value"]
    #[doc = ""]
    #[doc = " @param pcnt_unit  Pulse Counter unit number"]
    #[doc = " @param count Pointer to accept counter value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_get_counter_value(pcnt_unit: pcnt_unit_t, count: *mut i16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Pause PCNT counter of PCNT unit"]
    #[doc = ""]
    #[doc = " @param pcnt_unit PCNT unit number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_counter_pause(pcnt_unit: pcnt_unit_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Resume counting for PCNT counter"]
    #[doc = ""]
    #[doc = " @param pcnt_unit PCNT unit number, select from pcnt_unit_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_counter_resume(pcnt_unit: pcnt_unit_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear and reset PCNT counter value to zero"]
    #[doc = ""]
    #[doc = " @param  pcnt_unit PCNT unit number, select from pcnt_unit_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_counter_clear(pcnt_unit: pcnt_unit_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable PCNT interrupt for PCNT unit"]
    #[doc = "        @note"]
    #[doc = "        Each Pulse counter unit has five watch point events that share the same interrupt."]
    #[doc = "        Configure events with pcnt_event_enable() and pcnt_event_disable()"]
    #[doc = ""]
    #[doc = " @param pcnt_unit PCNT unit number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_intr_enable(pcnt_unit: pcnt_unit_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable PCNT interrupt for PCNT unit"]
    #[doc = ""]
    #[doc = " @param pcnt_unit PCNT unit number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_intr_disable(pcnt_unit: pcnt_unit_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable PCNT event of PCNT unit"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param evt_type Watch point event type."]
    #[doc = "                 All enabled events share the same interrupt (one interrupt per pulse counter unit)."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_event_enable(unit: pcnt_unit_t, evt_type: pcnt_evt_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable PCNT event of PCNT unit"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param evt_type Watch point event type."]
    #[doc = "                 All enabled events share the same interrupt (one interrupt per pulse counter unit)."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_event_disable(unit: pcnt_unit_t, evt_type: pcnt_evt_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set PCNT event value of PCNT unit"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param evt_type Watch point event type."]
    #[doc = "                 All enabled events share the same interrupt (one interrupt per pulse counter unit)."]
    #[doc = ""]
    #[doc = " @param value Counter value for PCNT event"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_set_event_value(
        unit: pcnt_unit_t,
        evt_type: pcnt_evt_type_t,
        value: i16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get PCNT event value of PCNT unit"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param evt_type Watch point event type."]
    #[doc = "                 All enabled events share the same interrupt (one interrupt per pulse counter unit)."]
    #[doc = " @param value Pointer to accept counter value for PCNT event"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_get_event_value(
        unit: pcnt_unit_t,
        evt_type: pcnt_evt_type_t,
        value: *mut i16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register PCNT interrupt handler, the handler is an ISR."]
    #[doc = "        The handler will be attached to the same CPU core that this function is running on."]
    #[doc = "        Please do not use pcnt_isr_service_install if this function was called."]
    #[doc = ""]
    #[doc = " @param fn Interrupt handler function."]
    #[doc = " @param arg Parameter for handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here. Calling esp_intr_free to unregister this ISR service if needed,"]
    #[doc = "        but only if the handle is not NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_FOUND Can not find the interrupt that matches the flags."]
    #[doc = "     - ESP_ERR_INVALID_ARG Function pointer error."]
    pub fn pcnt_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut pcnt_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure PCNT pulse signal input pin and control input pin"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param channel PCNT channel number"]
    #[doc = " @param pulse_io Pulse signal input GPIO"]
    #[doc = " @param ctrl_io Control signal input GPIO"]
    #[doc = ""]
    #[doc = " @note  Set the signal input to PCNT_PIN_NOT_USED if unused."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_set_pin(
        unit: pcnt_unit_t,
        channel: pcnt_channel_t,
        pulse_io: c_types::c_int,
        ctrl_io: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable PCNT input filter"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_filter_enable(unit: pcnt_unit_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable PCNT input filter"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_filter_disable(unit: pcnt_unit_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set PCNT filter value"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param filter_val PCNT signal filter value, counter in APB_CLK cycles."]
    #[doc = "        Any pulses lasting shorter than this will be ignored when the filter is enabled."]
    #[doc = "        @note"]
    #[doc = "        filter_val is a 10-bit value, so the maximum filter_val should be limited to 1023."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_set_filter_value(unit: pcnt_unit_t, filter_val: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get PCNT filter value"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param filter_val Pointer to accept PCNT filter value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_get_filter_value(unit: pcnt_unit_t, filter_val: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set PCNT counter mode"]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param channel PCNT channel number"]
    #[doc = " @param pos_mode Counter mode when detecting positive edge"]
    #[doc = " @param neg_mode Counter mode when detecting negative edge"]
    #[doc = " @param hctrl_mode Counter mode when control signal is high level"]
    #[doc = " @param lctrl_mode Counter mode when control signal is low level"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_set_mode(
        unit: pcnt_unit_t,
        channel: pcnt_channel_t,
        pos_mode: pcnt_count_mode_t,
        neg_mode: pcnt_count_mode_t,
        hctrl_mode: pcnt_ctrl_mode_t,
        lctrl_mode: pcnt_ctrl_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Add ISR handler for specified unit."]
    #[doc = ""]
    #[doc = " Call this function after using pcnt_isr_service_install() to"]
    #[doc = " install the PCNT driver's ISR handler service."]
    #[doc = ""]
    #[doc = " The ISR handlers do not need to be declared with IRAM_ATTR,"]
    #[doc = " unless you pass the ESP_INTR_FLAG_IRAM flag when allocating the"]
    #[doc = " ISR in pcnt_isr_service_install()."]
    #[doc = ""]
    #[doc = " This ISR handler will be called from an ISR. So there is a stack"]
    #[doc = " size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = " limit is smaller compared to a global PCNT interrupt handler due"]
    #[doc = " to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = " @param isr_handler Interrupt handler function."]
    #[doc = " @param args Parameter for handler function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_isr_handler_add(
        unit: pcnt_unit_t,
        isr_handler: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        args: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install PCNT ISR service."]
    #[doc = " @note We can manage different interrupt service for each unit."]
    #[doc = "       This function will use the default ISR handle service, Calling pcnt_isr_service_uninstall to"]
    #[doc = "       uninstall the default service if needed. Please do not use pcnt_isr_register if this function was called."]
    #[doc = ""]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_NO_MEM No memory to install this service"]
    #[doc = "     - ESP_ERR_INVALID_STATE ISR service already installed"]
    pub fn pcnt_isr_service_install(intr_alloc_flags: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall PCNT ISR service, freeing related resources."]
    pub fn pcnt_isr_service_uninstall();
}
extern "C" {
    #[doc = " @brief Delete ISR handler for specified unit."]
    #[doc = ""]
    #[doc = " @param unit PCNT unit number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE pcnt driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pcnt_isr_handler_remove(unit: pcnt_unit_t) -> esp_err_t;
}
#[doc = "< RMT channel number 0"]
pub const rmt_channel_id_t_RMT_CHANNEL_0: rmt_channel_id_t = 0;
#[doc = "< RMT channel number 1"]
pub const rmt_channel_id_t_RMT_CHANNEL_1: rmt_channel_id_t = 1;
#[doc = "< RMT channel number 2"]
pub const rmt_channel_id_t_RMT_CHANNEL_2: rmt_channel_id_t = 2;
#[doc = "< RMT channel number 3"]
pub const rmt_channel_id_t_RMT_CHANNEL_3: rmt_channel_id_t = 3;
#[doc = "< RMT channel number 4"]
pub const rmt_channel_id_t_RMT_CHANNEL_4: rmt_channel_id_t = 4;
#[doc = "< RMT channel number 5"]
pub const rmt_channel_id_t_RMT_CHANNEL_5: rmt_channel_id_t = 5;
#[doc = "< RMT channel number 6"]
pub const rmt_channel_id_t_RMT_CHANNEL_6: rmt_channel_id_t = 6;
#[doc = "< RMT channel number 7"]
pub const rmt_channel_id_t_RMT_CHANNEL_7: rmt_channel_id_t = 7;
#[doc = "< Number of RMT channels"]
pub const rmt_channel_id_t_RMT_CHANNEL_MAX: rmt_channel_id_t = 8;
#[doc = " @brief RMT channel ID"]
pub type rmt_channel_id_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_dev_s {
    pub data_ch: [u32; 8usize],
    pub conf_ch: [rmt_dev_s__bindgen_ty_1; 8usize],
    pub status_ch: [u32; 8usize],
    pub apb_mem_addr_ch: [u32; 8usize],
    pub int_raw: rmt_dev_s__bindgen_ty_2,
    pub int_st: rmt_dev_s__bindgen_ty_3,
    pub int_ena: rmt_dev_s__bindgen_ty_4,
    pub int_clr: rmt_dev_s__bindgen_ty_5,
    pub carrier_duty_ch: [rmt_dev_s__bindgen_ty_6; 8usize],
    pub tx_lim_ch: [rmt_dev_s__bindgen_ty_7; 8usize],
    pub apb_conf: rmt_dev_s__bindgen_ty_8,
    pub reserved_f4: u32,
    pub reserved_f8: u32,
    pub date: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_1 {
    pub conf0: rmt_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub conf1: rmt_dev_s__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rmt_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn div_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_div_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_thres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_idle_thres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mem_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn carrier_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_carrier_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn carrier_out_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_carrier_out_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        div_cnt: u32,
        idle_thres: u32,
        mem_size: u32,
        carrier_en: u32,
        carrier_out_lv: u32,
        mem_pd: u32,
        clk_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let div_cnt: u32 = unsafe { ::core::mem::transmute(div_cnt) };
            div_cnt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let idle_thres: u32 = unsafe { ::core::mem::transmute(idle_thres) };
            idle_thres as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let mem_size: u32 = unsafe { ::core::mem::transmute(mem_size) };
            mem_size as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let carrier_en: u32 = unsafe { ::core::mem::transmute(carrier_en) };
            carrier_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let carrier_out_lv: u32 = unsafe { ::core::mem::transmute(carrier_out_lv) };
            carrier_out_lv as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let mem_pd: u32 = unsafe { ::core::mem::transmute(mem_pd) };
            mem_pd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_1__bindgen_ty_2 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rmt_dev_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_wr_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_wr_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_rd_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_rd_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apb_mem_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apb_mem_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_conti_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_conti_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_filter_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_filter_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_filter_thres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_filter_thres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_cnt_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_cnt_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_always_on(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_always_on(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_out_lv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_out_lv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_out_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_out_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_start: u32,
        rx_en: u32,
        mem_wr_rst: u32,
        mem_rd_rst: u32,
        apb_mem_rst: u32,
        mem_owner: u32,
        tx_conti_mode: u32,
        rx_filter_en: u32,
        rx_filter_thres: u32,
        ref_cnt_rst: u32,
        ref_always_on: u32,
        idle_out_lv: u32,
        idle_out_en: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rx_en: u32 = unsafe { ::core::mem::transmute(rx_en) };
            rx_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mem_wr_rst: u32 = unsafe { ::core::mem::transmute(mem_wr_rst) };
            mem_wr_rst as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mem_rd_rst: u32 = unsafe { ::core::mem::transmute(mem_rd_rst) };
            mem_rd_rst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let apb_mem_rst: u32 = unsafe { ::core::mem::transmute(apb_mem_rst) };
            apb_mem_rst as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mem_owner: u32 = unsafe { ::core::mem::transmute(mem_owner) };
            mem_owner as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tx_conti_mode: u32 = unsafe { ::core::mem::transmute(tx_conti_mode) };
            tx_conti_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_filter_en: u32 = unsafe { ::core::mem::transmute(rx_filter_en) };
            rx_filter_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let rx_filter_thres: u32 = unsafe { ::core::mem::transmute(rx_filter_thres) };
            rx_filter_thres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ref_cnt_rst: u32 = unsafe { ::core::mem::transmute(ref_cnt_rst) };
            ref_cnt_rst as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ref_always_on: u32 = unsafe { ::core::mem::transmute(ref_always_on) };
            ref_always_on as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let idle_out_lv: u32 = unsafe { ::core::mem::transmute(idle_out_lv) };
            idle_out_lv as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let idle_out_en: u32 = unsafe { ::core::mem::transmute(idle_out_en) };
            idle_out_en as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rmt_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ch0_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ch0_tx_end: u32,
        ch0_rx_end: u32,
        ch0_err: u32,
        ch1_tx_end: u32,
        ch1_rx_end: u32,
        ch1_err: u32,
        ch2_tx_end: u32,
        ch2_rx_end: u32,
        ch2_err: u32,
        ch3_tx_end: u32,
        ch3_rx_end: u32,
        ch3_err: u32,
        ch4_tx_end: u32,
        ch4_rx_end: u32,
        ch4_err: u32,
        ch5_tx_end: u32,
        ch5_rx_end: u32,
        ch5_err: u32,
        ch6_tx_end: u32,
        ch6_rx_end: u32,
        ch6_err: u32,
        ch7_tx_end: u32,
        ch7_rx_end: u32,
        ch7_err: u32,
        ch0_tx_thr_event: u32,
        ch1_tx_thr_event: u32,
        ch2_tx_thr_event: u32,
        ch3_tx_thr_event: u32,
        ch4_tx_thr_event: u32,
        ch5_tx_thr_event: u32,
        ch6_tx_thr_event: u32,
        ch7_tx_thr_event: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ch0_tx_end: u32 = unsafe { ::core::mem::transmute(ch0_tx_end) };
            ch0_tx_end as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ch0_rx_end: u32 = unsafe { ::core::mem::transmute(ch0_rx_end) };
            ch0_rx_end as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ch0_err: u32 = unsafe { ::core::mem::transmute(ch0_err) };
            ch0_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ch1_tx_end: u32 = unsafe { ::core::mem::transmute(ch1_tx_end) };
            ch1_tx_end as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ch1_rx_end: u32 = unsafe { ::core::mem::transmute(ch1_rx_end) };
            ch1_rx_end as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ch1_err: u32 = unsafe { ::core::mem::transmute(ch1_err) };
            ch1_err as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ch2_tx_end: u32 = unsafe { ::core::mem::transmute(ch2_tx_end) };
            ch2_tx_end as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ch2_rx_end: u32 = unsafe { ::core::mem::transmute(ch2_rx_end) };
            ch2_rx_end as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ch2_err: u32 = unsafe { ::core::mem::transmute(ch2_err) };
            ch2_err as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ch3_tx_end: u32 = unsafe { ::core::mem::transmute(ch3_tx_end) };
            ch3_tx_end as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ch3_rx_end: u32 = unsafe { ::core::mem::transmute(ch3_rx_end) };
            ch3_rx_end as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ch3_err: u32 = unsafe { ::core::mem::transmute(ch3_err) };
            ch3_err as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ch4_tx_end: u32 = unsafe { ::core::mem::transmute(ch4_tx_end) };
            ch4_tx_end as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ch4_rx_end: u32 = unsafe { ::core::mem::transmute(ch4_rx_end) };
            ch4_rx_end as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ch4_err: u32 = unsafe { ::core::mem::transmute(ch4_err) };
            ch4_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ch5_tx_end: u32 = unsafe { ::core::mem::transmute(ch5_tx_end) };
            ch5_tx_end as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ch5_rx_end: u32 = unsafe { ::core::mem::transmute(ch5_rx_end) };
            ch5_rx_end as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ch5_err: u32 = unsafe { ::core::mem::transmute(ch5_err) };
            ch5_err as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ch6_tx_end: u32 = unsafe { ::core::mem::transmute(ch6_tx_end) };
            ch6_tx_end as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ch6_rx_end: u32 = unsafe { ::core::mem::transmute(ch6_rx_end) };
            ch6_rx_end as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ch6_err: u32 = unsafe { ::core::mem::transmute(ch6_err) };
            ch6_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ch7_tx_end: u32 = unsafe { ::core::mem::transmute(ch7_tx_end) };
            ch7_tx_end as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ch7_rx_end: u32 = unsafe { ::core::mem::transmute(ch7_rx_end) };
            ch7_rx_end as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ch7_err: u32 = unsafe { ::core::mem::transmute(ch7_err) };
            ch7_err as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ch0_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch0_tx_thr_event) };
            ch0_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ch1_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch1_tx_thr_event) };
            ch1_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ch2_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch2_tx_thr_event) };
            ch2_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let ch3_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch3_tx_thr_event) };
            ch3_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ch4_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch4_tx_thr_event) };
            ch4_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ch5_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch5_tx_thr_event) };
            ch5_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ch6_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch6_tx_thr_event) };
            ch6_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ch7_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch7_tx_thr_event) };
            ch7_tx_thr_event as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rmt_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn ch0_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ch0_tx_end: u32,
        ch0_rx_end: u32,
        ch0_err: u32,
        ch1_tx_end: u32,
        ch1_rx_end: u32,
        ch1_err: u32,
        ch2_tx_end: u32,
        ch2_rx_end: u32,
        ch2_err: u32,
        ch3_tx_end: u32,
        ch3_rx_end: u32,
        ch3_err: u32,
        ch4_tx_end: u32,
        ch4_rx_end: u32,
        ch4_err: u32,
        ch5_tx_end: u32,
        ch5_rx_end: u32,
        ch5_err: u32,
        ch6_tx_end: u32,
        ch6_rx_end: u32,
        ch6_err: u32,
        ch7_tx_end: u32,
        ch7_rx_end: u32,
        ch7_err: u32,
        ch0_tx_thr_event: u32,
        ch1_tx_thr_event: u32,
        ch2_tx_thr_event: u32,
        ch3_tx_thr_event: u32,
        ch4_tx_thr_event: u32,
        ch5_tx_thr_event: u32,
        ch6_tx_thr_event: u32,
        ch7_tx_thr_event: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ch0_tx_end: u32 = unsafe { ::core::mem::transmute(ch0_tx_end) };
            ch0_tx_end as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ch0_rx_end: u32 = unsafe { ::core::mem::transmute(ch0_rx_end) };
            ch0_rx_end as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ch0_err: u32 = unsafe { ::core::mem::transmute(ch0_err) };
            ch0_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ch1_tx_end: u32 = unsafe { ::core::mem::transmute(ch1_tx_end) };
            ch1_tx_end as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ch1_rx_end: u32 = unsafe { ::core::mem::transmute(ch1_rx_end) };
            ch1_rx_end as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ch1_err: u32 = unsafe { ::core::mem::transmute(ch1_err) };
            ch1_err as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ch2_tx_end: u32 = unsafe { ::core::mem::transmute(ch2_tx_end) };
            ch2_tx_end as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ch2_rx_end: u32 = unsafe { ::core::mem::transmute(ch2_rx_end) };
            ch2_rx_end as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ch2_err: u32 = unsafe { ::core::mem::transmute(ch2_err) };
            ch2_err as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ch3_tx_end: u32 = unsafe { ::core::mem::transmute(ch3_tx_end) };
            ch3_tx_end as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ch3_rx_end: u32 = unsafe { ::core::mem::transmute(ch3_rx_end) };
            ch3_rx_end as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ch3_err: u32 = unsafe { ::core::mem::transmute(ch3_err) };
            ch3_err as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ch4_tx_end: u32 = unsafe { ::core::mem::transmute(ch4_tx_end) };
            ch4_tx_end as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ch4_rx_end: u32 = unsafe { ::core::mem::transmute(ch4_rx_end) };
            ch4_rx_end as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ch4_err: u32 = unsafe { ::core::mem::transmute(ch4_err) };
            ch4_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ch5_tx_end: u32 = unsafe { ::core::mem::transmute(ch5_tx_end) };
            ch5_tx_end as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ch5_rx_end: u32 = unsafe { ::core::mem::transmute(ch5_rx_end) };
            ch5_rx_end as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ch5_err: u32 = unsafe { ::core::mem::transmute(ch5_err) };
            ch5_err as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ch6_tx_end: u32 = unsafe { ::core::mem::transmute(ch6_tx_end) };
            ch6_tx_end as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ch6_rx_end: u32 = unsafe { ::core::mem::transmute(ch6_rx_end) };
            ch6_rx_end as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ch6_err: u32 = unsafe { ::core::mem::transmute(ch6_err) };
            ch6_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ch7_tx_end: u32 = unsafe { ::core::mem::transmute(ch7_tx_end) };
            ch7_tx_end as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ch7_rx_end: u32 = unsafe { ::core::mem::transmute(ch7_rx_end) };
            ch7_rx_end as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ch7_err: u32 = unsafe { ::core::mem::transmute(ch7_err) };
            ch7_err as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ch0_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch0_tx_thr_event) };
            ch0_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ch1_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch1_tx_thr_event) };
            ch1_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ch2_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch2_tx_thr_event) };
            ch2_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let ch3_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch3_tx_thr_event) };
            ch3_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ch4_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch4_tx_thr_event) };
            ch4_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ch5_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch5_tx_thr_event) };
            ch5_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ch6_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch6_tx_thr_event) };
            ch6_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ch7_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch7_tx_thr_event) };
            ch7_tx_thr_event as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rmt_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn ch0_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ch0_tx_end: u32,
        ch0_rx_end: u32,
        ch0_err: u32,
        ch1_tx_end: u32,
        ch1_rx_end: u32,
        ch1_err: u32,
        ch2_tx_end: u32,
        ch2_rx_end: u32,
        ch2_err: u32,
        ch3_tx_end: u32,
        ch3_rx_end: u32,
        ch3_err: u32,
        ch4_tx_end: u32,
        ch4_rx_end: u32,
        ch4_err: u32,
        ch5_tx_end: u32,
        ch5_rx_end: u32,
        ch5_err: u32,
        ch6_tx_end: u32,
        ch6_rx_end: u32,
        ch6_err: u32,
        ch7_tx_end: u32,
        ch7_rx_end: u32,
        ch7_err: u32,
        ch0_tx_thr_event: u32,
        ch1_tx_thr_event: u32,
        ch2_tx_thr_event: u32,
        ch3_tx_thr_event: u32,
        ch4_tx_thr_event: u32,
        ch5_tx_thr_event: u32,
        ch6_tx_thr_event: u32,
        ch7_tx_thr_event: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ch0_tx_end: u32 = unsafe { ::core::mem::transmute(ch0_tx_end) };
            ch0_tx_end as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ch0_rx_end: u32 = unsafe { ::core::mem::transmute(ch0_rx_end) };
            ch0_rx_end as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ch0_err: u32 = unsafe { ::core::mem::transmute(ch0_err) };
            ch0_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ch1_tx_end: u32 = unsafe { ::core::mem::transmute(ch1_tx_end) };
            ch1_tx_end as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ch1_rx_end: u32 = unsafe { ::core::mem::transmute(ch1_rx_end) };
            ch1_rx_end as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ch1_err: u32 = unsafe { ::core::mem::transmute(ch1_err) };
            ch1_err as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ch2_tx_end: u32 = unsafe { ::core::mem::transmute(ch2_tx_end) };
            ch2_tx_end as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ch2_rx_end: u32 = unsafe { ::core::mem::transmute(ch2_rx_end) };
            ch2_rx_end as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ch2_err: u32 = unsafe { ::core::mem::transmute(ch2_err) };
            ch2_err as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ch3_tx_end: u32 = unsafe { ::core::mem::transmute(ch3_tx_end) };
            ch3_tx_end as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ch3_rx_end: u32 = unsafe { ::core::mem::transmute(ch3_rx_end) };
            ch3_rx_end as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ch3_err: u32 = unsafe { ::core::mem::transmute(ch3_err) };
            ch3_err as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ch4_tx_end: u32 = unsafe { ::core::mem::transmute(ch4_tx_end) };
            ch4_tx_end as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ch4_rx_end: u32 = unsafe { ::core::mem::transmute(ch4_rx_end) };
            ch4_rx_end as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ch4_err: u32 = unsafe { ::core::mem::transmute(ch4_err) };
            ch4_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ch5_tx_end: u32 = unsafe { ::core::mem::transmute(ch5_tx_end) };
            ch5_tx_end as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ch5_rx_end: u32 = unsafe { ::core::mem::transmute(ch5_rx_end) };
            ch5_rx_end as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ch5_err: u32 = unsafe { ::core::mem::transmute(ch5_err) };
            ch5_err as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ch6_tx_end: u32 = unsafe { ::core::mem::transmute(ch6_tx_end) };
            ch6_tx_end as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ch6_rx_end: u32 = unsafe { ::core::mem::transmute(ch6_rx_end) };
            ch6_rx_end as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ch6_err: u32 = unsafe { ::core::mem::transmute(ch6_err) };
            ch6_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ch7_tx_end: u32 = unsafe { ::core::mem::transmute(ch7_tx_end) };
            ch7_tx_end as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ch7_rx_end: u32 = unsafe { ::core::mem::transmute(ch7_rx_end) };
            ch7_rx_end as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ch7_err: u32 = unsafe { ::core::mem::transmute(ch7_err) };
            ch7_err as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ch0_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch0_tx_thr_event) };
            ch0_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ch1_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch1_tx_thr_event) };
            ch1_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ch2_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch2_tx_thr_event) };
            ch2_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let ch3_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch3_tx_thr_event) };
            ch3_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ch4_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch4_tx_thr_event) };
            ch4_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ch5_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch5_tx_thr_event) };
            ch5_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ch6_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch6_tx_thr_event) };
            ch6_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ch7_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch7_tx_thr_event) };
            ch7_tx_thr_event as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl rmt_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn ch0_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_rx_end(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_rx_end(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch0_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch0_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch1_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch1_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch2_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch2_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch3_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch3_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch4_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch4_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch5_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch5_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch6_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch6_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ch7_tx_thr_event(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ch7_tx_thr_event(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ch0_tx_end: u32,
        ch0_rx_end: u32,
        ch0_err: u32,
        ch1_tx_end: u32,
        ch1_rx_end: u32,
        ch1_err: u32,
        ch2_tx_end: u32,
        ch2_rx_end: u32,
        ch2_err: u32,
        ch3_tx_end: u32,
        ch3_rx_end: u32,
        ch3_err: u32,
        ch4_tx_end: u32,
        ch4_rx_end: u32,
        ch4_err: u32,
        ch5_tx_end: u32,
        ch5_rx_end: u32,
        ch5_err: u32,
        ch6_tx_end: u32,
        ch6_rx_end: u32,
        ch6_err: u32,
        ch7_tx_end: u32,
        ch7_rx_end: u32,
        ch7_err: u32,
        ch0_tx_thr_event: u32,
        ch1_tx_thr_event: u32,
        ch2_tx_thr_event: u32,
        ch3_tx_thr_event: u32,
        ch4_tx_thr_event: u32,
        ch5_tx_thr_event: u32,
        ch6_tx_thr_event: u32,
        ch7_tx_thr_event: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ch0_tx_end: u32 = unsafe { ::core::mem::transmute(ch0_tx_end) };
            ch0_tx_end as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ch0_rx_end: u32 = unsafe { ::core::mem::transmute(ch0_rx_end) };
            ch0_rx_end as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ch0_err: u32 = unsafe { ::core::mem::transmute(ch0_err) };
            ch0_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ch1_tx_end: u32 = unsafe { ::core::mem::transmute(ch1_tx_end) };
            ch1_tx_end as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ch1_rx_end: u32 = unsafe { ::core::mem::transmute(ch1_rx_end) };
            ch1_rx_end as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ch1_err: u32 = unsafe { ::core::mem::transmute(ch1_err) };
            ch1_err as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ch2_tx_end: u32 = unsafe { ::core::mem::transmute(ch2_tx_end) };
            ch2_tx_end as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ch2_rx_end: u32 = unsafe { ::core::mem::transmute(ch2_rx_end) };
            ch2_rx_end as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ch2_err: u32 = unsafe { ::core::mem::transmute(ch2_err) };
            ch2_err as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ch3_tx_end: u32 = unsafe { ::core::mem::transmute(ch3_tx_end) };
            ch3_tx_end as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ch3_rx_end: u32 = unsafe { ::core::mem::transmute(ch3_rx_end) };
            ch3_rx_end as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ch3_err: u32 = unsafe { ::core::mem::transmute(ch3_err) };
            ch3_err as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ch4_tx_end: u32 = unsafe { ::core::mem::transmute(ch4_tx_end) };
            ch4_tx_end as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ch4_rx_end: u32 = unsafe { ::core::mem::transmute(ch4_rx_end) };
            ch4_rx_end as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ch4_err: u32 = unsafe { ::core::mem::transmute(ch4_err) };
            ch4_err as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ch5_tx_end: u32 = unsafe { ::core::mem::transmute(ch5_tx_end) };
            ch5_tx_end as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ch5_rx_end: u32 = unsafe { ::core::mem::transmute(ch5_rx_end) };
            ch5_rx_end as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let ch5_err: u32 = unsafe { ::core::mem::transmute(ch5_err) };
            ch5_err as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ch6_tx_end: u32 = unsafe { ::core::mem::transmute(ch6_tx_end) };
            ch6_tx_end as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ch6_rx_end: u32 = unsafe { ::core::mem::transmute(ch6_rx_end) };
            ch6_rx_end as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ch6_err: u32 = unsafe { ::core::mem::transmute(ch6_err) };
            ch6_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ch7_tx_end: u32 = unsafe { ::core::mem::transmute(ch7_tx_end) };
            ch7_tx_end as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ch7_rx_end: u32 = unsafe { ::core::mem::transmute(ch7_rx_end) };
            ch7_rx_end as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ch7_err: u32 = unsafe { ::core::mem::transmute(ch7_err) };
            ch7_err as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let ch0_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch0_tx_thr_event) };
            ch0_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let ch1_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch1_tx_thr_event) };
            ch1_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let ch2_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch2_tx_thr_event) };
            ch2_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let ch3_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch3_tx_thr_event) };
            ch3_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ch4_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch4_tx_thr_event) };
            ch4_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ch5_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch5_tx_thr_event) };
            ch5_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ch6_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch6_tx_thr_event) };
            ch6_tx_thr_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ch7_tx_thr_event: u32 = unsafe { ::core::mem::transmute(ch7_tx_thr_event) };
            ch7_tx_thr_event as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rmt_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn low(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn high(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(low: u32, high: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let low: u32 = unsafe { ::core::mem::transmute(low) };
            low as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let high: u32 = unsafe { ::core::mem::transmute(high) };
            high as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rmt_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn limit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_limit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(limit: u32, reserved9: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let limit: u32 = unsafe { ::core::mem::transmute(limit) };
            limit as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: rmt_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl rmt_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn fifo_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_tx_wrap_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_tx_wrap_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fifo_mask: u32,
        mem_tx_wrap_en: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fifo_mask: u32 = unsafe { ::core::mem::transmute(fifo_mask) };
            fifo_mask as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mem_tx_wrap_en: u32 = unsafe { ::core::mem::transmute(mem_tx_wrap_en) };
            mem_tx_wrap_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rmt_dev_t = rmt_dev_s;
extern "C" {
    pub static mut RMT: rmt_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_item32_s {
    pub __bindgen_anon_1: rmt_item32_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_item32_s__bindgen_ty_1 {
    pub __bindgen_anon_1: rmt_item32_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rmt_item32_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl rmt_item32_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn duration0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_duration0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn level0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn duration1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_duration1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn level1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        duration0: u32,
        level0: u32,
        duration1: u32,
        level1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let duration0: u32 = unsafe { ::core::mem::transmute(duration0) };
            duration0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let level0: u32 = unsafe { ::core::mem::transmute(level0) };
            level0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let duration1: u32 = unsafe { ::core::mem::transmute(duration1) };
            duration1 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let level1: u32 = unsafe { ::core::mem::transmute(level1) };
            level1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rmt_item32_t = rmt_item32_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_mem_s {
    pub chan: [rmt_mem_s__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_mem_s__bindgen_ty_1 {
    pub __bindgen_anon_1: rmt_mem_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_mem_s__bindgen_ty_1__bindgen_ty_1 {
    pub data32: [rmt_item32_t; 64usize],
    _bindgen_union_align: [u32; 64usize],
}
pub type rmt_mem_t = rmt_mem_s;
extern "C" {
    pub static mut RMTMEM: rmt_mem_t;
}
#[doc = " @brief RMT Channel Type"]
#[doc = ""]
pub use self::rmt_channel_id_t as rmt_channel_t;
#[doc = "< RMT RX mode, RMT transmitter owns the memory block"]
pub const rmt_mem_owner_t_RMT_MEM_OWNER_TX: rmt_mem_owner_t = 0;
#[doc = "< RMT RX mode, RMT receiver owns the memory block"]
pub const rmt_mem_owner_t_RMT_MEM_OWNER_RX: rmt_mem_owner_t = 1;
pub const rmt_mem_owner_t_RMT_MEM_OWNER_MAX: rmt_mem_owner_t = 2;
#[doc = " @brief RMT Internal Memory Owner"]
#[doc = ""]
pub type rmt_mem_owner_t = c_types::c_uint;
#[doc = "< RMT source clock system reference tick, 1MHz by default (not supported in this version)"]
pub const rmt_source_clk_t_RMT_BASECLK_REF: rmt_source_clk_t = 0;
#[doc = "< RMT source clock is APB CLK, 80Mhz by default"]
pub const rmt_source_clk_t_RMT_BASECLK_APB: rmt_source_clk_t = 1;
pub const rmt_source_clk_t_RMT_BASECLK_MAX: rmt_source_clk_t = 2;
#[doc = " @brief Clock Source of RMT Channel"]
#[doc = ""]
pub type rmt_source_clk_t = c_types::c_uint;
pub const rmt_data_mode_t_RMT_DATA_MODE_FIFO: rmt_data_mode_t = 0;
pub const rmt_data_mode_t_RMT_DATA_MODE_MEM: rmt_data_mode_t = 1;
pub const rmt_data_mode_t_RMT_DATA_MODE_MAX: rmt_data_mode_t = 2;
#[doc = " @brief RMT Data Mode"]
#[doc = ""]
#[doc = " @note We highly recommended to use MEM mode not FIFO mode since there will be some gotcha in FIFO mode."]
#[doc = ""]
pub type rmt_data_mode_t = c_types::c_uint;
#[doc = "< RMT TX mode"]
pub const rmt_mode_t_RMT_MODE_TX: rmt_mode_t = 0;
#[doc = "< RMT RX mode"]
pub const rmt_mode_t_RMT_MODE_RX: rmt_mode_t = 1;
pub const rmt_mode_t_RMT_MODE_MAX: rmt_mode_t = 2;
#[doc = " @brief RMT Channel Working Mode (TX or RX)"]
#[doc = ""]
pub type rmt_mode_t = c_types::c_uint;
#[doc = "< RMT TX idle level: low Level"]
pub const rmt_idle_level_t_RMT_IDLE_LEVEL_LOW: rmt_idle_level_t = 0;
#[doc = "< RMT TX idle level: high Level"]
pub const rmt_idle_level_t_RMT_IDLE_LEVEL_HIGH: rmt_idle_level_t = 1;
pub const rmt_idle_level_t_RMT_IDLE_LEVEL_MAX: rmt_idle_level_t = 2;
#[doc = " @brief RMT Idle Level"]
#[doc = ""]
pub type rmt_idle_level_t = c_types::c_uint;
#[doc = "< RMT carrier wave is modulated for low Level output"]
pub const rmt_carrier_level_t_RMT_CARRIER_LEVEL_LOW: rmt_carrier_level_t = 0;
#[doc = "< RMT carrier wave is modulated for high Level output"]
pub const rmt_carrier_level_t_RMT_CARRIER_LEVEL_HIGH: rmt_carrier_level_t = 1;
pub const rmt_carrier_level_t_RMT_CARRIER_LEVEL_MAX: rmt_carrier_level_t = 2;
#[doc = " @brief RMT Carrier Level"]
#[doc = ""]
pub type rmt_carrier_level_t = c_types::c_uint;
#[doc = "< RMT channel uninitialized"]
pub const rmt_channel_status_t_RMT_CHANNEL_UNINIT: rmt_channel_status_t = 0;
#[doc = "< RMT channel status idle"]
pub const rmt_channel_status_t_RMT_CHANNEL_IDLE: rmt_channel_status_t = 1;
#[doc = "< RMT channel status busy"]
pub const rmt_channel_status_t_RMT_CHANNEL_BUSY: rmt_channel_status_t = 2;
#[doc = " @brief RMT Channel Status"]
#[doc = ""]
pub type rmt_channel_status_t = c_types::c_uint;
#[doc = " @brief Data struct of RMT channel status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_channel_status_result_t {
    #[doc = "< Store the current status of each channel"]
    pub status: [rmt_channel_status_t; 8usize],
}
#[doc = " @brief Data struct of RMT TX configure parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_tx_config_t {
    #[doc = "< RMT carrier frequency"]
    pub carrier_freq_hz: u32,
    #[doc = "< Level of the RMT output, when the carrier is applied"]
    pub carrier_level: rmt_carrier_level_t,
    #[doc = "< RMT idle level"]
    pub idle_level: rmt_idle_level_t,
    #[doc = "< RMT carrier duty (%)"]
    pub carrier_duty_percent: u8,
    #[doc = "< RMT carrier enable"]
    pub carrier_en: bool,
    #[doc = "< Enable sending RMT items in a loop"]
    pub loop_en: bool,
    #[doc = "< RMT idle level output enable"]
    pub idle_output_en: bool,
}
#[doc = " @brief Data struct of RMT RX configure parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_rx_config_t {
    #[doc = "< RMT RX idle threshold"]
    pub idle_threshold: u16,
    #[doc = "< RMT filter tick number"]
    pub filter_ticks_thresh: u8,
    #[doc = "< RMT receiver filter enable"]
    pub filter_en: bool,
}
#[doc = " @brief Data struct of RMT configure parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmt_config_t {
    #[doc = "< RMT mode: transmitter or receiver"]
    pub rmt_mode: rmt_mode_t,
    #[doc = "< RMT channel"]
    pub channel: rmt_channel_t,
    #[doc = "< RMT GPIO number"]
    pub gpio_num: gpio_num_t,
    #[doc = "< RMT channel counter divider"]
    pub clk_div: u8,
    #[doc = "< RMT memory block number"]
    pub mem_block_num: u8,
    pub __bindgen_anon_1: rmt_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmt_config_t__bindgen_ty_1 {
    #[doc = "< RMT TX parameter"]
    pub tx_config: rmt_tx_config_t,
    #[doc = "< RMT RX parameter"]
    pub rx_config: rmt_rx_config_t,
    _bindgen_union_align: [u32; 4usize],
}
#[doc = " @brief RMT interrupt handle"]
pub type rmt_isr_handle_t = intr_handle_t;
#[doc = " @brief Type of RMT Tx End callback function"]
pub type rmt_tx_end_fn_t =
    ::core::option::Option<unsafe extern "C" fn(channel: rmt_channel_t, arg: *mut c_types::c_void)>;
#[doc = " @brief Structure encapsulating a RMT TX end callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmt_tx_end_callback_t {
    #[doc = "< Function which is called on RMT TX end"]
    pub function: rmt_tx_end_fn_t,
    #[doc = "< Optional argument passed to function"]
    pub arg: *mut c_types::c_void,
}
#[doc = " @brief User callback function to convert uint8_t type data to rmt format(rmt_item32_t)."]
#[doc = ""]
#[doc = "        This function may be called from an ISR, so, the code should be short and efficient."]
#[doc = ""]
#[doc = " @param  src Pointer to the buffer storing the raw data that needs to be converted to rmt format."]
#[doc = " @param[out] dest Pointer to the buffer storing the rmt format data."]
#[doc = " @param  src_size The raw data size."]
#[doc = " @param  wanted_num The number of rmt format data that wanted to get."]
#[doc = " @param[out] translated_size The size of the raw data that has been converted to rmt format,"]
#[doc = "             it should return 0 if no data is converted in user callback."]
#[doc = " @param[out] item_num The number of the rmt format data that actually converted to,"]
#[doc = "             it can be less than wanted_num if there is not enough raw data, but cannot exceed wanted_num."]
#[doc = "             it should return 0 if no data was converted."]
#[doc = ""]
#[doc = " @note"]
#[doc = "       In fact, item_num should be a multiple of translated_size, e.g. :"]
#[doc = "       When we convert each byte of uint8_t type data to rmt format data,"]
#[doc = "       the relation between item_num and translated_size should be `item_num = translated_size*8`."]
pub type sample_to_rmt_t = ::core::option::Option<
    unsafe extern "C" fn(
        src: *const c_types::c_void,
        dest: *mut rmt_item32_t,
        src_size: size_t,
        wanted_num: size_t,
        translated_size: *mut size_t,
        item_num: *mut size_t,
    ),
>;
extern "C" {
    #[doc = " @brief Set RMT clock divider, channel clock is divided from source clock."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param div_cnt RMT counter clock divider"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_clk_div(channel: rmt_channel_t, div_cnt: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT clock divider, channel clock is divided from source clock."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param div_cnt pointer to accept RMT counter divider"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_clk_div(channel: rmt_channel_t, div_cnt: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX idle threshold value"]
    #[doc = ""]
    #[doc = "        In receive mode, when no edge is detected on the input signal"]
    #[doc = "        for longer than idle_thres channel clock cycles,"]
    #[doc = "        the receive process is finished."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param thresh RMT RX idle threshold"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_rx_idle_thresh(channel: rmt_channel_t, thresh: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT idle threshold value."]
    #[doc = ""]
    #[doc = "        In receive mode, when no edge is detected on the input signal"]
    #[doc = "        for longer than idle_thres channel clock cycles,"]
    #[doc = "        the receive process is finished."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param thresh pointer to accept RMT RX idle threshold value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_rx_idle_thresh(channel: rmt_channel_t, thresh: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT memory block number for RMT channel"]
    #[doc = ""]
    #[doc = "        This function is used to configure the amount of memory blocks allocated to channel n"]
    #[doc = "        The 8 channels share a 512x32-bit RAM block which can be read and written"]
    #[doc = "        by the processor cores over the APB bus, as well as read by the transmitters"]
    #[doc = "        and written by the receivers."]
    #[doc = ""]
    #[doc = "        The RAM address range for channel n is start_addr_CHn to end_addr_CHn, which are defined by:"]
    #[doc = "        Memory block start address is RMT_CHANNEL_MEM(n) (in soc/rmt_reg.h),"]
    #[doc = "        that is, start_addr_chn = RMT base address + 0x800 + 64  4  n, and"]
    #[doc = "        end_addr_chn = RMT base address + 0x800 +  64  4  n + 64  4  RMT_MEM_SIZE_CHn mod 512  4"]
    #[doc = ""]
    #[doc = "        @note"]
    #[doc = "        If memory block number of one channel is set to a value greater than 1, this channel will occupy the memory"]
    #[doc = "        block of the next channel."]
    #[doc = "        Channel 0 can use at most 8 blocks of memory, accordingly channel 7 can only use one memory block."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param rmt_mem_num RMT RX memory block number, one block has 64 * 32 bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_mem_block_num(channel: rmt_channel_t, rmt_mem_num: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT memory block number"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param rmt_mem_num Pointer to accept RMT RX memory block number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_mem_block_num(channel: rmt_channel_t, rmt_mem_num: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure RMT carrier for TX signal."]
    #[doc = ""]
    #[doc = "        Set different values for carrier_high and carrier_low to set different frequency of carrier."]
    #[doc = "        The unit of carrier_high/low is the source clock tick, not the divided channel counter clock."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param carrier_en Whether to enable output carrier."]
    #[doc = " @param high_level High level duration of carrier"]
    #[doc = " @param low_level Low level duration of carrier."]
    #[doc = " @param carrier_level Configure the way carrier wave is modulated for channel."]
    #[doc = "     - 1'b1:transmit on low output level"]
    #[doc = "     - 1'b0:transmit on high output level"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_tx_carrier(
        channel: rmt_channel_t,
        carrier_en: bool,
        high_level: u16,
        low_level: u16,
        carrier_level: rmt_carrier_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT memory in low power mode."]
    #[doc = ""]
    #[doc = "        Reduce power consumed by memory. 1:memory is in low power state."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param pd_en RMT memory low power enable."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_mem_pd(channel: rmt_channel_t, pd_en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT memory low power mode."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param pd_en Pointer to accept RMT memory low power mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_mem_pd(channel: rmt_channel_t, pd_en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT start sending data from memory."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param tx_idx_rst Set true to reset memory index for TX."]
    #[doc = "                   Otherwise, transmitter will continue sending from the last index in memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_tx_start(channel: rmt_channel_t, tx_idx_rst: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT stop sending."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_tx_stop(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT start receiving data."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param rx_idx_rst Set true to reset memory index for receiver."]
    #[doc = "                   Otherwise, receiver will continue receiving data to the last index in memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_rx_start(channel: rmt_channel_t, rx_idx_rst: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT stop receiving data."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_rx_stop(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset RMT TX/RX memory index."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_memory_rw_rst(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT memory owner."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param owner To set when the transmitter or receiver can process the memory of channel."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_memory_owner(channel: rmt_channel_t, owner: rmt_mem_owner_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT memory owner."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param owner Pointer to get memory owner."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_memory_owner(channel: rmt_channel_t, owner: *mut rmt_mem_owner_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT tx loop mode."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param loop_en Enable RMT transmitter loop sending mode."]
    #[doc = "                If set true, transmitter will continue sending from the first data"]
    #[doc = "                to the last data in channel over and over again in a loop."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_tx_loop_mode(channel: rmt_channel_t, loop_en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT tx loop mode."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param loop_en Pointer to accept RMT transmitter loop sending mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_tx_loop_mode(channel: rmt_channel_t, loop_en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX filter."]
    #[doc = ""]
    #[doc = "        In receive mode, channel will ignore input pulse when the pulse width is smaller than threshold."]
    #[doc = "        Counted in source clock, not divided counter clock."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param rx_filter_en To enable RMT receiver filter."]
    #[doc = " @param thresh Threshold of pulse width for receiver."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_rx_filter(channel: rmt_channel_t, rx_filter_en: bool, thresh: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT source clock"]
    #[doc = ""]
    #[doc = "        RMT module has two clock sources:"]
    #[doc = "        1. APB clock which is 80Mhz"]
    #[doc = "        2. REF tick clock, which would be 1Mhz (not supported in this version)."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param base_clk To choose source clock for RMT module."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_source_clk(channel: rmt_channel_t, base_clk: rmt_source_clk_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT source clock"]
    #[doc = ""]
    #[doc = "        RMT module has two clock sources:"]
    #[doc = "        1. APB clock which is 80Mhz"]
    #[doc = "        2. REF tick clock, which would be 1Mhz (not supported in this version)."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param src_clk Pointer to accept source clock for RMT module."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_source_clk(channel: rmt_channel_t, src_clk: *mut rmt_source_clk_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT idle output level for transmitter"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param idle_out_en To enable idle level output."]
    #[doc = " @param level To set the output signal's level for channel in idle state."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_idle_level(
        channel: rmt_channel_t,
        idle_out_en: bool,
        level: rmt_idle_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT idle output level for transmitter"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param idle_out_en Pointer to accept value of enable idle."]
    #[doc = " @param level Pointer to accept value of output signal's level in idle state for specified channel."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_idle_level(
        channel: rmt_channel_t,
        idle_out_en: *mut bool,
        level: *mut rmt_idle_level_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RMT status"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param status Pointer to accept channel status."]
    #[doc = "        Please refer to RMT_CHnSTATUS_REG(n=0~7) in `rmt_reg.h` for more details of each field."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_status(channel: rmt_channel_t, status: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set mask value to RMT interrupt enable register."]
    #[doc = ""]
    #[doc = " @param mask Bit mask to set to the register"]
    pub fn rmt_set_intr_enable_mask(mask: u32);
}
extern "C" {
    #[doc = " @brief Clear mask value to RMT interrupt enable register."]
    #[doc = ""]
    #[doc = " @param mask Bit mask to clear the register"]
    pub fn rmt_clr_intr_enable_mask(mask: u32);
}
extern "C" {
    #[doc = " @brief Set RMT RX interrupt enable"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param en enable or disable RX interrupt."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_rx_intr_en(channel: rmt_channel_t, en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT RX error interrupt enable"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param en enable or disable RX err interrupt."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_err_intr_en(channel: rmt_channel_t, en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT TX interrupt enable"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param en enable or disable TX interrupt."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_tx_intr_en(channel: rmt_channel_t, en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT TX threshold event interrupt enable"]
    #[doc = ""]
    #[doc = " An interrupt will be triggered when the number of transmitted items reaches the threshold value"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param en enable or disable TX event interrupt."]
    #[doc = " @param evt_thresh RMT event interrupt threshold value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_tx_thr_intr_en(channel: rmt_channel_t, en: bool, evt_thresh: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RMT pin"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param mode TX or RX mode for RMT"]
    #[doc = " @param gpio_num GPIO number to transmit or receive the signal."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_set_pin(channel: rmt_channel_t, mode: rmt_mode_t, gpio_num: gpio_num_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure RMT parameters"]
    #[doc = ""]
    #[doc = " @param rmt_param RMT parameter struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_config(rmt_param: *const rmt_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register RMT interrupt handler, the handler is an ISR."]
    #[doc = ""]
    #[doc = "        The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @note  If you already called rmt_driver_install to use system RMT driver,"]
    #[doc = "        please do not register ISR handler again."]
    #[doc = ""]
    #[doc = " @param fn Interrupt handler function."]
    #[doc = " @param arg Parameter for the handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle If non-zero, a handle to later clean up the ISR gets stored here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Function pointer error."]
    #[doc = "     - ESP_FAIL System driver installed, can not register ISR handler for RMT"]
    pub fn rmt_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut rmt_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Deregister previously registered RMT interrupt handler"]
    #[doc = ""]
    #[doc = " @param handle Handle obtained from rmt_isr_register"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Handle invalid"]
    pub fn rmt_isr_deregister(handle: rmt_isr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Fill memory data of channel with given RMT items."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param item Pointer of items."]
    #[doc = " @param item_num RMT sending items number."]
    #[doc = " @param mem_offset Index offset of memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_fill_tx_items(
        channel: rmt_channel_t,
        item: *const rmt_item32_t,
        item_num: u16,
        mem_offset: u16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize RMT driver"]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param rx_buf_size Size of RMT RX ringbuffer. Can be 0 if the RX ringbuffer is not used."]
    #[doc = " @param intr_alloc_flags Flags for the RMT driver interrupt handler. Pass 0 for default flags. See esp_intr_alloc.h for details."]
    #[doc = "        If ESP_INTR_FLAG_IRAM is used, please do not use the memory allocated from psram when calling rmt_write_items."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver is already installed, call rmt_driver_uninstall first."]
    #[doc = "     - ESP_ERR_NO_MEM Memory allocation failure"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_driver_install(
        channel: rmt_channel_t,
        rx_buf_size: size_t,
        intr_alloc_flags: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall RMT driver."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_driver_uninstall(channel: rmt_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the current status of eight channels."]
    #[doc = ""]
    #[doc = " @note Do not call this function if it is possible that `rmt_driver_uninstall` will be called at the same time."]
    #[doc = ""]
    #[doc = " @param[out] channel_status store the current status of each channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter is NULL"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_channel_status(channel_status: *mut rmt_channel_status_result_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get speed of channel's internal counter clock."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param[out] clock_hz counter clock speed, in hz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter is NULL"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_counter_clock(channel: rmt_channel_t, clock_hz: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief RMT send waveform from rmt_item array."]
    #[doc = ""]
    #[doc = "        This API allows user to send waveform with any length."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param rmt_item head point of RMT items array."]
    #[doc = "        If ESP_INTR_FLAG_IRAM is used, please do not use the memory allocated from psram when calling rmt_write_items."]
    #[doc = " @param item_num RMT data item number."]
    #[doc = " @param wait_tx_done"]
    #[doc = "        - If set 1, it will block the task and wait for sending done."]
    #[doc = "        - If set 0, it will not wait and return immediately."]
    #[doc = ""]
    #[doc = "         @note"]
    #[doc = "         This function will not copy data, instead, it will point to the original items,"]
    #[doc = "         and send the waveform items."]
    #[doc = "         If wait_tx_done is set to true, this function will block and will not return until"]
    #[doc = "         all items have been sent out."]
    #[doc = "         If wait_tx_done is set to false, this function will return immediately, and the driver"]
    #[doc = "         interrupt will continue sending the items. We must make sure the item data will not be"]
    #[doc = "         damaged when the driver is still sending items in driver interrupt."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_write_items(
        channel: rmt_channel_t,
        rmt_item: *const rmt_item32_t,
        item_num: c_types::c_int,
        wait_tx_done: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait RMT TX finished."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param wait_time Maximum time in ticks to wait for transmission to be complete.  If set 0, return immediately with ESP_ERR_TIMEOUT if TX is busy (polling)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK RMT Tx done successfully"]
    #[doc = "     - ESP_ERR_TIMEOUT Exceeded the 'wait_time' given"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Driver not installed"]
    pub fn rmt_wait_tx_done(channel: rmt_channel_t, wait_time: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get ringbuffer from RMT."]
    #[doc = ""]
    #[doc = "        Users can get the RMT RX ringbuffer handle, and process the RX data."]
    #[doc = ""]
    #[doc = " @param channel RMT channel"]
    #[doc = " @param buf_handle Pointer to buffer handle to accept RX ringbuffer handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn rmt_get_ringbuf_handle(
        channel: rmt_channel_t,
        buf_handle: *mut RingbufHandle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Init rmt translator and register user callback."]
    #[doc = "        The callback will convert the raw data that needs to be sent to rmt format."]
    #[doc = "        If a channel is initialized more than once, tha user callback will be replaced by the later."]
    #[doc = ""]
    #[doc = " @param channel RMT channel ."]
    #[doc = " @param fn Point to the data conversion function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Init fail."]
    #[doc = "     - ESP_OK Init success."]
    pub fn rmt_translator_init(channel: rmt_channel_t, fn_: sample_to_rmt_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Translate uint8_t type of data into rmt format and send it out."]
    #[doc = "        Requires rmt_translator_init to init the translator first."]
    #[doc = ""]
    #[doc = " @param channel RMT channel ."]
    #[doc = " @param src Pointer to the raw data."]
    #[doc = " @param src_size The size of the raw data."]
    #[doc = " @param wait_tx_done Set true to wait all data send done."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Send fail"]
    #[doc = "     - ESP_OK Send success"]
    pub fn rmt_write_sample(
        channel: rmt_channel_t,
        src: *const u8,
        src_size: size_t,
        wait_tx_done: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Registers a callback that will be called when transmission ends."]
    #[doc = ""]
    #[doc = "        Called by rmt_driver_isr_default in interrupt context."]
    #[doc = ""]
    #[doc = " @note Requires rmt_driver_install to install the default ISR handler."]
    #[doc = ""]
    #[doc = " @param function Function to be called from the default interrupt handler or NULL."]
    #[doc = " @param arg Argument which will be provided to the callback when it is called."]
    #[doc = ""]
    #[doc = " @return the previous callback settings (members will be set to NULL if there was none)"]
    pub fn rmt_register_tx_end_callback(
        function: rmt_tx_end_fn_t,
        arg: *mut c_types::c_void,
    ) -> rmt_tx_end_callback_t;
}
extern "C" {
    #[doc = " @brief Register a handler for specific RTC_CNTL interrupts"]
    #[doc = ""]
    #[doc = " Multiple handlers can be registered using this function. Whenever an"]
    #[doc = " RTC interrupt happens, all handlers with matching rtc_intr_mask values"]
    #[doc = " will be called."]
    #[doc = ""]
    #[doc = " @param handler  handler function to call"]
    #[doc = " @param handler_arg  argument to be passed to the handler"]
    #[doc = " @param rtc_intr_mask  combination of RTC_CNTL_*_INT_ENA bits indicating the"]
    #[doc = "                       sources to call the handler for"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM not enough memory to allocate handler structure"]
    #[doc = "      - other errors returned by esp_intr_alloc"]
    pub fn rtc_isr_register(
        handler: intr_handler_t,
        handler_arg: *mut c_types::c_void,
        rtc_intr_mask: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deregister the handler previously registered using rtc_isr_register"]
    #[doc = " @param handler  handler function to call (as passed to rtc_isr_register)"]
    #[doc = " @param handler_arg  argument of the handler (as passed to rtc_isr_register)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if a handler matching both handler and"]
    #[doc = "        handler_arg isn't registered"]
    pub fn rtc_isr_deregister(
        handler: intr_handler_t,
        handler_arg: *mut c_types::c_void,
    ) -> esp_err_t;
}
#[doc = "< Pad input"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_INPUT_ONLY: rtc_gpio_mode_t = 0;
#[doc = "< Pad output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_OUTPUT_ONLY: rtc_gpio_mode_t = 1;
#[doc = "< Pad input + output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_INPUT_OUTPUT: rtc_gpio_mode_t = 2;
#[doc = "< Pad (output + input) disable"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_DISABLED: rtc_gpio_mode_t = 3;
#[doc = "< Pad open-drain output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_OUTPUT_OD: rtc_gpio_mode_t = 4;
#[doc = "< Pad input + open-drain output"]
pub const rtc_gpio_mode_t_RTC_GPIO_MODE_INPUT_OUTPUT_OD: rtc_gpio_mode_t = 5;
#[doc = " RTCIO output/input mode type."]
pub type rtc_gpio_mode_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Init a GPIO as RTC GPIO"]
    #[doc = ""]
    #[doc = " This function must be called when initializing a pad for an analog function."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_init(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Init a GPIO as digital GPIO"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_deinit(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the RTC IO input level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 1 High level"]
    #[doc = "     - 0 Low level"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_get_level(gpio_num: gpio_num_t) -> u32;
}
extern "C" {
    #[doc = " @brief Set the RTC IO output level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = " @param  level output level"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief    RTC GPIO set direction"]
    #[doc = ""]
    #[doc = " Configure RTC GPIO direction, such as output only, input only,"]
    #[doc = " output and input."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_set_direction(gpio_num: gpio_num_t, mode: rtc_gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief RTC GPIO set direction in deep sleep mode or disable sleep status (default)."]
    #[doc = "        In some application scenarios, IO needs to have another states during deep sleep."]
    #[doc = ""]
    #[doc = " NOTE: ESP32 support INPUT_ONLY mode."]
    #[doc = "       ESP32S2 support INPUT_ONLY, OUTPUT_ONLY, INPUT_OUTPUT mode."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_set_direction_in_sleep(
        gpio_num: gpio_num_t,
        mode: rtc_gpio_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  RTC GPIO pullup enable"]
    #[doc = ""]
    #[doc = " This function only works for RTC IOs. In general, call gpio_pullup_en,"]
    #[doc = " which will work both for normal GPIOs and RTC IOs."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  RTC GPIO pulldown enable"]
    #[doc = ""]
    #[doc = " This function only works for RTC IOs. In general, call gpio_pulldown_en,"]
    #[doc = " which will work both for normal GPIOs and RTC IOs."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  RTC GPIO pullup disable"]
    #[doc = ""]
    #[doc = " This function only works for RTC IOs. In general, call gpio_pullup_dis,"]
    #[doc = " which will work both for normal GPIOs and RTC IOs."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  RTC GPIO pulldown disable"]
    #[doc = ""]
    #[doc = " This function only works for RTC IOs. In general, call gpio_pulldown_dis,"]
    #[doc = " which will work both for normal GPIOs and RTC IOs."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable hold function on an RTC IO pad"]
    #[doc = ""]
    #[doc = " Enabling HOLD function will cause the pad to latch current values of"]
    #[doc = " input enable, output enable, output value, function, drive strength values."]
    #[doc = " This function is useful when going into light or deep sleep mode to prevent"]
    #[doc = " the pin configuration from changing."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_hold_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable hold function on an RTC IO pad"]
    #[doc = ""]
    #[doc = " Disabling hold function will allow the pad receive the values of"]
    #[doc = " input enable, output enable, output value, function, drive strength from"]
    #[doc = " RTC_IO peripheral."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number (e.g. GPIO_NUM_12)"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO is not an RTC IO"]
    pub fn rtc_gpio_hold_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Helper function to disconnect internal circuits from an RTC IO"]
    #[doc = " This function disables input, output, pullup, pulldown, and enables"]
    #[doc = " hold feature for an RTC IO."]
    #[doc = " Use this function if an RTC IO needs to be disconnected from internal"]
    #[doc = " circuits in deep sleep, to minimize leakage current."]
    #[doc = ""]
    #[doc = " In particular, for ESP32-WROVER module, call"]
    #[doc = " rtc_gpio_isolate(GPIO_NUM_12) before entering deep sleep, to reduce"]
    #[doc = " deep sleep current."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number (e.g. GPIO_NUM_12)."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if GPIO is not an RTC IO"]
    pub fn rtc_gpio_isolate(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable force hold signal for all RTC IOs"]
    #[doc = ""]
    #[doc = " Each RTC pad has a \"force hold\" input signal from the RTC controller."]
    #[doc = " If this signal is set, pad latches current values of input enable,"]
    #[doc = " function, output enable, and other signals which come from the RTC mux."]
    #[doc = " Force hold signal is enabled before going into deep sleep for pins which"]
    #[doc = " are used for EXT1 wakeup."]
    pub fn rtc_gpio_force_hold_all() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable force hold signal for all RTC IOs"]
    pub fn rtc_gpio_force_hold_dis_all() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set RTC GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn rtc_gpio_set_drive_capability(
        gpio_num: gpio_num_t,
        strength: gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get RTC GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Pointer to accept drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn rtc_gpio_get_drive_capability(
        gpio_num: gpio_num_t,
        strength: *mut gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup from sleep mode using specific GPIO"]
    #[doc = " @param gpio_num  GPIO number"]
    #[doc = " @param intr_type  Wakeup on high level (GPIO_INTR_HIGH_LEVEL) or low level"]
    #[doc = "                   (GPIO_INTR_LOW_LEVEL)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if gpio_num is not an RTC IO, or intr_type is not"]
    #[doc = "        one of GPIO_INTR_HIGH_LEVEL, GPIO_INTR_LOW_LEVEL."]
    pub fn rtc_gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable wakeup from sleep mode using specific GPIO"]
    #[doc = " @param gpio_num  GPIO number"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if gpio_num is not an RTC IO"]
    pub fn rtc_gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
#[doc = "< General purpose interrupt bit 0."]
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT0: sdio_slave_hostint_t = 1;
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT1: sdio_slave_hostint_t = 2;
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT2: sdio_slave_hostint_t = 4;
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT3: sdio_slave_hostint_t = 8;
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT4: sdio_slave_hostint_t = 16;
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT5: sdio_slave_hostint_t = 32;
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT6: sdio_slave_hostint_t = 64;
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_BIT7: sdio_slave_hostint_t = 128;
#[doc = "< New packet available"]
pub const sdio_slave_hostint_t_SDIO_SLAVE_HOSTINT_SEND_NEW_PACKET: sdio_slave_hostint_t = 8388608;
#[doc = " Mask of interrupts sending to the host."]
pub type sdio_slave_hostint_t = c_types::c_uint;
#[doc = "< Send at posedge, and sample at posedge. Default value for HS mode."]
#[doc = "   Normally there's no problem using this to work in DS mode."]
pub const sdio_slave_timing_t_SDIO_SLAVE_TIMING_PSEND_PSAMPLE: sdio_slave_timing_t = 0;
#[doc = "< Send at negedge, and sample at posedge. Default value for DS mode and below."]
pub const sdio_slave_timing_t_SDIO_SLAVE_TIMING_NSEND_PSAMPLE: sdio_slave_timing_t = 1;
#[doc = "< Send at posedge, and sample at negedge"]
pub const sdio_slave_timing_t_SDIO_SLAVE_TIMING_PSEND_NSAMPLE: sdio_slave_timing_t = 2;
#[doc = "< Send at negedge, and sample at negedge"]
pub const sdio_slave_timing_t_SDIO_SLAVE_TIMING_NSEND_NSAMPLE: sdio_slave_timing_t = 3;
#[doc = " Timing of SDIO slave"]
pub type sdio_slave_timing_t = c_types::c_uint;
#[doc = "< Stream mode, all packets to send will be combined as one if possible"]
pub const sdio_slave_sending_mode_t_SDIO_SLAVE_SEND_STREAM: sdio_slave_sending_mode_t = 0;
#[doc = "< Packet mode, one packets will be sent one after another (only increase packet_len if last packet sent)."]
pub const sdio_slave_sending_mode_t_SDIO_SLAVE_SEND_PACKET: sdio_slave_sending_mode_t = 1;
#[doc = " Configuration of SDIO slave mode"]
pub type sdio_slave_sending_mode_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slc_dev_s {
    pub conf0: slc_dev_s__bindgen_ty_1,
    pub slc0_int_raw: slc_dev_s__bindgen_ty_2,
    pub slc0_int_st: slc_dev_s__bindgen_ty_3,
    pub slc0_int_ena: slc_dev_s__bindgen_ty_4,
    pub slc0_int_clr: slc_dev_s__bindgen_ty_5,
    pub slc1_int_raw: slc_dev_s__bindgen_ty_6,
    pub slc1_int_st: slc_dev_s__bindgen_ty_7,
    pub slc1_int_ena: slc_dev_s__bindgen_ty_8,
    pub slc1_int_clr: slc_dev_s__bindgen_ty_9,
    pub rx_status: slc_dev_s__bindgen_ty_10,
    pub slc0_rxfifo_push: slc_dev_s__bindgen_ty_11,
    pub slc1_rxfifo_push: slc_dev_s__bindgen_ty_12,
    pub tx_status: slc_dev_s__bindgen_ty_13,
    pub slc0_txfifo_pop: slc_dev_s__bindgen_ty_14,
    pub slc1_txfifo_pop: slc_dev_s__bindgen_ty_15,
    pub slc0_rx_link: slc_dev_s__bindgen_ty_16,
    pub slc0_tx_link: slc_dev_s__bindgen_ty_17,
    pub slc1_rx_link: slc_dev_s__bindgen_ty_18,
    pub slc1_tx_link: slc_dev_s__bindgen_ty_19,
    pub intvec_tohost: slc_dev_s__bindgen_ty_20,
    pub slc0_token0: slc_dev_s__bindgen_ty_21,
    pub slc0_token1: slc_dev_s__bindgen_ty_22,
    pub slc1_token0: slc_dev_s__bindgen_ty_23,
    pub slc1_token1: slc_dev_s__bindgen_ty_24,
    pub conf1: slc_dev_s__bindgen_ty_25,
    pub slc0_state0: u32,
    pub slc0_state1: u32,
    pub slc1_state0: u32,
    pub slc1_state1: u32,
    pub bridge_conf: slc_dev_s__bindgen_ty_26,
    pub slc0_to_eof_des_addr: u32,
    pub slc0_tx_eof_des_addr: u32,
    pub slc0_to_eof_bfr_des_addr: u32,
    pub slc1_to_eof_des_addr: u32,
    pub slc1_tx_eof_des_addr: u32,
    pub slc1_to_eof_bfr_des_addr: u32,
    pub ahb_test: slc_dev_s__bindgen_ty_27,
    pub sdio_st: slc_dev_s__bindgen_ty_28,
    pub rx_dscr_conf: slc_dev_s__bindgen_ty_29,
    pub slc0_txlink_dscr: u32,
    pub slc0_txlink_dscr_bf0: u32,
    pub slc0_txlink_dscr_bf1: u32,
    pub slc0_rxlink_dscr: u32,
    pub slc0_rxlink_dscr_bf0: u32,
    pub slc0_rxlink_dscr_bf1: u32,
    pub slc1_txlink_dscr: u32,
    pub slc1_txlink_dscr_bf0: u32,
    pub slc1_txlink_dscr_bf1: u32,
    pub slc1_rxlink_dscr: u32,
    pub slc1_rxlink_dscr_bf0: u32,
    pub slc1_rxlink_dscr_bf1: u32,
    pub slc0_tx_erreof_des_addr: u32,
    pub slc1_tx_erreof_des_addr: u32,
    pub token_lat: slc_dev_s__bindgen_ty_30,
    pub tx_dscr_conf: slc_dev_s__bindgen_ty_31,
    pub cmd_infor0: u32,
    pub cmd_infor1: u32,
    pub slc0_len_conf: slc_dev_s__bindgen_ty_32,
    pub slc0_length: slc_dev_s__bindgen_ty_33,
    pub slc0_txpkt_h_dscr: u32,
    pub slc0_txpkt_e_dscr: u32,
    pub slc0_rxpkt_h_dscr: u32,
    pub slc0_rxpkt_e_dscr: u32,
    pub slc0_txpktu_h_dscr: u32,
    pub slc0_txpktu_e_dscr: u32,
    pub slc0_rxpktu_h_dscr: u32,
    pub slc0_rxpktu_e_dscr: u32,
    pub reserved_10c: u32,
    pub reserved_110: u32,
    pub seq_position: slc_dev_s__bindgen_ty_34,
    pub slc0_dscr_rec_conf: slc_dev_s__bindgen_ty_35,
    pub sdio_crc_st0: slc_dev_s__bindgen_ty_36,
    pub sdio_crc_st1: slc_dev_s__bindgen_ty_37,
    pub slc0_eof_start_des: u32,
    pub slc0_push_dscr_addr: u32,
    pub slc0_done_dscr_addr: u32,
    pub slc0_sub_start_des: u32,
    pub slc0_dscr_cnt: slc_dev_s__bindgen_ty_38,
    pub slc0_len_lim_conf: slc_dev_s__bindgen_ty_39,
    pub slc0_int_st1: slc_dev_s__bindgen_ty_40,
    pub slc0_int_ena1: slc_dev_s__bindgen_ty_41,
    pub slc1_int_st1: slc_dev_s__bindgen_ty_42,
    pub slc1_int_ena1: slc_dev_s__bindgen_ty_43,
    pub reserved_14c: u32,
    pub reserved_150: u32,
    pub reserved_154: u32,
    pub reserved_158: u32,
    pub reserved_15c: u32,
    pub reserved_160: u32,
    pub reserved_164: u32,
    pub reserved_168: u32,
    pub reserved_16c: u32,
    pub reserved_170: u32,
    pub reserved_174: u32,
    pub reserved_178: u32,
    pub reserved_17c: u32,
    pub reserved_180: u32,
    pub reserved_184: u32,
    pub reserved_188: u32,
    pub reserved_18c: u32,
    pub reserved_190: u32,
    pub reserved_194: u32,
    pub reserved_198: u32,
    pub reserved_19c: u32,
    pub reserved_1a0: u32,
    pub reserved_1a4: u32,
    pub reserved_1a8: u32,
    pub reserved_1ac: u32,
    pub reserved_1b0: u32,
    pub reserved_1b4: u32,
    pub reserved_1b8: u32,
    pub reserved_1bc: u32,
    pub reserved_1c0: u32,
    pub reserved_1c4: u32,
    pub reserved_1c8: u32,
    pub reserved_1cc: u32,
    pub reserved_1d0: u32,
    pub reserved_1d4: u32,
    pub reserved_1d8: u32,
    pub reserved_1dc: u32,
    pub reserved_1e0: u32,
    pub reserved_1e4: u32,
    pub reserved_1e8: u32,
    pub reserved_1ec: u32,
    pub reserved_1f0: u32,
    pub reserved_1f4: u32,
    pub date: u32,
    pub id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn slc0_tx_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_tx_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_fifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_fifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_tx_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_tx_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_auto_wrback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_auto_wrback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_no_restart_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_no_restart_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rxdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rxdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rxdata_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rxdata_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rxlink_auto_ret(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rxlink_auto_ret(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_txlink_auto_ret(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_txlink_auto_ret(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_txdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_txdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_txdata_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_txdata_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_token_auto_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token_auto_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_token_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_tx_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_tx_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_wr_retry_mask_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_wr_retry_mask_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_wr_retry_mask_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_wr_retry_mask_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_tx_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_tx_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_auto_wrback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_auto_wrback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_no_restart_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_no_restart_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rxdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rxdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rxdata_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rxdata_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rxlink_auto_ret(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rxlink_auto_ret(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_txlink_auto_ret(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_txlink_auto_ret(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_txdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_txdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_txdata_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_txdata_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token_auto_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token_auto_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_tx_rst: u32,
        slc0_rx_rst: u32,
        ahbm_fifo_rst: u32,
        ahbm_rst: u32,
        slc0_tx_loop_test: u32,
        slc0_rx_loop_test: u32,
        slc0_rx_auto_wrback: u32,
        slc0_rx_no_restart_clr: u32,
        slc0_rxdscr_burst_en: u32,
        slc0_rxdata_burst_en: u32,
        slc0_rxlink_auto_ret: u32,
        slc0_txlink_auto_ret: u32,
        slc0_txdscr_burst_en: u32,
        slc0_txdata_burst_en: u32,
        slc0_token_auto_clr: u32,
        slc0_token_sel: u32,
        slc1_tx_rst: u32,
        slc1_rx_rst: u32,
        slc0_wr_retry_mask_en: u32,
        slc1_wr_retry_mask_en: u32,
        slc1_tx_loop_test: u32,
        slc1_rx_loop_test: u32,
        slc1_rx_auto_wrback: u32,
        slc1_rx_no_restart_clr: u32,
        slc1_rxdscr_burst_en: u32,
        slc1_rxdata_burst_en: u32,
        slc1_rxlink_auto_ret: u32,
        slc1_txlink_auto_ret: u32,
        slc1_txdscr_burst_en: u32,
        slc1_txdata_burst_en: u32,
        slc1_token_auto_clr: u32,
        slc1_token_sel: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slc0_tx_rst: u32 = unsafe { ::core::mem::transmute(slc0_tx_rst) };
            slc0_tx_rst as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slc0_rx_rst: u32 = unsafe { ::core::mem::transmute(slc0_rx_rst) };
            slc0_rx_rst as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ahbm_fifo_rst: u32 = unsafe { ::core::mem::transmute(ahbm_fifo_rst) };
            ahbm_fifo_rst as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ahbm_rst: u32 = unsafe { ::core::mem::transmute(ahbm_rst) };
            ahbm_rst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let slc0_tx_loop_test: u32 = unsafe { ::core::mem::transmute(slc0_tx_loop_test) };
            slc0_tx_loop_test as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let slc0_rx_loop_test: u32 = unsafe { ::core::mem::transmute(slc0_rx_loop_test) };
            slc0_rx_loop_test as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let slc0_rx_auto_wrback: u32 = unsafe { ::core::mem::transmute(slc0_rx_auto_wrback) };
            slc0_rx_auto_wrback as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let slc0_rx_no_restart_clr: u32 =
                unsafe { ::core::mem::transmute(slc0_rx_no_restart_clr) };
            slc0_rx_no_restart_clr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let slc0_rxdscr_burst_en: u32 = unsafe { ::core::mem::transmute(slc0_rxdscr_burst_en) };
            slc0_rxdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let slc0_rxdata_burst_en: u32 = unsafe { ::core::mem::transmute(slc0_rxdata_burst_en) };
            slc0_rxdata_burst_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let slc0_rxlink_auto_ret: u32 = unsafe { ::core::mem::transmute(slc0_rxlink_auto_ret) };
            slc0_rxlink_auto_ret as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let slc0_txlink_auto_ret: u32 = unsafe { ::core::mem::transmute(slc0_txlink_auto_ret) };
            slc0_txlink_auto_ret as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let slc0_txdscr_burst_en: u32 = unsafe { ::core::mem::transmute(slc0_txdscr_burst_en) };
            slc0_txdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let slc0_txdata_burst_en: u32 = unsafe { ::core::mem::transmute(slc0_txdata_burst_en) };
            slc0_txdata_burst_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let slc0_token_auto_clr: u32 = unsafe { ::core::mem::transmute(slc0_token_auto_clr) };
            slc0_token_auto_clr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let slc0_token_sel: u32 = unsafe { ::core::mem::transmute(slc0_token_sel) };
            slc0_token_sel as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slc1_tx_rst: u32 = unsafe { ::core::mem::transmute(slc1_tx_rst) };
            slc1_tx_rst as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slc1_rx_rst: u32 = unsafe { ::core::mem::transmute(slc1_rx_rst) };
            slc1_rx_rst as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let slc0_wr_retry_mask_en: u32 =
                unsafe { ::core::mem::transmute(slc0_wr_retry_mask_en) };
            slc0_wr_retry_mask_en as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let slc1_wr_retry_mask_en: u32 =
                unsafe { ::core::mem::transmute(slc1_wr_retry_mask_en) };
            slc1_wr_retry_mask_en as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let slc1_tx_loop_test: u32 = unsafe { ::core::mem::transmute(slc1_tx_loop_test) };
            slc1_tx_loop_test as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let slc1_rx_loop_test: u32 = unsafe { ::core::mem::transmute(slc1_rx_loop_test) };
            slc1_rx_loop_test as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let slc1_rx_auto_wrback: u32 = unsafe { ::core::mem::transmute(slc1_rx_auto_wrback) };
            slc1_rx_auto_wrback as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let slc1_rx_no_restart_clr: u32 =
                unsafe { ::core::mem::transmute(slc1_rx_no_restart_clr) };
            slc1_rx_no_restart_clr as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let slc1_rxdscr_burst_en: u32 = unsafe { ::core::mem::transmute(slc1_rxdscr_burst_en) };
            slc1_rxdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let slc1_rxdata_burst_en: u32 = unsafe { ::core::mem::transmute(slc1_rxdata_burst_en) };
            slc1_rxdata_burst_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let slc1_rxlink_auto_ret: u32 = unsafe { ::core::mem::transmute(slc1_rxlink_auto_ret) };
            slc1_rxlink_auto_ret as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let slc1_txlink_auto_ret: u32 = unsafe { ::core::mem::transmute(slc1_txlink_auto_ret) };
            slc1_txlink_auto_ret as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let slc1_txdscr_burst_en: u32 = unsafe { ::core::mem::transmute(slc1_txdscr_burst_en) };
            slc1_txdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let slc1_txdata_burst_en: u32 = unsafe { ::core::mem::transmute(slc1_txdata_burst_en) };
            slc1_txdata_burst_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let slc1_token_auto_clr: u32 = unsafe { ::core::mem::transmute(slc1_token_auto_clr) };
            slc1_token_auto_clr as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let slc1_token_sel: u32 = unsafe { ::core::mem::transmute(slc1_token_sel) };
            slc1_token_sel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_dtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_dtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_quick_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_quick_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit0: u32,
        frhost_bit1: u32,
        frhost_bit2: u32,
        frhost_bit3: u32,
        frhost_bit4: u32,
        frhost_bit5: u32,
        frhost_bit6: u32,
        frhost_bit7: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        cmd_dtc: u32,
        rx_quick_eof: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit0: u32 = unsafe { ::core::mem::transmute(frhost_bit0) };
            frhost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit1: u32 = unsafe { ::core::mem::transmute(frhost_bit1) };
            frhost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit2: u32 = unsafe { ::core::mem::transmute(frhost_bit2) };
            frhost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit3: u32 = unsafe { ::core::mem::transmute(frhost_bit3) };
            frhost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit4: u32 = unsafe { ::core::mem::transmute(frhost_bit4) };
            frhost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit5: u32 = unsafe { ::core::mem::transmute(frhost_bit5) };
            frhost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit6: u32 = unsafe { ::core::mem::transmute(frhost_bit6) };
            frhost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit7: u32 = unsafe { ::core::mem::transmute(frhost_bit7) };
            frhost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let cmd_dtc: u32 = unsafe { ::core::mem::transmute(cmd_dtc) };
            cmd_dtc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rx_quick_eof: u32 = unsafe { ::core::mem::transmute(rx_quick_eof) };
            rx_quick_eof as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_dtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_dtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_quick_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_quick_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit0: u32,
        frhost_bit1: u32,
        frhost_bit2: u32,
        frhost_bit3: u32,
        frhost_bit4: u32,
        frhost_bit5: u32,
        frhost_bit6: u32,
        frhost_bit7: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        cmd_dtc: u32,
        rx_quick_eof: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit0: u32 = unsafe { ::core::mem::transmute(frhost_bit0) };
            frhost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit1: u32 = unsafe { ::core::mem::transmute(frhost_bit1) };
            frhost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit2: u32 = unsafe { ::core::mem::transmute(frhost_bit2) };
            frhost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit3: u32 = unsafe { ::core::mem::transmute(frhost_bit3) };
            frhost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit4: u32 = unsafe { ::core::mem::transmute(frhost_bit4) };
            frhost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit5: u32 = unsafe { ::core::mem::transmute(frhost_bit5) };
            frhost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit6: u32 = unsafe { ::core::mem::transmute(frhost_bit6) };
            frhost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit7: u32 = unsafe { ::core::mem::transmute(frhost_bit7) };
            frhost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let cmd_dtc: u32 = unsafe { ::core::mem::transmute(cmd_dtc) };
            cmd_dtc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rx_quick_eof: u32 = unsafe { ::core::mem::transmute(rx_quick_eof) };
            rx_quick_eof as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_dtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_dtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_quick_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_quick_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit0: u32,
        frhost_bit1: u32,
        frhost_bit2: u32,
        frhost_bit3: u32,
        frhost_bit4: u32,
        frhost_bit5: u32,
        frhost_bit6: u32,
        frhost_bit7: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        cmd_dtc: u32,
        rx_quick_eof: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit0: u32 = unsafe { ::core::mem::transmute(frhost_bit0) };
            frhost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit1: u32 = unsafe { ::core::mem::transmute(frhost_bit1) };
            frhost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit2: u32 = unsafe { ::core::mem::transmute(frhost_bit2) };
            frhost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit3: u32 = unsafe { ::core::mem::transmute(frhost_bit3) };
            frhost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit4: u32 = unsafe { ::core::mem::transmute(frhost_bit4) };
            frhost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit5: u32 = unsafe { ::core::mem::transmute(frhost_bit5) };
            frhost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit6: u32 = unsafe { ::core::mem::transmute(frhost_bit6) };
            frhost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit7: u32 = unsafe { ::core::mem::transmute(frhost_bit7) };
            frhost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let cmd_dtc: u32 = unsafe { ::core::mem::transmute(cmd_dtc) };
            cmd_dtc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rx_quick_eof: u32 = unsafe { ::core::mem::transmute(rx_quick_eof) };
            rx_quick_eof as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_dtc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_dtc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_quick_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_quick_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit0: u32,
        frhost_bit1: u32,
        frhost_bit2: u32,
        frhost_bit3: u32,
        frhost_bit4: u32,
        frhost_bit5: u32,
        frhost_bit6: u32,
        frhost_bit7: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        cmd_dtc: u32,
        rx_quick_eof: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit0: u32 = unsafe { ::core::mem::transmute(frhost_bit0) };
            frhost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit1: u32 = unsafe { ::core::mem::transmute(frhost_bit1) };
            frhost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit2: u32 = unsafe { ::core::mem::transmute(frhost_bit2) };
            frhost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit3: u32 = unsafe { ::core::mem::transmute(frhost_bit3) };
            frhost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit4: u32 = unsafe { ::core::mem::transmute(frhost_bit4) };
            frhost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit5: u32 = unsafe { ::core::mem::transmute(frhost_bit5) };
            frhost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit6: u32 = unsafe { ::core::mem::transmute(frhost_bit6) };
            frhost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit7: u32 = unsafe { ::core::mem::transmute(frhost_bit7) };
            frhost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let cmd_dtc: u32 = unsafe { ::core::mem::transmute(cmd_dtc) };
            cmd_dtc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rx_quick_eof: u32 = unsafe { ::core::mem::transmute(rx_quick_eof) };
            rx_quick_eof as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit8: u32,
        frhost_bit9: u32,
        frhost_bit10: u32,
        frhost_bit11: u32,
        frhost_bit12: u32,
        frhost_bit13: u32,
        frhost_bit14: u32,
        frhost_bit15: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit8: u32 = unsafe { ::core::mem::transmute(frhost_bit8) };
            frhost_bit8 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit9: u32 = unsafe { ::core::mem::transmute(frhost_bit9) };
            frhost_bit9 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit10: u32 = unsafe { ::core::mem::transmute(frhost_bit10) };
            frhost_bit10 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit11: u32 = unsafe { ::core::mem::transmute(frhost_bit11) };
            frhost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit12: u32 = unsafe { ::core::mem::transmute(frhost_bit12) };
            frhost_bit12 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit13: u32 = unsafe { ::core::mem::transmute(frhost_bit13) };
            frhost_bit13 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit14: u32 = unsafe { ::core::mem::transmute(frhost_bit14) };
            frhost_bit14 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit15: u32 = unsafe { ::core::mem::transmute(frhost_bit15) };
            frhost_bit15 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit8: u32,
        frhost_bit9: u32,
        frhost_bit10: u32,
        frhost_bit11: u32,
        frhost_bit12: u32,
        frhost_bit13: u32,
        frhost_bit14: u32,
        frhost_bit15: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit8: u32 = unsafe { ::core::mem::transmute(frhost_bit8) };
            frhost_bit8 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit9: u32 = unsafe { ::core::mem::transmute(frhost_bit9) };
            frhost_bit9 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit10: u32 = unsafe { ::core::mem::transmute(frhost_bit10) };
            frhost_bit10 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit11: u32 = unsafe { ::core::mem::transmute(frhost_bit11) };
            frhost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit12: u32 = unsafe { ::core::mem::transmute(frhost_bit12) };
            frhost_bit12 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit13: u32 = unsafe { ::core::mem::transmute(frhost_bit13) };
            frhost_bit13 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit14: u32 = unsafe { ::core::mem::transmute(frhost_bit14) };
            frhost_bit14 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit15: u32 = unsafe { ::core::mem::transmute(frhost_bit15) };
            frhost_bit15 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit8: u32,
        frhost_bit9: u32,
        frhost_bit10: u32,
        frhost_bit11: u32,
        frhost_bit12: u32,
        frhost_bit13: u32,
        frhost_bit14: u32,
        frhost_bit15: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit8: u32 = unsafe { ::core::mem::transmute(frhost_bit8) };
            frhost_bit8 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit9: u32 = unsafe { ::core::mem::transmute(frhost_bit9) };
            frhost_bit9 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit10: u32 = unsafe { ::core::mem::transmute(frhost_bit10) };
            frhost_bit10 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit11: u32 = unsafe { ::core::mem::transmute(frhost_bit11) };
            frhost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit12: u32 = unsafe { ::core::mem::transmute(frhost_bit12) };
            frhost_bit12 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit13: u32 = unsafe { ::core::mem::transmute(frhost_bit13) };
            frhost_bit13 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit14: u32 = unsafe { ::core::mem::transmute(frhost_bit14) };
            frhost_bit14 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit15: u32 = unsafe { ::core::mem::transmute(frhost_bit15) };
            frhost_bit15 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit8: u32,
        frhost_bit9: u32,
        frhost_bit10: u32,
        frhost_bit11: u32,
        frhost_bit12: u32,
        frhost_bit13: u32,
        frhost_bit14: u32,
        frhost_bit15: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        tx_done: u32,
        tx_suc_eof: u32,
        rx_done: u32,
        rx_eof: u32,
        tohost: u32,
        tx_dscr_err: u32,
        rx_dscr_err: u32,
        tx_dscr_empty: u32,
        host_rd_ack: u32,
        wr_retry_done: u32,
        tx_err_eof: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit8: u32 = unsafe { ::core::mem::transmute(frhost_bit8) };
            frhost_bit8 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit9: u32 = unsafe { ::core::mem::transmute(frhost_bit9) };
            frhost_bit9 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit10: u32 = unsafe { ::core::mem::transmute(frhost_bit10) };
            frhost_bit10 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit11: u32 = unsafe { ::core::mem::transmute(frhost_bit11) };
            frhost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit12: u32 = unsafe { ::core::mem::transmute(frhost_bit12) };
            frhost_bit12 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit13: u32 = unsafe { ::core::mem::transmute(frhost_bit13) };
            frhost_bit13 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit14: u32 = unsafe { ::core::mem::transmute(frhost_bit14) };
            frhost_bit14 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit15: u32 = unsafe { ::core::mem::transmute(frhost_bit15) };
            frhost_bit15 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof: u32 = unsafe { ::core::mem::transmute(tx_suc_eof) };
            tx_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done: u32 = unsafe { ::core::mem::transmute(rx_done) };
            rx_done as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost: u32 = unsafe { ::core::mem::transmute(tohost) };
            tohost as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err: u32 = unsafe { ::core::mem::transmute(tx_dscr_err) };
            tx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err: u32 = unsafe { ::core::mem::transmute(rx_dscr_err) };
            rx_dscr_err as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty) };
            tx_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack: u32 = unsafe { ::core::mem::transmute(host_rd_ack) };
            host_rd_ack as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done: u32 = unsafe { ::core::mem::transmute(wr_retry_done) };
            wr_retry_done as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof: u32 = unsafe { ::core::mem::transmute(tx_err_eof) };
            tx_err_eof as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn slc0_rx_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_rx_full: u32,
        slc0_rx_empty: u32,
        reserved2: u32,
        slc1_rx_full: u32,
        slc1_rx_empty: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slc0_rx_full: u32 = unsafe { ::core::mem::transmute(slc0_rx_full) };
            slc0_rx_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slc0_rx_empty: u32 = unsafe { ::core::mem::transmute(slc0_rx_empty) };
            slc0_rx_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slc1_rx_full: u32 = unsafe { ::core::mem::transmute(slc1_rx_full) };
            slc1_rx_full as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slc1_rx_empty: u32 = unsafe { ::core::mem::transmute(slc1_rx_empty) };
            slc1_rx_empty as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_push(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_push(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_wdata: u32,
        reserved9: u32,
        rxfifo_push: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let rxfifo_wdata: u32 = unsafe { ::core::mem::transmute(rxfifo_wdata) };
            rxfifo_wdata as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rxfifo_push: u32 = unsafe { ::core::mem::transmute(rxfifo_push) };
            rxfifo_push as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_push(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_push(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_wdata: u32,
        reserved9: u32,
        rxfifo_push: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let rxfifo_wdata: u32 = unsafe { ::core::mem::transmute(rxfifo_wdata) };
            rxfifo_wdata as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rxfifo_push: u32 = unsafe { ::core::mem::transmute(rxfifo_push) };
            rxfifo_push as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn slc0_tx_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_tx_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_tx_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_tx_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_tx_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_tx_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_tx_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_tx_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_tx_full: u32,
        slc0_tx_empty: u32,
        reserved2: u32,
        slc1_tx_full: u32,
        slc1_tx_empty: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slc0_tx_full: u32 = unsafe { ::core::mem::transmute(slc0_tx_full) };
            slc0_tx_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slc0_tx_empty: u32 = unsafe { ::core::mem::transmute(slc0_tx_empty) };
            slc0_tx_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slc1_tx_full: u32 = unsafe { ::core::mem::transmute(slc1_tx_full) };
            slc1_tx_full as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slc1_tx_empty: u32 = unsafe { ::core::mem::transmute(slc1_tx_empty) };
            slc1_tx_empty as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn txfifo_rdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_rdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_pop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_pop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        txfifo_rdata: u32,
        reserved11: u32,
        txfifo_pop: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let txfifo_rdata: u32 = unsafe { ::core::mem::transmute(txfifo_rdata) };
            txfifo_rdata as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let txfifo_pop: u32 = unsafe { ::core::mem::transmute(txfifo_pop) };
            txfifo_pop as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn txfifo_rdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_rdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_pop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_pop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        txfifo_rdata: u32,
        reserved11: u32,
        txfifo_pop: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let txfifo_rdata: u32 = unsafe { ::core::mem::transmute(txfifo_rdata) };
            txfifo_rdata as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let txfifo_pop: u32 = unsafe { ::core::mem::transmute(txfifo_pop) };
            txfifo_pop as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        bt_packet: u32,
        reserved21: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let bt_packet: u32 = unsafe { ::core::mem::transmute(bt_packet) };
            bt_packet as u64
        });
        __bindgen_bitfield_unit.set(21usize, 7u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn park(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_park(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        park: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let park: u32 = unsafe { ::core::mem::transmute(park) };
            park as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn slc0_intvec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_intvec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_intvec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_intvec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_intvec: u32,
        reserved8: u32,
        slc1_intvec: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let slc0_intvec: u32 = unsafe { ::core::mem::transmute(slc0_intvec) };
            slc0_intvec as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let slc1_intvec: u32 = unsafe { ::core::mem::transmute(slc1_intvec) };
            slc1_intvec as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_more(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_more(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wdata: u32,
        wr: u32,
        inc: u32,
        inc_more: u32,
        reserved15: u32,
        token0: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let wdata: u32 = unsafe { ::core::mem::transmute(wdata) };
            wdata as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wr: u32 = unsafe { ::core::mem::transmute(wr) };
            wr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let inc: u32 = unsafe { ::core::mem::transmute(inc) };
            inc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let inc_more: u32 = unsafe { ::core::mem::transmute(inc_more) };
            inc_more as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let token0: u32 = unsafe { ::core::mem::transmute(token0) };
            token0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_more(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_more(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wdata: u32,
        wr: u32,
        inc: u32,
        inc_more: u32,
        reserved15: u32,
        token1: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let wdata: u32 = unsafe { ::core::mem::transmute(wdata) };
            wdata as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wr: u32 = unsafe { ::core::mem::transmute(wr) };
            wr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let inc: u32 = unsafe { ::core::mem::transmute(inc) };
            inc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let inc_more: u32 = unsafe { ::core::mem::transmute(inc_more) };
            inc_more as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let token1: u32 = unsafe { ::core::mem::transmute(token1) };
            token1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_more(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_more(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wdata: u32,
        wr: u32,
        inc: u32,
        inc_more: u32,
        reserved15: u32,
        token0: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let wdata: u32 = unsafe { ::core::mem::transmute(wdata) };
            wdata as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wr: u32 = unsafe { ::core::mem::transmute(wr) };
            wr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let inc: u32 = unsafe { ::core::mem::transmute(inc) };
            inc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let inc_more: u32 = unsafe { ::core::mem::transmute(inc_more) };
            inc_more as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let token0: u32 = unsafe { ::core::mem::transmute(token0) };
            token0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inc_more(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inc_more(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wdata: u32,
        wr: u32,
        inc: u32,
        inc_more: u32,
        reserved15: u32,
        token1: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let wdata: u32 = unsafe { ::core::mem::transmute(wdata) };
            wdata as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wr: u32 = unsafe { ::core::mem::transmute(wr) };
            wr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let inc: u32 = unsafe { ::core::mem::transmute(inc) };
            inc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let inc_more: u32 = unsafe { ::core::mem::transmute(inc_more) };
            inc_more as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let token1: u32 = unsafe { ::core::mem::transmute(token1) };
            token1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn slc0_check_owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_check_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_tx_check_sum_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_tx_check_sum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_check_sum_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_check_sum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_hold_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_hold_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_len_auto_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_len_auto_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_tx_stitch_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_tx_stitch_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_stitch_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_stitch_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_check_owner(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_check_owner(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_tx_check_sum_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_tx_check_sum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_check_sum_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_check_sum_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_int_level_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_int_level_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_tx_stitch_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_tx_stitch_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_stitch_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_stitch_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_check_owner: u32,
        slc0_tx_check_sum_en: u32,
        slc0_rx_check_sum_en: u32,
        cmd_hold_en: u32,
        slc0_len_auto_clr: u32,
        slc0_tx_stitch_en: u32,
        slc0_rx_stitch_en: u32,
        reserved7: u32,
        slc1_check_owner: u32,
        slc1_tx_check_sum_en: u32,
        slc1_rx_check_sum_en: u32,
        host_int_level_sel: u32,
        slc1_tx_stitch_en: u32,
        slc1_rx_stitch_en: u32,
        clk_en: u32,
        reserved23: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slc0_check_owner: u32 = unsafe { ::core::mem::transmute(slc0_check_owner) };
            slc0_check_owner as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slc0_tx_check_sum_en: u32 = unsafe { ::core::mem::transmute(slc0_tx_check_sum_en) };
            slc0_tx_check_sum_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let slc0_rx_check_sum_en: u32 = unsafe { ::core::mem::transmute(slc0_rx_check_sum_en) };
            slc0_rx_check_sum_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cmd_hold_en: u32 = unsafe { ::core::mem::transmute(cmd_hold_en) };
            cmd_hold_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let slc0_len_auto_clr: u32 = unsafe { ::core::mem::transmute(slc0_len_auto_clr) };
            slc0_len_auto_clr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let slc0_tx_stitch_en: u32 = unsafe { ::core::mem::transmute(slc0_tx_stitch_en) };
            slc0_tx_stitch_en as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let slc0_rx_stitch_en: u32 = unsafe { ::core::mem::transmute(slc0_rx_stitch_en) };
            slc0_rx_stitch_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slc1_check_owner: u32 = unsafe { ::core::mem::transmute(slc1_check_owner) };
            slc1_check_owner as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slc1_tx_check_sum_en: u32 = unsafe { ::core::mem::transmute(slc1_tx_check_sum_en) };
            slc1_tx_check_sum_en as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let slc1_rx_check_sum_en: u32 = unsafe { ::core::mem::transmute(slc1_rx_check_sum_en) };
            slc1_rx_check_sum_en as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let host_int_level_sel: u32 = unsafe { ::core::mem::transmute(host_int_level_sel) };
            host_int_level_sel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let slc1_tx_stitch_en: u32 = unsafe { ::core::mem::transmute(slc1_tx_stitch_en) };
            slc1_tx_stitch_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let slc1_rx_stitch_en: u32 = unsafe { ::core::mem::transmute(slc1_rx_stitch_en) };
            slc1_rx_stitch_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let reserved23: u32 = unsafe { ::core::mem::transmute(reserved23) };
            reserved23 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn txeof_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_txeof_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fifo_map_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fifo_map_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_tx_dummy_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_tx_dummy_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hda_map_128k(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hda_map_128k(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_tx_dummy_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_tx_dummy_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_push_idle_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tx_push_idle_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        txeof_ena: u32,
        reserved6: u32,
        fifo_map_ena: u32,
        slc0_tx_dummy_mode: u32,
        hda_map_128k: u32,
        slc1_tx_dummy_mode: u32,
        reserved15: u32,
        tx_push_idle_num: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let txeof_ena: u32 = unsafe { ::core::mem::transmute(txeof_ena) };
            txeof_ena as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let fifo_map_ena: u32 = unsafe { ::core::mem::transmute(fifo_map_ena) };
            fifo_map_ena as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let slc0_tx_dummy_mode: u32 = unsafe { ::core::mem::transmute(slc0_tx_dummy_mode) };
            slc0_tx_dummy_mode as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hda_map_128k: u32 = unsafe { ::core::mem::transmute(hda_map_128k) };
            hda_map_128k as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let slc1_tx_dummy_mode: u32 = unsafe { ::core::mem::transmute(slc1_tx_dummy_mode) };
            slc1_tx_dummy_mode as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let tx_push_idle_num: u32 = unsafe { ::core::mem::transmute(tx_push_idle_num) };
            tx_push_idle_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: u32,
        reserved3: u32,
        addr: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let mode: u32 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn cmd_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn func_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_func_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_wakeup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_wakeup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn bus_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bus_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn func1_acc_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_func1_acc_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn func2_acc_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_func2_acc_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cmd_st: u32,
        reserved3: u32,
        func_st: u32,
        sdio_wakeup: u32,
        reserved9: u32,
        bus_st: u32,
        reserved15: u32,
        func1_acc_state: u32,
        reserved21: u32,
        func2_acc_state: u32,
        reserved29: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let cmd_st: u32 = unsafe { ::core::mem::transmute(cmd_st) };
            cmd_st as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let func_st: u32 = unsafe { ::core::mem::transmute(func_st) };
            func_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let sdio_wakeup: u32 = unsafe { ::core::mem::transmute(sdio_wakeup) };
            sdio_wakeup as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let bus_st: u32 = unsafe { ::core::mem::transmute(bus_st) };
            bus_st as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let func1_acc_state: u32 = unsafe { ::core::mem::transmute(func1_acc_state) };
            func1_acc_state as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let func2_acc_state: u32 = unsafe { ::core::mem::transmute(func2_acc_state) };
            func2_acc_state as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn slc0_token_no_replace(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token_no_replace(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_infor_no_replace(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_infor_no_replace(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_fill_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_fill_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_eof_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_eof_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rx_fill_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rx_fill_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_rd_retry_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_rd_retry_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token_no_replace(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token_no_replace(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_infor_no_replace(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_infor_no_replace(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_fill_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_fill_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_eof_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_eof_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rx_fill_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rx_fill_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_rd_retry_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_rd_retry_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_token_no_replace: u32,
        slc0_infor_no_replace: u32,
        slc0_rx_fill_mode: u32,
        slc0_rx_eof_mode: u32,
        slc0_rx_fill_en: u32,
        slc0_rd_retry_threshold: u32,
        slc1_token_no_replace: u32,
        slc1_infor_no_replace: u32,
        slc1_rx_fill_mode: u32,
        slc1_rx_eof_mode: u32,
        slc1_rx_fill_en: u32,
        slc1_rd_retry_threshold: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slc0_token_no_replace: u32 =
                unsafe { ::core::mem::transmute(slc0_token_no_replace) };
            slc0_token_no_replace as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slc0_infor_no_replace: u32 =
                unsafe { ::core::mem::transmute(slc0_infor_no_replace) };
            slc0_infor_no_replace as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let slc0_rx_fill_mode: u32 = unsafe { ::core::mem::transmute(slc0_rx_fill_mode) };
            slc0_rx_fill_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slc0_rx_eof_mode: u32 = unsafe { ::core::mem::transmute(slc0_rx_eof_mode) };
            slc0_rx_eof_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let slc0_rx_fill_en: u32 = unsafe { ::core::mem::transmute(slc0_rx_fill_en) };
            slc0_rx_fill_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let slc0_rd_retry_threshold: u32 =
                unsafe { ::core::mem::transmute(slc0_rd_retry_threshold) };
            slc0_rd_retry_threshold as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let slc1_token_no_replace: u32 =
                unsafe { ::core::mem::transmute(slc1_token_no_replace) };
            slc1_token_no_replace as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let slc1_infor_no_replace: u32 =
                unsafe { ::core::mem::transmute(slc1_infor_no_replace) };
            slc1_infor_no_replace as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let slc1_rx_fill_mode: u32 = unsafe { ::core::mem::transmute(slc1_rx_fill_mode) };
            slc1_rx_fill_mode as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let slc1_rx_eof_mode: u32 = unsafe { ::core::mem::transmute(slc1_rx_eof_mode) };
            slc1_rx_eof_mode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let slc1_rx_fill_en: u32 = unsafe { ::core::mem::transmute(slc1_rx_fill_en) };
            slc1_rx_fill_en as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let slc1_rd_retry_threshold: u32 =
                unsafe { ::core::mem::transmute(slc1_rd_retry_threshold) };
            slc1_rd_retry_threshold as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn slc0_token(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_token: u32,
        reserved12: u32,
        slc1_token: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let slc0_token: u32 = unsafe { ::core::mem::transmute(slc0_token) };
            slc0_token as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let slc1_token: u32 = unsafe { ::core::mem::transmute(slc1_token) };
            slc1_token as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn wr_retry_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wr_retry_threshold: u32,
        reserved11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let wr_retry_threshold: u32 = unsafe { ::core::mem::transmute(wr_retry_threshold) };
            wr_retry_threshold as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_32 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_32__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_32__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_32__bindgen_ty_1 {
    #[inline]
    pub fn len_wdata(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_len_wdata(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn len_wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_len_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn len_inc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_len_inc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn len_inc_more(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_len_inc_more(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_packet_load_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_packet_load_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_packet_load_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_packet_load_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_get_used_dscr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_get_used_dscr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_get_used_dscr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_get_used_dscr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_pkt_ind(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_pkt_ind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_new_pkt_ind(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_new_pkt_ind(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        len_wdata: u32,
        len_wr: u32,
        len_inc: u32,
        len_inc_more: u32,
        rx_packet_load_en: u32,
        tx_packet_load_en: u32,
        rx_get_used_dscr: u32,
        tx_get_used_dscr: u32,
        rx_new_pkt_ind: u32,
        tx_new_pkt_ind: u32,
        reserved29: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let len_wdata: u32 = unsafe { ::core::mem::transmute(len_wdata) };
            len_wdata as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let len_wr: u32 = unsafe { ::core::mem::transmute(len_wr) };
            len_wr as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let len_inc: u32 = unsafe { ::core::mem::transmute(len_inc) };
            len_inc as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let len_inc_more: u32 = unsafe { ::core::mem::transmute(len_inc_more) };
            len_inc_more as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_packet_load_en: u32 = unsafe { ::core::mem::transmute(rx_packet_load_en) };
            rx_packet_load_en as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_packet_load_en: u32 = unsafe { ::core::mem::transmute(tx_packet_load_en) };
            tx_packet_load_en as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let rx_get_used_dscr: u32 = unsafe { ::core::mem::transmute(rx_get_used_dscr) };
            rx_get_used_dscr as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let tx_get_used_dscr: u32 = unsafe { ::core::mem::transmute(tx_get_used_dscr) };
            tx_get_used_dscr as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let rx_new_pkt_ind: u32 = unsafe { ::core::mem::transmute(rx_new_pkt_ind) };
            rx_new_pkt_ind as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let tx_new_pkt_ind: u32 = unsafe { ::core::mem::transmute(tx_new_pkt_ind) };
            tx_new_pkt_ind as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_33 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_33__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_33__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_33__bindgen_ty_1 {
    #[inline]
    pub fn len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(len: u32, reserved20: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let len: u32 = unsafe { ::core::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_34 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_34__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_34__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_34__bindgen_ty_1 {
    #[inline]
    pub fn slc0_position(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_position(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_position(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_position(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_position: u32,
        slc1_position: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let slc0_position: u32 = unsafe { ::core::mem::transmute(slc0_position) };
            slc0_position as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let slc1_position: u32 = unsafe { ::core::mem::transmute(slc1_position) };
            slc1_position as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_35 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_35__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_35__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_35__bindgen_ty_1 {
    #[inline]
    pub fn rx_dscr_rec_lim(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_rec_lim(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_dscr_rec_lim: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rx_dscr_rec_lim: u32 = unsafe { ::core::mem::transmute(rx_dscr_rec_lim) };
            rx_dscr_rec_lim as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_36 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_36__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_36__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_36__bindgen_ty_1 {
    #[inline]
    pub fn dat0_crc_err_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dat0_crc_err_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dat1_crc_err_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dat1_crc_err_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dat2_crc_err_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dat2_crc_err_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dat3_crc_err_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dat3_crc_err_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dat0_crc_err_cnt: u32,
        dat1_crc_err_cnt: u32,
        dat2_crc_err_cnt: u32,
        dat3_crc_err_cnt: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let dat0_crc_err_cnt: u32 = unsafe { ::core::mem::transmute(dat0_crc_err_cnt) };
            dat0_crc_err_cnt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let dat1_crc_err_cnt: u32 = unsafe { ::core::mem::transmute(dat1_crc_err_cnt) };
            dat1_crc_err_cnt as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let dat2_crc_err_cnt: u32 = unsafe { ::core::mem::transmute(dat2_crc_err_cnt) };
            dat2_crc_err_cnt as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let dat3_crc_err_cnt: u32 = unsafe { ::core::mem::transmute(dat3_crc_err_cnt) };
            dat3_crc_err_cnt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_37 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_37__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_37__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_37__bindgen_ty_1 {
    #[inline]
    pub fn cmd_crc_err_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_crc_err_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn err_cnt_clr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_err_cnt_clr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cmd_crc_err_cnt: u32,
        reserved8: u32,
        err_cnt_clr: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cmd_crc_err_cnt: u32 = unsafe { ::core::mem::transmute(cmd_crc_err_cnt) };
            cmd_crc_err_cnt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 23u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let err_cnt_clr: u32 = unsafe { ::core::mem::transmute(err_cnt_clr) };
            err_cnt_clr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_38 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_38__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_38__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl slc_dev_s__bindgen_ty_38__bindgen_ty_1 {
    #[inline]
    pub fn rx_dscr_cnt_lat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_cnt_lat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_get_eof_occ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_get_eof_occ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_dscr_cnt_lat: u32,
        reserved10: u32,
        rx_get_eof_occ: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rx_dscr_cnt_lat: u32 = unsafe { ::core::mem::transmute(rx_dscr_cnt_lat) };
            rx_dscr_cnt_lat as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_get_eof_occ: u32 = unsafe { ::core::mem::transmute(rx_get_eof_occ) };
            rx_get_eof_occ as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_39 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_39__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_39__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl slc_dev_s__bindgen_ty_39__bindgen_ty_1 {
    #[inline]
    pub fn len_lim(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_len_lim(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        len_lim: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let len_lim: u32 = unsafe { ::core::mem::transmute(len_lim) };
            len_lim as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_40 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_40__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_40__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_40__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit41(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit41(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit51(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit51(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit61(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit61(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit71(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit71(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_dtc1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_dtc1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_quick_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_quick_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit01: u32,
        frhost_bit11: u32,
        frhost_bit21: u32,
        frhost_bit31: u32,
        frhost_bit41: u32,
        frhost_bit51: u32,
        frhost_bit61: u32,
        frhost_bit71: u32,
        rx_start1: u32,
        tx_start1: u32,
        rx_udf1: u32,
        tx_ovf1: u32,
        token0_1to01: u32,
        token1_1to01: u32,
        tx_done1: u32,
        tx_suc_eof1: u32,
        rx_done1: u32,
        rx_eof1: u32,
        tohost1: u32,
        tx_dscr_err1: u32,
        rx_dscr_err1: u32,
        tx_dscr_empty1: u32,
        host_rd_ack1: u32,
        wr_retry_done1: u32,
        tx_err_eof1: u32,
        cmd_dtc1: u32,
        rx_quick_eof1: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit01: u32 = unsafe { ::core::mem::transmute(frhost_bit01) };
            frhost_bit01 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit11: u32 = unsafe { ::core::mem::transmute(frhost_bit11) };
            frhost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit21: u32 = unsafe { ::core::mem::transmute(frhost_bit21) };
            frhost_bit21 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit31: u32 = unsafe { ::core::mem::transmute(frhost_bit31) };
            frhost_bit31 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit41: u32 = unsafe { ::core::mem::transmute(frhost_bit41) };
            frhost_bit41 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit51: u32 = unsafe { ::core::mem::transmute(frhost_bit51) };
            frhost_bit51 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit61: u32 = unsafe { ::core::mem::transmute(frhost_bit61) };
            frhost_bit61 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit71: u32 = unsafe { ::core::mem::transmute(frhost_bit71) };
            frhost_bit71 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start1: u32 = unsafe { ::core::mem::transmute(rx_start1) };
            rx_start1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start1: u32 = unsafe { ::core::mem::transmute(tx_start1) };
            tx_start1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf1: u32 = unsafe { ::core::mem::transmute(rx_udf1) };
            rx_udf1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf1: u32 = unsafe { ::core::mem::transmute(tx_ovf1) };
            tx_ovf1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to01: u32 = unsafe { ::core::mem::transmute(token0_1to01) };
            token0_1to01 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to01: u32 = unsafe { ::core::mem::transmute(token1_1to01) };
            token1_1to01 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done1: u32 = unsafe { ::core::mem::transmute(tx_done1) };
            tx_done1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof1: u32 = unsafe { ::core::mem::transmute(tx_suc_eof1) };
            tx_suc_eof1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done1: u32 = unsafe { ::core::mem::transmute(rx_done1) };
            rx_done1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof1: u32 = unsafe { ::core::mem::transmute(rx_eof1) };
            rx_eof1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost1: u32 = unsafe { ::core::mem::transmute(tohost1) };
            tohost1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err1: u32 = unsafe { ::core::mem::transmute(tx_dscr_err1) };
            tx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err1: u32 = unsafe { ::core::mem::transmute(rx_dscr_err1) };
            rx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty1: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty1) };
            tx_dscr_empty1 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack1: u32 = unsafe { ::core::mem::transmute(host_rd_ack1) };
            host_rd_ack1 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done1: u32 = unsafe { ::core::mem::transmute(wr_retry_done1) };
            wr_retry_done1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof1: u32 = unsafe { ::core::mem::transmute(tx_err_eof1) };
            tx_err_eof1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let cmd_dtc1: u32 = unsafe { ::core::mem::transmute(cmd_dtc1) };
            cmd_dtc1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rx_quick_eof1: u32 = unsafe { ::core::mem::transmute(rx_quick_eof1) };
            rx_quick_eof1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_41 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_41__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_41__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_41__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit41(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit41(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit51(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit51(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit61(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit61(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit71(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit71(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_dtc1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_dtc1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_quick_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_quick_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit01: u32,
        frhost_bit11: u32,
        frhost_bit21: u32,
        frhost_bit31: u32,
        frhost_bit41: u32,
        frhost_bit51: u32,
        frhost_bit61: u32,
        frhost_bit71: u32,
        rx_start1: u32,
        tx_start1: u32,
        rx_udf1: u32,
        tx_ovf1: u32,
        token0_1to01: u32,
        token1_1to01: u32,
        tx_done1: u32,
        tx_suc_eof1: u32,
        rx_done1: u32,
        rx_eof1: u32,
        tohost1: u32,
        tx_dscr_err1: u32,
        rx_dscr_err1: u32,
        tx_dscr_empty1: u32,
        host_rd_ack1: u32,
        wr_retry_done1: u32,
        tx_err_eof1: u32,
        cmd_dtc1: u32,
        rx_quick_eof1: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit01: u32 = unsafe { ::core::mem::transmute(frhost_bit01) };
            frhost_bit01 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit11: u32 = unsafe { ::core::mem::transmute(frhost_bit11) };
            frhost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit21: u32 = unsafe { ::core::mem::transmute(frhost_bit21) };
            frhost_bit21 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit31: u32 = unsafe { ::core::mem::transmute(frhost_bit31) };
            frhost_bit31 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit41: u32 = unsafe { ::core::mem::transmute(frhost_bit41) };
            frhost_bit41 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit51: u32 = unsafe { ::core::mem::transmute(frhost_bit51) };
            frhost_bit51 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit61: u32 = unsafe { ::core::mem::transmute(frhost_bit61) };
            frhost_bit61 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit71: u32 = unsafe { ::core::mem::transmute(frhost_bit71) };
            frhost_bit71 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start1: u32 = unsafe { ::core::mem::transmute(rx_start1) };
            rx_start1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start1: u32 = unsafe { ::core::mem::transmute(tx_start1) };
            tx_start1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf1: u32 = unsafe { ::core::mem::transmute(rx_udf1) };
            rx_udf1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf1: u32 = unsafe { ::core::mem::transmute(tx_ovf1) };
            tx_ovf1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to01: u32 = unsafe { ::core::mem::transmute(token0_1to01) };
            token0_1to01 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to01: u32 = unsafe { ::core::mem::transmute(token1_1to01) };
            token1_1to01 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done1: u32 = unsafe { ::core::mem::transmute(tx_done1) };
            tx_done1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof1: u32 = unsafe { ::core::mem::transmute(tx_suc_eof1) };
            tx_suc_eof1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done1: u32 = unsafe { ::core::mem::transmute(rx_done1) };
            rx_done1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof1: u32 = unsafe { ::core::mem::transmute(rx_eof1) };
            rx_eof1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost1: u32 = unsafe { ::core::mem::transmute(tohost1) };
            tohost1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err1: u32 = unsafe { ::core::mem::transmute(tx_dscr_err1) };
            tx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err1: u32 = unsafe { ::core::mem::transmute(rx_dscr_err1) };
            rx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty1: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty1) };
            tx_dscr_empty1 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack1: u32 = unsafe { ::core::mem::transmute(host_rd_ack1) };
            host_rd_ack1 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done1: u32 = unsafe { ::core::mem::transmute(wr_retry_done1) };
            wr_retry_done1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof1: u32 = unsafe { ::core::mem::transmute(tx_err_eof1) };
            tx_err_eof1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let cmd_dtc1: u32 = unsafe { ::core::mem::transmute(cmd_dtc1) };
            cmd_dtc1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let rx_quick_eof1: u32 = unsafe { ::core::mem::transmute(rx_quick_eof1) };
            rx_quick_eof1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_42 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_42__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_42__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_42__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit81(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit81(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit91(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit91(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit101(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit101(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit111(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit111(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit121(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit121(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit131(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit131(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit141(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit141(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit151(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit151(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit81: u32,
        frhost_bit91: u32,
        frhost_bit101: u32,
        frhost_bit111: u32,
        frhost_bit121: u32,
        frhost_bit131: u32,
        frhost_bit141: u32,
        frhost_bit151: u32,
        rx_start1: u32,
        tx_start1: u32,
        rx_udf1: u32,
        tx_ovf1: u32,
        token0_1to01: u32,
        token1_1to01: u32,
        tx_done1: u32,
        tx_suc_eof1: u32,
        rx_done1: u32,
        rx_eof1: u32,
        tohost1: u32,
        tx_dscr_err1: u32,
        rx_dscr_err1: u32,
        tx_dscr_empty1: u32,
        host_rd_ack1: u32,
        wr_retry_done1: u32,
        tx_err_eof1: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit81: u32 = unsafe { ::core::mem::transmute(frhost_bit81) };
            frhost_bit81 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit91: u32 = unsafe { ::core::mem::transmute(frhost_bit91) };
            frhost_bit91 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit101: u32 = unsafe { ::core::mem::transmute(frhost_bit101) };
            frhost_bit101 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit111: u32 = unsafe { ::core::mem::transmute(frhost_bit111) };
            frhost_bit111 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit121: u32 = unsafe { ::core::mem::transmute(frhost_bit121) };
            frhost_bit121 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit131: u32 = unsafe { ::core::mem::transmute(frhost_bit131) };
            frhost_bit131 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit141: u32 = unsafe { ::core::mem::transmute(frhost_bit141) };
            frhost_bit141 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit151: u32 = unsafe { ::core::mem::transmute(frhost_bit151) };
            frhost_bit151 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start1: u32 = unsafe { ::core::mem::transmute(rx_start1) };
            rx_start1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start1: u32 = unsafe { ::core::mem::transmute(tx_start1) };
            tx_start1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf1: u32 = unsafe { ::core::mem::transmute(rx_udf1) };
            rx_udf1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf1: u32 = unsafe { ::core::mem::transmute(tx_ovf1) };
            tx_ovf1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to01: u32 = unsafe { ::core::mem::transmute(token0_1to01) };
            token0_1to01 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to01: u32 = unsafe { ::core::mem::transmute(token1_1to01) };
            token1_1to01 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done1: u32 = unsafe { ::core::mem::transmute(tx_done1) };
            tx_done1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof1: u32 = unsafe { ::core::mem::transmute(tx_suc_eof1) };
            tx_suc_eof1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done1: u32 = unsafe { ::core::mem::transmute(rx_done1) };
            rx_done1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof1: u32 = unsafe { ::core::mem::transmute(rx_eof1) };
            rx_eof1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost1: u32 = unsafe { ::core::mem::transmute(tohost1) };
            tohost1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err1: u32 = unsafe { ::core::mem::transmute(tx_dscr_err1) };
            tx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err1: u32 = unsafe { ::core::mem::transmute(rx_dscr_err1) };
            rx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty1: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty1) };
            tx_dscr_empty1 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack1: u32 = unsafe { ::core::mem::transmute(host_rd_ack1) };
            host_rd_ack1 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done1: u32 = unsafe { ::core::mem::transmute(wr_retry_done1) };
            wr_retry_done1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof1: u32 = unsafe { ::core::mem::transmute(tx_err_eof1) };
            tx_err_eof1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slc_dev_s__bindgen_ty_43 {
    pub __bindgen_anon_1: slc_dev_s__bindgen_ty_43__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slc_dev_s__bindgen_ty_43__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl slc_dev_s__bindgen_ty_43__bindgen_ty_1 {
    #[inline]
    pub fn frhost_bit81(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit81(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit91(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit91(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit101(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit101(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit111(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit111(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit121(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit121(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit131(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit131(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit141(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit141(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frhost_bit151(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frhost_bit151(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_suc_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_suc_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dscr_err1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dscr_err1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dscr_empty1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dscr_empty1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_rd_ack1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_rd_ack1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_retry_done1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_retry_done1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_err_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_err_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frhost_bit81: u32,
        frhost_bit91: u32,
        frhost_bit101: u32,
        frhost_bit111: u32,
        frhost_bit121: u32,
        frhost_bit131: u32,
        frhost_bit141: u32,
        frhost_bit151: u32,
        rx_start1: u32,
        tx_start1: u32,
        rx_udf1: u32,
        tx_ovf1: u32,
        token0_1to01: u32,
        token1_1to01: u32,
        tx_done1: u32,
        tx_suc_eof1: u32,
        rx_done1: u32,
        rx_eof1: u32,
        tohost1: u32,
        tx_dscr_err1: u32,
        rx_dscr_err1: u32,
        tx_dscr_empty1: u32,
        host_rd_ack1: u32,
        wr_retry_done1: u32,
        tx_err_eof1: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frhost_bit81: u32 = unsafe { ::core::mem::transmute(frhost_bit81) };
            frhost_bit81 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frhost_bit91: u32 = unsafe { ::core::mem::transmute(frhost_bit91) };
            frhost_bit91 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frhost_bit101: u32 = unsafe { ::core::mem::transmute(frhost_bit101) };
            frhost_bit101 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frhost_bit111: u32 = unsafe { ::core::mem::transmute(frhost_bit111) };
            frhost_bit111 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frhost_bit121: u32 = unsafe { ::core::mem::transmute(frhost_bit121) };
            frhost_bit121 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frhost_bit131: u32 = unsafe { ::core::mem::transmute(frhost_bit131) };
            frhost_bit131 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frhost_bit141: u32 = unsafe { ::core::mem::transmute(frhost_bit141) };
            frhost_bit141 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frhost_bit151: u32 = unsafe { ::core::mem::transmute(frhost_bit151) };
            frhost_bit151 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rx_start1: u32 = unsafe { ::core::mem::transmute(rx_start1) };
            rx_start1 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tx_start1: u32 = unsafe { ::core::mem::transmute(tx_start1) };
            tx_start1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rx_udf1: u32 = unsafe { ::core::mem::transmute(rx_udf1) };
            rx_udf1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_ovf1: u32 = unsafe { ::core::mem::transmute(tx_ovf1) };
            tx_ovf1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let token0_1to01: u32 = unsafe { ::core::mem::transmute(token0_1to01) };
            token0_1to01 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let token1_1to01: u32 = unsafe { ::core::mem::transmute(token1_1to01) };
            token1_1to01 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done1: u32 = unsafe { ::core::mem::transmute(tx_done1) };
            tx_done1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_suc_eof1: u32 = unsafe { ::core::mem::transmute(tx_suc_eof1) };
            tx_suc_eof1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_done1: u32 = unsafe { ::core::mem::transmute(rx_done1) };
            rx_done1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rx_eof1: u32 = unsafe { ::core::mem::transmute(rx_eof1) };
            rx_eof1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let tohost1: u32 = unsafe { ::core::mem::transmute(tohost1) };
            tohost1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let tx_dscr_err1: u32 = unsafe { ::core::mem::transmute(tx_dscr_err1) };
            tx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let rx_dscr_err1: u32 = unsafe { ::core::mem::transmute(rx_dscr_err1) };
            rx_dscr_err1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let tx_dscr_empty1: u32 = unsafe { ::core::mem::transmute(tx_dscr_empty1) };
            tx_dscr_empty1 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let host_rd_ack1: u32 = unsafe { ::core::mem::transmute(host_rd_ack1) };
            host_rd_ack1 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wr_retry_done1: u32 = unsafe { ::core::mem::transmute(wr_retry_done1) };
            wr_retry_done1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let tx_err_eof1: u32 = unsafe { ::core::mem::transmute(tx_err_eof1) };
            tx_err_eof1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type slc_dev_t = slc_dev_s;
extern "C" {
    pub static mut SLC: slc_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct host_dev_s {
    pub reserved_0: u32,
    pub reserved_4: u32,
    pub reserved_8: u32,
    pub reserved_c: u32,
    pub func2_0: host_dev_s__bindgen_ty_1,
    pub func2_1: host_dev_s__bindgen_ty_2,
    pub reserved_18: u32,
    pub reserved_1c: u32,
    pub func2_2: host_dev_s__bindgen_ty_3,
    pub reserved_24: u32,
    pub reserved_28: u32,
    pub reserved_2c: u32,
    pub reserved_30: u32,
    pub gpio_status0: u32,
    pub gpio_status1: host_dev_s__bindgen_ty_4,
    pub gpio_in0: u32,
    pub gpio_in1: host_dev_s__bindgen_ty_5,
    pub slc0_token_rdata: host_dev_s__bindgen_ty_6,
    pub slc0_pf: u32,
    pub slc1_pf: u32,
    pub slc0_int_raw: host_dev_s__bindgen_ty_7,
    pub slc1_int_raw: host_dev_s__bindgen_ty_8,
    pub slc0_int_st: host_dev_s__bindgen_ty_9,
    pub slc1_int_st: host_dev_s__bindgen_ty_10,
    pub pkt_len: host_dev_s__bindgen_ty_11,
    pub state_w0: host_dev_s__bindgen_ty_12,
    pub state_w1: host_dev_s__bindgen_ty_13,
    pub conf_w0: host_dev_s__bindgen_ty_14,
    pub conf_w1: host_dev_s__bindgen_ty_15,
    pub conf_w2: host_dev_s__bindgen_ty_16,
    pub conf_w3: host_dev_s__bindgen_ty_17,
    pub conf_w4: host_dev_s__bindgen_ty_18,
    pub conf_w5: host_dev_s__bindgen_ty_19,
    pub win_cmd: u32,
    pub conf_w6: host_dev_s__bindgen_ty_20,
    pub conf_w7: host_dev_s__bindgen_ty_21,
    pub pkt_len0: host_dev_s__bindgen_ty_22,
    pub pkt_len1: host_dev_s__bindgen_ty_23,
    pub pkt_len2: host_dev_s__bindgen_ty_24,
    pub conf_w8: host_dev_s__bindgen_ty_25,
    pub conf_w9: host_dev_s__bindgen_ty_26,
    pub conf_w10: host_dev_s__bindgen_ty_27,
    pub conf_w11: host_dev_s__bindgen_ty_28,
    pub conf_w12: host_dev_s__bindgen_ty_29,
    pub conf_w13: host_dev_s__bindgen_ty_30,
    pub conf_w14: host_dev_s__bindgen_ty_31,
    pub conf_w15: host_dev_s__bindgen_ty_32,
    pub check_sum0: u32,
    pub check_sum1: u32,
    pub slc1_token_rdata: host_dev_s__bindgen_ty_33,
    pub slc0_token_wdata: host_dev_s__bindgen_ty_34,
    pub slc1_token_wdata: host_dev_s__bindgen_ty_35,
    pub token_con: host_dev_s__bindgen_ty_36,
    pub slc0_int_clr: host_dev_s__bindgen_ty_37,
    pub slc1_int_clr: host_dev_s__bindgen_ty_38,
    pub slc0_func1_int_ena: host_dev_s__bindgen_ty_39,
    pub slc1_func1_int_ena: host_dev_s__bindgen_ty_40,
    pub slc0_func2_int_ena: host_dev_s__bindgen_ty_41,
    pub slc1_func2_int_ena: host_dev_s__bindgen_ty_42,
    pub slc0_int_ena: host_dev_s__bindgen_ty_43,
    pub slc1_int_ena: host_dev_s__bindgen_ty_44,
    pub slc0_rx_infor: host_dev_s__bindgen_ty_45,
    pub slc1_rx_infor: host_dev_s__bindgen_ty_46,
    pub slc0_len_wd: u32,
    pub apbwin_wdata: u32,
    pub apbwin_conf: host_dev_s__bindgen_ty_47,
    pub apbwin_rdata: u32,
    pub slc0_rdclr: host_dev_s__bindgen_ty_48,
    pub slc1_rdclr: host_dev_s__bindgen_ty_49,
    pub slc0_int_ena1: host_dev_s__bindgen_ty_50,
    pub slc1_int_ena1: host_dev_s__bindgen_ty_51,
    pub reserved_11c: u32,
    pub reserved_120: u32,
    pub reserved_124: u32,
    pub reserved_128: u32,
    pub reserved_12c: u32,
    pub reserved_130: u32,
    pub reserved_134: u32,
    pub reserved_138: u32,
    pub reserved_13c: u32,
    pub reserved_140: u32,
    pub reserved_144: u32,
    pub reserved_148: u32,
    pub reserved_14c: u32,
    pub reserved_150: u32,
    pub reserved_154: u32,
    pub reserved_158: u32,
    pub reserved_15c: u32,
    pub reserved_160: u32,
    pub reserved_164: u32,
    pub reserved_168: u32,
    pub reserved_16c: u32,
    pub reserved_170: u32,
    pub reserved_174: u32,
    pub date: u32,
    pub id: u32,
    pub reserved_180: u32,
    pub reserved_184: u32,
    pub reserved_188: u32,
    pub reserved_18c: u32,
    pub reserved_190: u32,
    pub reserved_194: u32,
    pub reserved_198: u32,
    pub reserved_19c: u32,
    pub reserved_1a0: u32,
    pub reserved_1a4: u32,
    pub reserved_1a8: u32,
    pub reserved_1ac: u32,
    pub reserved_1b0: u32,
    pub reserved_1b4: u32,
    pub reserved_1b8: u32,
    pub reserved_1bc: u32,
    pub reserved_1c0: u32,
    pub reserved_1c4: u32,
    pub reserved_1c8: u32,
    pub reserved_1cc: u32,
    pub reserved_1d0: u32,
    pub reserved_1d4: u32,
    pub reserved_1d8: u32,
    pub reserved_1dc: u32,
    pub reserved_1e0: u32,
    pub reserved_1e4: u32,
    pub reserved_1e8: u32,
    pub reserved_1ec: u32,
    pub conf: host_dev_s__bindgen_ty_52,
    pub inf_st: host_dev_s__bindgen_ty_53,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn func2_int(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_func2_int(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        func2_int: u32,
        reserved25: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let func2_int: u32 = unsafe { ::core::mem::transmute(func2_int) };
            func2_int as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved25: u32 = unsafe { ::core::mem::transmute(reserved25) };
            reserved25 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn func2_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_func2_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func2_int_en: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let func2_int_en: u32 = unsafe { ::core::mem::transmute(func2_int_en) };
            func2_int_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn func1_mdstat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_func1_mdstat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func1_mdstat: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let func1_mdstat: u32 = unsafe { ::core::mem::transmute(func1_mdstat) };
            func1_mdstat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn sdio_int1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_int1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sdio_int1: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sdio_int1: u32 = unsafe { ::core::mem::transmute(sdio_int1) };
            sdio_int1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn sdio_in1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_in1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sdio_in1: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sdio_in1: u32 = unsafe { ::core::mem::transmute(sdio_in1) };
            sdio_in1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl host_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn token0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reg_token1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reg_token1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        token0: u32,
        rx_pf_valid: u32,
        reserved13: u32,
        reg_token1: u32,
        rx_pf_eof: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let token0: u32 = unsafe { ::core::mem::transmute(token0) };
            token0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved13: u32 = unsafe { ::core::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reg_token1: u32 = unsafe { ::core::mem::transmute(reg_token1) };
            reg_token1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let rx_pf_eof: u32 = unsafe { ::core::mem::transmute(rx_pf_eof) };
            rx_pf_eof as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        rx_new_packet: u32,
        rd_retry: u32,
        gpio_sdio: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_new_packet: u32 = unsafe { ::core::mem::transmute(rx_new_packet) };
            rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let gpio_sdio: u32 = unsafe { ::core::mem::transmute(gpio_sdio) };
            gpio_sdio as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        wifi_rx_new_packet: u32,
        rd_retry: u32,
        bt_rx_new_packet: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wifi_rx_new_packet: u32 = unsafe { ::core::mem::transmute(wifi_rx_new_packet) };
            wifi_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bt_rx_new_packet: u32 = unsafe { ::core::mem::transmute(bt_rx_new_packet) };
            bt_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        rx_new_packet: u32,
        rd_retry: u32,
        gpio_sdio: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_new_packet: u32 = unsafe { ::core::mem::transmute(rx_new_packet) };
            rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let gpio_sdio: u32 = unsafe { ::core::mem::transmute(gpio_sdio) };
            gpio_sdio as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        wifi_rx_new_packet: u32,
        rd_retry: u32,
        bt_rx_new_packet: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wifi_rx_new_packet: u32 = unsafe { ::core::mem::transmute(wifi_rx_new_packet) };
            wifi_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bt_rx_new_packet: u32 = unsafe { ::core::mem::transmute(bt_rx_new_packet) };
            bt_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn reg_slc0_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reg_slc0_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reg_slc0_len_check(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reg_slc0_len_check(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reg_slc0_len: u32,
        reg_slc0_len_check: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reg_slc0_len: u32 = unsafe { ::core::mem::transmute(reg_slc0_len) };
            reg_slc0_len as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reg_slc0_len_check: u32 = unsafe { ::core::mem::transmute(reg_slc0_len_check) };
            reg_slc0_len_check as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn state0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state0: u32,
        state1: u32,
        state2: u32,
        state3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state0: u32 = unsafe { ::core::mem::transmute(state0) };
            state0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let state1: u32 = unsafe { ::core::mem::transmute(state1) };
            state1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let state2: u32 = unsafe { ::core::mem::transmute(state2) };
            state2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let state3: u32 = unsafe { ::core::mem::transmute(state3) };
            state3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn state4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state4: u32,
        state5: u32,
        state6: u32,
        state7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state4: u32 = unsafe { ::core::mem::transmute(state4) };
            state4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let state5: u32 = unsafe { ::core::mem::transmute(state5) };
            state5 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let state6: u32 = unsafe { ::core::mem::transmute(state6) };
            state6 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let state7: u32 = unsafe { ::core::mem::transmute(state7) };
            state7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn conf0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf0: u32,
        conf1: u32,
        conf2: u32,
        conf3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf0: u32 = unsafe { ::core::mem::transmute(conf0) };
            conf0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf1: u32 = unsafe { ::core::mem::transmute(conf1) };
            conf1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf2: u32 = unsafe { ::core::mem::transmute(conf2) };
            conf2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf3: u32 = unsafe { ::core::mem::transmute(conf3) };
            conf3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn conf4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf4: u32,
        conf5: u32,
        conf6: u32,
        conf7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf4: u32 = unsafe { ::core::mem::transmute(conf4) };
            conf4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf5: u32 = unsafe { ::core::mem::transmute(conf5) };
            conf5 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf6: u32 = unsafe { ::core::mem::transmute(conf6) };
            conf6 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf7: u32 = unsafe { ::core::mem::transmute(conf7) };
            conf7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn conf8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf8: u32,
        conf9: u32,
        conf10: u32,
        conf11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf8: u32 = unsafe { ::core::mem::transmute(conf8) };
            conf8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf9: u32 = unsafe { ::core::mem::transmute(conf9) };
            conf9 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf10: u32 = unsafe { ::core::mem::transmute(conf10) };
            conf10 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf11: u32 = unsafe { ::core::mem::transmute(conf11) };
            conf11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn conf12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf12: u32,
        conf13: u32,
        conf14: u32,
        conf15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf12: u32 = unsafe { ::core::mem::transmute(conf12) };
            conf12 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf13: u32 = unsafe { ::core::mem::transmute(conf13) };
            conf13 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf14: u32 = unsafe { ::core::mem::transmute(conf14) };
            conf14 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf15: u32 = unsafe { ::core::mem::transmute(conf15) };
            conf15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn conf16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf16: u32,
        conf17: u32,
        conf18: u32,
        conf19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf16: u32 = unsafe { ::core::mem::transmute(conf16) };
            conf16 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf17: u32 = unsafe { ::core::mem::transmute(conf17) };
            conf17 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf18: u32 = unsafe { ::core::mem::transmute(conf18) };
            conf18 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf19: u32 = unsafe { ::core::mem::transmute(conf19) };
            conf19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn conf20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf22(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf22(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf20: u32,
        conf21: u32,
        conf22: u32,
        conf23: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf20: u32 = unsafe { ::core::mem::transmute(conf20) };
            conf20 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf21: u32 = unsafe { ::core::mem::transmute(conf21) };
            conf21 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf22: u32 = unsafe { ::core::mem::transmute(conf22) };
            conf22 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf23: u32 = unsafe { ::core::mem::transmute(conf23) };
            conf23 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn conf24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf24: u32,
        conf25: u32,
        conf26: u32,
        conf27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf24: u32 = unsafe { ::core::mem::transmute(conf24) };
            conf24 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf25: u32 = unsafe { ::core::mem::transmute(conf25) };
            conf25 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf26: u32 = unsafe { ::core::mem::transmute(conf26) };
            conf26 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf27: u32 = unsafe { ::core::mem::transmute(conf27) };
            conf27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn conf28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf30(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf28: u32,
        conf29: u32,
        conf30: u32,
        conf31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf28: u32 = unsafe { ::core::mem::transmute(conf28) };
            conf28 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf29: u32 = unsafe { ::core::mem::transmute(conf29) };
            conf29 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf30: u32 = unsafe { ::core::mem::transmute(conf30) };
            conf30 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf31: u32 = unsafe { ::core::mem::transmute(conf31) };
            conf31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn reg_slc0_len0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reg_slc0_len0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reg_slc0_len0: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reg_slc0_len0: u32 = unsafe { ::core::mem::transmute(reg_slc0_len0) };
            reg_slc0_len0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn reg_slc0_len1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reg_slc0_len1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reg_slc0_len1: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reg_slc0_len1: u32 = unsafe { ::core::mem::transmute(reg_slc0_len1) };
            reg_slc0_len1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn reg_slc0_len2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reg_slc0_len2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reg_slc0_len2: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let reg_slc0_len2: u32 = unsafe { ::core::mem::transmute(reg_slc0_len2) };
            reg_slc0_len2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn conf32(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf32(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf33(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf33(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf34(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf34(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf35(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf35(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf32: u32,
        conf33: u32,
        conf34: u32,
        conf35: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf32: u32 = unsafe { ::core::mem::transmute(conf32) };
            conf32 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf33: u32 = unsafe { ::core::mem::transmute(conf33) };
            conf33 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf34: u32 = unsafe { ::core::mem::transmute(conf34) };
            conf34 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf35: u32 = unsafe { ::core::mem::transmute(conf35) };
            conf35 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn conf36(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf36(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf37(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf37(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf38(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf38(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf39(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf39(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf36: u32,
        conf37: u32,
        conf38: u32,
        conf39: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf36: u32 = unsafe { ::core::mem::transmute(conf36) };
            conf36 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf37: u32 = unsafe { ::core::mem::transmute(conf37) };
            conf37 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf38: u32 = unsafe { ::core::mem::transmute(conf38) };
            conf38 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf39: u32 = unsafe { ::core::mem::transmute(conf39) };
            conf39 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn conf40(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf40(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf41(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf41(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf42(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf42(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf43(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf43(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf40: u32,
        conf41: u32,
        conf42: u32,
        conf43: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf40: u32 = unsafe { ::core::mem::transmute(conf40) };
            conf40 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf41: u32 = unsafe { ::core::mem::transmute(conf41) };
            conf41 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf42: u32 = unsafe { ::core::mem::transmute(conf42) };
            conf42 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf43: u32 = unsafe { ::core::mem::transmute(conf43) };
            conf43 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn conf44(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf44(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf45(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf45(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf46(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf46(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf47(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf47(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf44: u32,
        conf45: u32,
        conf46: u32,
        conf47: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf44: u32 = unsafe { ::core::mem::transmute(conf44) };
            conf44 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf45: u32 = unsafe { ::core::mem::transmute(conf45) };
            conf45 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf46: u32 = unsafe { ::core::mem::transmute(conf46) };
            conf46 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf47: u32 = unsafe { ::core::mem::transmute(conf47) };
            conf47 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn conf48(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf48(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf49(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf49(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf50(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf50(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf51(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf51(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf48: u32,
        conf49: u32,
        conf50: u32,
        conf51: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf48: u32 = unsafe { ::core::mem::transmute(conf48) };
            conf48 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf49: u32 = unsafe { ::core::mem::transmute(conf49) };
            conf49 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf50: u32 = unsafe { ::core::mem::transmute(conf50) };
            conf50 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf51: u32 = unsafe { ::core::mem::transmute(conf51) };
            conf51 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn conf52(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf52(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf53(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf53(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf54(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf54(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf55(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf55(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf52: u32,
        conf53: u32,
        conf54: u32,
        conf55: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf52: u32 = unsafe { ::core::mem::transmute(conf52) };
            conf52 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf53: u32 = unsafe { ::core::mem::transmute(conf53) };
            conf53 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf54: u32 = unsafe { ::core::mem::transmute(conf54) };
            conf54 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf55: u32 = unsafe { ::core::mem::transmute(conf55) };
            conf55 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn conf56(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf56(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf57(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf57(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf58(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf58(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf59(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf59(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf56: u32,
        conf57: u32,
        conf58: u32,
        conf59: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf56: u32 = unsafe { ::core::mem::transmute(conf56) };
            conf56 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf57: u32 = unsafe { ::core::mem::transmute(conf57) };
            conf57 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf58: u32 = unsafe { ::core::mem::transmute(conf58) };
            conf58 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf59: u32 = unsafe { ::core::mem::transmute(conf59) };
            conf59 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_32 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_32__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_32__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_32__bindgen_ty_1 {
    #[inline]
    pub fn conf60(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf60(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf61(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf61(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf62(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf62(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn conf63(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_conf63(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conf60: u32,
        conf61: u32,
        conf62: u32,
        conf63: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let conf60: u32 = unsafe { ::core::mem::transmute(conf60) };
            conf60 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let conf61: u32 = unsafe { ::core::mem::transmute(conf61) };
            conf61 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let conf62: u32 = unsafe { ::core::mem::transmute(conf62) };
            conf62 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let conf63: u32 = unsafe { ::core::mem::transmute(conf63) };
            conf63 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_33 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_33__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_33__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl host_dev_s__bindgen_ty_33__bindgen_ty_1 {
    #[inline]
    pub fn token0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reg_token1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reg_token1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        token0: u32,
        rx_pf_valid: u32,
        reserved13: u32,
        reg_token1: u32,
        rx_pf_eof: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let token0: u32 = unsafe { ::core::mem::transmute(token0) };
            token0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved13: u32 = unsafe { ::core::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reg_token1: u32 = unsafe { ::core::mem::transmute(reg_token1) };
            reg_token1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let rx_pf_eof: u32 = unsafe { ::core::mem::transmute(rx_pf_eof) };
            rx_pf_eof as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_34 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_34__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_34__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl host_dev_s__bindgen_ty_34__bindgen_ty_1 {
    #[inline]
    pub fn token0_wd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token0_wd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_wd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token1_wd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        token0_wd: u32,
        reserved12: u32,
        token1_wd: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let token0_wd: u32 = unsafe { ::core::mem::transmute(token0_wd) };
            token0_wd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let token1_wd: u32 = unsafe { ::core::mem::transmute(token1_wd) };
            token1_wd as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_35 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_35__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_35__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl host_dev_s__bindgen_ty_35__bindgen_ty_1 {
    #[inline]
    pub fn token0_wd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token0_wd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_wd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_token1_wd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        token0_wd: u32,
        reserved12: u32,
        token1_wd: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let token0_wd: u32 = unsafe { ::core::mem::transmute(token0_wd) };
            token0_wd as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let token1_wd: u32 = unsafe { ::core::mem::transmute(token1_wd) };
            token1_wd as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_36 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_36__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_36__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_36__bindgen_ty_1 {
    #[inline]
    pub fn slc0_token0_dec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token0_dec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_token1_dec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token1_dec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_token0_wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token0_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_token1_wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_token1_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token0_dec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token0_dec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token1_dec(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token1_dec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token0_wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token0_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc1_token1_wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc1_token1_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slc0_len_wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slc0_len_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slc0_token0_dec: u32,
        slc0_token1_dec: u32,
        slc0_token0_wr: u32,
        slc0_token1_wr: u32,
        slc1_token0_dec: u32,
        slc1_token1_dec: u32,
        slc1_token0_wr: u32,
        slc1_token1_wr: u32,
        slc0_len_wr: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slc0_token0_dec: u32 = unsafe { ::core::mem::transmute(slc0_token0_dec) };
            slc0_token0_dec as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slc0_token1_dec: u32 = unsafe { ::core::mem::transmute(slc0_token1_dec) };
            slc0_token1_dec as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let slc0_token0_wr: u32 = unsafe { ::core::mem::transmute(slc0_token0_wr) };
            slc0_token0_wr as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slc0_token1_wr: u32 = unsafe { ::core::mem::transmute(slc0_token1_wr) };
            slc0_token1_wr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let slc1_token0_dec: u32 = unsafe { ::core::mem::transmute(slc1_token0_dec) };
            slc1_token0_dec as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let slc1_token1_dec: u32 = unsafe { ::core::mem::transmute(slc1_token1_dec) };
            slc1_token1_dec as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let slc1_token0_wr: u32 = unsafe { ::core::mem::transmute(slc1_token0_wr) };
            slc1_token0_wr as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let slc1_token1_wr: u32 = unsafe { ::core::mem::transmute(slc1_token1_wr) };
            slc1_token1_wr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let slc0_len_wr: u32 = unsafe { ::core::mem::transmute(slc0_len_wr) };
            slc0_len_wr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_37 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_37__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_37__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_37__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        rx_new_packet: u32,
        rd_retry: u32,
        gpio_sdio: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_new_packet: u32 = unsafe { ::core::mem::transmute(rx_new_packet) };
            rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let gpio_sdio: u32 = unsafe { ::core::mem::transmute(gpio_sdio) };
            gpio_sdio as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_38 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_38__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_38__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_38__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        wifi_rx_new_packet: u32,
        rd_retry: u32,
        bt_rx_new_packet: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wifi_rx_new_packet: u32 = unsafe { ::core::mem::transmute(wifi_rx_new_packet) };
            wifi_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bt_rx_new_packet: u32 = unsafe { ::core::mem::transmute(bt_rx_new_packet) };
            bt_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_39 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_39__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_39__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_39__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        rx_new_packet: u32,
        rd_retry: u32,
        gpio_sdio: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_new_packet: u32 = unsafe { ::core::mem::transmute(rx_new_packet) };
            rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let gpio_sdio: u32 = unsafe { ::core::mem::transmute(gpio_sdio) };
            gpio_sdio as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_40 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_40__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_40__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_40__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        wifi_rx_new_packet: u32,
        rd_retry: u32,
        bt_rx_new_packet: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wifi_rx_new_packet: u32 = unsafe { ::core::mem::transmute(wifi_rx_new_packet) };
            wifi_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bt_rx_new_packet: u32 = unsafe { ::core::mem::transmute(bt_rx_new_packet) };
            bt_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_41 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_41__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_41__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_41__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        rx_new_packet: u32,
        rd_retry: u32,
        gpio_sdio: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_new_packet: u32 = unsafe { ::core::mem::transmute(rx_new_packet) };
            rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let gpio_sdio: u32 = unsafe { ::core::mem::transmute(gpio_sdio) };
            gpio_sdio as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_42 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_42__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_42__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_42__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        wifi_rx_new_packet: u32,
        rd_retry: u32,
        bt_rx_new_packet: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wifi_rx_new_packet: u32 = unsafe { ::core::mem::transmute(wifi_rx_new_packet) };
            wifi_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bt_rx_new_packet: u32 = unsafe { ::core::mem::transmute(bt_rx_new_packet) };
            bt_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_43 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_43__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_43__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_43__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        rx_new_packet: u32,
        rd_retry: u32,
        gpio_sdio: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_new_packet: u32 = unsafe { ::core::mem::transmute(rx_new_packet) };
            rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let gpio_sdio: u32 = unsafe { ::core::mem::transmute(gpio_sdio) };
            gpio_sdio as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_44 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_44__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_44__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_44__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_rx_new_packet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_rx_new_packet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit0: u32,
        tohost_bit1: u32,
        tohost_bit2: u32,
        tohost_bit3: u32,
        tohost_bit4: u32,
        tohost_bit5: u32,
        tohost_bit6: u32,
        tohost_bit7: u32,
        token0_1to0: u32,
        token1_1to0: u32,
        token0_0to1: u32,
        token1_0to1: u32,
        rx_sof: u32,
        rx_eof: u32,
        rx_start: u32,
        tx_start: u32,
        rx_udf: u32,
        tx_ovf: u32,
        rx_pf_valid: u32,
        ext_bit0: u32,
        ext_bit1: u32,
        ext_bit2: u32,
        ext_bit3: u32,
        wifi_rx_new_packet: u32,
        rd_retry: u32,
        bt_rx_new_packet: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit0: u32 = unsafe { ::core::mem::transmute(tohost_bit0) };
            tohost_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit1: u32 = unsafe { ::core::mem::transmute(tohost_bit1) };
            tohost_bit1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit2: u32 = unsafe { ::core::mem::transmute(tohost_bit2) };
            tohost_bit2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit3: u32 = unsafe { ::core::mem::transmute(tohost_bit3) };
            tohost_bit3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit4: u32 = unsafe { ::core::mem::transmute(tohost_bit4) };
            tohost_bit4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit5: u32 = unsafe { ::core::mem::transmute(tohost_bit5) };
            tohost_bit5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit6: u32 = unsafe { ::core::mem::transmute(tohost_bit6) };
            tohost_bit6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit7: u32 = unsafe { ::core::mem::transmute(tohost_bit7) };
            tohost_bit7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to0: u32 = unsafe { ::core::mem::transmute(token0_1to0) };
            token0_1to0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to0: u32 = unsafe { ::core::mem::transmute(token1_1to0) };
            token1_1to0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to1: u32 = unsafe { ::core::mem::transmute(token0_0to1) };
            token0_0to1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to1: u32 = unsafe { ::core::mem::transmute(token1_0to1) };
            token1_0to1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof: u32 = unsafe { ::core::mem::transmute(rx_sof) };
            rx_sof as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof: u32 = unsafe { ::core::mem::transmute(rx_eof) };
            rx_eof as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start: u32 = unsafe { ::core::mem::transmute(rx_start) };
            rx_start as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start: u32 = unsafe { ::core::mem::transmute(tx_start) };
            tx_start as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf: u32 = unsafe { ::core::mem::transmute(rx_udf) };
            rx_udf as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf: u32 = unsafe { ::core::mem::transmute(tx_ovf) };
            tx_ovf as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid: u32 = unsafe { ::core::mem::transmute(rx_pf_valid) };
            rx_pf_valid as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit0: u32 = unsafe { ::core::mem::transmute(ext_bit0) };
            ext_bit0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit1: u32 = unsafe { ::core::mem::transmute(ext_bit1) };
            ext_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit2: u32 = unsafe { ::core::mem::transmute(ext_bit2) };
            ext_bit2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit3: u32 = unsafe { ::core::mem::transmute(ext_bit3) };
            ext_bit3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wifi_rx_new_packet: u32 = unsafe { ::core::mem::transmute(wifi_rx_new_packet) };
            wifi_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry: u32 = unsafe { ::core::mem::transmute(rd_retry) };
            rd_retry as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bt_rx_new_packet: u32 = unsafe { ::core::mem::transmute(bt_rx_new_packet) };
            bt_rx_new_packet as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_45 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_45__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_45__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_45__bindgen_ty_1 {
    #[inline]
    pub fn infor(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_infor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(infor: u32, reserved20: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let infor: u32 = unsafe { ::core::mem::transmute(infor) };
            infor as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_46 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_46__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_46__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_46__bindgen_ty_1 {
    #[inline]
    pub fn infor(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_infor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(infor: u32, reserved20: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let infor: u32 = unsafe { ::core::mem::transmute(infor) };
            infor as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_47 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_47__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_47__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_47__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn wr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved30(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved30(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        wr: u32,
        start: u32,
        reserved30: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let wr: u32 = unsafe { ::core::mem::transmute(wr) };
            wr as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved30: u32 = unsafe { ::core::mem::transmute(reserved30) };
            reserved30 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_48 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_48__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_48__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl host_dev_s__bindgen_ty_48__bindgen_ty_1 {
    #[inline]
    pub fn bit7_clraddr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_bit7_clraddr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn bit6_clraddr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_bit6_clraddr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bit7_clraddr: u32,
        bit6_clraddr: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let bit7_clraddr: u32 = unsafe { ::core::mem::transmute(bit7_clraddr) };
            bit7_clraddr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 9u8, {
            let bit6_clraddr: u32 = unsafe { ::core::mem::transmute(bit6_clraddr) };
            bit6_clraddr as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_49 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_49__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_49__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl host_dev_s__bindgen_ty_49__bindgen_ty_1 {
    #[inline]
    pub fn bit7_clraddr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_bit7_clraddr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn bit6_clraddr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_bit6_clraddr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bit7_clraddr: u32,
        bit6_clraddr: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let bit7_clraddr: u32 = unsafe { ::core::mem::transmute(bit7_clraddr) };
            bit7_clraddr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 9u8, {
            let bit6_clraddr: u32 = unsafe { ::core::mem::transmute(bit6_clraddr) };
            bit6_clraddr as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_50 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_50__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_50__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_50__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit41(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit41(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit51(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit51(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit61(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit61(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit71(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit71(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_new_packet1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_new_packet1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_sdio1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpio_sdio1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit01: u32,
        tohost_bit11: u32,
        tohost_bit21: u32,
        tohost_bit31: u32,
        tohost_bit41: u32,
        tohost_bit51: u32,
        tohost_bit61: u32,
        tohost_bit71: u32,
        token0_1to01: u32,
        token1_1to01: u32,
        token0_0to11: u32,
        token1_0to11: u32,
        rx_sof1: u32,
        rx_eof1: u32,
        rx_start1: u32,
        tx_start1: u32,
        rx_udf1: u32,
        tx_ovf1: u32,
        rx_pf_valid1: u32,
        ext_bit01: u32,
        ext_bit11: u32,
        ext_bit21: u32,
        ext_bit31: u32,
        rx_new_packet1: u32,
        rd_retry1: u32,
        gpio_sdio1: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit01: u32 = unsafe { ::core::mem::transmute(tohost_bit01) };
            tohost_bit01 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit11: u32 = unsafe { ::core::mem::transmute(tohost_bit11) };
            tohost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit21: u32 = unsafe { ::core::mem::transmute(tohost_bit21) };
            tohost_bit21 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit31: u32 = unsafe { ::core::mem::transmute(tohost_bit31) };
            tohost_bit31 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit41: u32 = unsafe { ::core::mem::transmute(tohost_bit41) };
            tohost_bit41 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit51: u32 = unsafe { ::core::mem::transmute(tohost_bit51) };
            tohost_bit51 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit61: u32 = unsafe { ::core::mem::transmute(tohost_bit61) };
            tohost_bit61 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit71: u32 = unsafe { ::core::mem::transmute(tohost_bit71) };
            tohost_bit71 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to01: u32 = unsafe { ::core::mem::transmute(token0_1to01) };
            token0_1to01 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to01: u32 = unsafe { ::core::mem::transmute(token1_1to01) };
            token1_1to01 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to11: u32 = unsafe { ::core::mem::transmute(token0_0to11) };
            token0_0to11 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to11: u32 = unsafe { ::core::mem::transmute(token1_0to11) };
            token1_0to11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof1: u32 = unsafe { ::core::mem::transmute(rx_sof1) };
            rx_sof1 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof1: u32 = unsafe { ::core::mem::transmute(rx_eof1) };
            rx_eof1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start1: u32 = unsafe { ::core::mem::transmute(rx_start1) };
            rx_start1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start1: u32 = unsafe { ::core::mem::transmute(tx_start1) };
            tx_start1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf1: u32 = unsafe { ::core::mem::transmute(rx_udf1) };
            rx_udf1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf1: u32 = unsafe { ::core::mem::transmute(tx_ovf1) };
            tx_ovf1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid1: u32 = unsafe { ::core::mem::transmute(rx_pf_valid1) };
            rx_pf_valid1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit01: u32 = unsafe { ::core::mem::transmute(ext_bit01) };
            ext_bit01 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit11: u32 = unsafe { ::core::mem::transmute(ext_bit11) };
            ext_bit11 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit21: u32 = unsafe { ::core::mem::transmute(ext_bit21) };
            ext_bit21 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit31: u32 = unsafe { ::core::mem::transmute(ext_bit31) };
            ext_bit31 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_new_packet1: u32 = unsafe { ::core::mem::transmute(rx_new_packet1) };
            rx_new_packet1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry1: u32 = unsafe { ::core::mem::transmute(rd_retry1) };
            rd_retry1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let gpio_sdio1: u32 = unsafe { ::core::mem::transmute(gpio_sdio1) };
            gpio_sdio1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_51 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_51__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_51__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_51__bindgen_ty_1 {
    #[inline]
    pub fn tohost_bit01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit41(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit41(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit51(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit51(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit61(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit61(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tohost_bit71(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tohost_bit71(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_1to01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_1to01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token0_0to11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token0_0to11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn token1_0to11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_token1_0to11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_sof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_sof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_eof1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_eof1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_start1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_start1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_udf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_udf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_ovf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_ovf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_pf_valid1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_pf_valid1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit01(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit01(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_bit31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ext_bit31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_rx_new_packet1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_rx_new_packet1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_retry1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_retry1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bt_rx_new_packet1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bt_rx_new_packet1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved26(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved26(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tohost_bit01: u32,
        tohost_bit11: u32,
        tohost_bit21: u32,
        tohost_bit31: u32,
        tohost_bit41: u32,
        tohost_bit51: u32,
        tohost_bit61: u32,
        tohost_bit71: u32,
        token0_1to01: u32,
        token1_1to01: u32,
        token0_0to11: u32,
        token1_0to11: u32,
        rx_sof1: u32,
        rx_eof1: u32,
        rx_start1: u32,
        tx_start1: u32,
        rx_udf1: u32,
        tx_ovf1: u32,
        rx_pf_valid1: u32,
        ext_bit01: u32,
        ext_bit11: u32,
        ext_bit21: u32,
        ext_bit31: u32,
        wifi_rx_new_packet1: u32,
        rd_retry1: u32,
        bt_rx_new_packet1: u32,
        reserved26: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tohost_bit01: u32 = unsafe { ::core::mem::transmute(tohost_bit01) };
            tohost_bit01 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tohost_bit11: u32 = unsafe { ::core::mem::transmute(tohost_bit11) };
            tohost_bit11 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tohost_bit21: u32 = unsafe { ::core::mem::transmute(tohost_bit21) };
            tohost_bit21 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tohost_bit31: u32 = unsafe { ::core::mem::transmute(tohost_bit31) };
            tohost_bit31 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tohost_bit41: u32 = unsafe { ::core::mem::transmute(tohost_bit41) };
            tohost_bit41 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tohost_bit51: u32 = unsafe { ::core::mem::transmute(tohost_bit51) };
            tohost_bit51 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tohost_bit61: u32 = unsafe { ::core::mem::transmute(tohost_bit61) };
            tohost_bit61 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tohost_bit71: u32 = unsafe { ::core::mem::transmute(tohost_bit71) };
            tohost_bit71 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let token0_1to01: u32 = unsafe { ::core::mem::transmute(token0_1to01) };
            token0_1to01 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let token1_1to01: u32 = unsafe { ::core::mem::transmute(token1_1to01) };
            token1_1to01 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let token0_0to11: u32 = unsafe { ::core::mem::transmute(token0_0to11) };
            token0_0to11 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let token1_0to11: u32 = unsafe { ::core::mem::transmute(token1_0to11) };
            token1_0to11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rx_sof1: u32 = unsafe { ::core::mem::transmute(rx_sof1) };
            rx_sof1 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rx_eof1: u32 = unsafe { ::core::mem::transmute(rx_eof1) };
            rx_eof1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rx_start1: u32 = unsafe { ::core::mem::transmute(rx_start1) };
            rx_start1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_start1: u32 = unsafe { ::core::mem::transmute(tx_start1) };
            tx_start1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rx_udf1: u32 = unsafe { ::core::mem::transmute(rx_udf1) };
            rx_udf1 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tx_ovf1: u32 = unsafe { ::core::mem::transmute(tx_ovf1) };
            tx_ovf1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let rx_pf_valid1: u32 = unsafe { ::core::mem::transmute(rx_pf_valid1) };
            rx_pf_valid1 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let ext_bit01: u32 = unsafe { ::core::mem::transmute(ext_bit01) };
            ext_bit01 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ext_bit11: u32 = unsafe { ::core::mem::transmute(ext_bit11) };
            ext_bit11 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let ext_bit21: u32 = unsafe { ::core::mem::transmute(ext_bit21) };
            ext_bit21 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let ext_bit31: u32 = unsafe { ::core::mem::transmute(ext_bit31) };
            ext_bit31 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let wifi_rx_new_packet1: u32 = unsafe { ::core::mem::transmute(wifi_rx_new_packet1) };
            wifi_rx_new_packet1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rd_retry1: u32 = unsafe { ::core::mem::transmute(rd_retry1) };
            rd_retry1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let bt_rx_new_packet1: u32 = unsafe { ::core::mem::transmute(bt_rx_new_packet1) };
            bt_rx_new_packet1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved26: u32 = unsafe { ::core::mem::transmute(reserved26) };
            reserved26 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_52 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_52__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_52__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl host_dev_s__bindgen_ty_52__bindgen_ty_1 {
    #[inline]
    pub fn frc_sdio11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_frc_sdio11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn frc_sdio20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_frc_sdio20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn frc_neg_samp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_frc_neg_samp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn frc_pos_samp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_frc_pos_samp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn frc_quick_in(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_frc_quick_in(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio20_int_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio20_int_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_pad_pullup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_pad_pullup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hspeed_con_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hspeed_con_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frc_sdio11: u32,
        frc_sdio20: u32,
        frc_neg_samp: u32,
        frc_pos_samp: u32,
        frc_quick_in: u32,
        sdio20_int_delay: u32,
        sdio_pad_pullup: u32,
        hspeed_con_en: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let frc_sdio11: u32 = unsafe { ::core::mem::transmute(frc_sdio11) };
            frc_sdio11 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let frc_sdio20: u32 = unsafe { ::core::mem::transmute(frc_sdio20) };
            frc_sdio20 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let frc_neg_samp: u32 = unsafe { ::core::mem::transmute(frc_neg_samp) };
            frc_neg_samp as u64
        });
        __bindgen_bitfield_unit.set(15usize, 5u8, {
            let frc_pos_samp: u32 = unsafe { ::core::mem::transmute(frc_pos_samp) };
            frc_pos_samp as u64
        });
        __bindgen_bitfield_unit.set(20usize, 5u8, {
            let frc_quick_in: u32 = unsafe { ::core::mem::transmute(frc_quick_in) };
            frc_quick_in as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let sdio20_int_delay: u32 = unsafe { ::core::mem::transmute(sdio20_int_delay) };
            sdio20_int_delay as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sdio_pad_pullup: u32 = unsafe { ::core::mem::transmute(sdio_pad_pullup) };
            sdio_pad_pullup as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let hspeed_con_en: u32 = unsafe { ::core::mem::transmute(hspeed_con_en) };
            hspeed_con_en as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union host_dev_s__bindgen_ty_53 {
    pub __bindgen_anon_1: host_dev_s__bindgen_ty_53__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct host_dev_s__bindgen_ty_53__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl host_dev_s__bindgen_ty_53__bindgen_ty_1 {
    #[inline]
    pub fn sdio20_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sdio20_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_neg_samp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_neg_samp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_quick_in(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_quick_in(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sdio20_mode: u32,
        sdio_neg_samp: u32,
        sdio_quick_in: u32,
        reserved15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let sdio20_mode: u32 = unsafe { ::core::mem::transmute(sdio20_mode) };
            sdio20_mode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let sdio_neg_samp: u32 = unsafe { ::core::mem::transmute(sdio_neg_samp) };
            sdio_neg_samp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let sdio_quick_in: u32 = unsafe { ::core::mem::transmute(sdio_quick_in) };
            sdio_quick_in as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type host_dev_t = host_dev_s;
extern "C" {
    pub static mut HOST: host_dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hinf_dev_s {
    pub cfg_data0: hinf_dev_s__bindgen_ty_1,
    pub cfg_data1: hinf_dev_s__bindgen_ty_2,
    pub reserved_8: u32,
    pub reserved_c: u32,
    pub reserved_10: u32,
    pub reserved_14: u32,
    pub reserved_18: u32,
    pub cfg_data7: hinf_dev_s__bindgen_ty_3,
    pub cis_conf0: u32,
    pub cis_conf1: u32,
    pub cis_conf2: u32,
    pub cis_conf3: u32,
    pub cis_conf4: u32,
    pub cis_conf5: u32,
    pub cis_conf6: u32,
    pub cis_conf7: u32,
    pub cfg_data16: hinf_dev_s__bindgen_ty_4,
    pub reserved_44: u32,
    pub reserved_48: u32,
    pub reserved_4c: u32,
    pub reserved_50: u32,
    pub reserved_54: u32,
    pub reserved_58: u32,
    pub reserved_5c: u32,
    pub reserved_60: u32,
    pub reserved_64: u32,
    pub reserved_68: u32,
    pub reserved_6c: u32,
    pub reserved_70: u32,
    pub reserved_74: u32,
    pub reserved_78: u32,
    pub reserved_7c: u32,
    pub reserved_80: u32,
    pub reserved_84: u32,
    pub reserved_88: u32,
    pub reserved_8c: u32,
    pub reserved_90: u32,
    pub reserved_94: u32,
    pub reserved_98: u32,
    pub reserved_9c: u32,
    pub reserved_a0: u32,
    pub reserved_a4: u32,
    pub reserved_a8: u32,
    pub reserved_ac: u32,
    pub reserved_b0: u32,
    pub reserved_b4: u32,
    pub reserved_b8: u32,
    pub reserved_bc: u32,
    pub reserved_c0: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub reserved_f0: u32,
    pub reserved_f4: u32,
    pub reserved_f8: u32,
    pub date: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hinf_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: hinf_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hinf_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl hinf_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn user_id_fn1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_user_id_fn1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn device_id_fn1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_device_id_fn1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        user_id_fn1: u32,
        device_id_fn1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let user_id_fn1: u32 = unsafe { ::core::mem::transmute(user_id_fn1) };
            user_id_fn1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let device_id_fn1: u32 = unsafe { ::core::mem::transmute(device_id_fn1) };
            device_id_fn1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hinf_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: hinf_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hinf_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl hinf_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn sdio_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_ioready1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_ioready1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn highspeed_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_highspeed_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn highspeed_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_highspeed_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_cd_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_cd_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_ioready2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_ioready2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_int_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_int_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ioenable2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ioenable2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cd_disable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn func1_eps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_func1_eps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn emp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_emp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ioenable1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ioenable1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio20_conf0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sdio20_conf0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_ver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_ver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn func2_eps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_func2_eps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio20_conf1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sdio20_conf1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sdio_enable: u32,
        sdio_ioready1: u32,
        highspeed_enable: u32,
        highspeed_mode: u32,
        sdio_cd_enable: u32,
        sdio_ioready2: u32,
        sdio_int_mask: u32,
        ioenable2: u32,
        cd_disable: u32,
        func1_eps: u32,
        emp: u32,
        ioenable1: u32,
        sdio20_conf0: u32,
        sdio_ver: u32,
        func2_eps: u32,
        sdio20_conf1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sdio_enable: u32 = unsafe { ::core::mem::transmute(sdio_enable) };
            sdio_enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sdio_ioready1: u32 = unsafe { ::core::mem::transmute(sdio_ioready1) };
            sdio_ioready1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let highspeed_enable: u32 = unsafe { ::core::mem::transmute(highspeed_enable) };
            highspeed_enable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let highspeed_mode: u32 = unsafe { ::core::mem::transmute(highspeed_mode) };
            highspeed_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sdio_cd_enable: u32 = unsafe { ::core::mem::transmute(sdio_cd_enable) };
            sdio_cd_enable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let sdio_ioready2: u32 = unsafe { ::core::mem::transmute(sdio_ioready2) };
            sdio_ioready2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sdio_int_mask: u32 = unsafe { ::core::mem::transmute(sdio_int_mask) };
            sdio_int_mask as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ioenable2: u32 = unsafe { ::core::mem::transmute(ioenable2) };
            ioenable2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cd_disable: u32 = unsafe { ::core::mem::transmute(cd_disable) };
            cd_disable as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let func1_eps: u32 = unsafe { ::core::mem::transmute(func1_eps) };
            func1_eps as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let emp: u32 = unsafe { ::core::mem::transmute(emp) };
            emp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ioenable1: u32 = unsafe { ::core::mem::transmute(ioenable1) };
            ioenable1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let sdio20_conf0: u32 = unsafe { ::core::mem::transmute(sdio20_conf0) };
            sdio20_conf0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let sdio_ver: u32 = unsafe { ::core::mem::transmute(sdio_ver) };
            sdio_ver as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let func2_eps: u32 = unsafe { ::core::mem::transmute(func2_eps) };
            func2_eps as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let sdio20_conf1: u32 = unsafe { ::core::mem::transmute(sdio20_conf1) };
            sdio20_conf1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hinf_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: hinf_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hinf_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl hinf_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn pin_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pin_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn chip_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_chip_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sdio_ioready0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdio_ioready0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pin_state: u32,
        chip_state: u32,
        sdio_rst: u32,
        sdio_ioready0: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let pin_state: u32 = unsafe { ::core::mem::transmute(pin_state) };
            pin_state as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let chip_state: u32 = unsafe { ::core::mem::transmute(chip_state) };
            chip_state as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sdio_rst: u32 = unsafe { ::core::mem::transmute(sdio_rst) };
            sdio_rst as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let sdio_ioready0: u32 = unsafe { ::core::mem::transmute(sdio_ioready0) };
            sdio_ioready0 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hinf_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: hinf_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hinf_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl hinf_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn user_id_fn2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_user_id_fn2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn device_id_fn2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_device_id_fn2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        user_id_fn2: u32,
        device_id_fn2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let user_id_fn2: u32 = unsafe { ::core::mem::transmute(user_id_fn2) };
            user_id_fn2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let device_id_fn2: u32 = unsafe { ::core::mem::transmute(device_id_fn2) };
            device_id_fn2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type hinf_dev_t = hinf_dev_s;
extern "C" {
    pub static mut HINF: hinf_dev_t;
}
#[doc = " pin and signal information of each slot"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdio_slave_slot_info_t {
    pub clk_gpio: u32,
    pub cmd_gpio: u32,
    pub d0_gpio: u32,
    pub d1_gpio: u32,
    pub d2_gpio: u32,
    pub d3_gpio: u32,
    pub func: c_types::c_int,
}
extern "C" {
    pub static mut sdio_slave_slot_info: [sdio_slave_slot_info_t; 0usize];
}
pub type sdio_event_cb_t = ::core::option::Option<unsafe extern "C" fn(event: u8)>;
#[doc = " Configuration of SDIO slave"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdio_slave_config_t {
    #[doc = "< timing of sdio_slave. see `sdio_slave_timing_t`."]
    pub timing: sdio_slave_timing_t,
    #[doc = "< mode of sdio_slave. `SDIO_SLAVE_MODE_STREAM` if the data needs to be sent as much as possible; `SDIO_SLAVE_MODE_PACKET` if the data should be sent in packets."]
    pub sending_mode: sdio_slave_sending_mode_t,
    #[doc = "< max buffers that can be queued before sending."]
    pub send_queue_size: c_types::c_int,
    pub recv_buffer_size: size_t,
    #[doc = "< when the host interrupts slave, this callback will be called with interrupt number (0-7)."]
    pub event_cb: sdio_event_cb_t,
    #[doc = "< Features to be enabled for the slave, combinations of ``SDIO_SLAVE_FLAG_*``."]
    pub flags: u32,
}
#[doc = " Handle of a receive buffer, register a handle by calling ``sdio_slave_recv_register_buf``. Use the handle to load the buffer to the"]
#[doc = "  driver, or call ``sdio_slave_recv_unregister_buf`` if it is no longer used."]
pub type sdio_slave_buf_handle_t = *mut c_types::c_void;
extern "C" {
    #[doc = " Initialize the sdio slave driver"]
    #[doc = ""]
    #[doc = " @param config Configuration of the sdio slave driver."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_NOT_FOUND if no free interrupt found."]
    #[doc = "     - ESP_ERR_INVALID_STATE if already initialized."]
    #[doc = "     - ESP_ERR_NO_MEM if fail due to memory allocation failed."]
    #[doc = "     - ESP_OK if success"]
    pub fn sdio_slave_initialize(config: *mut sdio_slave_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " De-initialize the sdio slave driver to release the resources."]
    pub fn sdio_slave_deinit();
}
extern "C" {
    #[doc = " Start hardware for sending and receiving, as well as set the IOREADY1 to 1."]
    #[doc = ""]
    #[doc = " @note The driver will continue sending from previous data and PKT_LEN counting, keep data received as well as start receiving from current TOKEN1 counting."]
    #[doc = " See ``sdio_slave_reset``."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_ERR_INVALID_STATE if already started."]
    #[doc = "  - ESP_OK otherwise."]
    pub fn sdio_slave_start() -> esp_err_t;
}
extern "C" {
    #[doc = " Stop hardware from sending and receiving, also set IOREADY1 to 0."]
    #[doc = ""]
    #[doc = " @note this will not clear the data already in the driver, and also not reset the PKT_LEN and TOKEN1 counting. Call ``sdio_slave_reset`` to do that."]
    pub fn sdio_slave_stop();
}
extern "C" {
    #[doc = " Clear the data still in the driver, as well as reset the PKT_LEN and TOKEN1 counting."]
    #[doc = ""]
    #[doc = " @return always return ESP_OK."]
    pub fn sdio_slave_reset() -> esp_err_t;
}
extern "C" {
    #[doc = " Register buffer used for receiving. All buffers should be registered before used, and then can be used (again) in the driver by the handle returned."]
    #[doc = ""]
    #[doc = " @param start The start address of the buffer."]
    #[doc = ""]
    #[doc = " @note The driver will use and only use the amount of space specified in the `recv_buffer_size` member set in the `sdio_slave_config_t`."]
    #[doc = "       All buffers should be larger than that. The buffer is used by the DMA, so it should be DMA capable and 32-bit aligned."]
    #[doc = ""]
    #[doc = " @return The buffer handle if success, otherwise NULL."]
    pub fn sdio_slave_recv_register_buf(start: *mut u8) -> sdio_slave_buf_handle_t;
}
extern "C" {
    #[doc = " Unregister buffer from driver, and free the space used by the descriptor pointing to the buffer."]
    #[doc = ""]
    #[doc = " @param handle Handle to the buffer to release."]
    #[doc = ""]
    #[doc = " @return ESP_OK if success, ESP_ERR_INVALID_ARG if the handle is NULL or the buffer is being used."]
    pub fn sdio_slave_recv_unregister_buf(handle: sdio_slave_buf_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Load buffer to the queue waiting to receive data. The driver takes ownership of the buffer until the buffer is returned by"]
    #[doc = "  ``sdio_slave_send_get_finished`` after the transaction is finished."]
    #[doc = ""]
    #[doc = " @param handle Handle to the buffer ready to receive data."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG    if invalid handle or the buffer is already in the queue. Only after the buffer is returened by"]
    #[doc = "                              ``sdio_slave_recv`` can you load it again."]
    #[doc = "     - ESP_OK if success"]
    pub fn sdio_slave_recv_load_buf(handle: sdio_slave_buf_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Get received data if exist. The driver returns the ownership of the buffer to the app."]
    #[doc = ""]
    #[doc = " @param handle_ret Handle to the buffer holding received data. Use this handle in ``sdio_slave_recv_load_buf`` to receive in the same buffer again."]
    #[doc = " @param[out] out_addr Output of the start address, set to NULL if not needed."]
    #[doc = " @param[out] out_len Actual length of the data in the buffer, set to NULL if not needed."]
    #[doc = " @param wait Time to wait before data received."]
    #[doc = ""]
    #[doc = " @note Call ``sdio_slave_load_buf`` with the handle to re-load the buffer onto the link list, and receive with the same buffer again."]
    #[doc = "       The address and length of the buffer got here is the same as got from `sdio_slave_get_buffer`."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG    if handle_ret is NULL"]
    #[doc = "     - ESP_ERR_TIMEOUT        if timeout before receiving new data"]
    #[doc = "     - ESP_OK if success"]
    pub fn sdio_slave_recv(
        handle_ret: *mut sdio_slave_buf_handle_t,
        out_addr: *mut *mut u8,
        out_len: *mut size_t,
        wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Retrieve the buffer corresponding to a handle."]
    #[doc = ""]
    #[doc = " @param handle Handle to get the buffer."]
    #[doc = " @param len_o Output of buffer length"]
    #[doc = ""]
    #[doc = " @return buffer address if success, otherwise NULL."]
    pub fn sdio_slave_recv_get_buf(handle: sdio_slave_buf_handle_t, len_o: *mut size_t) -> *mut u8;
}
extern "C" {
    #[doc = " Put a new sending transfer into the send queue. The driver takes ownership of the buffer until the buffer is returned by"]
    #[doc = "  ``sdio_slave_send_get_finished`` after the transaction is finished."]
    #[doc = ""]
    #[doc = " @param addr Address for data to be sent. The buffer should be DMA capable and 32-bit aligned."]
    #[doc = " @param len Length of the data, should not be longer than 4092 bytes (may support longer in the future)."]
    #[doc = " @param arg Argument to returned in ``sdio_slave_send_get_finished``. The argument can be used to indicate which transaction is done,"]
    #[doc = "            or as a parameter for a callback. Set to NULL if not needed."]
    #[doc = " @param wait Time to wait if the buffer is full."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG if the length is not greater than 0."]
    #[doc = "     - ESP_ERR_TIMEOUT if the queue is still full until timeout."]
    #[doc = "     - ESP_OK if success."]
    pub fn sdio_slave_send_queue(
        addr: *mut u8,
        len: size_t,
        arg: *mut c_types::c_void,
        wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Return the ownership of a finished transaction."]
    #[doc = " @param out_arg Argument of the finished transaction. Set to NULL if unused."]
    #[doc = " @param wait Time to wait if there's no finished sending transaction."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_TIMEOUT if no transaction finished, or ESP_OK if succeed."]
    pub fn sdio_slave_send_get_finished(
        out_arg: *mut *mut c_types::c_void,
        wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Start a new sending transfer, and wait for it (blocked) to be finished."]
    #[doc = ""]
    #[doc = " @param addr Start address of the buffer to send"]
    #[doc = " @param len Length of buffer to send."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG if the length of descriptor is not greater than 0."]
    #[doc = "     - ESP_ERR_TIMEOUT if the queue is full or host do not start a transfer before timeout."]
    #[doc = "     - ESP_OK if success."]
    pub fn sdio_slave_transmit(addr: *mut u8, len: size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Read the spi slave register shared with host."]
    #[doc = ""]
    #[doc = " @param pos register address, 0-27 or 32-63."]
    #[doc = ""]
    #[doc = " @note register 28 to 31 are reserved for interrupt vector."]
    #[doc = ""]
    #[doc = " @return value of the register."]
    pub fn sdio_slave_read_reg(pos: c_types::c_int) -> u8;
}
extern "C" {
    #[doc = " Write the spi slave register shared with host."]
    #[doc = ""]
    #[doc = " @param pos register address, 0-11, 14-15, 18-19, 24-27 and 32-63, other address are reserved."]
    #[doc = " @param reg the value to write."]
    #[doc = ""]
    #[doc = " @note register 29 and 31 are used for interrupt vector."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if address wrong, otherwise ESP_OK."]
    pub fn sdio_slave_write_reg(pos: c_types::c_int, reg: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " Get the interrupt enable for host."]
    #[doc = ""]
    #[doc = " @return the interrupt mask."]
    pub fn sdio_slave_get_host_intena() -> sdio_slave_hostint_t;
}
extern "C" {
    #[doc = " Set the interrupt enable for host."]
    #[doc = ""]
    #[doc = " @param mask Enable mask for host interrupt."]
    pub fn sdio_slave_set_host_intena(mask: sdio_slave_hostint_t);
}
extern "C" {
    #[doc = " Interrupt the host by general purpose interrupt."]
    #[doc = ""]
    #[doc = " @param pos Interrupt num, 0-7."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_INVALID_ARG if interrupt num error"]
    #[doc = "     - ESP_OK otherwise"]
    pub fn sdio_slave_send_host_int(pos: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " Clear general purpose interrupt to host."]
    #[doc = ""]
    #[doc = " @param mask Interrupt bits to clear, by bit mask."]
    pub fn sdio_slave_clear_host_int(mask: sdio_slave_hostint_t);
}
extern "C" {
    #[doc = " Wait for general purpose interrupt from host."]
    #[doc = ""]
    #[doc = " @param pos Interrupt source number to wait for."]
    #[doc = " is set."]
    #[doc = " @param wait Time to wait before interrupt triggered."]
    #[doc = ""]
    #[doc = " @note this clears the interrupt at the same time."]
    #[doc = ""]
    #[doc = " @return ESP_OK if success, ESP_ERR_TIMEOUT if timeout."]
    pub fn sdio_slave_wait_int(pos: c_types::c_int, wait: TickType_t) -> esp_err_t;
}
#[doc = " Decoded values from SD card Card Specific Data register"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_csd_t {
    #[doc = "< CSD structure format"]
    pub csd_ver: c_types::c_int,
    #[doc = "< MMC version (for CID format)"]
    pub mmc_ver: c_types::c_int,
    #[doc = "< total number of sectors"]
    pub capacity: c_types::c_int,
    #[doc = "< sector size in bytes"]
    pub sector_size: c_types::c_int,
    #[doc = "< block length for reads"]
    pub read_block_len: c_types::c_int,
    #[doc = "< Card Command Class for SD"]
    pub card_command_class: c_types::c_int,
    #[doc = "< Max transfer speed"]
    pub tr_speed: c_types::c_int,
}
#[doc = " Decoded values from SD card Card IDentification register"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_cid_t {
    #[doc = "< manufacturer identification number"]
    pub mfg_id: c_types::c_int,
    #[doc = "< OEM/product identification number"]
    pub oem_id: c_types::c_int,
    #[doc = "< product name (MMC v1 has the longest)"]
    pub name: [c_types::c_char; 8usize],
    #[doc = "< product revision"]
    pub revision: c_types::c_int,
    #[doc = "< product serial number"]
    pub serial: c_types::c_int,
    #[doc = "< manufacturing date"]
    pub date: c_types::c_int,
}
#[doc = " Decoded values from SD Configuration Register"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_scr_t {
    #[doc = "< SD Physical layer specification version, reported by card"]
    pub sd_spec: c_types::c_int,
    #[doc = "< bus widths supported by card: BIT(0)  1-bit bus, BIT(2)  4-bit bus"]
    pub bus_width: c_types::c_int,
}
#[doc = " Decoded values of Extended Card Specific Data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_ext_csd_t {
    #[doc = "< Power class used by the card"]
    pub power_class: u8,
}
#[doc = " SD/MMC command response buffer"]
pub type sdmmc_response_t = [u32; 4usize];
#[doc = " SD SWITCH_FUNC response buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_switch_func_rsp_t {
    #[doc = "< response data"]
    pub data: [u32; 16usize],
}
#[doc = " SD/MMC command information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_command_t {
    #[doc = "< SD or MMC command index"]
    pub opcode: u32,
    #[doc = "< SD/MMC command argument"]
    pub arg: u32,
    #[doc = "< response buffer"]
    pub response: sdmmc_response_t,
    #[doc = "< buffer to send or read into"]
    pub data: *mut c_types::c_void,
    #[doc = "< length of data buffer"]
    pub datalen: size_t,
    #[doc = "< block length"]
    pub blklen: size_t,
    #[doc = "< see below"]
    pub flags: c_types::c_int,
    #[doc = "< error returned from transfer"]
    pub error: esp_err_t,
    #[doc = "< response timeout, in milliseconds"]
    pub timeout_ms: c_types::c_int,
}
#[doc = " SD/MMC Host description"]
#[doc = ""]
#[doc = " This structure defines properties of SD/MMC host and functions"]
#[doc = " of SD/MMC host which can be used by upper layers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_host_t {
    #[doc = "< flags defining host properties"]
    pub flags: u32,
    #[doc = "< slot number, to be passed to host functions"]
    pub slot: c_types::c_int,
    #[doc = "< max frequency supported by the host"]
    pub max_freq_khz: c_types::c_int,
    #[doc = "< I/O voltage used by the controller (voltage switching is not supported)"]
    pub io_voltage: f32,
    #[doc = "< Host function to initialize the driver"]
    pub init: ::core::option::Option<unsafe extern "C" fn() -> esp_err_t>,
    #[doc = "< host function to set bus width"]
    pub set_bus_width: ::core::option::Option<
        unsafe extern "C" fn(slot: c_types::c_int, width: size_t) -> esp_err_t,
    >,
    #[doc = "< host function to get bus width"]
    pub get_bus_width: ::core::option::Option<unsafe extern "C" fn(slot: c_types::c_int) -> size_t>,
    #[doc = "< host function to set DDR mode"]
    pub set_bus_ddr_mode: ::core::option::Option<
        unsafe extern "C" fn(slot: c_types::c_int, ddr_enable: bool) -> esp_err_t,
    >,
    #[doc = "< host function to set card clock frequency"]
    pub set_card_clk: ::core::option::Option<
        unsafe extern "C" fn(slot: c_types::c_int, freq_khz: u32) -> esp_err_t,
    >,
    #[doc = "< host function to do a transaction"]
    pub do_transaction: ::core::option::Option<
        unsafe extern "C" fn(slot: c_types::c_int, cmdinfo: *mut sdmmc_command_t) -> esp_err_t,
    >,
    #[doc = "< host function to deinitialize the driver"]
    pub deinit: ::core::option::Option<unsafe extern "C" fn() -> esp_err_t>,
    #[doc = "< Host function to enable SDIO interrupt line"]
    pub io_int_enable:
        ::core::option::Option<unsafe extern "C" fn(slot: c_types::c_int) -> esp_err_t>,
    #[doc = "< Host function to wait for SDIO interrupt line to be active"]
    pub io_int_wait: ::core::option::Option<
        unsafe extern "C" fn(slot: c_types::c_int, timeout_ticks: TickType_t) -> esp_err_t,
    >,
    #[doc = "< timeout, in milliseconds, of a single command. Set to 0 to use the default value."]
    pub command_timeout_ms: c_types::c_int,
}
#[doc = " SD/MMC card information structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sdmmc_card_t {
    #[doc = "< Host with which the card is associated"]
    pub host: sdmmc_host_t,
    #[doc = "< OCR (Operation Conditions Register) value"]
    pub ocr: u32,
    pub __bindgen_anon_1: sdmmc_card_t__bindgen_ty_1,
    #[doc = "< decoded CSD (Card-Specific Data) register value"]
    pub csd: sdmmc_csd_t,
    #[doc = "< decoded SCR (SD card Configuration Register) value"]
    pub scr: sdmmc_scr_t,
    #[doc = "< decoded EXT_CSD (Extended Card Specific Data) register value"]
    pub ext_csd: sdmmc_ext_csd_t,
    #[doc = "< RCA (Relative Card Address)"]
    pub rca: u16,
    #[doc = "< Maximum frequency, in kHz, supported by the card"]
    pub max_freq_khz: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sdmmc_card_t__bindgen_ty_1 {
    #[doc = "< decoded CID (Card IDentification) register value"]
    pub cid: sdmmc_cid_t,
    #[doc = "< raw CID of MMC card to be decoded"]
    #[doc = "after the CSD is fetched in the data transfer mode"]
    pub raw_cid: sdmmc_response_t,
    _bindgen_union_align: [u32; 7usize],
}
impl sdmmc_card_t {
    #[inline]
    pub fn is_mem(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sdio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_sdio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mmc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mmc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_io_functions(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_num_io_functions(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn log_bus_width(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log_bus_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn is_ddr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_ddr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_mem: u32,
        is_sdio: u32,
        is_mmc: u32,
        num_io_functions: u32,
        log_bus_width: u32,
        is_ddr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_mem: u32 = unsafe { ::core::mem::transmute(is_mem) };
            is_mem as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_sdio: u32 = unsafe { ::core::mem::transmute(is_sdio) };
            is_sdio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_mmc: u32 = unsafe { ::core::mem::transmute(is_mmc) };
            is_mmc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let num_io_functions: u32 = unsafe { ::core::mem::transmute(num_io_functions) };
            num_io_functions as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let log_bus_width: u32 = unsafe { ::core::mem::transmute(log_bus_width) };
            log_bus_width as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_ddr: u32 = unsafe { ::core::mem::transmute(is_ddr) };
            is_ddr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Extra configuration for SDMMC peripheral slot"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdmmc_slot_config_t {
    #[doc = "< GPIO number of card detect signal"]
    pub gpio_cd: gpio_num_t,
    #[doc = "< GPIO number of write protect signal"]
    pub gpio_wp: gpio_num_t,
    #[doc = "< Bus width used by the slot (might be less than the max width supported)"]
    pub width: u8,
    #[doc = "< Features used by this slot"]
    pub flags: u32,
}
extern "C" {
    #[doc = " @brief Initialize SDMMC host peripheral"]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if sdmmc_host_init was already called"]
    #[doc = "      - ESP_ERR_NO_MEM if memory can not be allocated"]
    pub fn sdmmc_host_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize given slot of SDMMC peripheral"]
    #[doc = ""]
    #[doc = " On the ESP32, SDMMC peripheral has two slots:"]
    #[doc = "  - Slot 0: 8-bit wide, maps to HS1_* signals in PIN MUX"]
    #[doc = "  - Slot 1: 4-bit wide, maps to HS2_* signals in PIN MUX"]
    #[doc = ""]
    #[doc = " Card detect and write protect signals can be routed to"]
    #[doc = " arbitrary GPIOs using GPIO matrix."]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @param slot_config  additional configuration for the slot"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if host has not been initialized using sdmmc_host_init"]
    pub fn sdmmc_host_init_slot(
        slot: c_types::c_int,
        slot_config: *const sdmmc_slot_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Select bus width to be used for data transfer"]
    #[doc = ""]
    #[doc = " SD/MMC card must be initialized prior to this command, and a command to set"]
    #[doc = " bus width has to be sent to the card (e.g. SD_APP_SET_BUS_WIDTH)"]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @param width  bus width (1, 4, or 8 for slot 0; 1 or 4 for slot 1)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if slot number or width is not valid"]
    pub fn sdmmc_host_set_bus_width(slot: c_types::c_int, width: size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get bus width configured in ``sdmmc_host_init_slot`` to be used for data transfer"]
    #[doc = ""]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @return configured bus width of the specified slot."]
    pub fn sdmmc_host_get_slot_width(slot: c_types::c_int) -> size_t;
}
extern "C" {
    #[doc = " @brief Set card clock frequency"]
    #[doc = ""]
    #[doc = " Currently only integer fractions of 40MHz clock can be used."]
    #[doc = " For High Speed cards, 40MHz can be used."]
    #[doc = " For Default Speed cards, 20MHz can be used."]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @param freq_khz  card clock frequency, in kHz"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - other error codes may be returned in the future"]
    pub fn sdmmc_host_set_card_clk(slot: c_types::c_int, freq_khz: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable DDR mode of SD interface"]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @param ddr_enabled  enable or disable DDR mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if DDR mode is not supported on this slot"]
    pub fn sdmmc_host_set_bus_ddr_mode(slot: c_types::c_int, ddr_enabled: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send command to the card and get response"]
    #[doc = ""]
    #[doc = " This function returns when command is sent and response is received,"]
    #[doc = " or data is transferred, or timeout occurs."]
    #[doc = ""]
    #[doc = " @note This function is not thread safe w.r.t. init/deinit functions,"]
    #[doc = "       and bus width/clock speed configuration functions. Multiple tasks"]
    #[doc = "       can call sdmmc_host_do_transaction as long as other sdmmc_host_*"]
    #[doc = "       functions are not called."]
    #[doc = ""]
    #[doc = " @attention Data buffer passed in cmdinfo->data must be in DMA capable memory"]
    #[doc = ""]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @param cmdinfo   pointer to structure describing command and data to transfer"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_TIMEOUT if response or data transfer has timed out"]
    #[doc = "      - ESP_ERR_INVALID_CRC if response or data transfer CRC check has failed"]
    #[doc = "      - ESP_ERR_INVALID_RESPONSE if the card has sent an invalid response"]
    #[doc = "      - ESP_ERR_INVALID_SIZE if the size of data transfer is not valid in SD protocol"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the data buffer is not in DMA capable memory"]
    pub fn sdmmc_host_do_transaction(
        slot: c_types::c_int,
        cmdinfo: *mut sdmmc_command_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable IO interrupts"]
    #[doc = ""]
    #[doc = " This function configures the host to accept SDIO interrupts."]
    #[doc = ""]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @return returns ESP_OK, other errors possible in the future"]
    pub fn sdmmc_host_io_int_enable(slot: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Block until an SDIO interrupt is received, or timeout occurs"]
    #[doc = " @param slot  slot number (SDMMC_HOST_SLOT_0 or SDMMC_HOST_SLOT_1)"]
    #[doc = " @param timeout_ticks  number of RTOS ticks to wait for the interrupt"]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success (interrupt received)"]
    #[doc = "  - ESP_ERR_TIMEOUT if the interrupt did not occur within timeout_ticks"]
    pub fn sdmmc_host_io_int_wait(slot: c_types::c_int, timeout_ticks: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable SDMMC host and release allocated resources"]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if sdmmc_host_init function has not been called"]
    pub fn sdmmc_host_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the pull-ups of sd pins."]
    #[doc = ""]
    #[doc = " @note You should always place actual pullups on the lines instead of using"]
    #[doc = " this function. Internal pullup resistance are high and not sufficient, may"]
    #[doc = " cause instability in products. This is for debug or examples only."]
    #[doc = ""]
    #[doc = " @param slot Slot to use, normally set it to 1."]
    #[doc = " @param width Bit width of your configuration, 1 or 4."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: if success"]
    #[doc = "      - ESP_ERR_INVALID_ARG: if configured width larger than maximum the slot can"]
    #[doc = "              support"]
    pub fn sdmmc_host_pullup_en(slot: c_types::c_int, width: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " Generate a linked list pointing to a (huge) buffer in an descriptor array."]
    #[doc = ""]
    #[doc = " The caller should ensure there is enough size to hold the array, by calling"]
    #[doc = " ``lldesc_get_required_num``."]
    #[doc = ""]
    #[doc = " @param out_desc_array Output of a descriptor array, the head should be fed to the DMA."]
    #[doc = " @param buffer Buffer for the descriptors to point to."]
    #[doc = " @param size Size (or length for TX) of the buffer"]
    #[doc = " @param isrx The RX DMA may require the buffer to be word-aligned, set to true for a RX link, otherwise false."]
    pub fn lldesc_setup_link(
        out_desc_array: *mut lldesc_t,
        buffer: *const c_types::c_void,
        size: c_types::c_int,
        isrx: bool,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_dev_s {
    pub cmd: spi_dev_s__bindgen_ty_1,
    pub addr: u32,
    pub ctrl: spi_dev_s__bindgen_ty_2,
    pub ctrl1: spi_dev_s__bindgen_ty_3,
    pub rd_status: spi_dev_s__bindgen_ty_4,
    pub ctrl2: spi_dev_s__bindgen_ty_5,
    pub clock: spi_dev_s__bindgen_ty_6,
    pub user: spi_dev_s__bindgen_ty_7,
    pub user1: spi_dev_s__bindgen_ty_8,
    pub user2: spi_dev_s__bindgen_ty_9,
    pub mosi_dlen: spi_dev_s__bindgen_ty_10,
    pub miso_dlen: spi_dev_s__bindgen_ty_11,
    pub slv_wr_status: u32,
    pub pin: spi_dev_s__bindgen_ty_12,
    pub slave: spi_dev_s__bindgen_ty_13,
    pub slave1: spi_dev_s__bindgen_ty_14,
    pub slave2: spi_dev_s__bindgen_ty_15,
    pub slave3: spi_dev_s__bindgen_ty_16,
    pub slv_wrbuf_dlen: spi_dev_s__bindgen_ty_17,
    pub slv_rdbuf_dlen: spi_dev_s__bindgen_ty_18,
    pub cache_fctrl: spi_dev_s__bindgen_ty_19,
    pub cache_sctrl: spi_dev_s__bindgen_ty_20,
    pub sram_cmd: spi_dev_s__bindgen_ty_21,
    pub sram_drd_cmd: spi_dev_s__bindgen_ty_22,
    pub sram_dwr_cmd: spi_dev_s__bindgen_ty_23,
    pub slv_rd_bit: spi_dev_s__bindgen_ty_24,
    pub reserved_68: u32,
    pub reserved_6c: u32,
    pub reserved_70: u32,
    pub reserved_74: u32,
    pub reserved_78: u32,
    pub reserved_7c: u32,
    pub data_buf: [u32; 16usize],
    pub tx_crc: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub ext0: spi_dev_s__bindgen_ty_25,
    pub ext1: spi_dev_s__bindgen_ty_26,
    pub ext2: spi_dev_s__bindgen_ty_27,
    pub ext3: spi_dev_s__bindgen_ty_28,
    pub dma_conf: spi_dev_s__bindgen_ty_29,
    pub dma_out_link: spi_dev_s__bindgen_ty_30,
    pub dma_in_link: spi_dev_s__bindgen_ty_31,
    pub dma_status: spi_dev_s__bindgen_ty_32,
    pub dma_int_ena: spi_dev_s__bindgen_ty_33,
    pub dma_int_raw: spi_dev_s__bindgen_ty_34,
    pub dma_int_st: spi_dev_s__bindgen_ty_35,
    pub dma_int_clr: spi_dev_s__bindgen_ty_36,
    pub dma_in_err_eof_des_addr: u32,
    pub dma_in_suc_eof_des_addr: u32,
    pub dma_inlink_dscr: u32,
    pub dma_inlink_dscr_bf0: u32,
    pub dma_inlink_dscr_bf1: u32,
    pub dma_out_eof_bfr_des_addr: u32,
    pub dma_out_eof_des_addr: u32,
    pub dma_outlink_dscr: u32,
    pub dma_outlink_dscr_bf0: u32,
    pub dma_outlink_dscr_bf1: u32,
    pub dma_rx_status: u32,
    pub dma_tx_status: u32,
    pub reserved_150: u32,
    pub reserved_154: u32,
    pub reserved_158: u32,
    pub reserved_15c: u32,
    pub reserved_160: u32,
    pub reserved_164: u32,
    pub reserved_168: u32,
    pub reserved_16c: u32,
    pub reserved_170: u32,
    pub reserved_174: u32,
    pub reserved_178: u32,
    pub reserved_17c: u32,
    pub reserved_180: u32,
    pub reserved_184: u32,
    pub reserved_188: u32,
    pub reserved_18c: u32,
    pub reserved_190: u32,
    pub reserved_194: u32,
    pub reserved_198: u32,
    pub reserved_19c: u32,
    pub reserved_1a0: u32,
    pub reserved_1a4: u32,
    pub reserved_1a8: u32,
    pub reserved_1ac: u32,
    pub reserved_1b0: u32,
    pub reserved_1b4: u32,
    pub reserved_1b8: u32,
    pub reserved_1bc: u32,
    pub reserved_1c0: u32,
    pub reserved_1c4: u32,
    pub reserved_1c8: u32,
    pub reserved_1cc: u32,
    pub reserved_1d0: u32,
    pub reserved_1d4: u32,
    pub reserved_1d8: u32,
    pub reserved_1dc: u32,
    pub reserved_1e0: u32,
    pub reserved_1e4: u32,
    pub reserved_1e8: u32,
    pub reserved_1ec: u32,
    pub reserved_1f0: u32,
    pub reserved_1f4: u32,
    pub reserved_1f8: u32,
    pub reserved_1fc: u32,
    pub reserved_200: u32,
    pub reserved_204: u32,
    pub reserved_208: u32,
    pub reserved_20c: u32,
    pub reserved_210: u32,
    pub reserved_214: u32,
    pub reserved_218: u32,
    pub reserved_21c: u32,
    pub reserved_220: u32,
    pub reserved_224: u32,
    pub reserved_228: u32,
    pub reserved_22c: u32,
    pub reserved_230: u32,
    pub reserved_234: u32,
    pub reserved_238: u32,
    pub reserved_23c: u32,
    pub reserved_240: u32,
    pub reserved_244: u32,
    pub reserved_248: u32,
    pub reserved_24c: u32,
    pub reserved_250: u32,
    pub reserved_254: u32,
    pub reserved_258: u32,
    pub reserved_25c: u32,
    pub reserved_260: u32,
    pub reserved_264: u32,
    pub reserved_268: u32,
    pub reserved_26c: u32,
    pub reserved_270: u32,
    pub reserved_274: u32,
    pub reserved_278: u32,
    pub reserved_27c: u32,
    pub reserved_280: u32,
    pub reserved_284: u32,
    pub reserved_288: u32,
    pub reserved_28c: u32,
    pub reserved_290: u32,
    pub reserved_294: u32,
    pub reserved_298: u32,
    pub reserved_29c: u32,
    pub reserved_2a0: u32,
    pub reserved_2a4: u32,
    pub reserved_2a8: u32,
    pub reserved_2ac: u32,
    pub reserved_2b0: u32,
    pub reserved_2b4: u32,
    pub reserved_2b8: u32,
    pub reserved_2bc: u32,
    pub reserved_2c0: u32,
    pub reserved_2c4: u32,
    pub reserved_2c8: u32,
    pub reserved_2cc: u32,
    pub reserved_2d0: u32,
    pub reserved_2d4: u32,
    pub reserved_2d8: u32,
    pub reserved_2dc: u32,
    pub reserved_2e0: u32,
    pub reserved_2e4: u32,
    pub reserved_2e8: u32,
    pub reserved_2ec: u32,
    pub reserved_2f0: u32,
    pub reserved_2f4: u32,
    pub reserved_2f8: u32,
    pub reserved_2fc: u32,
    pub reserved_300: u32,
    pub reserved_304: u32,
    pub reserved_308: u32,
    pub reserved_30c: u32,
    pub reserved_310: u32,
    pub reserved_314: u32,
    pub reserved_318: u32,
    pub reserved_31c: u32,
    pub reserved_320: u32,
    pub reserved_324: u32,
    pub reserved_328: u32,
    pub reserved_32c: u32,
    pub reserved_330: u32,
    pub reserved_334: u32,
    pub reserved_338: u32,
    pub reserved_33c: u32,
    pub reserved_340: u32,
    pub reserved_344: u32,
    pub reserved_348: u32,
    pub reserved_34c: u32,
    pub reserved_350: u32,
    pub reserved_354: u32,
    pub reserved_358: u32,
    pub reserved_35c: u32,
    pub reserved_360: u32,
    pub reserved_364: u32,
    pub reserved_368: u32,
    pub reserved_36c: u32,
    pub reserved_370: u32,
    pub reserved_374: u32,
    pub reserved_378: u32,
    pub reserved_37c: u32,
    pub reserved_380: u32,
    pub reserved_384: u32,
    pub reserved_388: u32,
    pub reserved_38c: u32,
    pub reserved_390: u32,
    pub reserved_394: u32,
    pub reserved_398: u32,
    pub reserved_39c: u32,
    pub reserved_3a0: u32,
    pub reserved_3a4: u32,
    pub reserved_3a8: u32,
    pub reserved_3ac: u32,
    pub reserved_3b0: u32,
    pub reserved_3b4: u32,
    pub reserved_3b8: u32,
    pub reserved_3bc: u32,
    pub reserved_3c0: u32,
    pub reserved_3c4: u32,
    pub reserved_3c8: u32,
    pub reserved_3cc: u32,
    pub reserved_3d0: u32,
    pub reserved_3d4: u32,
    pub reserved_3d8: u32,
    pub reserved_3dc: u32,
    pub reserved_3e0: u32,
    pub reserved_3e4: u32,
    pub reserved_3e8: u32,
    pub reserved_3ec: u32,
    pub reserved_3f0: u32,
    pub reserved_3f4: u32,
    pub reserved_3f8: u32,
    pub date: spi_dev_s__bindgen_ty_37,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_per(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_per(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_pes(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_pes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_hpm(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_hpm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_res(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_dp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_dp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_ce(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_ce(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_be(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_be(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_se(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_se(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_pp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_pp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_wrsr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_wrsr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_rdsr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_rdsr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_rdid(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_rdid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_wrdi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_wrdi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_wren(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_wren(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_read(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_read(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        flash_per: u32,
        flash_pes: u32,
        usr: u32,
        flash_hpm: u32,
        flash_res: u32,
        flash_dp: u32,
        flash_ce: u32,
        flash_be: u32,
        flash_se: u32,
        flash_pp: u32,
        flash_wrsr: u32,
        flash_rdsr: u32,
        flash_rdid: u32,
        flash_wrdi: u32,
        flash_wren: u32,
        flash_read: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let flash_per: u32 = unsafe { ::core::mem::transmute(flash_per) };
            flash_per as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let flash_pes: u32 = unsafe { ::core::mem::transmute(flash_pes) };
            flash_pes as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let usr: u32 = unsafe { ::core::mem::transmute(usr) };
            usr as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let flash_hpm: u32 = unsafe { ::core::mem::transmute(flash_hpm) };
            flash_hpm as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let flash_res: u32 = unsafe { ::core::mem::transmute(flash_res) };
            flash_res as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let flash_dp: u32 = unsafe { ::core::mem::transmute(flash_dp) };
            flash_dp as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let flash_ce: u32 = unsafe { ::core::mem::transmute(flash_ce) };
            flash_ce as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let flash_be: u32 = unsafe { ::core::mem::transmute(flash_be) };
            flash_be as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let flash_se: u32 = unsafe { ::core::mem::transmute(flash_se) };
            flash_se as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let flash_pp: u32 = unsafe { ::core::mem::transmute(flash_pp) };
            flash_pp as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let flash_wrsr: u32 = unsafe { ::core::mem::transmute(flash_wrsr) };
            flash_wrsr as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let flash_rdsr: u32 = unsafe { ::core::mem::transmute(flash_rdsr) };
            flash_rdsr as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let flash_rdid: u32 = unsafe { ::core::mem::transmute(flash_rdid) };
            flash_rdid as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let flash_wrdi: u32 = unsafe { ::core::mem::transmute(flash_wrdi) };
            flash_wrdi as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let flash_wren: u32 = unsafe { ::core::mem::transmute(flash_wren) };
            flash_wren as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let flash_read: u32 = unsafe { ::core::mem::transmute(flash_read) };
            flash_read as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn fcs_crc_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fcs_crc_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_crc_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_crc_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_flash_idle_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wait_flash_idle_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastrd_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fastrd_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_dual(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_dual(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resandres(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resandres(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_quad(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_quad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsr_2b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrsr_2b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fread_qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fread_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_bit_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_bit_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_bit_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_bit_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved27(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved27(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        fcs_crc_en: u32,
        tx_crc_en: u32,
        wait_flash_idle_en: u32,
        fastrd_mode: u32,
        fread_dual: u32,
        resandres: u32,
        reserved16: u32,
        fread_quad: u32,
        wp: u32,
        wrsr_2b: u32,
        fread_dio: u32,
        fread_qio: u32,
        rd_bit_order: u32,
        wr_bit_order: u32,
        reserved27: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let fcs_crc_en: u32 = unsafe { ::core::mem::transmute(fcs_crc_en) };
            fcs_crc_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tx_crc_en: u32 = unsafe { ::core::mem::transmute(tx_crc_en) };
            tx_crc_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let wait_flash_idle_en: u32 = unsafe { ::core::mem::transmute(wait_flash_idle_en) };
            wait_flash_idle_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fastrd_mode: u32 = unsafe { ::core::mem::transmute(fastrd_mode) };
            fastrd_mode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fread_dual: u32 = unsafe { ::core::mem::transmute(fread_dual) };
            fread_dual as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let resandres: u32 = unsafe { ::core::mem::transmute(resandres) };
            resandres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let fread_quad: u32 = unsafe { ::core::mem::transmute(fread_quad) };
            fread_quad as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let wp: u32 = unsafe { ::core::mem::transmute(wp) };
            wp as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let wrsr_2b: u32 = unsafe { ::core::mem::transmute(wrsr_2b) };
            wrsr_2b as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let fread_dio: u32 = unsafe { ::core::mem::transmute(fread_dio) };
            fread_dio as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let fread_qio: u32 = unsafe { ::core::mem::transmute(fread_qio) };
            fread_qio as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let rd_bit_order: u32 = unsafe { ::core::mem::transmute(rd_bit_order) };
            rd_bit_order as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let wr_bit_order: u32 = unsafe { ::core::mem::transmute(wr_bit_order) };
            wr_bit_order as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved27: u32 = unsafe { ::core::mem::transmute(reserved27) };
            reserved27 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_hold_delay_res(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_cs_hold_delay_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_hold_delay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cs_hold_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        cs_hold_delay_res: u32,
        cs_hold_delay: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let cs_hold_delay_res: u32 = unsafe { ::core::mem::transmute(cs_hold_delay_res) };
            cs_hold_delay_res as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let cs_hold_delay: u32 = unsafe { ::core::mem::transmute(cs_hold_delay) };
            cs_hold_delay as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn wb_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wb_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn status_ext(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_status_ext(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: u32,
        wb_mode: u32,
        status_ext: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let wb_mode: u32 = unsafe { ::core::mem::transmute(wb_mode) };
            wb_mode as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let status_ext: u32 = unsafe { ::core::mem::transmute(status_ext) };
            status_ext as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn setup_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_setup_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn hold_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_hold_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_out_low_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ck_out_low_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_out_high_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ck_out_high_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn miso_delay_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_miso_delay_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn miso_delay_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_miso_delay_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mosi_delay_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mosi_delay_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mosi_delay_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mosi_delay_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_delay_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cs_delay_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_delay_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cs_delay_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        setup_time: u32,
        hold_time: u32,
        ck_out_low_mode: u32,
        ck_out_high_mode: u32,
        miso_delay_mode: u32,
        miso_delay_num: u32,
        mosi_delay_mode: u32,
        mosi_delay_num: u32,
        cs_delay_mode: u32,
        cs_delay_num: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let setup_time: u32 = unsafe { ::core::mem::transmute(setup_time) };
            setup_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let hold_time: u32 = unsafe { ::core::mem::transmute(hold_time) };
            hold_time as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let ck_out_low_mode: u32 = unsafe { ::core::mem::transmute(ck_out_low_mode) };
            ck_out_low_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let ck_out_high_mode: u32 = unsafe { ::core::mem::transmute(ck_out_high_mode) };
            ck_out_high_mode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let miso_delay_mode: u32 = unsafe { ::core::mem::transmute(miso_delay_mode) };
            miso_delay_mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let miso_delay_num: u32 = unsafe { ::core::mem::transmute(miso_delay_num) };
            miso_delay_num as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let mosi_delay_mode: u32 = unsafe { ::core::mem::transmute(mosi_delay_mode) };
            mosi_delay_mode as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let mosi_delay_num: u32 = unsafe { ::core::mem::transmute(mosi_delay_num) };
            mosi_delay_num as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let cs_delay_mode: u32 = unsafe { ::core::mem::transmute(cs_delay_mode) };
            cs_delay_mode as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let cs_delay_num: u32 = unsafe { ::core::mem::transmute(cs_delay_num) };
            cs_delay_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn clkcnt_l(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkcnt_l(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkcnt_h(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkcnt_h(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkcnt_n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_clkcnt_n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clkdiv_pre(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_clkdiv_pre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_equ_sysclk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_equ_sysclk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clkcnt_l: u32,
        clkcnt_h: u32,
        clkcnt_n: u32,
        clkdiv_pre: u32,
        clk_equ_sysclk: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let clkcnt_l: u32 = unsafe { ::core::mem::transmute(clkcnt_l) };
            clkcnt_l as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let clkcnt_h: u32 = unsafe { ::core::mem::transmute(clkcnt_h) };
            clkcnt_h as u64
        });
        __bindgen_bitfield_unit.set(12usize, 6u8, {
            let clkcnt_n: u32 = unsafe { ::core::mem::transmute(clkcnt_n) };
            clkcnt_n as u64
        });
        __bindgen_bitfield_unit.set(18usize, 13u8, {
            let clkdiv_pre: u32 = unsafe { ::core::mem::transmute(clkdiv_pre) };
            clkdiv_pre as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let clk_equ_sysclk: u32 = unsafe { ::core::mem::transmute(clk_equ_sysclk) };
            clk_equ_sysclk as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn doutdin(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doutdin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_setup(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_setup(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_i_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_i_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_out_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_out_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_byte_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_byte_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_byte_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_byte_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_dual(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_dual(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_quad(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_quad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fwrite_qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fwrite_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_hold_pol(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_hold_pol(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dout_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dout_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_din_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_din_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dummy_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_addr_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_addr_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_cmd_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_cmd_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_prep_hold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_prep_hold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_miso_highpart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_miso_highpart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_mosi_highpart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_mosi_highpart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dummy_idle(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy_idle(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_mosi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_mosi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_miso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_miso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_dummy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_command(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_command(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doutdin: u32,
        reserved1: u32,
        cs_hold: u32,
        cs_setup: u32,
        ck_i_edge: u32,
        ck_out_edge: u32,
        reserved8: u32,
        rd_byte_order: u32,
        wr_byte_order: u32,
        fwrite_dual: u32,
        fwrite_quad: u32,
        fwrite_dio: u32,
        fwrite_qio: u32,
        sio: u32,
        usr_hold_pol: u32,
        usr_dout_hold: u32,
        usr_din_hold: u32,
        usr_dummy_hold: u32,
        usr_addr_hold: u32,
        usr_cmd_hold: u32,
        usr_prep_hold: u32,
        usr_miso_highpart: u32,
        usr_mosi_highpart: u32,
        usr_dummy_idle: u32,
        usr_mosi: u32,
        usr_miso: u32,
        usr_dummy: u32,
        usr_addr: u32,
        usr_command: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doutdin: u32 = unsafe { ::core::mem::transmute(doutdin) };
            doutdin as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cs_hold: u32 = unsafe { ::core::mem::transmute(cs_hold) };
            cs_hold as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cs_setup: u32 = unsafe { ::core::mem::transmute(cs_setup) };
            cs_setup as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ck_i_edge: u32 = unsafe { ::core::mem::transmute(ck_i_edge) };
            ck_i_edge as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ck_out_edge: u32 = unsafe { ::core::mem::transmute(ck_out_edge) };
            ck_out_edge as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rd_byte_order: u32 = unsafe { ::core::mem::transmute(rd_byte_order) };
            rd_byte_order as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wr_byte_order: u32 = unsafe { ::core::mem::transmute(wr_byte_order) };
            wr_byte_order as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fwrite_dual: u32 = unsafe { ::core::mem::transmute(fwrite_dual) };
            fwrite_dual as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fwrite_quad: u32 = unsafe { ::core::mem::transmute(fwrite_quad) };
            fwrite_quad as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fwrite_dio: u32 = unsafe { ::core::mem::transmute(fwrite_dio) };
            fwrite_dio as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fwrite_qio: u32 = unsafe { ::core::mem::transmute(fwrite_qio) };
            fwrite_qio as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sio: u32 = unsafe { ::core::mem::transmute(sio) };
            sio as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let usr_hold_pol: u32 = unsafe { ::core::mem::transmute(usr_hold_pol) };
            usr_hold_pol as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let usr_dout_hold: u32 = unsafe { ::core::mem::transmute(usr_dout_hold) };
            usr_dout_hold as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let usr_din_hold: u32 = unsafe { ::core::mem::transmute(usr_din_hold) };
            usr_din_hold as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let usr_dummy_hold: u32 = unsafe { ::core::mem::transmute(usr_dummy_hold) };
            usr_dummy_hold as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let usr_addr_hold: u32 = unsafe { ::core::mem::transmute(usr_addr_hold) };
            usr_addr_hold as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let usr_cmd_hold: u32 = unsafe { ::core::mem::transmute(usr_cmd_hold) };
            usr_cmd_hold as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let usr_prep_hold: u32 = unsafe { ::core::mem::transmute(usr_prep_hold) };
            usr_prep_hold as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let usr_miso_highpart: u32 = unsafe { ::core::mem::transmute(usr_miso_highpart) };
            usr_miso_highpart as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let usr_mosi_highpart: u32 = unsafe { ::core::mem::transmute(usr_mosi_highpart) };
            usr_mosi_highpart as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let usr_dummy_idle: u32 = unsafe { ::core::mem::transmute(usr_dummy_idle) };
            usr_dummy_idle as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let usr_mosi: u32 = unsafe { ::core::mem::transmute(usr_mosi) };
            usr_mosi as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let usr_miso: u32 = unsafe { ::core::mem::transmute(usr_miso) };
            usr_miso as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let usr_dummy: u32 = unsafe { ::core::mem::transmute(usr_dummy) };
            usr_dummy as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let usr_addr: u32 = unsafe { ::core::mem::transmute(usr_addr) };
            usr_addr as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let usr_command: u32 = unsafe { ::core::mem::transmute(usr_command) };
            usr_command as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn usr_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_usr_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_usr_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_dummy_cyclelen: u32,
        reserved8: u32,
        usr_addr_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let usr_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(usr_dummy_cyclelen) };
            usr_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(8usize, 18u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let usr_addr_bitlen: u32 = unsafe { ::core::mem::transmute(usr_addr_bitlen) };
            usr_addr_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn usr_command_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_usr_command_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_command_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_usr_command_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_command_value: u32,
        reserved16: u32,
        usr_command_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let usr_command_value: u32 = unsafe { ::core::mem::transmute(usr_command_value) };
            usr_command_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let usr_command_bitlen: u32 = unsafe { ::core::mem::transmute(usr_command_bitlen) };
            usr_command_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn usr_mosi_dbitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_usr_mosi_dbitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_mosi_dbitlen: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let usr_mosi_dbitlen: u32 = unsafe { ::core::mem::transmute(usr_mosi_dbitlen) };
            usr_mosi_dbitlen as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn usr_miso_dbitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_usr_miso_dbitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_miso_dbitlen: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let usr_miso_dbitlen: u32 = unsafe { ::core::mem::transmute(usr_miso_dbitlen) };
            usr_miso_dbitlen as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn cs0_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs0_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs1_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs1_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs2_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs2_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_dis(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_dis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn master_cs_pol(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_master_cs_pol(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn master_ck_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_master_ck_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn ck_idle_edge(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ck_idle_edge(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_keep_active(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_keep_active(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cs0_dis: u32,
        cs1_dis: u32,
        cs2_dis: u32,
        reserved3: u32,
        ck_dis: u32,
        master_cs_pol: u32,
        reserved9: u32,
        master_ck_sel: u32,
        reserved14: u32,
        ck_idle_edge: u32,
        cs_keep_active: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cs0_dis: u32 = unsafe { ::core::mem::transmute(cs0_dis) };
            cs0_dis as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cs1_dis: u32 = unsafe { ::core::mem::transmute(cs1_dis) };
            cs1_dis as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cs2_dis: u32 = unsafe { ::core::mem::transmute(cs2_dis) };
            cs2_dis as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ck_dis: u32 = unsafe { ::core::mem::transmute(ck_dis) };
            ck_dis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let master_cs_pol: u32 = unsafe { ::core::mem::transmute(master_cs_pol) };
            master_cs_pol as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let master_ck_sel: u32 = unsafe { ::core::mem::transmute(master_ck_sel) };
            master_ck_sel as u64
        });
        __bindgen_bitfield_unit.set(14usize, 15u8, {
            let reserved14: u32 = unsafe { ::core::mem::transmute(reserved14) };
            reserved14 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ck_idle_edge: u32 = unsafe { ::core::mem::transmute(ck_idle_edge) };
            ck_idle_edge as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let cs_keep_active: u32 = unsafe { ::core::mem::transmute(cs_keep_active) };
            cs_keep_active as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn rd_buf_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_buf_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_buf_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_buf_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_sta_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_sta_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_sta_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_sta_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trans_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trans_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_buf_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_buf_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_buf_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_buf_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_sta_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rd_sta_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_sta_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_sta_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trans_inten(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trans_inten(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_i_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cs_i_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn last_command(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_command(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn last_state(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_state(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn trans_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_trans_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd_define(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmd_define(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_rd_sta_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_rd_sta_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_rd_buf_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wr_rd_buf_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slave_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_slave_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sync_reset(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rd_buf_done: u32,
        wr_buf_done: u32,
        rd_sta_done: u32,
        wr_sta_done: u32,
        trans_done: u32,
        rd_buf_inten: u32,
        wr_buf_inten: u32,
        rd_sta_inten: u32,
        wr_sta_inten: u32,
        trans_inten: u32,
        cs_i_mode: u32,
        reserved12: u32,
        last_command: u32,
        last_state: u32,
        trans_cnt: u32,
        cmd_define: u32,
        wr_rd_sta_en: u32,
        wr_rd_buf_en: u32,
        slave_mode: u32,
        sync_reset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rd_buf_done: u32 = unsafe { ::core::mem::transmute(rd_buf_done) };
            rd_buf_done as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wr_buf_done: u32 = unsafe { ::core::mem::transmute(wr_buf_done) };
            wr_buf_done as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rd_sta_done: u32 = unsafe { ::core::mem::transmute(rd_sta_done) };
            rd_sta_done as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wr_sta_done: u32 = unsafe { ::core::mem::transmute(wr_sta_done) };
            wr_sta_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let trans_done: u32 = unsafe { ::core::mem::transmute(trans_done) };
            trans_done as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rd_buf_inten: u32 = unsafe { ::core::mem::transmute(rd_buf_inten) };
            rd_buf_inten as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let wr_buf_inten: u32 = unsafe { ::core::mem::transmute(wr_buf_inten) };
            wr_buf_inten as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rd_sta_inten: u32 = unsafe { ::core::mem::transmute(rd_sta_inten) };
            rd_sta_inten as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let wr_sta_inten: u32 = unsafe { ::core::mem::transmute(wr_sta_inten) };
            wr_sta_inten as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let trans_inten: u32 = unsafe { ::core::mem::transmute(trans_inten) };
            trans_inten as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let cs_i_mode: u32 = unsafe { ::core::mem::transmute(cs_i_mode) };
            cs_i_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let last_command: u32 = unsafe { ::core::mem::transmute(last_command) };
            last_command as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let last_state: u32 = unsafe { ::core::mem::transmute(last_state) };
            last_state as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let trans_cnt: u32 = unsafe { ::core::mem::transmute(trans_cnt) };
            trans_cnt as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let cmd_define: u32 = unsafe { ::core::mem::transmute(cmd_define) };
            cmd_define as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let wr_rd_sta_en: u32 = unsafe { ::core::mem::transmute(wr_rd_sta_en) };
            wr_rd_sta_en as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let wr_rd_buf_en: u32 = unsafe { ::core::mem::transmute(wr_rd_buf_en) };
            wr_rd_buf_en as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let slave_mode: u32 = unsafe { ::core::mem::transmute(slave_mode) };
            slave_mode as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sync_reset: u32 = unsafe { ::core::mem::transmute(sync_reset) };
            sync_reset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn rdbuf_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdbuf_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrbuf_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrbuf_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdsta_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdsta_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsta_dummy_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrsta_dummy_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_wr_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rd_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn status_readback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_status_readback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn status_fast_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_status_fast_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn status_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_status_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdbuf_dummy_en: u32,
        wrbuf_dummy_en: u32,
        rdsta_dummy_en: u32,
        wrsta_dummy_en: u32,
        wr_addr_bitlen: u32,
        rd_addr_bitlen: u32,
        reserved16: u32,
        status_readback: u32,
        status_fast_en: u32,
        status_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rdbuf_dummy_en: u32 = unsafe { ::core::mem::transmute(rdbuf_dummy_en) };
            rdbuf_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wrbuf_dummy_en: u32 = unsafe { ::core::mem::transmute(wrbuf_dummy_en) };
            wrbuf_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rdsta_dummy_en: u32 = unsafe { ::core::mem::transmute(rdsta_dummy_en) };
            rdsta_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wrsta_dummy_en: u32 = unsafe { ::core::mem::transmute(wrsta_dummy_en) };
            wrsta_dummy_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let wr_addr_bitlen: u32 = unsafe { ::core::mem::transmute(wr_addr_bitlen) };
            wr_addr_bitlen as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let rd_addr_bitlen: u32 = unsafe { ::core::mem::transmute(rd_addr_bitlen) };
            rd_addr_bitlen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let status_readback: u32 = unsafe { ::core::mem::transmute(status_readback) };
            status_readback as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let status_fast_en: u32 = unsafe { ::core::mem::transmute(status_fast_en) };
            status_fast_en as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let status_bitlen: u32 = unsafe { ::core::mem::transmute(status_bitlen) };
            status_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn rdsta_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdsta_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsta_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrsta_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rdbuf_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdbuf_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrbuf_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrbuf_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdsta_dummy_cyclelen: u32,
        wrsta_dummy_cyclelen: u32,
        rdbuf_dummy_cyclelen: u32,
        wrbuf_dummy_cyclelen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rdsta_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(rdsta_dummy_cyclelen) };
            rdsta_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let wrsta_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(wrsta_dummy_cyclelen) };
            wrsta_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rdbuf_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(rdbuf_dummy_cyclelen) };
            rdbuf_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let wrbuf_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(wrbuf_dummy_cyclelen) };
            wrbuf_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn rdbuf_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdbuf_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrbuf_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrbuf_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rdsta_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rdsta_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wrsta_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wrsta_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdbuf_cmd_value: u32,
        wrbuf_cmd_value: u32,
        rdsta_cmd_value: u32,
        wrsta_cmd_value: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rdbuf_cmd_value: u32 = unsafe { ::core::mem::transmute(rdbuf_cmd_value) };
            rdbuf_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let wrbuf_cmd_value: u32 = unsafe { ::core::mem::transmute(wrbuf_cmd_value) };
            wrbuf_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rdsta_cmd_value: u32 = unsafe { ::core::mem::transmute(rdsta_cmd_value) };
            rdsta_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let wrsta_cmd_value: u32 = unsafe { ::core::mem::transmute(wrsta_cmd_value) };
            wrsta_cmd_value as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn bit_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_bit_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bit_len: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let bit_len: u32 = unsafe { ::core::mem::transmute(bit_len) };
            bit_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn bit_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_bit_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bit_len: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let bit_len: u32 = unsafe { ::core::mem::transmute(bit_len) };
            bit_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn req_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_req_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_cmd_4byte(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_cmd_4byte(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_usr_cmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_usr_cmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flash_pes_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flash_pes_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        req_en: u32,
        usr_cmd_4byte: u32,
        flash_usr_cmd: u32,
        flash_pes_en: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let req_en: u32 = unsafe { ::core::mem::transmute(req_en) };
            req_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let usr_cmd_4byte: u32 = unsafe { ::core::mem::transmute(usr_cmd_4byte) };
            usr_cmd_4byte as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let flash_usr_cmd: u32 = unsafe { ::core::mem::transmute(flash_usr_cmd) };
            flash_usr_cmd as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flash_pes_en: u32 = unsafe { ::core::mem::transmute(flash_pes_en) };
            flash_pes_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl spi_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_sram_dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_sram_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_sram_qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_sram_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_wr_sram_dummy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_wr_sram_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_rd_sram_dummy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usr_rd_sram_dummy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_sram_usr_rcmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cache_sram_usr_rcmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sram_bytes_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sram_bytes_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sram_dummy_cyclelen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sram_dummy_cyclelen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sram_addr_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_sram_addr_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_sram_usr_wcmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cache_sram_usr_wcmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        usr_sram_dio: u32,
        usr_sram_qio: u32,
        usr_wr_sram_dummy: u32,
        usr_rd_sram_dummy: u32,
        cache_sram_usr_rcmd: u32,
        sram_bytes_len: u32,
        sram_dummy_cyclelen: u32,
        sram_addr_bitlen: u32,
        cache_sram_usr_wcmd: u32,
        reserved29: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let usr_sram_dio: u32 = unsafe { ::core::mem::transmute(usr_sram_dio) };
            usr_sram_dio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let usr_sram_qio: u32 = unsafe { ::core::mem::transmute(usr_sram_qio) };
            usr_sram_qio as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let usr_wr_sram_dummy: u32 = unsafe { ::core::mem::transmute(usr_wr_sram_dummy) };
            usr_wr_sram_dummy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let usr_rd_sram_dummy: u32 = unsafe { ::core::mem::transmute(usr_rd_sram_dummy) };
            usr_rd_sram_dummy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cache_sram_usr_rcmd: u32 = unsafe { ::core::mem::transmute(cache_sram_usr_rcmd) };
            cache_sram_usr_rcmd as u64
        });
        __bindgen_bitfield_unit.set(6usize, 8u8, {
            let sram_bytes_len: u32 = unsafe { ::core::mem::transmute(sram_bytes_len) };
            sram_bytes_len as u64
        });
        __bindgen_bitfield_unit.set(14usize, 8u8, {
            let sram_dummy_cyclelen: u32 = unsafe { ::core::mem::transmute(sram_dummy_cyclelen) };
            sram_dummy_cyclelen as u64
        });
        __bindgen_bitfield_unit.set(22usize, 6u8, {
            let sram_addr_bitlen: u32 = unsafe { ::core::mem::transmute(sram_addr_bitlen) };
            sram_addr_bitlen as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let cache_sram_usr_wcmd: u32 = unsafe { ::core::mem::transmute(cache_sram_usr_wcmd) };
            cache_sram_usr_wcmd as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let reserved29: u32 = unsafe { ::core::mem::transmute(reserved29) };
            reserved29 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn dio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qio(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_io(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_io(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dio: u32,
        qio: u32,
        reserved2: u32,
        rst_io: u32,
        reserved5: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dio: u32 = unsafe { ::core::mem::transmute(dio) };
            dio as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let qio: u32 = unsafe { ::core::mem::transmute(qio) };
            qio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rst_io: u32 = unsafe { ::core::mem::transmute(rst_io) };
            rst_io as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn usr_rd_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_usr_rd_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_rd_cmd_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_usr_rd_cmd_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_rd_cmd_value: u32,
        reserved16: u32,
        usr_rd_cmd_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let usr_rd_cmd_value: u32 = unsafe { ::core::mem::transmute(usr_rd_cmd_value) };
            usr_rd_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let usr_rd_cmd_bitlen: u32 = unsafe { ::core::mem::transmute(usr_rd_cmd_bitlen) };
            usr_rd_cmd_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn usr_wr_cmd_value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_usr_wr_cmd_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn usr_wr_cmd_bitlen(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_usr_wr_cmd_bitlen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        usr_wr_cmd_value: u32,
        reserved16: u32,
        usr_wr_cmd_bitlen: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let usr_wr_cmd_value: u32 = unsafe { ::core::mem::transmute(usr_wr_cmd_value) };
            usr_wr_cmd_value as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let usr_wr_cmd_bitlen: u32 = unsafe { ::core::mem::transmute(usr_wr_cmd_bitlen) };
            usr_wr_cmd_bitlen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn slv_rdata_bit(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_slv_rdata_bit(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slv_rdata_bit: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let slv_rdata_bit: u32 = unsafe { ::core::mem::transmute(slv_rdata_bit) };
            slv_rdata_bit as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn t_pp_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_t_pp_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn t_pp_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_t_pp_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn t_pp_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t_pp_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t_pp_time: u32,
        reserved12: u32,
        t_pp_shift: u32,
        reserved20: u32,
        t_pp_ena: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let t_pp_time: u32 = unsafe { ::core::mem::transmute(t_pp_time) };
            t_pp_time as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let t_pp_shift: u32 = unsafe { ::core::mem::transmute(t_pp_shift) };
            t_pp_shift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 11u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let t_pp_ena: u32 = unsafe { ::core::mem::transmute(t_pp_ena) };
            t_pp_ena as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn t_erase_time(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_t_erase_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn t_erase_shift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_t_erase_shift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn t_erase_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t_erase_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t_erase_time: u32,
        reserved12: u32,
        t_erase_shift: u32,
        reserved20: u32,
        t_erase_ena: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let t_erase_time: u32 = unsafe { ::core::mem::transmute(t_erase_time) };
            t_erase_time as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let t_erase_shift: u32 = unsafe { ::core::mem::transmute(t_erase_shift) };
            t_erase_shift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 11u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let t_erase_ena: u32 = unsafe { ::core::mem::transmute(t_erase_ena) };
            t_erase_ena as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(st: u32, reserved3: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let st: u32 = unsafe { ::core::mem::transmute(st) };
            st as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn int_hold_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_int_hold_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        int_hold_ena: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let int_hold_ena: u32 = unsafe { ::core::mem::transmute(int_hold_ena) };
            int_hold_ena as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_29 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_29__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_dev_s__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn in_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_fifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_fifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ahbm_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ahbm_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_loop_test(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_loop_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_auto_wrback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_auto_wrback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outdscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outdscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indscr_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_indscr_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_data_burst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_data_burst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dma_rx_stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dma_rx_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dma_tx_stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dma_tx_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dma_continue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dma_continue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved17(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved17(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        in_rst: u32,
        out_rst: u32,
        ahbm_fifo_rst: u32,
        ahbm_rst: u32,
        in_loop_test: u32,
        out_loop_test: u32,
        out_auto_wrback: u32,
        out_eof_mode: u32,
        outdscr_burst_en: u32,
        indscr_burst_en: u32,
        out_data_burst_en: u32,
        reserved13: u32,
        dma_rx_stop: u32,
        dma_tx_stop: u32,
        dma_continue: u32,
        reserved17: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_rst: u32 = unsafe { ::core::mem::transmute(in_rst) };
            in_rst as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let out_rst: u32 = unsafe { ::core::mem::transmute(out_rst) };
            out_rst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ahbm_fifo_rst: u32 = unsafe { ::core::mem::transmute(ahbm_fifo_rst) };
            ahbm_fifo_rst as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ahbm_rst: u32 = unsafe { ::core::mem::transmute(ahbm_rst) };
            ahbm_rst as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let in_loop_test: u32 = unsafe { ::core::mem::transmute(in_loop_test) };
            in_loop_test as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_loop_test: u32 = unsafe { ::core::mem::transmute(out_loop_test) };
            out_loop_test as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_auto_wrback: u32 = unsafe { ::core::mem::transmute(out_auto_wrback) };
            out_auto_wrback as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let out_eof_mode: u32 = unsafe { ::core::mem::transmute(out_eof_mode) };
            out_eof_mode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let outdscr_burst_en: u32 = unsafe { ::core::mem::transmute(outdscr_burst_en) };
            outdscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let indscr_burst_en: u32 = unsafe { ::core::mem::transmute(indscr_burst_en) };
            indscr_burst_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let out_data_burst_en: u32 = unsafe { ::core::mem::transmute(out_data_burst_en) };
            out_data_burst_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved13: u32 = unsafe { ::core::mem::transmute(reserved13) };
            reserved13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let dma_rx_stop: u32 = unsafe { ::core::mem::transmute(dma_rx_stop) };
            dma_rx_stop as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dma_tx_stop: u32 = unsafe { ::core::mem::transmute(dma_tx_stop) };
            dma_tx_stop as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let dma_continue: u32 = unsafe { ::core::mem::transmute(dma_continue) };
            dma_continue as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved17: u32 = unsafe { ::core::mem::transmute(reserved17) };
            reserved17 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_30 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_30__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_30__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_30__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        reserved20: u32,
        stop: u32,
        start: u32,
        restart: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_31 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_31__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_31__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_31__bindgen_ty_1 {
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_ret(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_ret(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved21(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved21(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn stop(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr: u32,
        auto_ret: u32,
        reserved21: u32,
        stop: u32,
        start: u32,
        restart: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let auto_ret: u32 = unsafe { ::core::mem::transmute(auto_ret) };
            auto_ret as u64
        });
        __bindgen_bitfield_unit.set(21usize, 7u8, {
            let reserved21: u32 = unsafe { ::core::mem::transmute(reserved21) };
            reserved21 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let stop: u32 = unsafe { ::core::mem::transmute(stop) };
            stop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let restart: u32 = unsafe { ::core::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_32 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_32__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_32__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_32__bindgen_ty_1 {
    #[inline]
    pub fn rx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_en: u32,
        tx_en: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_en: u32 = unsafe { ::core::mem::transmute(rx_en) };
            rx_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_en: u32 = unsafe { ::core::mem::transmute(tx_en) };
            tx_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_33 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_33__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_33__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_33__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_34 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_34__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_34__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_34__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_35 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_35__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_35__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_35__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_36 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_36__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_36__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_36__bindgen_ty_1 {
    #[inline]
    pub fn inlink_dscr_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inlink_dscr_error(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inlink_dscr_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_err_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_err_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_suc_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_suc_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_total_eof(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_total_eof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inlink_dscr_empty: u32,
        outlink_dscr_error: u32,
        inlink_dscr_error: u32,
        in_done: u32,
        in_err_eof: u32,
        in_suc_eof: u32,
        out_done: u32,
        out_eof: u32,
        out_total_eof: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inlink_dscr_empty: u32 = unsafe { ::core::mem::transmute(inlink_dscr_empty) };
            inlink_dscr_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let outlink_dscr_error: u32 = unsafe { ::core::mem::transmute(outlink_dscr_error) };
            outlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inlink_dscr_error: u32 = unsafe { ::core::mem::transmute(inlink_dscr_error) };
            inlink_dscr_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_done: u32 = unsafe { ::core::mem::transmute(in_done) };
            in_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_err_eof: u32 = unsafe { ::core::mem::transmute(in_err_eof) };
            in_err_eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let in_suc_eof: u32 = unsafe { ::core::mem::transmute(in_suc_eof) };
            in_suc_eof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let out_done: u32 = unsafe { ::core::mem::transmute(out_done) };
            out_done as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let out_eof: u32 = unsafe { ::core::mem::transmute(out_eof) };
            out_eof as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let out_total_eof: u32 = unsafe { ::core::mem::transmute(out_total_eof) };
            out_total_eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_dev_s__bindgen_ty_37 {
    pub __bindgen_anon_1: spi_dev_s__bindgen_ty_37__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev_s__bindgen_ty_37__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_dev_s__bindgen_ty_37__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type spi_dev_t = spi_dev_s;
extern "C" {
    pub static mut SPI0: spi_dev_t;
}
extern "C" {
    pub static mut SPI1: spi_dev_t;
}
extern "C" {
    pub static mut SPI2: spi_dev_t;
}
extern "C" {
    pub static mut SPI3: spi_dev_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_signal_conn_t {
    pub spiclk_out: u8,
    pub spiclk_in: u8,
    pub spid_out: u8,
    pub spiq_out: u8,
    pub spiwp_out: u8,
    pub spihd_out: u8,
    pub spid_in: u8,
    pub spiq_in: u8,
    pub spiwp_in: u8,
    pub spihd_in: u8,
    pub spics_out: [u8; 3usize],
    pub spics_in: u8,
    pub spidqs_out: u8,
    pub spidqs_in: u8,
    pub spicd_out: u8,
    pub spicd_in: u8,
    pub spiclk_iomux_pin: u8,
    pub spid_iomux_pin: u8,
    pub spiq_iomux_pin: u8,
    pub spiwp_iomux_pin: u8,
    pub spihd_iomux_pin: u8,
    pub spics0_iomux_pin: u8,
    pub irq: u8,
    pub irq_dma: u8,
    pub module: periph_module_t,
    pub func: c_types::c_int,
    pub hw: *mut spi_dev_t,
}
extern "C" {
    pub static spi_periph_signal: [spi_signal_conn_t; 3usize];
}
#[doc = "< SPI1"]
pub const spi_host_device_t_SPI1_HOST: spi_host_device_t = 0;
#[doc = "< SPI2"]
pub const spi_host_device_t_SPI2_HOST: spi_host_device_t = 1;
#[doc = "< SPI3"]
pub const spi_host_device_t_SPI3_HOST: spi_host_device_t = 2;
#[doc = " @brief Enum with the three SPI peripherals that are software-accessible in it"]
pub type spi_host_device_t = c_types::c_uint;
#[doc = " @brief This is a configuration structure for a SPI bus."]
#[doc = ""]
#[doc = " You can use this structure to specify the GPIO pins of the bus. Normally, the driver will use the"]
#[doc = " GPIO matrix to route the signals. An exception is made when all signals either can be routed through"]
#[doc = " the IO_MUX or are -1. In that case, the IO_MUX is used, allowing for >40MHz speeds."]
#[doc = ""]
#[doc = " @note Be advised that the slave driver does not use the quadwp/quadhd lines and fields in spi_bus_config_t refering to these lines will be ignored and can thus safely be left uninitialized."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_bus_config_t {
    #[doc = "< GPIO pin for Master Out Slave In (=spi_d) signal, or -1 if not used."]
    pub mosi_io_num: c_types::c_int,
    #[doc = "< GPIO pin for Master In Slave Out (=spi_q) signal, or -1 if not used."]
    pub miso_io_num: c_types::c_int,
    #[doc = "< GPIO pin for Spi CLocK signal, or -1 if not used."]
    pub sclk_io_num: c_types::c_int,
    #[doc = "< GPIO pin for WP (Write Protect) signal which is used as D2 in 4-bit communication modes, or -1 if not used."]
    pub quadwp_io_num: c_types::c_int,
    #[doc = "< GPIO pin for HD (HolD) signal which is used as D3 in 4-bit communication modes, or -1 if not used."]
    pub quadhd_io_num: c_types::c_int,
    #[doc = "< Maximum transfer size, in bytes. Defaults to 4094 if 0."]
    pub max_transfer_sz: c_types::c_int,
    #[doc = "< Abilities of bus to be checked by the driver. Or-ed value of ``SPICOMMON_BUSFLAG_*`` flags."]
    pub flags: u32,
    #[doc = "< Interrupt flag for the bus to set the priority, and IRAM attribute, see"]
    #[doc = "  ``esp_intr_alloc.h``. Note that the EDGE, INTRDISABLED attribute are ignored"]
    #[doc = "  by the driver. Note that if ESP_INTR_FLAG_IRAM is set, ALL the callbacks of"]
    #[doc = "  the driver, and their callee functions, should be put in the IRAM."]
    pub intr_flags: c_types::c_int,
}
extern "C" {
    #[doc = " @brief Initialize a SPI bus"]
    #[doc = ""]
    #[doc = " @warning For now, only supports HSPI and VSPI."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral that controls this bus"]
    #[doc = " @param bus_config Pointer to a spi_bus_config_t struct specifying how the host should be initialized"]
    #[doc = " @param dma_chan Either channel 1 or 2, or 0 in the case when no DMA is required. Selecting a DMA channel"]
    #[doc = "                 for a SPI bus allows transfers on the bus to have sizes only limited by the amount of"]
    #[doc = "                 internal memory. Selecting no DMA channel (by passing the value 0) limits the amount of"]
    #[doc = "                 bytes transfered to a maximum of 64. Set to 0 if only the SPI flash uses"]
    #[doc = "                 this bus."]
    #[doc = ""]
    #[doc = " @warning If a DMA channel is selected, any transmit and receive buffer used should be allocated in"]
    #[doc = "          DMA-capable memory."]
    #[doc = ""]
    #[doc = " @warning The ISR of SPI is always executed on the core which calls this"]
    #[doc = "          function. Never starve the ISR on this core or the SPI transactions will not"]
    #[doc = "          be handled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if configuration is invalid"]
    #[doc = "         - ESP_ERR_INVALID_STATE if host already is in use"]
    #[doc = "         - ESP_ERR_NO_MEM        if out of memory"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_bus_initialize(
        host: spi_host_device_t,
        bus_config: *const spi_bus_config_t,
        dma_chan: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Free a SPI bus"]
    #[doc = ""]
    #[doc = " @warning In order for this to succeed, all devices have to be removed first."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral to free"]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_INVALID_STATE if not all devices on the bus are freed"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_bus_free(host: spi_host_device_t) -> esp_err_t;
}
pub type transaction_cb_t =
    ::core::option::Option<unsafe extern "C" fn(trans: *mut spi_transaction_t)>;
#[doc = " @brief This is a configuration for a SPI slave device that is connected to one of the SPI buses."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_device_interface_config_t {
    #[doc = "< Default amount of bits in command phase (0-16), used when ``SPI_TRANS_VARIABLE_CMD`` is not used, otherwise ignored."]
    pub command_bits: u8,
    #[doc = "< Default amount of bits in address phase (0-64), used when ``SPI_TRANS_VARIABLE_ADDR`` is not used, otherwise ignored."]
    pub address_bits: u8,
    #[doc = "< Amount of dummy bits to insert between address and data phase"]
    pub dummy_bits: u8,
    #[doc = "< SPI mode (0-3)"]
    pub mode: u8,
    #[doc = "< Duty cycle of positive clock, in 1/256th increments (128 = 50%/50% duty). Setting this to 0 (=not setting it) is equivalent to setting this to 128."]
    pub duty_cycle_pos: u16,
    #[doc = "< Amount of SPI bit-cycles the cs should be activated before the transmission (0-16). This only works on half-duplex transactions."]
    pub cs_ena_pretrans: u16,
    #[doc = "< Amount of SPI bit-cycles the cs should stay active after the transmission (0-16)"]
    pub cs_ena_posttrans: u8,
    #[doc = "< Clock speed, divisors of 80MHz, in Hz. See ``SPI_MASTER_FREQ_*``."]
    pub clock_speed_hz: c_types::c_int,
    #[doc = "< Maximum data valid time of slave. The time required between SCLK and MISO"]
    #[doc = "valid, including the possible clock delay from slave to master. The driver uses this value to give an extra"]
    #[doc = "delay before the MISO is ready on the line. Leave at 0 unless you know you need a delay. For better timing"]
    #[doc = "performance at high frequency (over 8MHz), it's suggest to have the right value."]
    pub input_delay_ns: c_types::c_int,
    #[doc = "< CS GPIO pin for this device, or -1 if not used"]
    pub spics_io_num: c_types::c_int,
    #[doc = "< Bitwise OR of SPI_DEVICE_* flags"]
    pub flags: u32,
    #[doc = "< Transaction queue size. This sets how many transactions can be 'in the air' (queued using spi_device_queue_trans but not yet finished using spi_device_get_trans_result) at the same time"]
    pub queue_size: c_types::c_int,
    #[doc = "< Callback to be called before a transmission is started."]
    #[doc = ""]
    #[doc = "  This callback is called within interrupt"]
    #[doc = "  context should be in IRAM for best"]
    #[doc = "  performance, see \"Transferring Speed\""]
    #[doc = "  section in the SPI Master documentation for"]
    #[doc = "  full details. If not, the callback may crash"]
    #[doc = "  during flash operation when the driver is"]
    #[doc = "  initialized with ESP_INTR_FLAG_IRAM."]
    pub pre_cb: transaction_cb_t,
    #[doc = "< Callback to be called after a transmission has completed."]
    #[doc = ""]
    #[doc = "  This callback is called within interrupt"]
    #[doc = "  context should be in IRAM for best"]
    #[doc = "  performance, see \"Transferring Speed\""]
    #[doc = "  section in the SPI Master documentation for"]
    #[doc = "  full details. If not, the callback may crash"]
    #[doc = "  during flash operation when the driver is"]
    #[doc = "  initialized with ESP_INTR_FLAG_IRAM."]
    pub post_cb: transaction_cb_t,
}
#[doc = " This structure describes one SPI transaction. The descriptor should not be modified until the transaction finishes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_transaction_t {
    #[doc = "< Bitwise OR of SPI_TRANS_* flags"]
    pub flags: u32,
    #[doc = "< Command data, of which the length is set in the ``command_bits`` of spi_device_interface_config_t."]
    #[doc = ""]
    #[doc = "  <b>NOTE: this field, used to be \"command\" in ESP-IDF 2.1 and before, is re-written to be used in a new way in ESP-IDF 3.0.</b>"]
    #[doc = ""]
    #[doc = "  Example: write 0x0123 and command_bits=12 to send command 0x12, 0x3_ (in previous version, you may have to write 0x3_12)."]
    pub cmd: u16,
    #[doc = "< Address data, of which the length is set in the ``address_bits`` of spi_device_interface_config_t."]
    #[doc = ""]
    #[doc = "  <b>NOTE: this field, used to be \"address\" in ESP-IDF 2.1 and before, is re-written to be used in a new way in ESP-IDF3.0.</b>"]
    #[doc = ""]
    #[doc = "  Example: write 0x123400 and address_bits=24 to send address of 0x12, 0x34, 0x00 (in previous version, you may have to write 0x12340000)."]
    pub addr: u64,
    #[doc = "< Total data length, in bits"]
    pub length: size_t,
    #[doc = "< Total data length received, should be not greater than ``length`` in full-duplex mode (0 defaults this to the value of ``length``)."]
    pub rxlength: size_t,
    #[doc = "< User-defined variable. Can be used to store eg transaction ID."]
    pub user: *mut c_types::c_void,
    pub __bindgen_anon_1: spi_transaction_t__bindgen_ty_1,
    pub __bindgen_anon_2: spi_transaction_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_transaction_t__bindgen_ty_1 {
    #[doc = "< Pointer to transmit buffer, or NULL for no MOSI phase"]
    pub tx_buffer: *const c_types::c_void,
    #[doc = "< If SPI_TRANS_USE_TXDATA is set, data set here is sent directly from this variable."]
    pub tx_data: [u8; 4usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_transaction_t__bindgen_ty_2 {
    #[doc = "< Pointer to receive buffer, or NULL for no MISO phase. Written by 4 bytes-unit if DMA is used."]
    pub rx_buffer: *mut c_types::c_void,
    #[doc = "< If SPI_TRANS_USE_RXDATA is set, data is received directly to this variable"]
    pub rx_data: [u8; 4usize],
    _bindgen_union_align: u32,
}
#[doc = " This struct is for SPI transactions which may change their address and command length."]
#[doc = " Please do set the flags in base to ``SPI_TRANS_VARIABLE_CMD_ADR`` to use the bit length here."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_transaction_ext_t {
    #[doc = "< Transaction data, so that pointer to spi_transaction_t can be converted into spi_transaction_ext_t"]
    pub base: spi_transaction_t,
    #[doc = "< The command length in this transaction, in bits."]
    pub command_bits: u8,
    #[doc = "< The address length in this transaction, in bits."]
    pub address_bits: u8,
    #[doc = "< The dummy length in this transaction, in bits."]
    pub dummy_bits: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_device_t {
    _unused: [u8; 0],
}
pub type spi_device_handle_t = *mut spi_device_t;
extern "C" {
    #[doc = " @brief Allocate a device on a SPI bus"]
    #[doc = ""]
    #[doc = " This initializes the internal structures for a device, plus allocates a CS pin on the indicated SPI master"]
    #[doc = " peripheral and routes it to the indicated GPIO. All SPI master devices have three CS pins and can thus control"]
    #[doc = " up to three devices."]
    #[doc = ""]
    #[doc = " @note While in general, speeds up to 80MHz on the dedicated SPI pins and 40MHz on GPIO-matrix-routed pins are"]
    #[doc = "       supported, full-duplex transfers routed over the GPIO matrix only support speeds up to 26MHz."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral to allocate device on"]
    #[doc = " @param dev_config SPI interface protocol config for the device"]
    #[doc = " @param handle Pointer to variable to hold the device handle"]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_NOT_FOUND     if host doesn't have any free CS slots"]
    #[doc = "         - ESP_ERR_NO_MEM        if out of memory"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_bus_add_device(
        host: spi_host_device_t,
        dev_config: *const spi_device_interface_config_t,
        handle: *mut spi_device_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove a device from the SPI bus"]
    #[doc = ""]
    #[doc = " @param handle Device handle to free"]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_INVALID_STATE if device already is freed"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_bus_remove_device(handle: spi_device_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a SPI transaction for interrupt transaction execution. Get the result by ``spi_device_get_trans_result``."]
    #[doc = ""]
    #[doc = " @note Normally a device cannot start (queue) polling and interrupt"]
    #[doc = "      transactions simultaneously."]
    #[doc = ""]
    #[doc = " @param handle Device handle obtained using spi_host_add_dev"]
    #[doc = " @param trans_desc Description of transaction to execute"]
    #[doc = " @param ticks_to_wait Ticks to wait until there's room in the queue; use portMAX_DELAY to"]
    #[doc = "                      never time out."]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_TIMEOUT       if there was no room in the queue before ticks_to_wait expired"]
    #[doc = "         - ESP_ERR_NO_MEM        if allocating DMA-capable temporary buffer failed"]
    #[doc = "         - ESP_ERR_INVALID_STATE if previous transactions are not finished"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_device_queue_trans(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the result of a SPI transaction queued earlier by ``spi_device_queue_trans``."]
    #[doc = ""]
    #[doc = " This routine will wait until a transaction to the given device"]
    #[doc = " succesfully completed. It will then return the description of the"]
    #[doc = " completed transaction so software can inspect the result and e.g. free the memory or"]
    #[doc = " re-use the buffers."]
    #[doc = ""]
    #[doc = " @param handle Device handle obtained using spi_host_add_dev"]
    #[doc = " @param trans_desc Pointer to variable able to contain a pointer to the description of the transaction"]
    #[doc = "that is executed. The descriptor should not be modified until the descriptor is returned by"]
    #[doc = "spi_device_get_trans_result."]
    #[doc = " @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time"]
    #[doc = "out."]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_TIMEOUT       if there was no completed transaction before ticks_to_wait expired"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_device_get_trans_result(
        handle: spi_device_handle_t,
        trans_desc: *mut *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send a SPI transaction, wait for it to complete, and return the result"]
    #[doc = ""]
    #[doc = " This function is the equivalent of calling spi_device_queue_trans() followed by spi_device_get_trans_result()."]
    #[doc = " Do not use this when there is still a transaction separately queued (started) from spi_device_queue_trans() or polling_start/transmit that hasn't been finalized."]
    #[doc = ""]
    #[doc = " @note This function is not thread safe when multiple tasks access the same SPI device."]
    #[doc = "      Normally a device cannot start (queue) polling and interrupt"]
    #[doc = "      transactions simutanuously."]
    #[doc = ""]
    #[doc = " @param handle Device handle obtained using spi_host_add_dev"]
    #[doc = " @param trans_desc Description of transaction to execute"]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_device_transmit(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Immediately start a polling transaction."]
    #[doc = ""]
    #[doc = " @note Normally a device cannot start (queue) polling and interrupt"]
    #[doc = "      transactions simutanuously. Moreover, a device cannot start a new polling"]
    #[doc = "      transaction if another polling transaction is not finished."]
    #[doc = ""]
    #[doc = " @param handle Device handle obtained using spi_host_add_dev"]
    #[doc = " @param trans_desc Description of transaction to execute"]
    #[doc = " @param ticks_to_wait Ticks to wait until there's room in the queue;"]
    #[doc = "              currently only portMAX_DELAY is supported."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_TIMEOUT       if the device cannot get control of the bus before ``ticks_to_wait`` expired"]
    #[doc = "         - ESP_ERR_NO_MEM        if allocating DMA-capable temporary buffer failed"]
    #[doc = "         - ESP_ERR_INVALID_STATE if previous transactions are not finished"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_device_polling_start(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Poll until the polling transaction ends."]
    #[doc = ""]
    #[doc = " This routine will not return until the transaction to the given device has"]
    #[doc = " succesfully completed. The task is not blocked, but actively busy-spins for"]
    #[doc = " the transaction to be completed."]
    #[doc = ""]
    #[doc = " @param handle Device handle obtained using spi_host_add_dev"]
    #[doc = " @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time"]
    #[doc = "out."]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_TIMEOUT       if the transaction cannot finish before ticks_to_wait expired"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_device_polling_end(
        handle: spi_device_handle_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send a polling transaction, wait for it to complete, and return the result"]
    #[doc = ""]
    #[doc = " This function is the equivalent of calling spi_device_polling_start() followed by spi_device_polling_end()."]
    #[doc = " Do not use this when there is still a transaction that hasn't been finalized."]
    #[doc = ""]
    #[doc = " @note This function is not thread safe when multiple tasks access the same SPI device."]
    #[doc = "      Normally a device cannot start (queue) polling and interrupt"]
    #[doc = "      transactions simutanuously."]
    #[doc = ""]
    #[doc = " @param handle Device handle obtained using spi_host_add_dev"]
    #[doc = " @param trans_desc Description of transaction to execute"]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_device_polling_transmit(
        handle: spi_device_handle_t,
        trans_desc: *mut spi_transaction_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Occupy the SPI bus for a device to do continuous transactions."]
    #[doc = ""]
    #[doc = " Transactions to all other devices will be put off until ``spi_device_release_bus`` is called."]
    #[doc = ""]
    #[doc = " @note The function will wait until all the existing transactions have been sent."]
    #[doc = ""]
    #[doc = " @param device The device to occupy the bus."]
    #[doc = " @param wait Time to wait before the the bus is occupied by the device. Currently MUST set to portMAX_DELAY."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_ERR_INVALID_ARG : ``wait`` is not set to portMAX_DELAY."]
    #[doc = "      - ESP_OK : Success."]
    pub fn spi_device_acquire_bus(device: spi_device_handle_t, wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release the SPI bus occupied by the device. All other devices can start sending transactions."]
    #[doc = ""]
    #[doc = " @param dev The device to release the bus."]
    pub fn spi_device_release_bus(dev: spi_device_handle_t);
}
extern "C" {
    #[doc = " @brief Calculate the working frequency that is most close to desired frequency, and also the register value."]
    #[doc = ""]
    #[doc = " @param fapb The frequency of apb clock, should be ``APB_CLK_FREQ``."]
    #[doc = " @param hz Desired working frequency"]
    #[doc = " @param duty_cycle Duty cycle of the spi clock"]
    #[doc = " @param reg_o Output of value to be set in clock register, or NULL if not needed."]
    #[doc = ""]
    #[doc = " @deprecated The app shouldn't care about the register. Call ``spi_get_actual_clock`` instead."]
    #[doc = ""]
    #[doc = " @return Actual working frequency that most fit."]
    pub fn spi_cal_clock(
        fapb: c_types::c_int,
        hz: c_types::c_int,
        duty_cycle: c_types::c_int,
        reg_o: *mut u32,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Calculate the working frequency that is most close to desired frequency."]
    #[doc = ""]
    #[doc = " @param fapb The frequency of apb clock, should be ``APB_CLK_FREQ``."]
    #[doc = " @param hz Desired working frequency"]
    #[doc = " @param duty_cycle Duty cycle of the spi clock"]
    #[doc = ""]
    #[doc = " @return Actual working frequency that most fit."]
    pub fn spi_get_actual_clock(
        fapb: c_types::c_int,
        hz: c_types::c_int,
        duty_cycle: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Calculate the timing settings of specified frequency and settings."]
    #[doc = ""]
    #[doc = " @param gpio_is_used True if using GPIO matrix, or False if iomux pins are used."]
    #[doc = " @param input_delay_ns Input delay from SCLK launch edge to MISO data valid."]
    #[doc = " @param eff_clk Effective clock frequency (in Hz) from spi_cal_clock."]
    #[doc = " @param dummy_o Address of dummy bits used output. Set to NULL if not needed."]
    #[doc = " @param cycles_remain_o Address of cycles remaining (after dummy bits are used) output."]
    #[doc = "         - -1 If too many cycles remaining, suggest to compensate half a clock."]
    #[doc = "         - 0 If no remaining cycles or dummy bits are not used."]
    #[doc = "         - positive value: cycles suggest to compensate."]
    #[doc = ""]
    #[doc = " @note If **dummy_o* is not zero, it means dummy bits should be applied in half duplex mode, and full duplex mode may not work."]
    pub fn spi_get_timing(
        gpio_is_used: bool,
        input_delay_ns: c_types::c_int,
        eff_clk: c_types::c_int,
        dummy_o: *mut c_types::c_int,
        cycles_remain_o: *mut c_types::c_int,
    );
}
extern "C" {
    #[doc = " @brief Get the frequency limit of current configurations."]
    #[doc = "         SPI master working at this limit is OK, while above the limit, full duplex mode and DMA will not work,"]
    #[doc = "         and dummy bits will be aplied in the half duplex mode."]
    #[doc = ""]
    #[doc = " @param gpio_is_used True if using GPIO matrix, or False if native pins are used."]
    #[doc = " @param input_delay_ns Input delay from SCLK launch edge to MISO data valid."]
    #[doc = " @return Frequency limit of current configurations."]
    pub fn spi_get_freq_limit(gpio_is_used: bool, input_delay_ns: c_types::c_int)
        -> c_types::c_int;
}
#[doc = " Extra configuration for SPI host"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdspi_slot_config_t {
    #[doc = "< GPIO number of MISO signal"]
    pub gpio_miso: gpio_num_t,
    #[doc = "< GPIO number of MOSI signal"]
    pub gpio_mosi: gpio_num_t,
    #[doc = "< GPIO number of SCK signal"]
    pub gpio_sck: gpio_num_t,
    #[doc = "< GPIO number of CS signal"]
    pub gpio_cs: gpio_num_t,
    #[doc = "< GPIO number of card detect signal"]
    pub gpio_cd: gpio_num_t,
    #[doc = "< GPIO number of write protect signal"]
    pub gpio_wp: gpio_num_t,
    #[doc = "< GPIO number of interrupt line (input) for SDIO card."]
    pub gpio_int: gpio_num_t,
    #[doc = "< DMA channel to be used by SPI driver (1 or 2)"]
    pub dma_channel: c_types::c_int,
}
extern "C" {
    #[doc = " @brief Initialize SD SPI driver"]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - other error codes may be returned in future versions"]
    pub fn sdspi_host_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize SD SPI driver for the specific SPI controller"]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @note The SDIO over sdspi needs an extra interrupt line. Call ``gpio_install_isr_service()`` before this function."]
    #[doc = ""]
    #[doc = " @param slot         SPI controller to use (HSPI_HOST or VSPI_HOST)"]
    #[doc = " @param slot_config  pointer to slot configuration structure"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if sdspi_init_slot has invalid arguments"]
    #[doc = "      - ESP_ERR_NO_MEM if memory can not be allocated"]
    #[doc = "      - other errors from the underlying spi_master and gpio drivers"]
    pub fn sdspi_host_init_slot(
        slot: c_types::c_int,
        slot_config: *const sdspi_slot_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send command to the card and get response"]
    #[doc = ""]
    #[doc = " This function returns when command is sent and response is received,"]
    #[doc = " or data is transferred, or timeout occurs."]
    #[doc = ""]
    #[doc = " @note This function is not thread safe w.r.t. init/deinit functions,"]
    #[doc = "       and bus width/clock speed configuration functions. Multiple tasks"]
    #[doc = "       can call sdspi_host_do_transaction as long as other sdspi_host_*"]
    #[doc = "       functions are not called."]
    #[doc = ""]
    #[doc = " @param slot      SPI controller (HSPI_HOST or VSPI_HOST)"]
    #[doc = " @param cmdinfo   pointer to structure describing command and data to transfer"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_TIMEOUT if response or data transfer has timed out"]
    #[doc = "      - ESP_ERR_INVALID_CRC if response or data transfer CRC check has failed"]
    #[doc = "      - ESP_ERR_INVALID_RESPONSE if the card has sent an invalid response"]
    pub fn sdspi_host_do_transaction(
        slot: c_types::c_int,
        cmdinfo: *mut sdmmc_command_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set card clock frequency"]
    #[doc = ""]
    #[doc = " Currently only integer fractions of 40MHz clock can be used."]
    #[doc = " For High Speed cards, 40MHz can be used."]
    #[doc = " For Default Speed cards, 20MHz can be used."]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @param slot      SPI controller (HSPI_HOST or VSPI_HOST)"]
    #[doc = " @param freq_khz  card clock frequency, in kHz"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - other error codes may be returned in the future"]
    pub fn sdspi_host_set_card_clk(slot: c_types::c_int, freq_khz: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release resources allocated using sdspi_host_init"]
    #[doc = ""]
    #[doc = " @note This function is not thread safe"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if sdspi_host_init function has not been called"]
    pub fn sdspi_host_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable SDIO interrupt."]
    #[doc = ""]
    #[doc = " @param slot SPI controller to use (HSPI_HOST or VSPI_HOST)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn sdspi_host_io_int_enable(slot: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait for SDIO interrupt until timeout."]
    #[doc = ""]
    #[doc = " @param slot SPI controller to use (HSPI_HOST or VSPI_HOST)"]
    #[doc = " @param timeout_ticks Ticks to wait before timeout."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn sdspi_host_io_int_wait(slot: c_types::c_int, timeout_ticks: TickType_t) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_sd_dev_s {
    pub channel: [gpio_sd_dev_s__bindgen_ty_1; 8usize],
    pub cg: gpio_sd_dev_s__bindgen_ty_2,
    pub misc: gpio_sd_dev_s__bindgen_ty_3,
    pub version: gpio_sd_dev_s__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_sd_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: gpio_sd_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_sd_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl gpio_sd_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn duty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_duty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn prescale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_prescale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        duty: u32,
        prescale: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let duty: u32 = unsafe { ::core::mem::transmute(duty) };
            duty as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let prescale: u32 = unsafe { ::core::mem::transmute(prescale) };
            prescale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_sd_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: gpio_sd_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_sd_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_sd_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, clk_en: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_sd_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: gpio_sd_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_sd_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_sd_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn spi_swap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_spi_swap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        spi_swap: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let spi_swap: u32 = unsafe { ::core::mem::transmute(spi_swap) };
            spi_swap as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_sd_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: gpio_sd_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_sd_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_sd_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpio_sd_dev_t = gpio_sd_dev_s;
extern "C" {
    pub static mut SIGMADELTA: gpio_sd_dev_t;
}
#[doc = " @brief SIGMADELTA port number, the max port number is (SIGMADELTA_NUM_MAX -1)."]
pub type sigmadelta_port_t = c_types::c_int;
#[doc = " @brief Sigma-delta channel list"]
pub type sigmadelta_channel_t = c_types::c_int;
#[doc = " @brief Sigma-delta configure struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigmadelta_config_t {
    #[doc = "< Sigma-delta channel number"]
    pub channel: sigmadelta_channel_t,
    #[doc = "< Sigma-delta duty, duty ranges from -128 to 127."]
    pub sigmadelta_duty: i8,
    #[doc = "< Sigma-delta prescale, prescale ranges from 0 to 255."]
    pub sigmadelta_prescale: u8,
    #[doc = "< Sigma-delta output io number, refer to gpio.h for more details."]
    pub sigmadelta_gpio: u8,
}
extern "C" {
    #[doc = " @brief Configure Sigma-delta channel"]
    #[doc = ""]
    #[doc = " @param  config Pointer of Sigma-delta channel configuration struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE sigmadelta driver already initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_config(config: *const sigmadelta_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set Sigma-delta channel duty."]
    #[doc = ""]
    #[doc = "        This function is used to set Sigma-delta channel duty,"]
    #[doc = "        If you add a capacitor between the output pin and ground,"]
    #[doc = "        the average output voltage will be Vdc = VDDIO / 256 * duty + VDDIO/2,"]
    #[doc = "        where VDDIO is the power supply voltage."]
    #[doc = ""]
    #[doc = " @param channel Sigma-delta channel number"]
    #[doc = " @param duty Sigma-delta duty of one channel, the value ranges from -128 to 127, recommended range is -90 ~ 90."]
    #[doc = "             The waveform is more like a random one in this range."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE sigmadelta driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_set_duty(channel: sigmadelta_channel_t, duty: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set Sigma-delta channel's clock pre-scale value."]
    #[doc = "        The source clock is APP_CLK, 80MHz. The clock frequency of the sigma-delta channel is APP_CLK / pre_scale"]
    #[doc = ""]
    #[doc = " @param channel Sigma-delta channel number"]
    #[doc = " @param prescale The divider of source clock, ranges from 0 to 255"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE sigmadelta driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_set_prescale(channel: sigmadelta_channel_t, prescale: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set Sigma-delta signal output pin"]
    #[doc = ""]
    #[doc = " @param channel Sigma-delta channel number"]
    #[doc = " @param gpio_num GPIO number of output pin."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE sigmadelta driver has not been initialized"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn sigmadelta_set_pin(channel: sigmadelta_channel_t, gpio_num: gpio_num_t) -> esp_err_t;
}
pub type slave_transaction_cb_t =
    ::core::option::Option<unsafe extern "C" fn(trans: *mut spi_slave_transaction_t)>;
#[doc = " @brief This is a configuration for a SPI host acting as a slave device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_slave_interface_config_t {
    #[doc = "< CS GPIO pin for this device"]
    pub spics_io_num: c_types::c_int,
    #[doc = "< Bitwise OR of SPI_SLAVE_* flags"]
    pub flags: u32,
    #[doc = "< Transaction queue size. This sets how many transactions can be 'in the air' (queued using spi_slave_queue_trans but not yet finished using spi_slave_get_trans_result) at the same time"]
    pub queue_size: c_types::c_int,
    #[doc = "< SPI mode (0-3)"]
    pub mode: u8,
    #[doc = "< Callback called after the SPI registers are loaded with new data."]
    #[doc = ""]
    #[doc = "  This callback is called within interrupt"]
    #[doc = "  context should be in IRAM for best"]
    #[doc = "  performance, see \"Transferring Speed\""]
    #[doc = "  section in the SPI Master documentation for"]
    #[doc = "  full details. If not, the callback may crash"]
    #[doc = "  during flash operation when the driver is"]
    #[doc = "  initialized with ESP_INTR_FLAG_IRAM."]
    pub post_setup_cb: slave_transaction_cb_t,
    #[doc = "< Callback called after a transaction is done."]
    #[doc = ""]
    #[doc = "  This callback is called within interrupt"]
    #[doc = "  context should be in IRAM for best"]
    #[doc = "  performance, see \"Transferring Speed\""]
    #[doc = "  section in the SPI Master documentation for"]
    #[doc = "  full details. If not, the callback may crash"]
    #[doc = "  during flash operation when the driver is"]
    #[doc = "  initialized with ESP_INTR_FLAG_IRAM."]
    pub post_trans_cb: slave_transaction_cb_t,
}
#[doc = " This structure describes one SPI transaction"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_slave_transaction_t {
    #[doc = "< Total data length, in bits"]
    pub length: size_t,
    #[doc = "< Transaction data length, in bits"]
    pub trans_len: size_t,
    #[doc = "< Pointer to transmit buffer, or NULL for no MOSI phase"]
    pub tx_buffer: *const c_types::c_void,
    #[doc = "< Pointer to receive buffer, or NULL for no MISO phase."]
    #[doc = " When the DMA is anabled, must start at WORD boundary (``rx_buffer%4==0``),"]
    #[doc = " and has length of a multiple of 4 bytes."]
    pub rx_buffer: *mut c_types::c_void,
    #[doc = "< User-defined variable. Can be used to store eg transaction ID."]
    pub user: *mut c_types::c_void,
}
extern "C" {
    #[doc = " @brief Initialize a SPI bus as a slave interface"]
    #[doc = ""]
    #[doc = " @warning For now, only supports HSPI and VSPI."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral to use as a SPI slave interface"]
    #[doc = " @param bus_config Pointer to a spi_bus_config_t struct specifying how the host should be initialized"]
    #[doc = " @param slave_config Pointer to a spi_slave_interface_config_t struct specifying the details for the slave interface"]
    #[doc = " @param dma_chan Either 1 or 2. A SPI bus used by this driver must have a DMA channel associated with"]
    #[doc = "                 it. The SPI hardware has two DMA channels to share. This parameter indicates which"]
    #[doc = "                 one to use."]
    #[doc = ""]
    #[doc = " @warning If a DMA channel is selected, any transmit and receive buffer used should be allocated in"]
    #[doc = "          DMA-capable memory."]
    #[doc = ""]
    #[doc = " @warning The ISR of SPI is always executed on the core which calls this"]
    #[doc = "          function. Never starve the ISR on this core or the SPI transactions will not"]
    #[doc = "          be handled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if configuration is invalid"]
    #[doc = "         - ESP_ERR_INVALID_STATE if host already is in use"]
    #[doc = "         - ESP_ERR_NO_MEM        if out of memory"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_slave_initialize(
        host: spi_host_device_t,
        bus_config: *const spi_bus_config_t,
        slave_config: *const spi_slave_interface_config_t,
        dma_chan: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Free a SPI bus claimed as a SPI slave interface"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral to free"]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_ERR_INVALID_STATE if not all devices on the bus are freed"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_slave_free(host: spi_host_device_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue a SPI transaction for execution"]
    #[doc = ""]
    #[doc = " Queues a SPI transaction to be executed by this slave device. (The transaction queue size was specified when the slave"]
    #[doc = " device was initialised via spi_slave_initialize.) This function may block if the queue is full (depending on the"]
    #[doc = " ticks_to_wait parameter). No SPI operation is directly initiated by this function, the next queued transaction"]
    #[doc = " will happen when the master initiates a SPI transaction by pulling down CS and sending out clock signals."]
    #[doc = ""]
    #[doc = " This function hands over ownership of the buffers in ``trans_desc`` to the SPI slave driver; the application is"]
    #[doc = " not to access this memory until ``spi_slave_queue_trans`` is called to hand ownership back to the application."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral that is acting as a slave"]
    #[doc = " @param trans_desc Description of transaction to execute. Not const because we may want to write status back"]
    #[doc = "                   into the transaction description."]
    #[doc = " @param ticks_to_wait Ticks to wait until there's room in the queue; use portMAX_DELAY to"]
    #[doc = "                      never time out."]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_slave_queue_trans(
        host: spi_host_device_t,
        trans_desc: *const spi_slave_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the result of a SPI transaction queued earlier"]
    #[doc = ""]
    #[doc = " This routine will wait until a transaction to the given device (queued earlier with"]
    #[doc = " spi_slave_queue_trans) has succesfully completed. It will then return the description of the"]
    #[doc = " completed transaction so software can inspect the result and e.g. free the memory or"]
    #[doc = " re-use the buffers."]
    #[doc = ""]
    #[doc = " It is mandatory to eventually use this function for any transaction queued by ``spi_slave_queue_trans``."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral to that is acting as a slave"]
    #[doc = " @param[out] trans_desc Pointer to variable able to contain a pointer to the description of the"]
    #[doc = "                   transaction that is executed"]
    #[doc = " @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time"]
    #[doc = "                      out."]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_slave_get_trans_result(
        host: spi_host_device_t,
        trans_desc: *mut *mut spi_slave_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Do a SPI transaction"]
    #[doc = ""]
    #[doc = " Essentially does the same as spi_slave_queue_trans followed by spi_slave_get_trans_result. Do"]
    #[doc = " not use this when there is still a transaction queued that hasn't been finalized"]
    #[doc = " using spi_slave_get_trans_result."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral to that is acting as a slave"]
    #[doc = " @param trans_desc Pointer to variable able to contain a pointer to the description of the"]
    #[doc = "                   transaction that is executed. Not const because we may want to write status back"]
    #[doc = "                   into the transaction description."]
    #[doc = " @param ticks_to_wait Ticks to wait until there's a returned item; use portMAX_DELAY to never time"]
    #[doc = "                      out."]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_INVALID_ARG   if parameter is invalid"]
    #[doc = "         - ESP_OK                on success"]
    pub fn spi_slave_transmit(
        host: spi_host_device_t,
        trans_desc: *mut spi_slave_transaction_t,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timg_dev_s {
    pub hw_timer: [timg_dev_s__bindgen_ty_1; 2usize],
    pub wdt_config0: timg_dev_s__bindgen_ty_2,
    pub wdt_config1: timg_dev_s__bindgen_ty_3,
    pub wdt_config2: u32,
    pub wdt_config3: u32,
    pub wdt_config4: u32,
    pub wdt_config5: u32,
    pub wdt_feed: u32,
    pub wdt_wprotect: u32,
    pub rtc_cali_cfg: timg_dev_s__bindgen_ty_4,
    pub rtc_cali_cfg1: timg_dev_s__bindgen_ty_5,
    pub lactconfig: timg_dev_s__bindgen_ty_6,
    pub lactrtc: timg_dev_s__bindgen_ty_7,
    pub lactlo: u32,
    pub lacthi: u32,
    pub lactupdate: u32,
    pub lactalarmlo: u32,
    pub lactalarmhi: u32,
    pub lactloadlo: u32,
    pub lactloadhi: u32,
    pub lactload: u32,
    pub int_ena: timg_dev_s__bindgen_ty_8,
    pub int_raw: timg_dev_s__bindgen_ty_9,
    pub int_st_timers: timg_dev_s__bindgen_ty_10,
    pub int_clr_timers: timg_dev_s__bindgen_ty_11,
    pub reserved_a8: u32,
    pub reserved_ac: u32,
    pub reserved_b0: u32,
    pub reserved_b4: u32,
    pub reserved_b8: u32,
    pub reserved_bc: u32,
    pub reserved_c0: u32,
    pub reserved_c4: u32,
    pub reserved_c8: u32,
    pub reserved_cc: u32,
    pub reserved_d0: u32,
    pub reserved_d4: u32,
    pub reserved_d8: u32,
    pub reserved_dc: u32,
    pub reserved_e0: u32,
    pub reserved_e4: u32,
    pub reserved_e8: u32,
    pub reserved_ec: u32,
    pub reserved_f0: u32,
    pub reserved_f4: u32,
    pub timg_date: timg_dev_s__bindgen_ty_12,
    pub clk: timg_dev_s__bindgen_ty_13,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_1 {
    pub config: timg_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub cnt_low: u32,
    pub cnt_high: u32,
    pub update: u32,
    pub alarm_low: u32,
    pub alarm_high: u32,
    pub load_low: u32,
    pub load_high: u32,
    pub reload: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl timg_dev_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn alarm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alarm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn level_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edge_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edge_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn divider(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_divider(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn autoreload(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoreload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn increase(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_increase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        alarm_en: u32,
        level_int_en: u32,
        edge_int_en: u32,
        divider: u32,
        autoreload: u32,
        increase: u32,
        enable: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let alarm_en: u32 = unsafe { ::core::mem::transmute(alarm_en) };
            alarm_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let level_int_en: u32 = unsafe { ::core::mem::transmute(level_int_en) };
            level_int_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let edge_int_en: u32 = unsafe { ::core::mem::transmute(edge_int_en) };
            edge_int_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 16u8, {
            let divider: u32 = unsafe { ::core::mem::transmute(divider) };
            divider as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let autoreload: u32 = unsafe { ::core::mem::transmute(autoreload) };
            autoreload as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let increase: u32 = unsafe { ::core::mem::transmute(increase) };
            increase as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let enable: u32 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl timg_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn flashboot_mod_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flashboot_mod_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sys_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sys_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_reset_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cpu_reset_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn level_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edge_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edge_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stg3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stg3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn stg2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stg2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn stg1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stg1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn stg0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stg0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        flashboot_mod_en: u32,
        sys_reset_length: u32,
        cpu_reset_length: u32,
        level_int_en: u32,
        edge_int_en: u32,
        stg3: u32,
        stg2: u32,
        stg1: u32,
        stg0: u32,
        en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let flashboot_mod_en: u32 = unsafe { ::core::mem::transmute(flashboot_mod_en) };
            flashboot_mod_en as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let sys_reset_length: u32 = unsafe { ::core::mem::transmute(sys_reset_length) };
            sys_reset_length as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let cpu_reset_length: u32 = unsafe { ::core::mem::transmute(cpu_reset_length) };
            cpu_reset_length as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let level_int_en: u32 = unsafe { ::core::mem::transmute(level_int_en) };
            level_int_en as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let edge_int_en: u32 = unsafe { ::core::mem::transmute(edge_int_en) };
            edge_int_en as u64
        });
        __bindgen_bitfield_unit.set(23usize, 2u8, {
            let stg3: u32 = unsafe { ::core::mem::transmute(stg3) };
            stg3 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let stg2: u32 = unsafe { ::core::mem::transmute(stg2) };
            stg2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let stg1: u32 = unsafe { ::core::mem::transmute(stg1) };
            stg1 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let stg0: u32 = unsafe { ::core::mem::transmute(stg0) };
            stg0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl timg_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_prescale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_clk_prescale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        clk_prescale: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let clk_prescale: u32 = unsafe { ::core::mem::transmute(clk_prescale) };
            clk_prescale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl timg_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn start_cycling(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start_cycling(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_clk_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        start_cycling: u32,
        clk_sel: u32,
        rdy: u32,
        max: u32,
        start: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let start_cycling: u32 = unsafe { ::core::mem::transmute(start_cycling) };
            start_cycling as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let clk_sel: u32 = unsafe { ::core::mem::transmute(clk_sel) };
            clk_sel as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rdy: u32 = unsafe { ::core::mem::transmute(rdy) };
            rdy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let max: u32 = unsafe { ::core::mem::transmute(max) };
            max as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn value(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_value(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, value: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let value: u32 = unsafe { ::core::mem::transmute(value) };
            value as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl timg_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rtc_only(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpst_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpst_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lac_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lac_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alarm_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alarm_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn level_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edge_int_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edge_int_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn divider(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_divider(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn autoreload(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoreload(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn increase(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_increase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rtc_only: u32,
        cpst_en: u32,
        lac_en: u32,
        alarm_en: u32,
        level_int_en: u32,
        edge_int_en: u32,
        divider: u32,
        autoreload: u32,
        increase: u32,
        en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rtc_only: u32 = unsafe { ::core::mem::transmute(rtc_only) };
            rtc_only as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cpst_en: u32 = unsafe { ::core::mem::transmute(cpst_en) };
            cpst_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let lac_en: u32 = unsafe { ::core::mem::transmute(lac_en) };
            lac_en as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let alarm_en: u32 = unsafe { ::core::mem::transmute(alarm_en) };
            alarm_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let level_int_en: u32 = unsafe { ::core::mem::transmute(level_int_en) };
            level_int_en as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let edge_int_en: u32 = unsafe { ::core::mem::transmute(edge_int_en) };
            edge_int_en as u64
        });
        __bindgen_bitfield_unit.set(13usize, 16u8, {
            let divider: u32 = unsafe { ::core::mem::transmute(divider) };
            divider as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let autoreload: u32 = unsafe { ::core::mem::transmute(autoreload) };
            autoreload as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let increase: u32 = unsafe { ::core::mem::transmute(increase) };
            increase as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn step_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_step_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        step_len: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let step_len: u32 = unsafe { ::core::mem::transmute(step_len) };
            step_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn t0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn t1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lact(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lact(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t0: u32,
        t1: u32,
        wdt: u32,
        lact: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let t0: u32 = unsafe { ::core::mem::transmute(t0) };
            t0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let t1: u32 = unsafe { ::core::mem::transmute(t1) };
            t1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wdt: u32 = unsafe { ::core::mem::transmute(wdt) };
            wdt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lact: u32 = unsafe { ::core::mem::transmute(lact) };
            lact as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn t0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn t1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lact(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lact(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t0: u32,
        t1: u32,
        wdt: u32,
        lact: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let t0: u32 = unsafe { ::core::mem::transmute(t0) };
            t0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let t1: u32 = unsafe { ::core::mem::transmute(t1) };
            t1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wdt: u32 = unsafe { ::core::mem::transmute(wdt) };
            wdt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lact: u32 = unsafe { ::core::mem::transmute(lact) };
            lact as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn t0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn t1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lact(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lact(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t0: u32,
        t1: u32,
        wdt: u32,
        lact: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let t0: u32 = unsafe { ::core::mem::transmute(t0) };
            t0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let t1: u32 = unsafe { ::core::mem::transmute(t1) };
            t1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wdt: u32 = unsafe { ::core::mem::transmute(wdt) };
            wdt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lact: u32 = unsafe { ::core::mem::transmute(lact) };
            lact as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn t0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn t1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_t1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wdt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wdt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lact(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lact(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        t0: u32,
        t1: u32,
        wdt: u32,
        lact: u32,
        reserved4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let t0: u32 = unsafe { ::core::mem::transmute(t0) };
            t0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let t1: u32 = unsafe { ::core::mem::transmute(t1) };
            t1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wdt: u32 = unsafe { ::core::mem::transmute(wdt) };
            wdt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let lact: u32 = unsafe { ::core::mem::transmute(lact) };
            lact as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved4: u32 = unsafe { ::core::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn date(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_date(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(date: u32, reserved28: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let date: u32 = unsafe { ::core::mem::transmute(date) };
            date as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union timg_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: timg_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct timg_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl timg_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved0: u32, en: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type timg_dev_t = timg_dev_s;
extern "C" {
    pub static mut TIMERG0: timg_dev_t;
}
extern "C" {
    pub static mut TIMERG1: timg_dev_t;
}
#[doc = "<Hw timer group 0"]
pub const timer_group_t_TIMER_GROUP_0: timer_group_t = 0;
#[doc = "<Hw timer group 1"]
pub const timer_group_t_TIMER_GROUP_1: timer_group_t = 1;
pub const timer_group_t_TIMER_GROUP_MAX: timer_group_t = 2;
#[doc = " @brief Selects a Timer-Group out of 2 available groups"]
pub type timer_group_t = c_types::c_uint;
#[doc = "<Select timer0 of GROUPx"]
pub const timer_idx_t_TIMER_0: timer_idx_t = 0;
#[doc = "<Select timer1 of GROUPx"]
pub const timer_idx_t_TIMER_1: timer_idx_t = 1;
pub const timer_idx_t_TIMER_MAX: timer_idx_t = 2;
#[doc = " @brief Select a hardware timer from timer groups"]
pub type timer_idx_t = c_types::c_uint;
#[doc = "< Descending Count from cnt.high|cnt.low"]
pub const timer_count_dir_t_TIMER_COUNT_DOWN: timer_count_dir_t = 0;
#[doc = "< Ascending Count from Zero"]
pub const timer_count_dir_t_TIMER_COUNT_UP: timer_count_dir_t = 1;
pub const timer_count_dir_t_TIMER_COUNT_MAX: timer_count_dir_t = 2;
#[doc = " @brief Decides the direction of counter"]
pub type timer_count_dir_t = c_types::c_uint;
#[doc = "<Pause timer counter"]
pub const timer_start_t_TIMER_PAUSE: timer_start_t = 0;
#[doc = "<Start timer counter"]
pub const timer_start_t_TIMER_START: timer_start_t = 1;
#[doc = " @brief Decides whether timer is on or paused"]
pub type timer_start_t = c_types::c_uint;
#[doc = "< interrupt of timer 0"]
pub const timer_intr_t_TIMER_INTR_T0: timer_intr_t = 1;
#[doc = "< interrupt of timer 1"]
pub const timer_intr_t_TIMER_INTR_T1: timer_intr_t = 2;
#[doc = "< interrupt of watchdog"]
pub const timer_intr_t_TIMER_INTR_WDT: timer_intr_t = 4;
pub const timer_intr_t_TIMER_INTR_NONE: timer_intr_t = 0;
#[doc = " @brief Interrupt types of the timer."]
pub type timer_intr_t = c_types::c_uint;
#[doc = "< The stage is turned off"]
pub const timer_wdt_behavior_t_TIMER_WDT_OFF: timer_wdt_behavior_t = 0;
#[doc = "< The stage will trigger an interrupt"]
pub const timer_wdt_behavior_t_TIMER_WDT_INT: timer_wdt_behavior_t = 1;
#[doc = "< The stage will reset the CPU"]
pub const timer_wdt_behavior_t_TIMER_WDT_RESET_CPU: timer_wdt_behavior_t = 2;
#[doc = "< The stage will reset the whole system"]
pub const timer_wdt_behavior_t_TIMER_WDT_RESET_SYSTEM: timer_wdt_behavior_t = 3;
#[doc = " @brief Behavior of the watchdog if a stage times out."]
pub type timer_wdt_behavior_t = c_types::c_uint;
#[doc = "< Disable timer alarm"]
pub const timer_alarm_t_TIMER_ALARM_DIS: timer_alarm_t = 0;
#[doc = "< Enable timer alarm"]
pub const timer_alarm_t_TIMER_ALARM_EN: timer_alarm_t = 1;
pub const timer_alarm_t_TIMER_ALARM_MAX: timer_alarm_t = 2;
#[doc = " @brief Decides whether to enable alarm mode"]
pub type timer_alarm_t = c_types::c_uint;
#[doc = "< Interrupt mode: level mode"]
pub const timer_intr_mode_t_TIMER_INTR_LEVEL: timer_intr_mode_t = 0;
pub const timer_intr_mode_t_TIMER_INTR_MAX: timer_intr_mode_t = 1;
#[doc = " @brief Select interrupt type if running in alarm mode."]
pub type timer_intr_mode_t = c_types::c_uint;
#[doc = "< Disable auto-reload: hardware will not load counter value after an alarm event"]
pub const timer_autoreload_t_TIMER_AUTORELOAD_DIS: timer_autoreload_t = 0;
#[doc = "< Enable auto-reload: hardware will load counter value after an alarm event"]
pub const timer_autoreload_t_TIMER_AUTORELOAD_EN: timer_autoreload_t = 1;
pub const timer_autoreload_t_TIMER_AUTORELOAD_MAX: timer_autoreload_t = 2;
#[doc = " @brief Select if Alarm needs to be loaded by software or automatically reload by hardware."]
pub type timer_autoreload_t = c_types::c_uint;
#[doc = " @brief Data structure with timer's configuration settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_config_t {
    #[doc = "< Timer alarm enable"]
    pub alarm_en: timer_alarm_t,
    #[doc = "< Counter enable"]
    pub counter_en: timer_start_t,
    #[doc = "< Interrupt mode"]
    pub intr_type: timer_intr_mode_t,
    #[doc = "< Counter direction"]
    pub counter_dir: timer_count_dir_t,
    #[doc = "< Timer auto-reload"]
    pub auto_reload: timer_autoreload_t,
    #[doc = "< Counter clock divider. The divider's range is from from 2 to 65536."]
    pub divider: u32,
}
#[doc = " @brief Interrupt handle callback function. User need to retrun a bool value"]
#[doc = "        in callback."]
#[doc = ""]
#[doc = " @return"]
#[doc = "     - True Do task yield at the end of ISR"]
#[doc = "     - False Not do task yield at the end of ISR"]
#[doc = ""]
#[doc = " @note If you called FreeRTOS functions in callback, you need to return true or false based on"]
#[doc = "       the retrun value of argument `pxHigherPriorityTaskWoken`."]
#[doc = "       For example, `xQueueSendFromISR` is called in callback, if the return value `pxHigherPriorityTaskWoken`"]
#[doc = "       of any FreeRTOS calls is pdTRUE, return true; otherwise return false."]
pub type timer_isr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void) -> bool>;
#[doc = " @brief Interrupt handle, used in order to free the isr after use."]
#[doc = " Aliases to an int handle for now."]
pub type timer_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Read the counter value of hardware timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param timer_val Pointer to accept timer counter value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_counter_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        timer_val: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read the counter value of hardware timer, in unit of a given scale."]
    #[doc = ""]
    #[doc = " @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param time Pointer, type of double*, to accept timer counter value, in seconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_counter_time_sec(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        time: *mut f64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set counter value to hardware timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param load_val Counter value to write to the hardware timer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_counter_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        load_val: u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start the counter of hardware timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_start(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Pause the counter of hardware timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_pause(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set counting mode for hardware timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param counter_dir Counting direction of timer, count-up or count-down"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_counter_mode(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        counter_dir: timer_count_dir_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable counter reload function when alarm event occurs."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param reload Counter reload mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_auto_reload(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        reload: timer_autoreload_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set hardware timer source clock divider. Timer groups clock are divider from APB clock."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param divider Timer clock divider value. The divider's range is from from 2 to 65536."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_divider(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        divider: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set timer alarm value."]
    #[doc = ""]
    #[doc = " @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param alarm_value A 64-bit value to set the alarm value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_alarm_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_value: u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get timer alarm value."]
    #[doc = ""]
    #[doc = " @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param alarm_value Pointer of A 64-bit value to accept the alarm value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_alarm_value(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_value: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable generation of timer alarm events."]
    #[doc = ""]
    #[doc = " @param group_num Timer group, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param alarm_en To enable or disable timer alarm function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_set_alarm(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_en: timer_alarm_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Add ISR handle callback for the corresponding timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number"]
    #[doc = " @param timer_num Timer index of timer group"]
    #[doc = " @param isr_handler Interrupt handler function, it is a callback function."]
    #[doc = " @param arg Parameter for handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @note This ISR handler will be called from an ISR."]
    #[doc = "       This ISR handler do not need to handle interrupt status, and should be kept short."]
    #[doc = "       If you want to realize some specific applications or write the whole ISR, you can"]
    #[doc = "       call timer_isr_register(...) to register ISR."]
    #[doc = ""]
    #[doc = "       The callback should return a bool value to determine whether need to do YIELD at"]
    #[doc = "       the end of the ISR."]
    #[doc = ""]
    #[doc = "       If the intr_alloc_flags value ESP_INTR_FLAG_IRAM is set,"]
    #[doc = "       the handler function must be declared with IRAM_ATTR attribute"]
    #[doc = "       and can only call functions in IRAM or ROM. It cannot call other timer APIs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_isr_callback_add(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        isr_handler: timer_isr_t,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handle callback for the corresponding timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number"]
    #[doc = " @param timer_num Timer index of timer group"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_isr_callback_remove(group_num: timer_group_t, timer_num: timer_idx_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register Timer interrupt handler, the handler is an ISR."]
    #[doc = "        The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number"]
    #[doc = " @param timer_num Timer index of timer group"]
    #[doc = " @param fn Interrupt handler function."]
    #[doc = " @param arg Parameter for handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here."]
    #[doc = ""]
    #[doc = " @note If use this function to reigster ISR, you need to write the whole ISR."]
    #[doc = "       In the interrupt handler, you need to call timer_spinlock_take(..) before"]
    #[doc = "       your handling, and call timer_spinlock_give(...) after your handling."]
    #[doc = ""]
    #[doc = "       If the intr_alloc_flags value ESP_INTR_FLAG_IRAM is set,"]
    #[doc = "       the handler function must be declared with IRAM_ATTR attribute"]
    #[doc = "       and can only call functions in IRAM or ROM. It cannot call other timer APIs."]
    #[doc = "       Use direct register access to configure timers from inside the ISR in this case."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_isr_register(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut timer_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initializes and configure the timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param config Pointer to timer initialization parameters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_init(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        config: *const timer_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitializes the timer."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_deinit(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get timer configure value."]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index, 0 for hw_timer[0] & 1 for hw_timer[1]"]
    #[doc = " @param config Pointer of struct to accept timer parameters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_get_config(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        config: *mut timer_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable timer group interrupt, by enable mask"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param intr_mask Timer interrupt enable mask."]
    #[doc = "          - TIMER_INTR_T0: t0 interrupt"]
    #[doc = "          - TIMER_INTR_T1: t1 interrupt"]
    #[doc = "          - TIMER_INTR_WDT: watchdog interrupt"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_group_intr_enable(group_num: timer_group_t, intr_mask: timer_intr_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable timer group interrupt, by disable mask"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param intr_mask Timer interrupt disable mask."]
    #[doc = "          - TIMER_INTR_T0: t0 interrupt"]
    #[doc = "          - TIMER_INTR_T1: t1 interrupt"]
    #[doc = "          - TIMER_INTR_WDT: watchdog interrupt"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_group_intr_disable(group_num: timer_group_t, intr_mask: timer_intr_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable timer interrupt"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_enable_intr(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable timer interrupt"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_disable_intr(group_num: timer_group_t, timer_num: timer_idx_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear timer interrupt status, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - None"]
    pub fn timer_group_intr_clr_in_isr(group_num: timer_group_t, timer_num: timer_idx_t);
}
extern "C" {
    #[doc = " @brief Clear timer interrupt status, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - None"]
    pub fn timer_group_clr_intr_status_in_isr(group_num: timer_group_t, timer_num: timer_idx_t);
}
extern "C" {
    #[doc = " @brief Enable alarm interrupt, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - None"]
    pub fn timer_group_enable_alarm_in_isr(group_num: timer_group_t, timer_num: timer_idx_t);
}
extern "C" {
    #[doc = " @brief Get the current counter value, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - Counter value"]
    pub fn timer_group_get_counter_value_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
    ) -> u64;
}
extern "C" {
    #[doc = " @brief Set the alarm threshold for the timer, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = " @param alarm_val Alarm threshold."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - None"]
    pub fn timer_group_set_alarm_value_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        alarm_val: u64,
    );
}
extern "C" {
    #[doc = " @brief Enable/disable a counter, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index."]
    #[doc = " @param counter_en Enable/disable."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - None"]
    pub fn timer_group_set_counter_enable_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
        counter_en: timer_start_t,
    );
}
extern "C" {
    #[doc = " @brief Get the masked interrupt status, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - Interrupt status"]
    pub fn timer_group_intr_get_in_isr(group_num: timer_group_t) -> timer_intr_t;
}
extern "C" {
    #[doc = " @brief Get interrupt status, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - Interrupt status"]
    pub fn timer_group_get_intr_status_in_isr(group_num: timer_group_t) -> u32;
}
extern "C" {
    #[doc = " @brief Clear the masked interrupt status, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param intr_mask Masked interrupt."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - None"]
    pub fn timer_group_clr_intr_sta_in_isr(group_num: timer_group_t, intr_mask: timer_intr_t);
}
extern "C" {
    #[doc = " @brief Get auto reload enable status, just used in ISR"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = " @param timer_num Timer index"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - True Auto reload enabled"]
    #[doc = "     - False Auto reload disabled"]
    pub fn timer_group_get_auto_reload_in_isr(
        group_num: timer_group_t,
        timer_num: timer_idx_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Take timer spinlock to enter critical protect"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_spinlock_take(group_num: timer_group_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Give timer spinlock to exit critical protect"]
    #[doc = ""]
    #[doc = " @param group_num Timer group number, 0 for TIMERG0 or 1 for TIMERG1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn timer_spinlock_give(group_num: timer_group_t) -> esp_err_t;
}
extern "C" {
    pub static touch_sensor_channel_io_map: [c_types::c_int; 10usize];
}
#[doc = "< Touch pad channel 0 is GPIO4(ESP32)"]
pub const touch_pad_t_TOUCH_PAD_NUM0: touch_pad_t = 0;
#[doc = "< Touch pad channel 1 is GPIO0(ESP32) / GPIO1(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM1: touch_pad_t = 1;
#[doc = "< Touch pad channel 2 is GPIO2(ESP32) / GPIO2(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM2: touch_pad_t = 2;
#[doc = "< Touch pad channel 3 is GPIO15(ESP32) / GPIO3(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM3: touch_pad_t = 3;
#[doc = "< Touch pad channel 4 is GPIO13(ESP32) / GPIO4(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM4: touch_pad_t = 4;
#[doc = "< Touch pad channel 5 is GPIO12(ESP32) / GPIO5(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM5: touch_pad_t = 5;
#[doc = "< Touch pad channel 6 is GPIO14(ESP32) / GPIO6(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM6: touch_pad_t = 6;
#[doc = "< Touch pad channel 7 is GPIO27(ESP32) / GPIO7(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM7: touch_pad_t = 7;
#[doc = "< Touch pad channel 8 is GPIO33(ESP32) / GPIO8(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM8: touch_pad_t = 8;
#[doc = "< Touch pad channel 9 is GPIO32(ESP32) / GPIO9(ESP32-S2)"]
pub const touch_pad_t_TOUCH_PAD_NUM9: touch_pad_t = 9;
pub const touch_pad_t_TOUCH_PAD_MAX: touch_pad_t = 10;
pub type touch_pad_t = c_types::c_uint;
#[doc = "<Touch sensor high reference voltage, no change"]
pub const touch_high_volt_t_TOUCH_HVOLT_KEEP: touch_high_volt_t = -1;
#[doc = "<Touch sensor high reference voltage, 2.4V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V4: touch_high_volt_t = 0;
#[doc = "<Touch sensor high reference voltage, 2.5V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V5: touch_high_volt_t = 1;
#[doc = "<Touch sensor high reference voltage, 2.6V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V6: touch_high_volt_t = 2;
#[doc = "<Touch sensor high reference voltage, 2.7V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V7: touch_high_volt_t = 3;
pub const touch_high_volt_t_TOUCH_HVOLT_MAX: touch_high_volt_t = 4;
pub type touch_high_volt_t = c_types::c_int;
#[doc = "<Touch sensor low reference voltage, no change"]
pub const touch_low_volt_t_TOUCH_LVOLT_KEEP: touch_low_volt_t = -1;
#[doc = "<Touch sensor low reference voltage, 0.5V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V5: touch_low_volt_t = 0;
#[doc = "<Touch sensor low reference voltage, 0.6V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V6: touch_low_volt_t = 1;
#[doc = "<Touch sensor low reference voltage, 0.7V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V7: touch_low_volt_t = 2;
#[doc = "<Touch sensor low reference voltage, 0.8V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V8: touch_low_volt_t = 3;
pub const touch_low_volt_t_TOUCH_LVOLT_MAX: touch_low_volt_t = 4;
pub type touch_low_volt_t = c_types::c_int;
#[doc = "<Touch sensor high reference voltage attenuation, no change"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_KEEP: touch_volt_atten_t = -1;
#[doc = "<Touch sensor high reference voltage attenuation, 1.5V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_1V5: touch_volt_atten_t = 0;
#[doc = "<Touch sensor high reference voltage attenuation, 1.0V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_1V: touch_volt_atten_t = 1;
#[doc = "<Touch sensor high reference voltage attenuation, 0.5V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_0V5: touch_volt_atten_t = 2;
#[doc = "<Touch sensor high reference voltage attenuation,   0V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_0V: touch_volt_atten_t = 3;
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_MAX: touch_volt_atten_t = 4;
pub type touch_volt_atten_t = c_types::c_int;
#[doc = "<Touch sensor charge / discharge speed, always zero"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_0: touch_cnt_slope_t = 0;
#[doc = "<Touch sensor charge / discharge speed, slowest"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_1: touch_cnt_slope_t = 1;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_2: touch_cnt_slope_t = 2;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_3: touch_cnt_slope_t = 3;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_4: touch_cnt_slope_t = 4;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_5: touch_cnt_slope_t = 5;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_6: touch_cnt_slope_t = 6;
#[doc = "<Touch sensor charge / discharge speed, fast"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_7: touch_cnt_slope_t = 7;
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_MAX: touch_cnt_slope_t = 8;
pub type touch_cnt_slope_t = c_types::c_uint;
#[doc = "<Initial level of charging voltage, low level"]
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_LOW: touch_tie_opt_t = 0;
#[doc = "<Initial level of charging voltage, high level"]
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_HIGH: touch_tie_opt_t = 1;
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_MAX: touch_tie_opt_t = 2;
pub type touch_tie_opt_t = c_types::c_uint;
#[doc = "<To start touch FSM by timer"]
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_TIMER: touch_fsm_mode_t = 0;
#[doc = "<To start touch FSM by software trigger"]
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_SW: touch_fsm_mode_t = 1;
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_MAX: touch_fsm_mode_t = 2;
pub type touch_fsm_mode_t = c_types::c_uint;
#[doc = "<Touch interrupt will happen if counter value is less than threshold."]
pub const touch_trigger_mode_t_TOUCH_TRIGGER_BELOW: touch_trigger_mode_t = 0;
#[doc = "<Touch interrupt will happen if counter value is larger than threshold."]
pub const touch_trigger_mode_t_TOUCH_TRIGGER_ABOVE: touch_trigger_mode_t = 1;
pub const touch_trigger_mode_t_TOUCH_TRIGGER_MAX: touch_trigger_mode_t = 2;
#[doc = " ESP32 Only"]
pub type touch_trigger_mode_t = c_types::c_uint;
#[doc = "< wakeup interrupt is generated if both SET1 and SET2 are \"touched\""]
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_BOTH: touch_trigger_src_t = 0;
#[doc = "< wakeup interrupt is generated if SET1 is \"touched\""]
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_SET1: touch_trigger_src_t = 1;
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_MAX: touch_trigger_src_t = 2;
pub type touch_trigger_src_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Configure touch pad interrupt threshold."]
    #[doc = ""]
    #[doc = " @note  If FSM mode is set to TOUCH_FSM_MODE_TIMER, this function will be blocked for one measurement cycle and wait for data to be valid."]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param threshold interrupt threshold,"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG if argument wrong"]
    #[doc = "     - ESP_FAIL if touch pad not initialized"]
    pub fn touch_pad_config(touch_num: touch_pad_t, threshold: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get touch sensor counter value."]
    #[doc = "        Each touch sensor has a counter to count the number of charge/discharge cycles."]
    #[doc = "        When the pad is not 'touched', we can get a number of the counter."]
    #[doc = "        When the pad is 'touched', the value in counter will get smaller because of the larger equivalent capacitance."]
    #[doc = ""]
    #[doc = " @note This API requests hardware measurement once. If IIR filter mode is enabled,"]
    #[doc = "       please use 'touch_pad_read_raw_data' interface instead."]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param touch_value pointer to accept touch sensor value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Touch pad parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE This touch pad hardware connection is error, the value of \"touch_value\" is 0."]
    #[doc = "     - ESP_FAIL Touch pad not initialized"]
    pub fn touch_pad_read(touch_num: touch_pad_t, touch_value: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get filtered touch sensor counter value by IIR filter."]
    #[doc = ""]
    #[doc = " @note touch_pad_filter_start has to be called before calling touch_pad_read_filtered."]
    #[doc = "       This function can be called from ISR"]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param touch_value pointer to accept touch sensor value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Touch pad parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE This touch pad hardware connection is error, the value of \"touch_value\" is 0."]
    #[doc = "     - ESP_FAIL Touch pad not initialized"]
    pub fn touch_pad_read_filtered(touch_num: touch_pad_t, touch_value: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get raw data (touch sensor counter value) from IIR filter process."]
    #[doc = "        Need not request hardware measurements."]
    #[doc = ""]
    #[doc = " @note touch_pad_filter_start has to be called before calling touch_pad_read_raw_data."]
    #[doc = "       This function can be called from ISR"]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param touch_value pointer to accept touch sensor value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Touch pad parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE This touch pad hardware connection is error, the value of \"touch_value\" is 0."]
    #[doc = "     - ESP_FAIL Touch pad not initialized"]
    pub fn touch_pad_read_raw_data(touch_num: touch_pad_t, touch_value: *mut u16) -> esp_err_t;
}
#[doc = " @brief Callback function that is called after each IIR filter calculation."]
#[doc = " @note This callback is called in timer task in each filtering cycle."]
#[doc = " @note This callback should not be blocked."]
#[doc = " @param raw_value  The latest raw data(touch sensor counter value) that"]
#[doc = "        points to all channels(raw_value[0..TOUCH_PAD_MAX-1])."]
#[doc = " @param filtered_value  The latest IIR filtered data(calculated from raw data) that"]
#[doc = "        points to all channels(filtered_value[0..TOUCH_PAD_MAX-1])."]
#[doc = ""]
pub type filter_cb_t =
    ::core::option::Option<unsafe extern "C" fn(raw_value: *mut u16, filtered_value: *mut u16)>;
extern "C" {
    #[doc = " @brief Register the callback function that is called after each IIR filter calculation."]
    #[doc = " @note The 'read_cb' callback is called in timer task in each filtering cycle."]
    #[doc = " @param read_cb  Pointer to filtered callback function."]
    #[doc = "                 If the argument passed in is NULL, the callback will stop."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG set error"]
    pub fn touch_pad_set_filter_read_cb(read_cb: filter_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register touch-pad ISR."]
    #[doc = "          The handler will be attached to the same CPU core that this function is running on."]
    #[doc = " @param fn  Pointer to ISR handler"]
    #[doc = " @param arg  Parameter for ISR"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NO_MEM No memory"]
    pub fn touch_pad_isr_register(fn_: intr_handler_t, arg: *mut c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor measurement and sleep time."]
    #[doc = "        Excessive total time will slow down the touch response."]
    #[doc = "        Too small measurement time will not be sampled enough, resulting in inaccurate measurements."]
    #[doc = ""]
    #[doc = " @note The greater the duty cycle of the measurement time, the more system power is consumed."]
    #[doc = " @param sleep_cycle  The touch sensor will sleep after each measurement."]
    #[doc = "                     sleep_cycle decide the interval between each measurement."]
    #[doc = "                     t_sleep = sleep_cycle / (RTC_SLOW_CLK frequency)."]
    #[doc = "                     The approximate frequency value of RTC_SLOW_CLK can be obtained using rtc_clk_slow_freq_get_hz function."]
    #[doc = " @param meas_cycle The duration of the touch sensor measurement."]
    #[doc = "                   t_meas = meas_cycle / 8M, the maximum measure time is 0xffff / 8M = 8.19 ms"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_set_meas_time(sleep_cycle: u16, meas_cycle: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor measurement and sleep time"]
    #[doc = " @param sleep_cycle  Pointer to accept sleep cycle number"]
    #[doc = " @param meas_cycle Pointer to accept measurement cycle count."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_meas_time(sleep_cycle: *mut u16, meas_cycle: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Trigger a touch sensor measurement, only support in SW mode of FSM"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_sw_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor interrupt threshold"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param threshold threshold of touchpad count, refer to touch_pad_set_trigger_mode to see how to set trigger mode."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_thresh(touch_num: touch_pad_t, threshold: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor interrupt threshold"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param threshold pointer to accept threshold"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_get_thresh(touch_num: touch_pad_t, threshold: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor interrupt trigger mode."]
    #[doc = "        Interrupt can be triggered either when counter result is less than"]
    #[doc = "        threshold or when counter result is more than threshold."]
    #[doc = " @param mode touch sensor interrupt trigger mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_trigger_mode(mode: touch_trigger_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor interrupt trigger mode"]
    #[doc = " @param mode pointer to accept touch sensor interrupt trigger mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_trigger_mode(mode: *mut touch_trigger_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor interrupt trigger source. There are two sets of touch signals."]
    #[doc = "        Set1 and set2 can be mapped to several touch signals. Either set will be triggered"]
    #[doc = "        if at least one of its touch signal is 'touched'. The interrupt can be configured to be generated"]
    #[doc = "        if set1 is triggered, or only if both sets are triggered."]
    #[doc = " @param src touch sensor interrupt trigger source"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_trigger_source(src: touch_trigger_src_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor interrupt trigger source"]
    #[doc = " @param src pointer to accept touch sensor interrupt trigger source"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_trigger_source(src: *mut touch_trigger_src_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor group mask."]
    #[doc = "        Touch pad module has two sets of signals, 'Touched' signal is triggered only if"]
    #[doc = "        at least one of touch pad in this group is \"touched\"."]
    #[doc = "        This function will set the register bits according to the given bitmask."]
    #[doc = " @param set1_mask bitmask of touch sensor signal group1, it's a 10-bit value"]
    #[doc = " @param set2_mask bitmask of touch sensor signal group2, it's a 10-bit value"]
    #[doc = " @param en_mask bitmask of touch sensor work enable, it's a 10-bit value"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_group_mask(set1_mask: u16, set2_mask: u16, en_mask: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor group mask."]
    #[doc = " @param set1_mask pointer to accept bitmask of touch sensor signal group1, it's a 10-bit value"]
    #[doc = " @param set2_mask pointer to accept bitmask of touch sensor signal group2, it's a 10-bit value"]
    #[doc = " @param en_mask pointer to accept bitmask of touch sensor work enable, it's a 10-bit value"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_group_mask(
        set1_mask: *mut u16,
        set2_mask: *mut u16,
        en_mask: *mut u16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear touch sensor group mask."]
    #[doc = "        Touch pad module has two sets of signals, Interrupt is triggered only if"]
    #[doc = "        at least one of touch pad in this group is \"touched\"."]
    #[doc = "        This function will clear the register bits according to the given bitmask."]
    #[doc = " @param set1_mask bitmask touch sensor signal group1, it's a 10-bit value"]
    #[doc = " @param set2_mask bitmask touch sensor signal group2, it's a 10-bit value"]
    #[doc = " @param en_mask bitmask of touch sensor work enable, it's a 10-bit value"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_clear_group_mask(set1_mask: u16, set2_mask: u16, en_mask: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief To enable touch pad interrupt"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_intr_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief To disable touch pad interrupt"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_intr_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set touch pad filter calibration period, in ms."]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @param new_period_ms filter period, in ms"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    #[doc = "      - ESP_ERR_INVALID_ARG parameter error"]
    pub fn touch_pad_set_filter_period(new_period_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get touch pad filter calibration period, in ms"]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @param p_period_ms pointer to accept period"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    #[doc = "      - ESP_ERR_INVALID_ARG parameter error"]
    pub fn touch_pad_get_filter_period(p_period_ms: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief start touch pad filter function"]
    #[doc = "      This API will start a filter to process the noise in order to prevent false triggering"]
    #[doc = "      when detecting slight change of capacitance."]
    #[doc = "      Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = ""]
    #[doc = " @note This filter uses FreeRTOS timer, which is dispatched from a task with"]
    #[doc = "       priority 1 by default on CPU 0. So if some application task with higher priority"]
    #[doc = "       takes a lot of CPU0 time, then the quality of data obtained from this filter will be affected."]
    #[doc = "       You can adjust FreeRTOS timer task priority in menuconfig."]
    #[doc = " @param filter_period_ms filter calibration period, in ms"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG parameter error"]
    #[doc = "      - ESP_ERR_NO_MEM No memory for driver"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    pub fn touch_pad_filter_start(filter_period_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief stop touch pad filter function"]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    pub fn touch_pad_filter_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief delete touch pad filter driver and release the memory"]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    pub fn touch_pad_filter_delete() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize touch module."]
    #[doc = " @note  If default parameter don't match the usage scenario, it can be changed after this function."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM Touch pad init error"]
    pub fn touch_pad_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Un-install touch pad driver."]
    #[doc = " @note  After this function is called, other touch functions are prohibited from being called."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Touch pad driver not initialized"]
    pub fn touch_pad_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize touch pad GPIO"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_io_init(touch_num: touch_pad_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor high voltage threshold of chanrge."]
    #[doc = "        The touch sensor measures the channel capacitance value by charging and discharging the channel."]
    #[doc = "        So the high threshold should be less than the supply voltage."]
    #[doc = " @param refh the value of DREFH"]
    #[doc = " @param refl the value of DREFL"]
    #[doc = " @param atten the attenuation on DREFH"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_voltage(
        refh: touch_high_volt_t,
        refl: touch_low_volt_t,
        atten: touch_volt_atten_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor reference voltage,"]
    #[doc = " @param refh pointer to accept DREFH value"]
    #[doc = " @param refl pointer to accept DREFL value"]
    #[doc = " @param atten pointer to accept the attenuation on DREFH"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_voltage(
        refh: *mut touch_high_volt_t,
        refl: *mut touch_low_volt_t,
        atten: *mut touch_volt_atten_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor charge/discharge speed for each pad."]
    #[doc = "        If the slope is 0, the counter would always be zero."]
    #[doc = "        If the slope is 1, the charging and discharging would be slow, accordingly."]
    #[doc = "        If the slope is set 7, which is the maximum value, the charging and discharging would be fast."]
    #[doc = " @note The higher the charge and discharge current, the greater the immunity of the touch channel,"]
    #[doc = "       but it will increase the system power consumption."]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param slope touch pad charge/discharge speed"]
    #[doc = " @param opt the initial voltage"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_cnt_mode(
        touch_num: touch_pad_t,
        slope: touch_cnt_slope_t,
        opt: touch_tie_opt_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor charge/discharge speed for each pad"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param slope pointer to accept touch pad charge/discharge slope"]
    #[doc = " @param opt pointer to accept the initial voltage"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_get_cnt_mode(
        touch_num: touch_pad_t,
        slope: *mut touch_cnt_slope_t,
        opt: *mut touch_tie_opt_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deregister the handler previously registered using touch_pad_isr_handler_register"]
    #[doc = " @param fn  handler function to call (as passed to touch_pad_isr_handler_register)"]
    #[doc = " @param arg  argument of the handler (as passed to touch_pad_isr_handler_register)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if a handler matching both fn and"]
    #[doc = "        arg isn't registered"]
    pub fn touch_pad_isr_deregister(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the touch pad which caused wakeup from deep sleep."]
    #[doc = " @param pad_num pointer to touch pad which caused wakeup"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG parameter is NULL"]
    pub fn touch_pad_get_wakeup_status(pad_num: *mut touch_pad_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor FSM mode, the test action can be triggered by the timer,"]
    #[doc = "        as well as by the software."]
    #[doc = " @param mode FSM mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_fsm_mode(mode: touch_fsm_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor FSM mode"]
    #[doc = " @param mode pointer to accept FSM mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_fsm_mode(mode: *mut touch_fsm_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief To clear the touch status register, usually use this function in touch ISR to clear status."]
    #[doc = ""]
    #[doc = " @note Generally no manual removal is required."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_clear_status() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the touch sensor status, usually used in ISR to decide which pads are 'touched'."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - The touch sensor status. e.g. Touch1 trigger status is `status_mask & (BIT1)`."]
    pub fn touch_pad_get_status() -> u32;
}
#[doc = " @brief UART port number, can be UART_NUM_0 ~ (UART_NUM_MAX -1)."]
pub type uart_port_t = c_types::c_int;
#[doc = "< mode: regular UART mode"]
pub const uart_mode_t_UART_MODE_UART: uart_mode_t = 0;
#[doc = "< mode: half duplex RS485 UART mode control by RTS pin"]
pub const uart_mode_t_UART_MODE_RS485_HALF_DUPLEX: uart_mode_t = 1;
#[doc = "< mode: IRDA  UART mode"]
pub const uart_mode_t_UART_MODE_IRDA: uart_mode_t = 2;
#[doc = "< mode: RS485 collision detection UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_COLLISION_DETECT: uart_mode_t = 3;
#[doc = "< mode: application control RS485 UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_APP_CTRL: uart_mode_t = 4;
#[doc = " @brief UART mode selection"]
pub type uart_mode_t = c_types::c_uint;
#[doc = "< word length: 5bits"]
pub const uart_word_length_t_UART_DATA_5_BITS: uart_word_length_t = 0;
#[doc = "< word length: 6bits"]
pub const uart_word_length_t_UART_DATA_6_BITS: uart_word_length_t = 1;
#[doc = "< word length: 7bits"]
pub const uart_word_length_t_UART_DATA_7_BITS: uart_word_length_t = 2;
#[doc = "< word length: 8bits"]
pub const uart_word_length_t_UART_DATA_8_BITS: uart_word_length_t = 3;
pub const uart_word_length_t_UART_DATA_BITS_MAX: uart_word_length_t = 4;
#[doc = " @brief UART word length constants"]
pub type uart_word_length_t = c_types::c_uint;
#[doc = "< stop bit: 1bit"]
pub const uart_stop_bits_t_UART_STOP_BITS_1: uart_stop_bits_t = 1;
#[doc = "< stop bit: 1.5bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_1_5: uart_stop_bits_t = 2;
#[doc = "< stop bit: 2bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_2: uart_stop_bits_t = 3;
pub const uart_stop_bits_t_UART_STOP_BITS_MAX: uart_stop_bits_t = 4;
#[doc = " @brief UART stop bits number"]
pub type uart_stop_bits_t = c_types::c_uint;
#[doc = "< Disable UART parity"]
pub const uart_parity_t_UART_PARITY_DISABLE: uart_parity_t = 0;
#[doc = "< Enable UART even parity"]
pub const uart_parity_t_UART_PARITY_EVEN: uart_parity_t = 2;
#[doc = "< Enable UART odd parity"]
pub const uart_parity_t_UART_PARITY_ODD: uart_parity_t = 3;
#[doc = " @brief UART parity constants"]
pub type uart_parity_t = c_types::c_uint;
#[doc = "< disable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_DISABLE: uart_hw_flowcontrol_t = 0;
#[doc = "< enable RX hardware flow control (rts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_RTS: uart_hw_flowcontrol_t = 1;
#[doc = "< enable TX hardware flow control (cts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS: uart_hw_flowcontrol_t = 2;
#[doc = "< enable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS_RTS: uart_hw_flowcontrol_t = 3;
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_MAX: uart_hw_flowcontrol_t = 4;
#[doc = " @brief UART hardware flow control modes"]
pub type uart_hw_flowcontrol_t = c_types::c_uint;
#[doc = "< inverse the UART irda_tx signal"]
pub const uart_signal_inv_t_UART_SIGNAL_IRDA_TX_INV: uart_signal_inv_t = 1;
#[doc = "< inverse the UART irda_rx signal"]
pub const uart_signal_inv_t_UART_SIGNAL_IRDA_RX_INV: uart_signal_inv_t = 2;
#[doc = "< inverse the UART rxd signal"]
pub const uart_signal_inv_t_UART_SIGNAL_RXD_INV: uart_signal_inv_t = 4;
#[doc = "< inverse the UART cts signal"]
pub const uart_signal_inv_t_UART_SIGNAL_CTS_INV: uart_signal_inv_t = 8;
#[doc = "< inverse the UART dsr signal"]
pub const uart_signal_inv_t_UART_SIGNAL_DSR_INV: uart_signal_inv_t = 16;
#[doc = "< inverse the UART txd signal"]
pub const uart_signal_inv_t_UART_SIGNAL_TXD_INV: uart_signal_inv_t = 32;
#[doc = "< inverse the UART rts signal"]
pub const uart_signal_inv_t_UART_SIGNAL_RTS_INV: uart_signal_inv_t = 64;
#[doc = "< inverse the UART dtr signal"]
pub const uart_signal_inv_t_UART_SIGNAL_DTR_INV: uart_signal_inv_t = 128;
#[doc = " @brief UART signal bit map"]
pub type uart_signal_inv_t = c_types::c_uint;
#[doc = "< UART source clock from APB"]
pub const uart_sclk_t_UART_SCLK_APB: uart_sclk_t = 0;
#[doc = "< UART source clock from REF_TICK"]
pub const uart_sclk_t_UART_SCLK_REF_TICK: uart_sclk_t = 1;
#[doc = " @brief UART source clock"]
pub type uart_sclk_t = c_types::c_uint;
#[doc = " @brief UART AT cmd char configuration parameters"]
#[doc = "        Note that this function may different on different chip. Please refer to the TRM at confirguration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_at_cmd_t {
    #[doc = "< UART AT cmd char"]
    pub cmd_char: u8,
    #[doc = "< AT cmd char repeat number"]
    pub char_num: u8,
    #[doc = "< gap time(in baud-rate) between AT cmd char"]
    pub gap_tout: u32,
    #[doc = "< the idle time(in baud-rate) between the non AT char and first AT char"]
    pub pre_idle: u32,
    #[doc = "< the idle time(in baud-rate) between the last AT char and the none AT char"]
    pub post_idle: u32,
}
#[doc = " @brief UART software flow control configuration parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_sw_flowctrl_t {
    #[doc = "< Xon flow control char"]
    pub xon_char: u8,
    #[doc = "< Xoff flow control char"]
    pub xoff_char: u8,
    #[doc = "< If the software flow control is enabled and the data amount in rxfifo is less than xon_thrd, an xon_char will be sent"]
    pub xon_thrd: u8,
    #[doc = "< If the software flow control is enabled and the data amount in rxfifo is more than xoff_thrd, an xoff_char will be sent"]
    pub xoff_thrd: u8,
}
#[doc = " @brief UART configuration parameters for uart_param_config function"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uart_config_t {
    #[doc = "< UART baud rate"]
    pub baud_rate: c_types::c_int,
    #[doc = "< UART byte size"]
    pub data_bits: uart_word_length_t,
    #[doc = "< UART parity mode"]
    pub parity: uart_parity_t,
    #[doc = "< UART stop bits"]
    pub stop_bits: uart_stop_bits_t,
    #[doc = "< UART HW flow control mode (cts/rts)"]
    pub flow_ctrl: uart_hw_flowcontrol_t,
    #[doc = "< UART HW RTS threshold"]
    pub rx_flow_ctrl_thresh: u8,
    pub __bindgen_anon_1: uart_config_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_config_t__bindgen_ty_1 {
    #[doc = "< UART source clock selection"]
    pub source_clk: uart_sclk_t,
    pub use_ref_tick: bool,
    _bindgen_union_align: u32,
}
#[doc = " @brief UART interrupt configuration parameters for uart_intr_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_intr_config_t {
    #[doc = "< UART interrupt enable mask, choose from UART_XXXX_INT_ENA_M under UART_INT_ENA_REG(i), connect with bit-or operator"]
    pub intr_enable_mask: u32,
    #[doc = "< UART timeout interrupt threshold (unit: time of sending one byte)"]
    pub rx_timeout_thresh: u8,
    #[doc = "< UART TX empty interrupt threshold."]
    pub txfifo_empty_intr_thresh: u8,
    #[doc = "< UART RX full interrupt threshold."]
    pub rxfifo_full_thresh: u8,
}
#[doc = "< UART data event"]
pub const uart_event_type_t_UART_DATA: uart_event_type_t = 0;
#[doc = "< UART break event"]
pub const uart_event_type_t_UART_BREAK: uart_event_type_t = 1;
#[doc = "< UART RX buffer full event"]
pub const uart_event_type_t_UART_BUFFER_FULL: uart_event_type_t = 2;
#[doc = "< UART FIFO overflow event"]
pub const uart_event_type_t_UART_FIFO_OVF: uart_event_type_t = 3;
#[doc = "< UART RX frame error event"]
pub const uart_event_type_t_UART_FRAME_ERR: uart_event_type_t = 4;
#[doc = "< UART RX parity event"]
pub const uart_event_type_t_UART_PARITY_ERR: uart_event_type_t = 5;
#[doc = "< UART TX data and break event"]
pub const uart_event_type_t_UART_DATA_BREAK: uart_event_type_t = 6;
#[doc = "< UART pattern detected"]
pub const uart_event_type_t_UART_PATTERN_DET: uart_event_type_t = 7;
#[doc = "< UART event max index"]
pub const uart_event_type_t_UART_EVENT_MAX: uart_event_type_t = 8;
#[doc = " @brief UART event types used in the ring buffer"]
pub type uart_event_type_t = c_types::c_uint;
#[doc = " @brief Event structure used in UART event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_event_t {
    #[doc = "< UART event type"]
    pub type_: uart_event_type_t,
    #[doc = "< UART data size for UART_DATA event"]
    pub size: size_t,
}
pub type uart_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Install UART driver and set the UART to the default configuration."]
    #[doc = ""]
    #[doc = " UART ISR handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @note  Rx_buffer_size should be greater than UART_FIFO_LEN. Tx_buffer_size should be either zero or greater than UART_FIFO_LEN."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param rx_buffer_size UART RX ring buffer size."]
    #[doc = " @param tx_buffer_size UART TX ring buffer size."]
    #[doc = "        If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out."]
    #[doc = " @param queue_size UART event queue size/depth."]
    #[doc = " @param uart_queue UART event queue handle (out param). On success, a new queue handle is written here to provide"]
    #[doc = "        access to UART events. If set to NULL, driver will not use an event queue."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. Do not set ESP_INTR_FLAG_IRAM here"]
    #[doc = "        (the driver's ISR handler is not located in IRAM)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_driver_install(
        uart_num: uart_port_t,
        rx_buffer_size: c_types::c_int,
        tx_buffer_size: c_types::c_int,
        queue_size: c_types::c_int,
        uart_queue: *mut QueueHandle_t,
        intr_alloc_flags: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall UART driver."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_driver_delete(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Checks whether the driver is installed or not"]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - true  driver is installed"]
    #[doc = "     - false driver is not installed"]
    pub fn uart_is_driver_installed(uart_num: uart_port_t) -> bool;
}
extern "C" {
    #[doc = " @brief Set UART data bits."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param data_bit UART data bits"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_word_length(uart_num: uart_port_t, data_bit: uart_word_length_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART data bit configuration."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param data_bit Pointer to accept value of UART data bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success, result will be put in (*data_bit)"]
    pub fn uart_get_word_length(
        uart_num: uart_port_t,
        data_bit: *mut uart_word_length_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART stop bits."]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param stop_bits  UART stop bits"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Fail"]
    pub fn uart_set_stop_bits(uart_num: uart_port_t, stop_bits: uart_stop_bits_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART stop bit configuration."]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param stop_bits  Pointer to accept value of UART stop bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*stop_bit)"]
    pub fn uart_get_stop_bits(uart_num: uart_port_t, stop_bits: *mut uart_stop_bits_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART parity mode."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param parity_mode the enum of uart parity configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success"]
    pub fn uart_set_parity(uart_num: uart_port_t, parity_mode: uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART parity mode configuration."]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param parity_mode Pointer to accept value of UART parity mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success, result will be put in (*parity_mode)"]
    #[doc = ""]
    pub fn uart_get_parity(uart_num: uart_port_t, parity_mode: *mut uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART baud rate."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param baudrate UART baud rate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success"]
    pub fn uart_set_baudrate(uart_num: uart_port_t, baudrate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART baud rate configuration."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param baudrate Pointer to accept value of UART baud rate"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*baudrate)"]
    #[doc = ""]
    pub fn uart_get_baudrate(uart_num: uart_port_t, baudrate: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART line inverse mode"]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param inverse_mask Choose the wires that need to be inverted. Using the ORred mask of `uart_signal_inv_t`"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_line_inverse(uart_num: uart_port_t, inverse_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set hardware flow control."]
    #[doc = ""]
    #[doc = " @param uart_num   UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param flow_ctrl Hardware flow control mode"]
    #[doc = " @param rx_thresh Threshold of Hardware RX flow control (0 ~ UART_FIFO_LEN)."]
    #[doc = "        Only when UART_HW_FLOWCTRL_RTS is set, will the rx_thresh value be set."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: uart_hw_flowcontrol_t,
        rx_thresh: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set software flow control."]
    #[doc = ""]
    #[doc = " @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param enable     switch on or off"]
    #[doc = " @param rx_thresh_xon  low water mark"]
    #[doc = " @param rx_thresh_xoff high water mark"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_sw_flow_ctrl(
        uart_num: uart_port_t,
        enable: bool,
        rx_thresh_xon: u8,
        rx_thresh_xoff: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the UART hardware flow control configuration."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param flow_ctrl Option for different flow control mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*flow_ctrl)"]
    pub fn uart_get_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: *mut uart_hw_flowcontrol_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt status"]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param clr_mask  Bit mask of the interrupt status to be cleared."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_clear_intr_status(uart_num: uart_port_t, clr_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART interrupt enable"]
    #[doc = ""]
    #[doc = " @param uart_num     UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param enable_mask  Bit mask of the enable bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_intr_mask(uart_num: uart_port_t, enable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt enable bits"]
    #[doc = ""]
    #[doc = " @param uart_num      UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param disable_mask  Bit mask of the disable bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_intr_mask(uart_num: uart_port_t, disable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_tx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param enable  1: enable; 0: disable"]
    #[doc = " @param thresh  Threshold of TX interrupt, 0 ~ UART_FIFO_LEN"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_tx_intr(
        uart_num: uart_port_t,
        enable: c_types::c_int,
        thresh: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register UART interrupt handler (ISR)."]
    #[doc = ""]
    #[doc = " @note UART ISR handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param fn  Interrupt handler function."]
    #[doc = " @param arg parameter for handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_isr_register(
        uart_num: uart_port_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        intr_alloc_flags: c_types::c_int,
        handle: *mut uart_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as"]
    #[doc = " uart_isr_register was called."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_isr_free(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART pin number"]
    #[doc = ""]
    #[doc = " @note Internal signal can be output to multiple GPIO pads."]
    #[doc = "       Only one GPIO pad can connect with input signal."]
    #[doc = ""]
    #[doc = " @note Instead of GPIO number a macro 'UART_PIN_NO_CHANGE' may be provided"]
    #[doc = "to keep the currently allocated pin."]
    #[doc = ""]
    #[doc = " @param uart_num   UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param tx_io_num  UART TX pin GPIO number."]
    #[doc = " @param rx_io_num  UART RX pin GPIO number."]
    #[doc = " @param rts_io_num UART RTS pin GPIO number."]
    #[doc = " @param cts_io_num UART CTS pin GPIO number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_pin(
        uart_num: uart_port_t,
        tx_io_num: c_types::c_int,
        rx_io_num: c_types::c_int,
        rts_io_num: c_types::c_int,
        cts_io_num: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART RTS pin level."]
    #[doc = " @note  UART must be configured with hardware flow control disabled."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param level    1: RTS output low (active); 0: RTS output high (block)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_rts(uart_num: uart_port_t, level: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART DTR pin level."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param level    1: DTR output low; 0: DTR output high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_dtr(uart_num: uart_port_t, level: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART idle interval after tx FIFO is empty"]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param idle_num idle interval after tx FIFO is empty(unit: the time it takes to send one bit"]
    #[doc = "        under current baudrate)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_tx_idle_num(uart_num: uart_port_t, idle_num: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART configuration parameters."]
    #[doc = ""]
    #[doc = " @param uart_num    UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param uart_config UART parameter settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_param_config(uart_num: uart_port_t, uart_config: *const uart_config_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure UART interrupts."]
    #[doc = ""]
    #[doc = " @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param intr_conf UART interrupt settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_intr_config(
        uart_num: uart_port_t,
        intr_conf: *const uart_intr_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait until UART TX FIFO is empty."]
    #[doc = ""]
    #[doc = " @param uart_num      UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param ticks_to_wait Timeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_ERR_TIMEOUT  Timeout"]
    pub fn uart_wait_tx_done(uart_num: uart_port_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length."]
    #[doc = ""]
    #[doc = " This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full."]
    #[doc = " @note This function should only be used when UART TX buffer is not enabled."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param buffer data buffer address"]
    #[doc = " @param len    data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1)  Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_tx_chars(
        uart_num: uart_port_t,
        buffer: *const c_types::c_char,
        len: u32,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,"]
    #[doc = ""]
    #[doc = " If the UART driver's parameter 'tx_buffer_size' is set to zero:"]
    #[doc = " This function will not return until all the data have been sent out, or at least pushed into TX FIFO."]
    #[doc = ""]
    #[doc = " Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,"]
    #[doc = " UART ISR will then move data from the ring buffer to TX FIFO gradually."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param src   data buffer address"]
    #[doc = " @param size  data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes(
        uart_num: uart_port_t,
        src: *const c_types::c_char,
        size: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,"]
    #[doc = ""]
    #[doc = " If the UART driver's parameter 'tx_buffer_size' is set to zero:"]
    #[doc = " This function will not return until all the data and the break signal have been sent out."]
    #[doc = " After all data is sent out, send a break signal."]
    #[doc = ""]
    #[doc = " Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,"]
    #[doc = " UART ISR will then move data from the ring buffer to TX FIFO gradually."]
    #[doc = " After all data sent out, send a break signal."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param src   data buffer address"]
    #[doc = " @param size  data length to send"]
    #[doc = " @param brk_len break signal duration(unit: the time it takes to send one bit at current baudrate)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes_with_break(
        uart_num: uart_port_t,
        src: *const c_types::c_char,
        size: size_t,
        brk_len: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief UART read bytes from UART buffer"]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param buf     pointer to the buffer."]
    #[doc = " @param length  data length"]
    #[doc = " @param ticks_to_wait sTimeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Error"]
    #[doc = "     - OTHERS (>=0) The number of bytes read from UART FIFO"]
    pub fn uart_read_bytes(
        uart_num: uart_port_t,
        buf: *mut u8,
        length: u32,
        ticks_to_wait: TickType_t,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Alias of uart_flush_input."]
    #[doc = "        UART ring buffer flush. This will discard all data in the UART RX buffer."]
    #[doc = " @note  Instead of waiting the data sent out, this function will clear UART rx buffer."]
    #[doc = "        In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_flush(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear input buffer, discard all the data is in the ring-buffer."]
    #[doc = " @note  In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_flush_input(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART get RX ring buffer cached data length"]
    #[doc = ""]
    #[doc = " @param   uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param   size Pointer of size_t to accept cached data length"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_get_buffered_data_len(uart_num: uart_port_t, size: *mut size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART disable pattern detect function."]
    #[doc = "          Designed for applications like 'AT commands'."]
    #[doc = "          When the hardware detects a series of one same character, the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_pattern_det_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART enable pattern detect function."]
    #[doc = "        Designed for applications like 'AT commands'."]
    #[doc = "        When the hardware detect a series of one same character, the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number."]
    #[doc = " @param pattern_chr character of the pattern."]
    #[doc = " @param chr_num number of the character, 8bit value."]
    #[doc = " @param chr_tout timeout of the interval between each pattern characters, 16bit value, unit is the baud-rate cycle you configured."]
    #[doc = "        When the duration is more than this value, it will not take this data as at_cmd char."]
    #[doc = " @param post_idle idle time after the last pattern character, 16bit value, unit is the baud-rate cycle you configured."]
    #[doc = "        When the duration is less than this value, it will not take the previous data as the last at_cmd char"]
    #[doc = " @param pre_idle idle time before the first pattern character, 16bit value, unit is the baud-rate cycle you configured."]
    #[doc = "        When the duration is less than this value, it will not take this data as the first at_cmd char."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_pattern_det_baud_intr(
        uart_num: uart_port_t,
        pattern_chr: c_types::c_char,
        chr_num: u8,
        chr_tout: c_types::c_int,
        post_idle: c_types::c_int,
        pre_idle: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer."]
    #[doc = "        The positions of the detected pattern are saved in a queue,"]
    #[doc = "        this function will dequeue the first pattern position and move the pointer to next pattern position."]
    #[doc = " @note  If the RX buffer is full and flow control is not enabled,"]
    #[doc = "        the detected pattern may not be found in the rx buffer due to overflow."]
    #[doc = ""]
    #[doc = "        The following APIs will modify the pattern position info:"]
    #[doc = "        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos"]
    #[doc = "        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer"]
    #[doc = "        when using pattern detect feature."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @return"]
    #[doc = "     - (-1) No pattern found for current index or parameter error"]
    #[doc = "     - others the pattern position in rx buffer."]
    pub fn uart_pattern_pop_pos(uart_num: uart_port_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer."]
    #[doc = "        The positions of the detected pattern are saved in a queue,"]
    #[doc = "        This function do nothing to the queue."]
    #[doc = " @note  If the RX buffer is full and flow control is not enabled,"]
    #[doc = "        the detected pattern may not be found in the rx buffer due to overflow."]
    #[doc = ""]
    #[doc = "        The following APIs will modify the pattern position info:"]
    #[doc = "        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos"]
    #[doc = "        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer"]
    #[doc = "        when using pattern detect feature."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @return"]
    #[doc = "     - (-1) No pattern found for current index or parameter error"]
    #[doc = "     - others the pattern position in rx buffer."]
    pub fn uart_pattern_get_pos(uart_num: uart_port_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Allocate a new memory with the given length to save record the detected pattern position in rx buffer."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param queue_length Max queue length for the detected pattern."]
    #[doc = "        If the queue length is not large enough, some pattern positions might be lost."]
    #[doc = "        Set this value to the maximum number of patterns that could be saved in data buffer at the same time."]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_NO_MEM No enough memory"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver not installed"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn uart_pattern_queue_reset(
        uart_num: uart_port_t,
        queue_length: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set communication mode"]
    #[doc = ""]
    #[doc = " @note  This function must be executed after uart_driver_install(), when the driver object is initialized."]
    #[doc = " @param uart_num     Uart number to configure, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param mode UART    UART mode to set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_mode(uart_num: uart_port_t, mode: uart_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set uart threshold value for RX fifo full"]
    #[doc = " @note If application is using higher baudrate and it is observed that bytes"]
    #[doc = "       in hardware RX fifo are overwritten then this threshold can be reduced"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param threshold Threshold value above which RX fifo full interrupt is generated"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_full_threshold(
        uart_num: uart_port_t,
        threshold: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set uart threshold values for TX fifo empty"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param threshold Threshold value below which TX fifo empty interrupt is generated"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_tx_empty_threshold(
        uart_num: uart_port_t,
        threshold: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set threshold timeout for TOUT feature"]
    #[doc = ""]
    #[doc = " @param uart_num     Uart number to configure, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param tout_thresh  This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126."]
    #[doc = "        tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate."]
    #[doc = "        If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0,"]
    #[doc = "        the TOUT feature is disabled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_timeout(uart_num: uart_port_t, tout_thresh: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns collision detection flag for RS485 mode"]
    #[doc = "        Function returns the collision detection flag into variable pointed by collision_flag."]
    #[doc = "        *collision_flag = true, if collision detected else it is equal to false."]
    #[doc = "        This function should be executed when actual transmission is completed (after uart_write_bytes())."]
    #[doc = ""]
    #[doc = " @param uart_num  Uart number to configure the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param collision_flag Pointer to variable of type bool to return collision flag."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_collision_flag(uart_num: uart_port_t, collision_flag: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the number of RX pin signal edges for light sleep wakeup"]
    #[doc = ""]
    #[doc = " UART can be used to wake up the system from light sleep. This feature works"]
    #[doc = " by counting the number of positive edges on RX pin and comparing the count to"]
    #[doc = " the threshold. When the count exceeds the threshold, system is woken up from"]
    #[doc = " light sleep. This function allows setting the threshold value."]
    #[doc = ""]
    #[doc = " Stop bit and parity bits (if enabled) also contribute to the number of edges."]
    #[doc = " For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire"]
    #[doc = " (with 8n1 configuration), start and stop bits included. This sequence has 3"]
    #[doc = " positive edges (transitions from 0 to 1). Therefore, to wake up the system"]
    #[doc = " when 'a' is sent, set wakeup_threshold=3."]
    #[doc = ""]
    #[doc = " The character that triggers wakeup is not received by UART (i.e. it can not"]
    #[doc = " be obtained from UART FIFO). Depending on the baud rate, a few characters"]
    #[doc = " after that will also not be received. Note that when the chip enters and exits"]
    #[doc = " light sleep mode, APB frequency will be changing. To make sure that UART has"]
    #[doc = " correct baud rate all the time, select REF_TICK as UART clock source,"]
    #[doc = " by setting use_ref_tick field in uart_config_t to true."]
    #[doc = ""]
    #[doc = " @note in ESP32, the wakeup signal can only be input via IO_MUX (i.e."]
    #[doc = "       GPIO3 should be configured as function_1 to wake up UART0,"]
    #[doc = "       GPIO9 should be configured as function_5 to wake up UART1), UART2"]
    #[doc = "       does not support light sleep wakeup feature."]
    #[doc = ""]
    #[doc = " @param uart_num  UART number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param wakeup_threshold  number of RX edges for light sleep wakeup, value is 3 .. 0x3ff."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if uart_num is incorrect or wakeup_threshold is"]
    #[doc = "        outside of [3, 0x3ff] range."]
    pub fn uart_set_wakeup_threshold(
        uart_num: uart_port_t,
        wakeup_threshold: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the number of RX pin signal edges for light sleep wakeup."]
    #[doc = ""]
    #[doc = " See description of uart_set_wakeup_threshold for the explanation of UART"]
    #[doc = " wakeup feature."]
    #[doc = ""]
    #[doc = " @param uart_num  UART number, the max port number is (UART_NUM_MAX -1)."]
    #[doc = " @param[out] out_wakeup_threshold  output, set to the current value of wakeup"]
    #[doc = "                                   threshold for the given UART."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if out_wakeup_threshold is NULL"]
    pub fn uart_get_wakeup_threshold(
        uart_num: uart_port_t,
        out_wakeup_threshold: *mut c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait until UART tx memory empty and the last char send ok (polling mode)."]
    #[doc = ""]
    #[doc = " @param uart_num UART number"]
    #[doc = ""]
    #[doc = " * @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "      - ESP_FAIL Driver not installed"]
    pub fn uart_wait_tx_idle_polling(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure TX signal loop back to RX module, just for the test usage."]
    #[doc = ""]
    #[doc = " @param uart_num UART number"]
    #[doc = " @param loop_back_en Set ture to enable the loop back function, else set it false."]
    #[doc = ""]
    #[doc = " * @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "      - ESP_FAIL Driver not installed"]
    pub fn uart_set_loop_back(uart_num: uart_port_t, loop_back_en: bool) -> esp_err_t;
}
pub const uart_select_notif_t_UART_SELECT_READ_NOTIF: uart_select_notif_t = 0;
pub const uart_select_notif_t_UART_SELECT_WRITE_NOTIF: uart_select_notif_t = 1;
pub const uart_select_notif_t_UART_SELECT_ERROR_NOTIF: uart_select_notif_t = 2;
pub type uart_select_notif_t = c_types::c_uint;
pub type uart_select_notif_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        uart_num: uart_port_t,
        uart_select_notif: uart_select_notif_t,
        task_woken: *mut BaseType_t,
    ),
>;
extern "C" {
    #[doc = " @brief Set notification callback function for select() events"]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @param uart_select_notif_callback callback function"]
    pub fn uart_set_select_notif_callback(
        uart_num: uart_port_t,
        uart_select_notif_callback: uart_select_notif_callback_t,
    );
}
extern "C" {
    #[doc = " @brief Get mutex guarding select() notifications"]
    pub fn uart_get_selectlock() -> *mut portMUX_TYPE;
}
extern "C" {
    #[doc = " @brief  Initializes core dump module internal data."]
    #[doc = ""]
    #[doc = " @note  Should be called at system startup."]
    pub fn esp_core_dump_init();
}
extern "C" {
    #[doc = " @brief  Saves core dump to flash."]
    #[doc = ""]
    #[doc = " The structure of data stored in flash is as follows:"]
    #[doc = ""]
    #[doc = " |  TOTAL_LEN |  VERSION    | TASKS_NUM   | TCB_SIZE |"]
    #[doc = " | TCB_ADDR_1 | STACK_TOP_1 | STACK_END_1 | TCB_1    | STACK_1 |"]
    #[doc = " .            .       .         ."]
    #[doc = " .            .       .         ."]
    #[doc = " | TCB_ADDR_N | STACK_TOP_N | STACK_END_N | TCB_N    | STACK_N |"]
    #[doc = " |    CRC32   |"]
    #[doc = ""]
    #[doc = " Core dump in flash consists of header and data for every task in the system at the moment of crash."]
    #[doc = " For flash data integrity control CRC is used at the end of core the dump data."]
    #[doc = " The structure of core dump data is described below in details."]
    #[doc = " 1) Core dump starts with header:"]
    #[doc = " 1.1) TOTAL_LEN is total length of core dump data in flash including CRC. Size is 4 bytes."]
    #[doc = " 1.2) VERSION field keeps 4 byte version of core dump."]
    #[doc = " 1.2) TASKS_NUM is the number of tasks for which data are stored. Size is 4 bytes."]
    #[doc = " 1.3) TCB_SIZE is the size of task's TCB structure. Size is 4 bytes."]
    #[doc = " 2) Core dump header is followed by the data for every task in the system."]
    #[doc = "    Task data are started with task header:"]
    #[doc = " 2.1) TCB_ADDR is the address of TCB in memory. Size is 4 bytes."]
    #[doc = " 2.2) STACK_TOP is the top of task's stack (address of the topmost stack item). Size is 4 bytes."]
    #[doc = " 2.2) STACK_END is the end of task's stack (address from which task's stack starts). Size is 4 bytes."]
    #[doc = " 3) Task header is followed by TCB data. Size is TCB_SIZE bytes."]
    #[doc = " 4) Task's stack is placed after TCB data. Size is (STACK_END - STACK_TOP) bytes."]
    #[doc = " 5) CRC is placed at the end of the data."]
    pub fn esp_core_dump_to_flash(frame: *mut XtExcFrame);
}
extern "C" {
    #[doc = " @brief  Print base64-encoded core dump to UART."]
    #[doc = ""]
    #[doc = " The structure of core dump data is the same as for data stored in flash (@see esp_core_dump_to_flash) with some notes:"]
    #[doc = " 1) CRC is not present in core dump printed to UART."]
    #[doc = " 2) Since CRC is omitted TOTAL_LEN does not include its size."]
    #[doc = " 3) Printed base64 data are surrounded with special messages to help user recognize the start and end of actual data."]
    pub fn esp_core_dump_to_uart(frame: *mut XtExcFrame);
}
extern "C" {
    #[doc = " @brief  Retrieves address and size of coredump data in flash."]
    #[doc = "         This function is always available, even when core dump is disabled in menuconfig."]
    #[doc = ""]
    #[doc = " @param  out_addr   pointer to store image address in flash."]
    #[doc = " @param  out_size   pointer to store image size in flash (including CRC). In bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success, otherwise \\see esp_err_t"]
    pub fn esp_core_dump_image_get(out_addr: *mut size_t, out_size: *mut size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Probe and initialize SD/MMC card using given host"]
    #[doc = ""]
    #[doc = " @note Only SD cards (SDSC and SDHC/SDXC) are supported now."]
    #[doc = "       Support for MMC/eMMC cards will be added later."]
    #[doc = ""]
    #[doc = " @param host  pointer to structure defining host controller"]
    #[doc = " @param out_card  pointer to structure which will receive information"]
    #[doc = "                  about the card when the function completes"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_card_init(host: *const sdmmc_host_t, out_card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Print information about the card to a stream"]
    #[doc = " @param stream  stream obtained using fopen or fdopen"]
    #[doc = " @param card  card information structure initialized using sdmmc_card_init"]
    pub fn sdmmc_card_print_info(stream: *mut FILE, card: *const sdmmc_card_t);
}
extern "C" {
    #[doc = " Write given number of sectors to SD/MMC card"]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param src   pointer to data buffer to read data from; data size must be"]
    #[doc = "              equal to sector_count * card->csd.sector_size"]
    #[doc = " @param start_sector  sector where to start writing"]
    #[doc = " @param sector_count  number of sectors to write"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_write_sectors(
        card: *mut sdmmc_card_t,
        src: *const c_types::c_void,
        start_sector: size_t,
        sector_count: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write given number of sectors to SD/MMC card"]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param dst   pointer to data buffer to write into; buffer size must be"]
    #[doc = "              at least sector_count * card->csd.sector_size"]
    #[doc = " @param start_sector  sector where to start reading"]
    #[doc = " @param sector_count  number of sectors to read"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_read_sectors(
        card: *mut sdmmc_card_t,
        dst: *mut c_types::c_void,
        start_sector: size_t,
        sector_count: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read one byte from an SDIO card using IO_RW_DIRECT (CMD52)"]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param function  IO function number"]
    #[doc = " @param reg  byte address within IO function"]
    #[doc = " @param[out] out_byte  output, receives the value read from the card"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_read_byte(
        card: *mut sdmmc_card_t,
        function: u32,
        reg: u32,
        out_byte: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write one byte to an SDIO card using IO_RW_DIRECT (CMD52)"]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param function  IO function number"]
    #[doc = " @param reg  byte address within IO function"]
    #[doc = " @param in_byte  value to be written"]
    #[doc = " @param[out] out_byte  if not NULL, receives new byte value read"]
    #[doc = "                       from the card (read-after-write)."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_write_byte(
        card: *mut sdmmc_card_t,
        function: u32,
        reg: u32,
        in_byte: u8,
        out_byte: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read multiple bytes from an SDIO card using IO_RW_EXTENDED (CMD53)"]
    #[doc = ""]
    #[doc = " This function performs read operation using CMD53 in byte mode."]
    #[doc = " For block mode, see sdmmc_io_read_blocks."]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param function  IO function number"]
    #[doc = " @param addr  byte address within IO function where reading starts"]
    #[doc = " @param dst  buffer which receives the data read from card"]
    #[doc = " @param size  number of bytes to read"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_SIZE if size exceeds 512 bytes"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_read_bytes(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        dst: *mut c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write multiple bytes to an SDIO card using IO_RW_EXTENDED (CMD53)"]
    #[doc = ""]
    #[doc = " This function performs write operation using CMD53 in byte mode."]
    #[doc = " For block mode, see sdmmc_io_write_blocks."]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param function  IO function number"]
    #[doc = " @param addr  byte address within IO function where writing starts"]
    #[doc = " @param src  data to be written"]
    #[doc = " @param size  number of bytes to write"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_SIZE if size exceeds 512 bytes"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_write_bytes(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        src: *const c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read blocks of data from an SDIO card using IO_RW_EXTENDED (CMD53)"]
    #[doc = ""]
    #[doc = " This function performs read operation using CMD53 in block mode."]
    #[doc = " For byte mode, see sdmmc_io_read_bytes."]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param function  IO function number"]
    #[doc = " @param addr  byte address within IO function where writing starts"]
    #[doc = " @param dst  buffer which receives the data read from card"]
    #[doc = " @param size  number of bytes to read, must be divisible by the card block"]
    #[doc = "              size."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_SIZE if size is not divisible by 512 bytes"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_read_blocks(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        dst: *mut c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write blocks of data to an SDIO card using IO_RW_EXTENDED (CMD53)"]
    #[doc = ""]
    #[doc = " This function performs write operation using CMD53 in block mode."]
    #[doc = " For byte mode, see sdmmc_io_write_bytes."]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param function  IO function number"]
    #[doc = " @param addr  byte address within IO function where writing starts"]
    #[doc = " @param src  data to be written"]
    #[doc = " @param size  number of bytes to read, must be divisible by the card block"]
    #[doc = "              size."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_SIZE if size is not divisible by 512 bytes"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn sdmmc_io_write_blocks(
        card: *mut sdmmc_card_t,
        function: u32,
        addr: u32,
        src: *const c_types::c_void,
        size: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Enable SDIO interrupt in the SDMMC host"]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if the host controller does not support"]
    #[doc = "        IO interrupts"]
    pub fn sdmmc_io_enable_int(card: *mut sdmmc_card_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Block until an SDIO interrupt is received"]
    #[doc = ""]
    #[doc = " Slave uses D1 line to signal interrupt condition to the host."]
    #[doc = " This function can be used to wait for the interrupt."]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param timeout_ticks  time to wait for the interrupt, in RTOS ticks"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if the interrupt is received"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if the host controller does not support"]
    #[doc = "        IO interrupts"]
    #[doc = "      - ESP_ERR_TIMEOUT if the interrupt does not happen in timeout_ticks"]
    pub fn sdmmc_io_wait_int(card: *mut sdmmc_card_t, timeout_ticks: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Get the data of CIS region of a SDIO card."]
    #[doc = ""]
    #[doc = " You may provide a buffer not sufficient to store all the CIS data. In this"]
    #[doc = " case, this functions store as much data into your buffer as possible. Also,"]
    #[doc = " this function will try to get and return the size required for you."]
    #[doc = ""]
    #[doc = " @param card  pointer to card information structure previously initialized"]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param out_buffer Output buffer of the CIS data"]
    #[doc = " @param buffer_size Size of the buffer."]
    #[doc = " @param inout_cis_size Mandatory, pointer to a size, input and output."]
    #[doc = "              - input: Limitation of maximum searching range, should be 0 or larger than"]
    #[doc = "                      buffer_size. The function searches for CIS_CODE_END until this range. Set to"]
    #[doc = "                      0 to search infinitely."]
    #[doc = "              - output: The size required to store all the CIS data, if CIS_CODE_END is found."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: on success"]
    #[doc = "      - ESP_ERR_INVALID_RESPONSE: if the card does not (correctly) support CIS."]
    #[doc = "      - ESP_ERR_INVALID_SIZE: CIS_CODE_END found, but buffer_size is less than"]
    #[doc = "              required size, which is stored in the inout_cis_size then."]
    #[doc = "      - ESP_ERR_NOT_FOUND: if the CIS_CODE_END not found. Increase input value of"]
    #[doc = "              inout_cis_size or set it to 0, if you still want to search for the end;"]
    #[doc = "              output value of inout_cis_size is invalid in this case."]
    #[doc = "      - and other error code return from sdmmc_io_read_bytes"]
    pub fn sdmmc_io_get_cis_data(
        card: *mut sdmmc_card_t,
        out_buffer: *mut u8,
        buffer_size: size_t,
        inout_cis_size: *mut size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Parse and print the CIS information of a SDIO card."]
    #[doc = ""]
    #[doc = " @note Not all the CIS codes and all kinds of tuples are supported. If you"]
    #[doc = " see some unresolved code, you can add the parsing of these code in"]
    #[doc = " sdmmc_io.c and contribute to the IDF through the Github repository."]
    #[doc = ""]
    #[doc = "              using sdmmc_card_init"]
    #[doc = " @param buffer Buffer to parse"]
    #[doc = " @param buffer_size Size of the buffer."]
    #[doc = " @param fp File pointer to print to, set to NULL to print to stdout."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK: on success"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED: if the value from the card is not supported to be parsed."]
    #[doc = "      - ESP_ERR_INVALID_SIZE: if the CIS size fields are not correct."]
    pub fn sdmmc_io_print_cis_info(
        buffer: *mut u8,
        buffer_size: size_t,
        fp: *mut FILE,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct essl_dev_t {
    _unused: [u8; 0],
}
#[doc = " Handle of an ESSL device"]
pub type essl_handle_t = *mut essl_dev_t;
extern "C" {
    #[doc = " @brief Initialize the slave."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = " @return ESP_OK if success, or other value returned from lower layer `init`."]
    pub fn essl_init(handle: essl_handle_t, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Wait for interrupt of a ESP32 slave device."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_wait_for_ready(handle: essl_handle_t, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Get buffer num for the host to send data to the slave. The buffers are size of ``buffer_size``."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param out_tx_num Output of buffer num that host can send data to ESP32 slave."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_get_tx_buffer_num(
        handle: essl_handle_t,
        out_tx_num: *mut u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Get amount of data the ESP32 slave preparing to send to host."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param out_rx_size Output of data size to read from slave."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_get_rx_data_size(
        handle: essl_handle_t,
        out_rx_size: *mut u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Reset the counters of this component. Usually you don't need to do this unless you know the slave is reset."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    pub fn essl_reset_cnt(handle: essl_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " Send a packet to the ESP32 slave. The slave receive the packet into buffers whose size is ``buffer_size`` (configured during initialization)."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param start Start address of the packet to send"]
    #[doc = " @param length Length of data to send, if the packet is over-size, the it will be divided into blocks and hold into different buffers automatically."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_TIMEOUT No buffer to use, or error ftrom SDMMC host controller"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_send_packet(
        handle: essl_handle_t,
        start: *const c_types::c_void,
        length: size_t,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Get a packet from ESP32 slave."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param[out] out_data Data output address"]
    #[doc = " @param size The size of the output buffer, if the buffer is smaller than the size of data to receive from slave, the driver returns ``ESP_ERR_NOT_FINISHED``"]
    #[doc = " @param[out] out_length Output of length the data actually received from slave."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success, all the data are read from the slave."]
    #[doc = "     - ESP_ERR_NOT_FINISHED Read success, while there're data remaining."]
    #[doc = "     - One of the error codes from SDMMC host controller"]
    pub fn essl_get_packet(
        handle: essl_handle_t,
        out_data: *mut c_types::c_void,
        size: size_t,
        out_length: *mut size_t,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write general purpose R/W registers (8-bit) of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param addr Address of register to write. Valid address: 0-59."]
    #[doc = " @param value Value to write to the register."]
    #[doc = " @param value_o Output of the returned written value."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @note sdio 28-31 are reserved, the lower API helps to skip."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Address not valid."]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_write_reg(
        handle: essl_handle_t,
        addr: u8,
        value: u8,
        value_o: *mut u8,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read general purpose R/W registers (8-bit) of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param add Address of register to read. Valid address: 0-27, 32-63 (28-31 reserved, return interrupt bits on read)."]
    #[doc = " @param value_o Output value read from the register."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Address not valid."]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_read_reg(
        handle: essl_handle_t,
        add: u8,
        value_o: *mut u8,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " wait for an interrupt of the slave"]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED Currently our driver doesnot support SDIO with SPI interface."]
    #[doc = "      - ESP_OK If interrupt triggered."]
    #[doc = "      - ESP_ERR_TIMEOUT No interrupts before timeout."]
    pub fn essl_wait_int(handle: essl_handle_t, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Clear interrupt bits of ESP32 slave. All the bits set in the mask will be cleared, while other bits will stay the same."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param intr_mask Mask of interrupt bits to clear."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_clear_intr(handle: essl_handle_t, intr_mask: u32, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Get interrupt bits of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param intr_raw Output of the raw interrupt bits. Set to NULL if only masked bits are read."]
    #[doc = " @param intr_st Output of the masked interrupt bits. set to NULL if only raw bits are read."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_INVALID_ARG   if both ``intr_raw`` and ``intr_st`` are NULL."]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_get_intr(
        handle: essl_handle_t,
        intr_raw: *mut u32,
        intr_st: *mut u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Set interrupt enable bits of ESP32 slave. The slave only sends interrupt on the line when there is a bit both the raw status and the enable are set."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param ena_mask Mask of the interrupt bits to enable."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_set_intr_ena(handle: essl_handle_t, ena_mask: u32, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Get interrupt enable bits of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param ena_mask_o Output of interrupt bit enable mask."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_get_intr_ena(
        handle: essl_handle_t,
        ena_mask_o: *mut u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Send interrupts to slave. Each bit of the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param handle Handle of a ``essl`` device."]
    #[doc = " @param intr_mask Mask of interrupt bits to send to slave."]
    #[doc = " @param wait_ms Millisecond to wait before timeout, will not wait at all if set to 0-9."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_send_slave_intr(handle: essl_handle_t, intr_mask: u32, wait_ms: u32) -> esp_err_t;
}
#[doc = " Configuration for the essl SDIO device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct essl_sdio_config_t {
    #[doc = "< The initialized sdmmc card pointer of the slave."]
    pub card: *mut sdmmc_card_t,
    #[doc = "< The pre-negotiated recv buffer size used by both the host and the slave."]
    pub recv_buffer_size: c_types::c_int,
}
extern "C" {
    #[doc = " @brief Initialize the ESSL SDIO device and get its handle."]
    #[doc = ""]
    #[doc = " @param out_handle Output of the handle."]
    #[doc = " @param config    Configuration for the ESSL SDIO device."]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: on success"]
    #[doc = "  - ESP_ERR_NO_MEM: memory exhausted."]
    pub fn essl_sdio_init_dev(
        out_handle: *mut essl_handle_t,
        config: *const essl_sdio_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize and free the space used by the ESSL SDIO device."]
    #[doc = ""]
    #[doc = " @param handle Handle of the ESSL SDIO device to deinit."]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: on success"]
    #[doc = "  - ESP_ERR_INVALID_ARG: wrong handle passed"]
    pub fn essl_sdio_deinit_dev(handle: essl_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " SDIO Initialize process of a ESP32 slave device."]
    #[doc = ""]
    #[doc = " @param arg Context of the ``essl`` component. Send to other functions later."]
    #[doc = " @param wait_ms Time to wait before operation is done, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_init(arg: *mut c_types::c_void, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Wait for interrupt of a ESP32 slave device."]
    #[doc = ""]
    #[doc = " @param arg Context of the ``essl`` component."]
    #[doc = " @param wait_ms Time to wait before operation is done, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_wait_for_ready(arg: *mut c_types::c_void, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Get buffer num for the host to send data to the slave. The buffers are size of ``buffer_size``."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_get_tx_buffer_num(arg: *mut c_types::c_void) -> u32;
}
extern "C" {
    #[doc = " Get amount of data the ESP32 slave preparing to send to host."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_get_rx_data_size(arg: *mut c_types::c_void) -> u32;
}
extern "C" {
    #[doc = " Send a packet to the ESP32 slave. The slave receive the packet into buffers whose size is ``buffer_size`` in the arg."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param start Start address of the packet to send"]
    #[doc = " @param length Length of data to send, if the packet is over-size, the it will be divided into blocks and hold into different buffers automatically."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_TIMEOUT No buffer to use, or error ftrom SDMMC host controller"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_send_packet(
        arg: *mut c_types::c_void,
        start: *const c_types::c_void,
        length: size_t,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Get a packet from ESP32 slave."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param[out] out_data Data output address"]
    #[doc = " @param size The size of the output buffer, if the buffer is smaller than the size of data to receive from slave, the driver returns ``ESP_ERR_NOT_FINISHED``"]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success, all the data are read from the slave."]
    #[doc = "     - ESP_ERR_NOT_FINISHED Read success, while there're data remaining."]
    #[doc = "     - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_get_packet(
        arg: *mut c_types::c_void,
        out_data: *mut c_types::c_void,
        size: size_t,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Wait for the interrupt from the SDIO slave."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = " @return"]
    #[doc = "  - ESP_ERR_NOT_SUPPORTED: if the interrupt line is not initialized properly."]
    #[doc = "  - ESP_OK: if interrupt happened"]
    #[doc = "  - ESP_ERR_TIMEOUT: if timeout before interrupt happened."]
    #[doc = "  - or other values returned from the `io_int_wait` member of the `card->host` structure."]
    pub fn essl_sdio_wait_int(arg: *mut c_types::c_void, wait_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " Clear interrupt bits of ESP32 slave. All the bits set in the mask will be cleared, while other bits will stay the same."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param intr_mask Mask of interrupt bits to clear."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_clear_intr(
        arg: *mut c_types::c_void,
        intr_mask: u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Get interrupt bits of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param intr_raw Output of the raw interrupt bits. Set to NULL if only masked bits are read."]
    #[doc = " @param intr_st Output of the masked interrupt bits. set to NULL if only raw bits are read."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_INVALID_ARG   if both ``intr_raw`` and ``intr_st`` are NULL."]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_get_intr(
        arg: *mut c_types::c_void,
        intr_raw: *mut u32,
        intr_st: *mut u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Set interrupt enable bits of ESP32 slave. The slave only sends interrupt on the line when there is a bit both the raw status and the enable are set."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param ena_mask Mask of the interrupt bits to enable."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_set_intr_ena(
        arg: *mut c_types::c_void,
        ena_mask: u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Get interrupt enable bits of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param ena_mask_o Output of interrupt bit enable mask."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_get_intr_ena(
        arg: *mut c_types::c_void,
        ena_mask_o: *mut u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Write general purpose R/W registers (8-bit) of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param addr Address of register to write. Valid address: 0-27, 32-63 (28-31 reserved)."]
    #[doc = " @param value Value to write to the register."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Address not valid."]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_write_reg(
        arg: *mut c_types::c_void,
        addr: u8,
        value: u8,
        value_o: *mut u8,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Read general purpose R/W registers (8-bit) of ESP32 slave."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param add Address of register to read. Valid address: 0-27, 32-63 (28-31 reserved, return interrupt bits on read)."]
    #[doc = " @param value Output value read from the register."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Address not valid."]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_read_reg(
        arg: *mut c_types::c_void,
        add: u8,
        value_o: *mut u8,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " Send interrupts to slave. Each bit of the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param arg Context of the component."]
    #[doc = " @param intr_mask Mask of interrupt bits to send to slave."]
    #[doc = " @param wait_ms Time to wait before timeout, in ms."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - One of the error codes from SDMMC host controller"]
    pub fn essl_sdio_send_slave_intr(
        arg: *mut c_types::c_void,
        intr_mask: u32,
        wait_ms: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset the counter on the host side."]
    #[doc = ""]
    #[doc = " @note Only call when you know the slave has reset its counter, or there will be inconsistent between the master and the slave."]
    #[doc = ""]
    #[doc = " @param arg  Context of the component."]
    pub fn essl_sdio_reset_cnt(arg: *mut c_types::c_void);
}
pub type __builtin_va_list = __va_list_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub __va_stk: *mut c_types::c_int,
    pub __va_reg: *mut c_types::c_int,
    pub __va_ndx: c_types::c_int,
}
