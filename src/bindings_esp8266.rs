/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.0.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 0;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_USE_LONG_TIME_T: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const XCHAL_HAVE_BE: u32 = 0;
pub const XCHAL_HAVE_WINDOWED: u32 = 0;
pub const XCHAL_NUM_AREGS: u32 = 16;
pub const XCHAL_NUM_AREGS_LOG2: u32 = 4;
pub const XCHAL_MAX_INSTRUCTION_SIZE: u32 = 3;
pub const XCHAL_HAVE_DEBUG: u32 = 1;
pub const XCHAL_HAVE_DENSITY: u32 = 1;
pub const XCHAL_HAVE_LOOPS: u32 = 0;
pub const XCHAL_HAVE_NSA: u32 = 1;
pub const XCHAL_HAVE_MINMAX: u32 = 0;
pub const XCHAL_HAVE_SEXT: u32 = 0;
pub const XCHAL_HAVE_CLAMPS: u32 = 0;
pub const XCHAL_HAVE_MUL16: u32 = 1;
pub const XCHAL_HAVE_MUL32: u32 = 1;
pub const XCHAL_HAVE_MUL32_HIGH: u32 = 0;
pub const XCHAL_HAVE_DIV32: u32 = 0;
pub const XCHAL_HAVE_L32R: u32 = 1;
pub const XCHAL_HAVE_ABSOLUTE_LITERALS: u32 = 1;
pub const XCHAL_HAVE_CONST16: u32 = 0;
pub const XCHAL_HAVE_ADDX: u32 = 1;
pub const XCHAL_HAVE_WIDE_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_PREDICTED_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_CALL4AND12: u32 = 0;
pub const XCHAL_HAVE_ABS: u32 = 1;
pub const XCHAL_HAVE_RELEASE_SYNC: u32 = 0;
pub const XCHAL_HAVE_S32C1I: u32 = 0;
pub const XCHAL_HAVE_SPECULATION: u32 = 0;
pub const XCHAL_HAVE_FULL_RESET: u32 = 1;
pub const XCHAL_NUM_CONTEXTS: u32 = 1;
pub const XCHAL_NUM_MISC_REGS: u32 = 0;
pub const XCHAL_HAVE_TAP_MASTER: u32 = 0;
pub const XCHAL_HAVE_PRID: u32 = 1;
pub const XCHAL_HAVE_EXTERN_REGS: u32 = 1;
pub const XCHAL_HAVE_MP_INTERRUPTS: u32 = 0;
pub const XCHAL_HAVE_MP_RUNSTALL: u32 = 0;
pub const XCHAL_HAVE_THREADPTR: u32 = 0;
pub const XCHAL_HAVE_BOOLEANS: u32 = 0;
pub const XCHAL_HAVE_CP: u32 = 0;
pub const XCHAL_CP_MAXCFG: u32 = 0;
pub const XCHAL_HAVE_MAC16: u32 = 0;
pub const XCHAL_HAVE_VECTORFPU2005: u32 = 0;
pub const XCHAL_HAVE_FP: u32 = 0;
pub const XCHAL_HAVE_DFP: u32 = 0;
pub const XCHAL_HAVE_DFP_accel: u32 = 0;
pub const XCHAL_HAVE_VECTRA1: u32 = 0;
pub const XCHAL_HAVE_VECTRALX: u32 = 0;
pub const XCHAL_HAVE_HIFIPRO: u32 = 0;
pub const XCHAL_HAVE_HIFI2: u32 = 0;
pub const XCHAL_HAVE_CONNXD2: u32 = 0;
pub const XCHAL_NUM_WRITEBUFFER_ENTRIES: u32 = 1;
pub const XCHAL_INST_FETCH_WIDTH: u32 = 4;
pub const XCHAL_DATA_WIDTH: u32 = 4;
pub const XCHAL_UNALIGNED_LOAD_EXCEPTION: u32 = 1;
pub const XCHAL_UNALIGNED_STORE_EXCEPTION: u32 = 1;
pub const XCHAL_UNALIGNED_LOAD_HW: u32 = 0;
pub const XCHAL_UNALIGNED_STORE_HW: u32 = 0;
pub const XCHAL_SW_VERSION: u32 = 800001;
pub const XCHAL_CORE_ID: &'static [u8; 6usize] = b"lx106\0";
pub const XCHAL_BUILD_UNIQUE_ID: u32 = 177910;
pub const XCHAL_HW_CONFIGID0: u32 = 3264011002;
pub const XCHAL_HW_CONFIGID1: u32 = 277001974;
pub const XCHAL_HW_VERSION_NAME: &'static [u8; 8usize] = b"LX3.0.1\0";
pub const XCHAL_HW_VERSION_MAJOR: u32 = 2300;
pub const XCHAL_HW_VERSION_MINOR: u32 = 1;
pub const XCHAL_HW_VERSION: u32 = 230001;
pub const XCHAL_HW_REL_LX3: u32 = 1;
pub const XCHAL_HW_REL_LX3_0: u32 = 1;
pub const XCHAL_HW_REL_LX3_0_1: u32 = 1;
pub const XCHAL_HW_CONFIGID_RELIABLE: u32 = 1;
pub const XCHAL_HW_MIN_VERSION_MAJOR: u32 = 2300;
pub const XCHAL_HW_MIN_VERSION_MINOR: u32 = 1;
pub const XCHAL_HW_MIN_VERSION: u32 = 230001;
pub const XCHAL_HW_MAX_VERSION_MAJOR: u32 = 2300;
pub const XCHAL_HW_MAX_VERSION_MINOR: u32 = 1;
pub const XCHAL_HW_MAX_VERSION: u32 = 230001;
pub const XCHAL_ICACHE_LINESIZE: u32 = 4;
pub const XCHAL_DCACHE_LINESIZE: u32 = 4;
pub const XCHAL_ICACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_DCACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_ICACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_IS_WRITEBACK: u32 = 0;
pub const XCHAL_DCACHE_IS_COHERENT: u32 = 0;
pub const XCHAL_HAVE_PREFETCH: u32 = 0;
pub const XCHAL_HAVE_PIF: u32 = 1;
pub const XCHAL_ICACHE_SETWIDTH: u32 = 0;
pub const XCHAL_DCACHE_SETWIDTH: u32 = 0;
pub const XCHAL_ICACHE_WAYS: u32 = 1;
pub const XCHAL_DCACHE_WAYS: u32 = 1;
pub const XCHAL_ICACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_DCACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_ICACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_DCACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_ICACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_CA_BITS: u32 = 4;
pub const XCHAL_NUM_INSTROM: u32 = 1;
pub const XCHAL_NUM_INSTRAM: u32 = 2;
pub const XCHAL_NUM_DATAROM: u32 = 1;
pub const XCHAL_NUM_DATARAM: u32 = 2;
pub const XCHAL_NUM_URAM: u32 = 0;
pub const XCHAL_NUM_XLMI: u32 = 1;
pub const XCHAL_INSTROM0_VADDR: u32 = 1075838976;
pub const XCHAL_INSTROM0_PADDR: u32 = 1075838976;
pub const XCHAL_INSTROM0_SIZE: u32 = 1048576;
pub const XCHAL_INSTROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_SIZE: u32 = 1048576;
pub const XCHAL_INSTRAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM1_VADDR: u32 = 1074790400;
pub const XCHAL_INSTRAM1_PADDR: u32 = 1074790400;
pub const XCHAL_INSTRAM1_SIZE: u32 = 1048576;
pub const XCHAL_INSTRAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_VADDR: u32 = 1072955392;
pub const XCHAL_DATAROM0_PADDR: u32 = 1072955392;
pub const XCHAL_DATAROM0_SIZE: u32 = 262144;
pub const XCHAL_DATAROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM0_VADDR: u32 = 1073479680;
pub const XCHAL_DATARAM0_PADDR: u32 = 1073479680;
pub const XCHAL_DATARAM0_SIZE: u32 = 262144;
pub const XCHAL_DATARAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM1_VADDR: u32 = 1073217536;
pub const XCHAL_DATARAM1_PADDR: u32 = 1073217536;
pub const XCHAL_DATARAM1_SIZE: u32 = 262144;
pub const XCHAL_DATARAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_XLMI0_VADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_PADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_SIZE: u32 = 262144;
pub const XCHAL_XLMI0_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_HIGHPRI_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_NMI: u32 = 1;
pub const XCHAL_HAVE_CCOUNT: u32 = 1;
pub const XCHAL_NUM_TIMERS: u32 = 1;
pub const XCHAL_NUM_INTERRUPTS: u32 = 15;
pub const XCHAL_NUM_INTERRUPTS_LOG2: u32 = 4;
pub const XCHAL_NUM_EXTINTERRUPTS: u32 = 13;
pub const XCHAL_NUM_INTLEVELS: u32 = 2;
pub const XCHAL_EXCM_LEVEL: u32 = 1;
pub const XCHAL_INTLEVEL1_MASK: u32 = 16383;
pub const XCHAL_INTLEVEL2_MASK: u32 = 0;
pub const XCHAL_INTLEVEL3_MASK: u32 = 16384;
pub const XCHAL_INTLEVEL4_MASK: u32 = 0;
pub const XCHAL_INTLEVEL5_MASK: u32 = 0;
pub const XCHAL_INTLEVEL6_MASK: u32 = 0;
pub const XCHAL_INTLEVEL7_MASK: u32 = 0;
pub const XCHAL_INTLEVEL1_ANDBELOW_MASK: u32 = 16383;
pub const XCHAL_INTLEVEL2_ANDBELOW_MASK: u32 = 16383;
pub const XCHAL_INTLEVEL3_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL4_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL5_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL6_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL7_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INT0_LEVEL: u32 = 1;
pub const XCHAL_INT1_LEVEL: u32 = 1;
pub const XCHAL_INT2_LEVEL: u32 = 1;
pub const XCHAL_INT3_LEVEL: u32 = 1;
pub const XCHAL_INT4_LEVEL: u32 = 1;
pub const XCHAL_INT5_LEVEL: u32 = 1;
pub const XCHAL_INT6_LEVEL: u32 = 1;
pub const XCHAL_INT7_LEVEL: u32 = 1;
pub const XCHAL_INT8_LEVEL: u32 = 1;
pub const XCHAL_INT9_LEVEL: u32 = 1;
pub const XCHAL_INT10_LEVEL: u32 = 1;
pub const XCHAL_INT11_LEVEL: u32 = 1;
pub const XCHAL_INT12_LEVEL: u32 = 1;
pub const XCHAL_INT13_LEVEL: u32 = 1;
pub const XCHAL_INT14_LEVEL: u32 = 3;
pub const XCHAL_DEBUGLEVEL: u32 = 2;
pub const XCHAL_HAVE_DEBUG_EXTERN_INT: u32 = 1;
pub const XCHAL_NMILEVEL: u32 = 3;
pub const XCHAL_INTTYPE_MASK_UNCONFIGURED: u32 = 4294934528;
pub const XCHAL_INTTYPE_MASK_SOFTWARE: u32 = 128;
pub const XCHAL_INTTYPE_MASK_EXTERN_EDGE: u32 = 16128;
pub const XCHAL_INTTYPE_MASK_EXTERN_LEVEL: u32 = 63;
pub const XCHAL_INTTYPE_MASK_TIMER: u32 = 64;
pub const XCHAL_INTTYPE_MASK_NMI: u32 = 16384;
pub const XCHAL_INTTYPE_MASK_WRITE_ERROR: u32 = 0;
pub const XCHAL_TIMER0_INTERRUPT: u32 = 6;
pub const XCHAL_NMI_INTERRUPT: u32 = 14;
pub const XCHAL_INTLEVEL3_NUM: u32 = 14;
pub const XCHAL_EXTINT0_NUM: u32 = 0;
pub const XCHAL_EXTINT1_NUM: u32 = 1;
pub const XCHAL_EXTINT2_NUM: u32 = 2;
pub const XCHAL_EXTINT3_NUM: u32 = 3;
pub const XCHAL_EXTINT4_NUM: u32 = 4;
pub const XCHAL_EXTINT5_NUM: u32 = 5;
pub const XCHAL_EXTINT6_NUM: u32 = 8;
pub const XCHAL_EXTINT7_NUM: u32 = 9;
pub const XCHAL_EXTINT8_NUM: u32 = 10;
pub const XCHAL_EXTINT9_NUM: u32 = 11;
pub const XCHAL_EXTINT10_NUM: u32 = 12;
pub const XCHAL_EXTINT11_NUM: u32 = 13;
pub const XCHAL_EXTINT12_NUM: u32 = 14;
pub const XCHAL_XEA_VERSION: u32 = 2;
pub const XCHAL_HAVE_XEA1: u32 = 0;
pub const XCHAL_HAVE_XEA2: u32 = 1;
pub const XCHAL_HAVE_XEAX: u32 = 0;
pub const XCHAL_HAVE_EXCEPTIONS: u32 = 1;
pub const XCHAL_HAVE_MEM_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_VECTOR_SELECT: u32 = 1;
pub const XCHAL_HAVE_VECBASE: u32 = 1;
pub const XCHAL_VECBASE_RESET_VADDR: u32 = 1073741824;
pub const XCHAL_VECBASE_RESET_PADDR: u32 = 1073741824;
pub const XCHAL_RESET_VECBASE_OVERLAP: u32 = 0;
pub const XCHAL_RESET_VECTOR0_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR0_PADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR1_VADDR: u32 = 1073741952;
pub const XCHAL_RESET_VECTOR1_PADDR: u32 = 1073741952;
pub const XCHAL_RESET_VECTOR_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR_PADDR: u32 = 1342177280;
pub const XCHAL_USER_VECOFS: u32 = 80;
pub const XCHAL_USER_VECTOR_VADDR: u32 = 1073741904;
pub const XCHAL_USER_VECTOR_PADDR: u32 = 1073741904;
pub const XCHAL_KERNEL_VECOFS: u32 = 48;
pub const XCHAL_KERNEL_VECTOR_VADDR: u32 = 1073741872;
pub const XCHAL_KERNEL_VECTOR_PADDR: u32 = 1073741872;
pub const XCHAL_DOUBLEEXC_VECOFS: u32 = 112;
pub const XCHAL_DOUBLEEXC_VECTOR_VADDR: u32 = 1073741936;
pub const XCHAL_DOUBLEEXC_VECTOR_PADDR: u32 = 1073741936;
pub const XCHAL_INTLEVEL2_VECOFS: u32 = 16;
pub const XCHAL_INTLEVEL2_VECTOR_VADDR: u32 = 1073741840;
pub const XCHAL_INTLEVEL2_VECTOR_PADDR: u32 = 1073741840;
pub const XCHAL_DEBUG_VECOFS: u32 = 16;
pub const XCHAL_DEBUG_VECTOR_VADDR: u32 = 1073741840;
pub const XCHAL_DEBUG_VECTOR_PADDR: u32 = 1073741840;
pub const XCHAL_NMI_VECOFS: u32 = 32;
pub const XCHAL_NMI_VECTOR_VADDR: u32 = 1073741856;
pub const XCHAL_NMI_VECTOR_PADDR: u32 = 1073741856;
pub const XCHAL_INTLEVEL3_VECOFS: u32 = 32;
pub const XCHAL_INTLEVEL3_VECTOR_VADDR: u32 = 1073741856;
pub const XCHAL_INTLEVEL3_VECTOR_PADDR: u32 = 1073741856;
pub const XCHAL_HAVE_OCD: u32 = 1;
pub const XCHAL_NUM_IBREAK: u32 = 1;
pub const XCHAL_NUM_DBREAK: u32 = 1;
pub const XCHAL_HAVE_OCD_DIR_ARRAY: u32 = 0;
pub const XCHAL_HAVE_TLBS: u32 = 1;
pub const XCHAL_HAVE_SPANNING_WAY: u32 = 1;
pub const XCHAL_SPANNING_WAY: u32 = 0;
pub const XCHAL_HAVE_IDENTITY_MAP: u32 = 1;
pub const XCHAL_HAVE_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_MIMIC_CACHEATTR: u32 = 1;
pub const XCHAL_HAVE_XLT_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_PTP_MMU: u32 = 0;
pub const XCHAL_MMU_ASID_BITS: u32 = 0;
pub const XCHAL_MMU_RINGS: u32 = 1;
pub const XCHAL_MMU_RING_BITS: u32 = 0;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const CONFIG_IDF_TARGET_ESP8266: u32 = 1;
pub const CONFIG_IDF_TARGET: &'static [u8; 8usize] = b"esp8266\0";
pub const CONFIG_SDK_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-lx106-elf-\0";
pub const CONFIG_SDK_PYTHON: &'static [u8; 7usize] = b"python\0";
pub const CONFIG_BOOTLOADER_INIT_SPI_FLASH: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_ESPTOOLPY_PORT: &'static [u8; 13usize] = b"/dev/ttyUSB0\0";
pub const CONFIG_ESPTOOLPY_BAUD_115200B: u32 = 1;
pub const CONFIG_ESPTOOLPY_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_BAUD: u32 = 115200;
pub const CONFIG_ESPTOOLPY_COMPRESSED: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_QIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &'static [u8; 4usize] = b"dio\0";
pub const CONFIG_SPI_FLASH_MODE: u32 = 0;
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &'static [u8; 4usize] = b"40m\0";
pub const CONFIG_SPI_FLASH_FREQ: u32 = 0;
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &'static [u8; 4usize] = b"2MB\0";
pub const CONFIG_SPI_FLASH_SIZE: u32 = 2097152;
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &'static [u8; 14usize] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_HARD_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &'static [u8; 11usize] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_74880B: u32 = 1;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_OTHER_VAL: u32 = 74880;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 74880;
pub const CONFIG_ESP_WIFI_IS_STATION: u32 = 1;
pub const CONFIG_ESP_WIFI_SSID: &'static [u8; 7usize] = b"myssid\0";
pub const CONFIG_ESP_WIFI_PASSWORD: &'static [u8; 11usize] = b"mypassword\0";
pub const CONFIG_MAX_STA_CONN: u32 = 4;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &'static [u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_FILENAME: &'static [u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_APP_UPDATE_CHECK_APP_SUM: u32 = 1;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ESP8266_DEFAULT_CPU_FREQ_80: u32 = 1;
pub const CONFIG_ESP8266_DEFAULT_CPU_FREQ_MHZ: u32 = 80;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_ESP_FILENAME_MACRO_NO_PATH: u32 = 1;
pub const CONFIG_USING_NEW_ETS_VPRINTF: u32 = 1;
pub const CONFIG_SOC_IRAM_SIZE: u32 = 49152;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 74880;
pub const CONFIG_ESP_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_PANIC: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_15N: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 15;
pub const CONFIG_RESET_REASON: u32 = 1;
pub const CONFIG_WIFI_PPT_TASKSTACK_SIZE: u32 = 2048;
pub const CONFIG_EVENT_LOOP_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP8266_CORE_GLOBAL_DATA_LINK_IRAM: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ESP8266_TIME_SYSCALL_USE_FRC1: u32 = 1;
pub const CONFIG_SCAN_AP_MAX: u32 = 99;
pub const CONFIG_WIFI_TX_RATE_SEQUENCE_FROM_HIGH: u32 = 1;
pub const CONFIG_ESP8266_WIFI_RX_BUFFER_NUM: u32 = 16;
pub const CONFIG_ESP8266_WIFI_LEFT_CONTINUOUS_RX_BUFFER_NUM: u32 = 8;
pub const CONFIG_ESP8266_WIFI_RX_PKT_NUM: u32 = 7;
pub const CONFIG_ESP8266_WIFI_TX_PKT_NUM: u32 = 6;
pub const CONFIG_ESP8266_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP8266_WIFI_CONNECT_OPEN_ROUTER_WHEN_PWD_IS_SET: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP_PHY_INIT_DATA_VDD33_CONST: u32 = 33;
pub const CONFIG_ESP8266_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTP_BUF_SIZE: u32 = 512;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_OTA_BUF_SIZE: u32 = 256;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_MAX_HOOK: u32 = 2;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1024;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 512;
pub const CONFIG_FREERTOS_GLOBAL_DATA_LINK_IRAM: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_STACKSIZE: u32 = 2048;
pub const CONFIG_TASK_SWITCH_FASTER: u32 = 1;
pub const CONFIG_LIBSODIUM_USE_MBEDTLS_SHA: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LWIP_GLOBAL_DATA_LINK_IRAM: u32 = 1;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_ARP_TABLE_SIZE: u32 = 10;
pub const CONFIG_LWIP_ARP_MAXAGE: u32 = 300;
pub const CONFIG_LWIP_SOCKET_MULTITHREAD: u32 = 1;
pub const CONFIG_SET_SOLINGER_DEFAULT: u32 = 1;
pub const CONFIG_ESP_UDP_SYNC_SEND: u32 = 1;
pub const CONFIG_ESP_UDP_SYNC_RETRY_MAX: u32 = 5;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_RECV_BUFSIZE_DEFAULT: u32 = 11680;
pub const CONFIG_LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 10000;
pub const CONFIG_LWIP_IP_REASS_MAX_PBUFS: u32 = 10;
pub const CONFIG_LWIP_ICMP: u32 = 1;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_DHCP_DISCOVER_RETRANSMISSION_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_IGMP: u32 = 1;
pub const CONFIG_ESP_DNS: u32 = 1;
pub const CONFIG_DNS_MAX_SERVERS: u32 = 3;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 5;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 8;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_TCP_MSS: u32 = 1460;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 2920;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5840;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 1000;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 4;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 4;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_DHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_RC4_DISABLED: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MQTT_USING_ESP: u32 = 1;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_LIBRARY_LEVEL_FLOAT_NANO: u32 = 1;
pub const CONFIG_OPENSSL_ASSERT_DO_NOTHING: u32 = 1;
pub const CONFIG_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_TCPIP_ADAPTER_GLOBAL_DATA_LINK_IRAM: u32 = 1;
pub const CONFIG_ESP_AES: u32 = 1;
pub const CONFIG_ESP_MD5: u32 = 1;
pub const CONFIG_ESP_ARC4: u32 = 1;
pub const CONFIG_LTM_FAST: u32 = 1;
pub const CONFIG_FLASHMODE_QIO: u32 = 1;
pub const CONFIG_MONITOR_BAUD: u32 = 74880;
pub const CONFIG_MONITOR_BAUD_74880B: u32 = 1;
pub const CONFIG_MONITOR_BAUD_OTHER_VAL: u32 = 74880;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_TARGET_PLATFORM: &'static [u8; 8usize] = b"esp8266\0";
pub const CONFIG_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-lx106-elf-\0";
pub const ESP_IDF_VERSION_MAJOR: u32 = 3;
pub const ESP_IDF_VERSION_MINOR: u32 = 3;
pub const ESP_IDF_VERSION_PATCH: u32 = 0;
pub const CRYSTAL_USED: u32 = 26;
pub const ETS_INT_MASK: u32 = 16383;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const CPU_CLK_FREQ: u32 = 80000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 312500;
pub const FREQ_1MHZ: u32 = 1000000;
pub const FREQ_1KHZ: u32 = 1000;
pub const CPU_FREQ_160MHZ: u32 = 160000000;
pub const CPU_FREQ_80MHz: u32 = 80000000;
pub const CPU_160M_TICKS_PRT_MS: u32 = 160000;
pub const CPU_80M_TICKS_PRT_MS: u32 = 80000;
pub const CPU_160M_TICKS_PRT_US: u32 = 160;
pub const CPU_80M_TICKS_PRT_US: u32 = 80;
pub const PERIPHS_DPORT_BASEADDR: u32 = 1072693248;
pub const PERIPHS_RTC_BASEADDR: u32 = 1610614528;
pub const HOST_INF_SEL: u32 = 1072693288;
pub const DPORT_LINK_DEVICE_SEL: u32 = 255;
pub const DPORT_LINK_DEVICE_SEL_S: u32 = 8;
pub const DPORT_PERI_IO_SWAP: u32 = 255;
pub const DPORT_PERI_IO_SWAP_S: u32 = 0;
pub const EDGE_INT_ENABLE_REG: u32 = 1072693252;
pub const DPORT_CTL_REG: u32 = 1072693268;
pub const DPORT_CTL_DOUBLE_CLK: u32 = 1;
pub const INT_ENA_WDEV: u32 = 1072827416;
pub const WDEV_COUNT_REG: u32 = 1072827392;
pub const PERIPHS_WDT_BASEADDR: u32 = 1610615040;
pub const WDT_CTL_ADDRESS: u32 = 0;
pub const WDT_OP_ADDRESS: u32 = 4;
pub const WDT_OP_ND_ADDRESS: u32 = 8;
pub const WDT_RST_ADDRESS: u32 = 20;
pub const WDT_CTL_RSTLEN_MASK: u32 = 56;
pub const WDT_CTL_RSPMOD_MASK: u32 = 6;
pub const WDT_CTL_EN_MASK: u32 = 1;
pub const WDT_CTL_RSTLEN_LSB: u32 = 3;
pub const WDT_CTL_RSPMOD_LSB: u32 = 1;
pub const WDT_CTL_EN_LSB: u32 = 0;
pub const WDT_FEED_VALUE: u32 = 115;
pub const REG_RTC_BASE: u32 = 1610614528;
pub const RTC_SLP_VAL: u32 = 1610614532;
pub const RTC_SLP_CNT_VAL: u32 = 1610614556;
pub const RTC_SCRATCH0: u32 = 1610614576;
pub const RTC_SCRATCH1: u32 = 1610614580;
pub const RTC_SCRATCH2: u32 = 1610614584;
pub const RTC_SCRATCH3: u32 = 1610614588;
pub const RTC_GPIO_OUT: u32 = 1610614632;
pub const RTC_GPIO_ENABLE: u32 = 1610614644;
pub const RTC_GPIO_IN_DATA: u32 = 1610614668;
pub const RTC_GPIO_CONF: u32 = 1610614672;
pub const PAD_XPD_DCDC_CONF: u32 = 1610614688;
pub const CACHE_FLASH_CTRL_REG: u32 = 1072693260;
pub const CACHE_READ_EN_BIT: u32 = 256;
pub const DRAM_BASE: u32 = 1073643520;
pub const DRAM_SIZE: u32 = 98304;
pub const IRAM_BASE: u32 = 1074790400;
pub const IRAM_SIZE: u32 = 49152;
pub const FLASH_BASE: u32 = 1075838976;
pub const FLASH_SIZE: u32 = 1048576;
pub const RTC_SYS_BASE: u32 = 1610616832;
pub const RTC_SYS_SIZE: u32 = 512;
pub const RTC_USER_BASE: u32 = 1610617344;
pub const RTC_USER_SIZE: u32 = 512;
pub const ROM_BASE: u32 = 1073741824;
pub const ROM_SIZE: u32 = 65536;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_SPI_INUM: u32 = 2;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_UART_INUM: u32 = 5;
pub const ETS_MAX_INUM: u32 = 6;
pub const ETS_SOFT_INUM: u32 = 7;
pub const ETS_WDT_INUM: u32 = 8;
pub const ETS_FRC_TIMER1_INUM: u32 = 9;
pub const ETS_INT_MAX: u32 = 14;
pub const MACSTR: &'static [u8; 30usize] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const HEAP_ALIGN_SIZE: u32 = 4;
pub const HEAP_REGIONS_MAX: u32 = 2;
pub const MEM_BLK_MIN: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 10;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const CONFIG_TCPIP_LWIP: u32 = 1;
pub const CONFIG_DHCP_STA_LIST: u32 = 1;
pub const NO_SYS: u32 = 1;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 0;
pub const LWIP_NETCONN: u32 = 0;
pub const LWIP_SOCKET: u32 = 0;
pub const LWIP_DHCP: u32 = 1;
pub const MEM_SIZE: u32 = 16000;
pub const TCP_SND_QUEUELEN: u32 = 40;
pub const MEMP_NUM_TCP_SEG: u32 = 40;
pub const LWIP_WND_SCALE: u32 = 1;
pub const TCP_RCV_SCALE: u32 = 0;
pub const PBUF_POOL_SIZE: u32 = 400;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_MDNS_RESPONDER: u32 = 1;
pub const LWIP_NUM_NETIF_CLIENT_DATA: u32 = 1;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 1;
pub const MIB2_STATS: u32 = 1;
pub const EFAULT: u32 = 14;
pub const LWIP_ERRNO_INCLUDE: &'static [u8; 12usize] = b"sys/errno.h\0";
pub const S16_F: &'static [u8; 3usize] = b"hd\0";
pub const U16_F: &'static [u8; 3usize] = b"hu\0";
pub const X16_F: &'static [u8; 3usize] = b"hx\0";
pub const S32_F: &'static [u8; 2usize] = b"d\0";
pub const U32_F: &'static [u8; 2usize] = b"u\0";
pub const X32_F: &'static [u8; 2usize] = b"x\0";
pub const LWIP_PLATFORM_BYTESWAP: u32 = 1;
pub const LWIP_TIMEVAL_PRIVATE: u32 = 0;
pub const LWIP_NO_STDDEF_H: u32 = 0;
pub const LWIP_NO_STDINT_H: u32 = 0;
pub const LWIP_NO_INTTYPES_H: u32 = 0;
pub const X8_F: &'static [u8; 3usize] = b"02\0";
pub const LWIP_NO_LIMITS_H: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const ARG_MAX: u32 = 4096;
pub const PATH_MAX: u32 = 4096;
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const LWIP_TIMERS: u32 = 1;
pub const LWIP_TIMERS_CUSTOM: u32 = 0;
pub const LWIP_MPU_COMPATIBLE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 1;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const MEM_LIBC_MALLOC: u32 = 0;
pub const MEMP_MEM_MALLOC: u32 = 0;
pub const MEM_ALIGNMENT: u32 = 1;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 16;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_UDP_PCB: u32 = 4;
pub const MEMP_NUM_TCP_PCB: u32 = 5;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 8;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 2;
pub const MEMP_NUM_NETCONN: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const MEMP_NUM_API_MSG: u32 = 8;
pub const MEMP_NUM_DNS_API_MSG: u32 = 8;
pub const MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: u32 = 8;
pub const MEMP_NUM_NETIFAPI_MSG: u32 = 8;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_MAXAGE: u32 = 300;
pub const ARP_QUEUEING: u32 = 0;
pub const ARP_QUEUE_LEN: u32 = 3;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const LWIP_ETHERNET: u32 = 1;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_TABLE_MATCH_NETIF: u32 = 0;
pub const LWIP_IPV4: u32 = 1;
pub const IP_FORWARD: u32 = 0;
pub const IP_REASSEMBLY: u32 = 1;
pub const IP_FRAG: u32 = 1;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const IP_FORWARD_ALLOW_TX_ON_RX_NETIF: u32 = 0;
pub const LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 255;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const LWIP_RAW: u32 = 0;
pub const RAW_TTL: u32 = 255;
pub const LWIP_DHCP_CHECK_LINK_UP: u32 = 0;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const LWIP_DHCP_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_MIB2_CALLBACKS: u32 = 0;
pub const LWIP_DNS: u32 = 0;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const LWIP_DNS_SECURE_RAND_XID: u32 = 1;
pub const LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING: u32 = 2;
pub const LWIP_DNS_SECURE_RAND_SRC_PORT: u32 = 4;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 0;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 255;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 255;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 536;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 536;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const LWIP_TCP_RTO_TIME: u32 = 3000;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const LWIP_NETIF_HOSTNAME: u32 = 0;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_REMOVE_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 0;
pub const LWIP_LOOPIF_MULTICAST: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const TCPIP_THREAD_NAME: &'static [u8; 13usize] = b"tcpip_thread\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 0;
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &'static [u8; 12usize] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &'static [u8; 5usize] = b"lwIP\0";
pub const DEFAULT_THREAD_STACKSIZE: u32 = 0;
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 0;
pub const LWIP_NETCONN_SEM_PER_THREAD: u32 = 0;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 0;
pub const LWIP_SOCKET_SET_ERRNO: u32 = 1;
pub const LWIP_COMPAT_SOCKETS: u32 = 1;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 1;
pub const LWIP_SOCKET_OFFSET: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 0;
pub const LWIP_SO_SNDTIMEO: u32 = 0;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_SNDRCVTIMEO_NONSTANDARD: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const LWIP_SO_LINGER: u32 = 0;
pub const LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 20000;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_FIONREAD_LINUXMODE: u32 = 0;
pub const LWIP_STATS: u32 = 1;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const LINK_STATS: u32 = 1;
pub const ETHARP_STATS: u32 = 1;
pub const IP_STATS: u32 = 1;
pub const ICMP_STATS: u32 = 1;
pub const IGMP_STATS: u32 = 1;
pub const UDP_STATS: u32 = 1;
pub const TCP_STATS: u32 = 1;
pub const LWIP_CHECKSUM_CTRL_PER_NETIF: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_GEN_ICMP: u32 = 1;
pub const CHECKSUM_GEN_ICMP6: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP6: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const LWIP_IPV6: u32 = 0;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const LWIP_IPV6_FORWARD: u32 = 0;
pub const LWIP_IPV6_FRAG: u32 = 0;
pub const LWIP_IPV6_REASS: u32 = 0;
pub const LWIP_IPV6_SEND_ROUTER_SOLICIT: u32 = 1;
pub const LWIP_IPV6_AUTOCONFIG: u32 = 0;
pub const LWIP_IPV6_DUP_DETECT_ATTEMPTS: u32 = 1;
pub const LWIP_ICMP6: u32 = 0;
pub const LWIP_ICMP6_DATASIZE: u32 = 8;
pub const LWIP_ICMP6_HL: u32 = 255;
pub const LWIP_IPV6_MLD: u32 = 0;
pub const MEMP_NUM_MLD6_GROUP: u32 = 4;
pub const LWIP_ND6_QUEUEING: u32 = 0;
pub const MEMP_NUM_ND6_QUEUE: u32 = 20;
pub const LWIP_ND6_NUM_NEIGHBORS: u32 = 10;
pub const LWIP_ND6_NUM_DESTINATIONS: u32 = 10;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 5;
pub const LWIP_ND6_NUM_ROUTERS: u32 = 3;
pub const LWIP_ND6_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_UNICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const LWIP_ND6_REACHABLE_TIME: u32 = 30000;
pub const LWIP_ND6_RETRANS_TIMER: u32 = 1000;
pub const LWIP_ND6_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const LWIP_ND6_ALLOW_RA_UPDATES: u32 = 1;
pub const LWIP_ND6_TCP_REACHABILITY_HINTS: u32 = 1;
pub const LWIP_ND6_RDNSS_MAX_DNS_SERVERS: u32 = 0;
pub const LWIP_IPV6_DHCP6: u32 = 0;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const LWIP_DBG_TYPES_ON: u32 = 128;
pub const ETHARP_DEBUG: u32 = 0;
pub const NETIF_DEBUG: u32 = 0;
pub const PBUF_DEBUG: u32 = 0;
pub const API_LIB_DEBUG: u32 = 0;
pub const API_MSG_DEBUG: u32 = 0;
pub const SOCKETS_DEBUG: u32 = 0;
pub const ICMP_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const IP_DEBUG: u32 = 0;
pub const IP_REASS_DEBUG: u32 = 0;
pub const RAW_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const MEMP_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const TCP_DEBUG: u32 = 0;
pub const TCP_INPUT_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_OUTPUT_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const UDP_DEBUG: u32 = 0;
pub const TCPIP_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const DHCP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const DNS_DEBUG: u32 = 0;
pub const IP6_DEBUG: u32 = 0;
pub const LWIP_PERF: u32 = 0;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IP4ADDR_STRLEN_MAX: u32 = 16;
pub const IPADDR_STRLEN_MAX: u32 = 16;
pub const DHCPS_COARSE_TIMER_SECS: u32 = 1;
pub const DHCPS_MAX_LEASE: u32 = 100;
pub const DHCPS_LEASE_TIME_DEF: u32 = 120;
pub const DHCPS_LEASE_UNIT: u32 = 60;
pub const IPSTR: &'static [u8; 12usize] = b"%d.%d.%d.%d\0";
pub const IPV6STR: &'static [u8; 40usize] = b"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\0";
pub const ESP_ERR_TCPIP_ADAPTER_BASE: u32 = 20480;
pub const ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS: u32 = 20481;
pub const ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY: u32 = 20482;
pub const ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED: u32 = 20483;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED: u32 = 20484;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED: u32 = 20485;
pub const ESP_ERR_TCPIP_ADAPTER_NO_MEM: u32 = 20486;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_NOT_STOPPED: u32 = 20487;
pub const TCPIP_ADAPTER_TRHEAD_SAFE: u32 = 1;
pub const TCPIP_ADAPTER_IPC_LOCAL: u32 = 0;
pub const TCPIP_ADAPTER_IPC_REMOTE: u32 = 1;
pub const TCPIP_HOSTNAME_MAX_SIZE: u32 = 32;
pub const ESP_ERR_ESPNOW_BASE: u32 = 12388;
pub const ESP_ERR_ESPNOW_NOT_INIT: u32 = 12389;
pub const ESP_ERR_ESPNOW_ARG: u32 = 12390;
pub const ESP_ERR_ESPNOW_NO_MEM: u32 = 12391;
pub const ESP_ERR_ESPNOW_FULL: u32 = 12392;
pub const ESP_ERR_ESPNOW_NOT_FOUND: u32 = 12393;
pub const ESP_ERR_ESPNOW_INTERNAL: u32 = 12394;
pub const ESP_ERR_ESPNOW_EXIST: u32 = 12395;
pub const ESP_ERR_ESPNOW_IF: u32 = 12396;
pub const ESP_NOW_ETH_ALEN: u32 = 6;
pub const ESP_NOW_KEY_LEN: u32 = 16;
pub const ESP_NOW_MAX_TOTAL_PEER_NUM: u32 = 20;
pub const ESP_NOW_MAX_ENCRYPT_PEER_NUM: u32 = 6;
pub const ESP_NOW_MAX_DATA_LEN: u32 = 250;
pub const PERIPHS_IO_MUX: u32 = 1610614784;
pub const PERIPHS_IO_MUX_FUNC: u32 = 19;
pub const PERIPHS_IO_MUX_FUNC_S: u32 = 4;
pub const PERIPHS_IO_MUX_PULLUP: u32 = 128;
pub const PERIPHS_IO_MUX_PULLDWN: u32 = 64;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP: u32 = 8;
pub const PERIPHS_IO_MUX_SLEEP_PULLDWN: u32 = 4;
pub const PERIPHS_IO_MUX_SLEEP_OE: u32 = 2;
pub const PERIPHS_IO_MUX_OE: u32 = 1;
pub const PERIPHS_IO_MUX_CONF_U: u32 = 1610614784;
pub const SPI0_CLK_EQU_SYS_CLK: u32 = 256;
pub const SPI1_CLK_EQU_SYS_CLK: u32 = 512;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610614788;
pub const FUNC_MTDI: u32 = 0;
pub const FUNC_I2SI_DATA: u32 = 1;
pub const FUNC_HSPIQ_MISO: u32 = 2;
pub const FUNC_GPIO12: u32 = 3;
pub const FUNC_UART0_DTR: u32 = 4;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610614792;
pub const FUNC_MTCK: u32 = 0;
pub const FUNC_I2SI_BCK: u32 = 1;
pub const FUNC_HSPID_MOSI: u32 = 2;
pub const FUNC_GPIO13: u32 = 3;
pub const FUNC_UART0_CTS: u32 = 4;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610614796;
pub const FUNC_MTMS: u32 = 0;
pub const FUNC_I2SI_WS: u32 = 1;
pub const FUNC_HSPI_CLK: u32 = 2;
pub const FUNC_GPIO14: u32 = 3;
pub const FUNC_UART0_DSR: u32 = 4;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610614800;
pub const FUNC_MTDO: u32 = 0;
pub const FUNC_I2SO_BCK: u32 = 1;
pub const FUNC_HSPI_CS0: u32 = 2;
pub const FUNC_GPIO15: u32 = 3;
pub const FUNC_U0RTS: u32 = 4;
pub const FUNC_UART0_RTS: u32 = 4;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610614804;
pub const FUNC_U0RXD: u32 = 0;
pub const FUNC_I2SO_DATA: u32 = 1;
pub const FUNC_GPIO3: u32 = 3;
pub const FUNC_CLK_XTAL_BK: u32 = 4;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610614808;
pub const FUNC_U0TXD: u32 = 0;
pub const FUNC_SPICS1: u32 = 1;
pub const FUNC_GPIO1: u32 = 3;
pub const FUNC_CLK_RTC_BK: u32 = 4;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1610614812;
pub const FUNC_SDCLK: u32 = 0;
pub const FUNC_SPICLK: u32 = 1;
pub const FUNC_GPIO6: u32 = 3;
pub const UART1_CTS: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1610614816;
pub const FUNC_SDDATA0: u32 = 0;
pub const FUNC_SPIQ_MISO: u32 = 1;
pub const FUNC_GPIO7: u32 = 3;
pub const FUNC_U1TXD: u32 = 4;
pub const FUNC_UART1_TXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1610614820;
pub const FUNC_SDDATA1: u32 = 0;
pub const FUNC_SPID_MOSI: u32 = 1;
pub const FUNC_GPIO8: u32 = 3;
pub const FUNC_U1RXD: u32 = 4;
pub const FUNC_UART1_RXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1610614824;
pub const FUNC_SDDATA2: u32 = 0;
pub const FUNC_SPIHD: u32 = 1;
pub const FUNC_GPIO9: u32 = 3;
pub const UFNC_HSPIHD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1610614828;
pub const FUNC_SDDATA3: u32 = 0;
pub const FUNC_SPIWP: u32 = 1;
pub const FUNC_GPIO10: u32 = 3;
pub const FUNC_HSPIWP: u32 = 4;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1610614832;
pub const FUNC_SDCMD: u32 = 0;
pub const FUNC_SPICS0: u32 = 1;
pub const FUNC_GPIO11: u32 = 3;
pub const U1RTS: u32 = 4;
pub const UART1_RTS: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1610614836;
pub const FUNC_GPIO0: u32 = 0;
pub const FUNC_SPICS2: u32 = 1;
pub const FUNC_CLK_OUT: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610614840;
pub const FUNC_GPIO2: u32 = 0;
pub const FUNC_I2SO_WS: u32 = 1;
pub const FUNC_U1TXD_BK: u32 = 2;
pub const FUNC_UART1_TXD_BK: u32 = 2;
pub const FUNC_U0TXD_BK: u32 = 4;
pub const FUNC_UART0_TXD_BK: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1610614844;
pub const FUNC_GPIO4: u32 = 0;
pub const FUNC_CLK_XTAL: u32 = 1;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1610614848;
pub const FUNC_GPIO5: u32 = 0;
pub const FUNC_CLK_RTC: u32 = 1;
pub const PERIPHS_GPIO_BASEADDR: u32 = 1610613504;
pub const GPIO_OUT_ADDRESS: u32 = 0;
pub const GPIO_BT_SEL: u32 = 65535;
pub const GPIO_BT_SEL_S: u32 = 16;
pub const GPIO_OUT_DATA: u32 = 65535;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_ADDRESS: u32 = 4;
pub const GPIO_OUT_DATA_W1TS: u32 = 65535;
pub const GPIO_OUT_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_ADDRESS: u32 = 8;
pub const GPIO_OUT_DATA_W1TC: u32 = 65535;
pub const GPIO_OUT_DATA_W1TC_S: u32 = 0;
pub const GPIO_OUT_DATA_MASK: u32 = 65535;
pub const GPIO_ENABLE_ADDRESS: u32 = 12;
pub const GPIO_SDIO_SEL: u32 = 63;
pub const GPIO_SDIO_SEL_S: u32 = 16;
pub const GPIO_ENABLE_DATA: u32 = 65535;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_ADDRESS: u32 = 16;
pub const GPIO_ENABLE_DATA_W1TS: u32 = 65535;
pub const GPIO_ENABLE_DATA_W1TS_s: u32 = 0;
pub const GPIO_ENABLE_W1TC_ADDRESS: u32 = 20;
pub const GPIO_ENABLE_DATA_W1TC: u32 = 65535;
pub const GPIO_ENABLE_DATA_W1TC_S: u32 = 0;
pub const GPIO_ENABLE_DATA_DATA_MASK: u32 = 65535;
pub const GPIO_IN_ADDRESS: u32 = 24;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 16;
pub const GPIO_IN_DATA: u32 = 65535;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_STATUS_ADDRESS: u32 = 28;
pub const GPIO_STATUS_INTERRUPT: u32 = 65535;
pub const GPIO_STATUS_INTERRUPT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_ADDRESS: u32 = 32;
pub const GPIO_STATUS_INTERRUPT_W1TS: u32 = 65535;
pub const GPIO_STATUS_INTERRUPT_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_ADDRESS: u32 = 36;
pub const GPIO_STATUS_INTERRUPT_W1TC: u32 = 65535;
pub const GPIO_STATUS_INTERRUPT_W1TC_S: u32 = 0;
pub const GPIO_STATUS_INTERRUPT_DATA_MASK: u32 = 65535;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_ID_NONE: u32 = 4294967295;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_DRIVER_MASK: u32 = 4;
pub const GPIO_PIN_SOURCE_MSB: u32 = 0;
pub const GPIO_PIN_SOURCE_LSB: u32 = 0;
pub const GPIO_PIN_SOURCE_MASK: u32 = 1;
pub const GPIO_PIN0_ADDRESS: u32 = 40;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_DRIVER: u32 = 4;
pub const GPIO_PIN0_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_SOURCE: u32 = 1;
pub const GPIO_PIN0_SOURCE_S: u32 = 0;
pub const GPIO_PIN1_ADDRESS: u32 = 44;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_DRIVER: u32 = 4;
pub const GPIO_PIN1_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_SOURCE: u32 = 1;
pub const GPIO_PIN1_SOURCE_S: u32 = 0;
pub const GPIO_PIN2_ADDRESS: u32 = 48;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_DRIVER: u32 = 4;
pub const GPIO_PIN2_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_SOURCE: u32 = 1;
pub const GPIO_PIN2_SOURCE_S: u32 = 0;
pub const GPIO_PIN3_ADDRESS: u32 = 52;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_DRIVER: u32 = 4;
pub const GPIO_PIN3_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_SOURCE: u32 = 1;
pub const GPIO_PIN3_SOURCE_S: u32 = 0;
pub const GPIO_PIN4_ADDRESS: u32 = 56;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_DRIVER: u32 = 4;
pub const GPIO_PIN4_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_SOURCE: u32 = 1;
pub const GPIO_PIN4_SOURCE_S: u32 = 0;
pub const GPIO_PIN5_ADDRESS: u32 = 60;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_DRIVER: u32 = 4;
pub const GPIO_PIN5_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_SOURCE: u32 = 1;
pub const GPIO_PIN5_SOURCE_S: u32 = 0;
pub const GPIO_PIN6_ADDRESS: u32 = 64;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_DRIVER: u32 = 4;
pub const GPIO_PIN6_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_SOURCE: u32 = 1;
pub const GPIO_PIN6_SOURCE_S: u32 = 0;
pub const GPIO_PIN7_ADDRESS: u32 = 68;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_DRIVER: u32 = 4;
pub const GPIO_PIN7_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_SOURCE: u32 = 1;
pub const GPIO_PIN7_SOURCE_S: u32 = 0;
pub const GPIO_PIN8_ADDRESS: u32 = 72;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_DRIVER: u32 = 4;
pub const GPIO_PIN8_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_SOURCE: u32 = 1;
pub const GPIO_PIN8_SOURCE_S: u32 = 0;
pub const GPIO_PIN9_ADDRESS: u32 = 76;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_DRIVER: u32 = 4;
pub const GPIO_PIN9_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_SOURCE: u32 = 1;
pub const GPIO_PIN9_SOURCE_S: u32 = 0;
pub const GPIO_PIN10_ADDRESS: u32 = 80;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_DRIVER: u32 = 4;
pub const GPIO_PIN10_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_SOURCE: u32 = 1;
pub const GPIO_PIN10_SOURCE_S: u32 = 0;
pub const GPIO_PIN11_ADDRESS: u32 = 84;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_DRIVER: u32 = 4;
pub const GPIO_PIN11_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_SOURCE: u32 = 1;
pub const GPIO_PIN11_SOURCE_S: u32 = 0;
pub const GPIO_PIN12_ADDRESS: u32 = 88;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_DRIVER: u32 = 4;
pub const GPIO_PIN12_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_SOURCE: u32 = 1;
pub const GPIO_PIN12_SOURCE_S: u32 = 0;
pub const GPIO_PIN13_ADDRESS: u32 = 92;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_DRIVER: u32 = 4;
pub const GPIO_PIN13_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_SOURCE: u32 = 1;
pub const GPIO_PIN13_SOURCE_S: u32 = 0;
pub const GPIO_PIN14_ADDRESS: u32 = 96;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_DRIVER: u32 = 4;
pub const GPIO_PIN14_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_SOURCE: u32 = 1;
pub const GPIO_PIN14_SOURCE_S: u32 = 0;
pub const GPIO_PIN15_ADDRESS: u32 = 100;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_DRIVER: u32 = 4;
pub const GPIO_PIN15_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_SOURCE: u32 = 1;
pub const GPIO_PIN15_SOURCE_S: u32 = 0;
pub const GPIO_SIGMA_DELTA_ADDRESS: u32 = 104;
pub const SIGMA_DELTA_ENABLE: u32 = 65536;
pub const SIGMA_DELTA_ENABLE_S: u32 = 16;
pub const SIGMA_DELTA_PRESCALAR: u32 = 255;
pub const SIGMA_DELTA_PRESCALAR_S: u32 = 8;
pub const SIGMA_DELTA_TARGET: u32 = 255;
pub const SIGMA_DELTA_TARGET_S: u32 = 0;
pub const GPIO_RTC_CALIB_SYNC_ADDRESS: u32 = 108;
pub const RTC_CALIB_START: u32 = 2147483648;
pub const RTC_CALIB_START_S: u32 = 31;
pub const RTC_PERIOD_NUM: u32 = 1023;
pub const RTC_PERIOD_NUM_S: u32 = 0;
pub const GPIO_RTC_CALIB_VALUE_ADDRESS: u32 = 112;
pub const RTC_CALIB_RDY: u32 = 2147483648;
pub const RTC_CALIB_RDY_S: u32 = 31;
pub const RTC_CALIB_RDY_REAL: u32 = 1073741824;
pub const RTC_CALIB_RDY_REAL_S: u32 = 30;
pub const RTC_CALIB_VALUE: u32 = 1048575;
pub const RTC_CALIB_VALUE_S: u32 = 0;
pub const GPIO_Pin_All: u32 = 131071;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_PIN_COUNT: u32 = 17;
pub const CMD_T_ASYNC: u32 = 1;
pub const CMD_T_SYNC: u32 = 2;
pub const MAX_LINE_N: u32 = 127;
pub const ESP_ERR_NVS_BASE: u32 = 4352;
pub const ESP_ERR_NVS_NOT_INITIALIZED: u32 = 4353;
pub const ESP_ERR_NVS_NOT_FOUND: u32 = 4354;
pub const ESP_ERR_NVS_TYPE_MISMATCH: u32 = 4355;
pub const ESP_ERR_NVS_READ_ONLY: u32 = 4356;
pub const ESP_ERR_NVS_NOT_ENOUGH_SPACE: u32 = 4357;
pub const ESP_ERR_NVS_INVALID_NAME: u32 = 4358;
pub const ESP_ERR_NVS_INVALID_HANDLE: u32 = 4359;
pub const ESP_ERR_NVS_REMOVE_FAILED: u32 = 4360;
pub const ESP_ERR_NVS_KEY_TOO_LONG: u32 = 4361;
pub const ESP_ERR_NVS_PAGE_FULL: u32 = 4362;
pub const ESP_ERR_NVS_INVALID_STATE: u32 = 4363;
pub const ESP_ERR_NVS_INVALID_LENGTH: u32 = 4364;
pub const ESP_ERR_NVS_NO_FREE_PAGES: u32 = 4365;
pub const ESP_ERR_NVS_VALUE_TOO_LONG: u32 = 4366;
pub const ESP_ERR_NVS_PART_NOT_FOUND: u32 = 4367;
pub const NVS_DEFAULT_PART_NAME: &'static [u8; 4usize] = b"nvs\0";
pub const TIMER_BASE_CLK: u32 = 80000000;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const portNUM_PROCESSORS: u32 = 1;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 1;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configUSE_TICKLESS_IDLE: u32 = 1;
pub const configMAX_PRIORITIES: u32 = 15;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_xTimerGetTimerDaemonTaskHandle: u32 = 1;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 255;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 191;
pub const configLIBRARY_KERNEL_INTERRUPT_PRIORITY: u32 = 15;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 1;
pub const configIDLE_TASK_STACK_SIZE: u32 = 1024;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const XTHAL_RELEASE_MAJOR: u32 = 8000;
pub const XTHAL_RELEASE_MINOR: u32 = 1;
pub const XTHAL_RELEASE_NAME: &'static [u8; 6usize] = b"8.0.1\0";
pub const XTHAL_REL_8: u32 = 1;
pub const XTHAL_REL_8_0: u32 = 1;
pub const XTHAL_REL_8_0_1: u32 = 1;
pub const XTHAL_MAJOR_REV: u32 = 8000;
pub const XTHAL_MINOR_REV: u32 = 1;
pub const XTHAL_MAYBE: i32 = -1;
pub const XTHAL_MAX_CPS: u32 = 8;
pub const XTHAL_LITTLEENDIAN: u32 = 0;
pub const XTHAL_BIGENDIAN: u32 = 1;
pub const XTHAL_PREFETCH_ENABLE: i32 = -1;
pub const XTHAL_PREFETCH_DISABLE: u32 = 0;
pub const XTHAL_DISASM_BUFSIZE: u32 = 80;
pub const XTHAL_DISASM_OPT_ADDR: u32 = 1;
pub const XTHAL_DISASM_OPT_OPHEX: u32 = 2;
pub const XTHAL_DISASM_OPT_OPCODE: u32 = 4;
pub const XTHAL_DISASM_OPT_PARMS: u32 = 8;
pub const XTHAL_DISASM_OPT_ALL: u32 = 4095;
pub const XTHAL_MAX_INTERRUPTS: u32 = 32;
pub const XTHAL_MAX_INTLEVELS: u32 = 16;
pub const XTHAL_MAX_TIMERS: u32 = 4;
pub const XTHAL_INTTYPE_UNCONFIGURED: u32 = 0;
pub const XTHAL_INTTYPE_SOFTWARE: u32 = 1;
pub const XTHAL_INTTYPE_EXTERN_EDGE: u32 = 2;
pub const XTHAL_INTTYPE_EXTERN_LEVEL: u32 = 3;
pub const XTHAL_INTTYPE_TIMER: u32 = 4;
pub const XTHAL_INTTYPE_NMI: u32 = 5;
pub const XTHAL_INTTYPE_WRITE_ERROR: u32 = 6;
pub const XTHAL_MAX_INTTYPES: u32 = 7;
pub const XTHAL_TIMER_UNCONFIGURED: i32 = -1;
pub const XTHAL_TIMER_UNASSIGNED: i32 = -1;
pub const XTHAL_MEMEP_PARITY: u32 = 1;
pub const XTHAL_MEMEP_ECC: u32 = 2;
pub const XTHAL_MEMEP_F_LOCAL: u32 = 0;
pub const XTHAL_MEMEP_F_DCACHE_DATA: u32 = 4;
pub const XTHAL_MEMEP_F_DCACHE_TAG: u32 = 5;
pub const XTHAL_MEMEP_F_ICACHE_DATA: u32 = 6;
pub const XTHAL_MEMEP_F_ICACHE_TAG: u32 = 7;
pub const XTHAL_MEMEP_F_CORRECTABLE: u32 = 16;
pub const XTHAL_AMB_EXCEPTION: u32 = 0;
pub const XTHAL_AMB_HITCACHE: u32 = 1;
pub const XTHAL_AMB_ALLOCATE: u32 = 2;
pub const XTHAL_AMB_WRITETHRU: u32 = 3;
pub const XTHAL_AMB_ISOLATE: u32 = 4;
pub const XTHAL_AMB_GUARD: u32 = 5;
pub const XTHAL_AMB_COHERENT: u32 = 6;
pub const XTHAL_AM_EXCEPTION: u32 = 1;
pub const XTHAL_AM_HITCACHE: u32 = 2;
pub const XTHAL_AM_ALLOCATE: u32 = 4;
pub const XTHAL_AM_WRITETHRU: u32 = 8;
pub const XTHAL_AM_ISOLATE: u32 = 16;
pub const XTHAL_AM_GUARD: u32 = 32;
pub const XTHAL_AM_COHERENT: u32 = 64;
pub const XTHAL_FAM_EXCEPTION: u32 = 1;
pub const XTHAL_FAM_BYPASS: u32 = 0;
pub const XTHAL_FAM_CACHED: u32 = 6;
pub const XTHAL_LAM_EXCEPTION: u32 = 1;
pub const XTHAL_LAM_ISOLATE: u32 = 18;
pub const XTHAL_LAM_BYPASS: u32 = 0;
pub const XTHAL_LAM_BYPASSG: u32 = 32;
pub const XTHAL_LAM_CACHED_NOALLOC: u32 = 2;
pub const XTHAL_LAM_NACACHED: u32 = 2;
pub const XTHAL_LAM_NACACHEDG: u32 = 34;
pub const XTHAL_LAM_CACHED: u32 = 6;
pub const XTHAL_LAM_COHCACHED: u32 = 70;
pub const XTHAL_SAM_EXCEPTION: u32 = 1;
pub const XTHAL_SAM_ISOLATE: u32 = 50;
pub const XTHAL_SAM_BYPASS: u32 = 40;
pub const XTHAL_SAM_WRITETHRU: u32 = 42;
pub const XTHAL_SAM_WRITEBACK: u32 = 38;
pub const XTHAL_SAM_COHWRITEBACK: u32 = 102;
pub const XTHAL_SAM_WRITEBACK_NOALLOC: u32 = 34;
pub const XTHAL_CAFLAG_EXPAND: u32 = 256;
pub const XTHAL_CAFLAG_EXACT: u32 = 512;
pub const XTHAL_CAFLAG_NO_PARTIAL: u32 = 1024;
pub const XTHAL_CAFLAG_NO_AUTO_WB: u32 = 2048;
pub const XTHAL_CAFLAG_NO_AUTO_INV: u32 = 4096;
pub const XCHAL_CA_BYPASS: u32 = 2;
pub const XCHAL_CA_WRITETHRU: u32 = 2;
pub const XCHAL_CA_WRITEBACK: u32 = 2;
pub const XCHAL_CA_WRITEBACK_NOALLOC: u32 = 2;
pub const XCHAL_CA_BYPASS_RW: u32 = 0;
pub const XCHAL_CA_WRITETHRU_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC_RW: u32 = 0;
pub const XCHAL_CA_ILLEGAL: u32 = 15;
pub const XCHAL_CA_ISOLATE: u32 = 0;
pub const XCHAL_MMU_ASID_INVALID: u32 = 0;
pub const XCHAL_MMU_ASID_KERNEL: u32 = 0;
pub const XCHAL_MMU_SR_BITS: u32 = 0;
pub const XCHAL_MMU_CA_BITS: u32 = 4;
pub const XCHAL_MMU_MAX_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_MMU_MIN_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_ITLB_WAY_BITS: u32 = 0;
pub const XCHAL_ITLB_WAYS: u32 = 1;
pub const XCHAL_ITLB_ARF_WAYS: u32 = 0;
pub const XCHAL_ITLB_SETS: u32 = 1;
pub const XCHAL_ITLB_WAY0_SET: u32 = 0;
pub const XCHAL_ITLB_ARF_SETS: u32 = 0;
pub const XCHAL_ITLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_ITLB_SET0_WAY: u32 = 0;
pub const XCHAL_ITLB_SET0_WAYS: u32 = 1;
pub const XCHAL_ITLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_ITLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_ITLB_SET0_ARF: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_ITLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_ITLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_ITLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_WAY_BITS: u32 = 0;
pub const XCHAL_DTLB_WAYS: u32 = 1;
pub const XCHAL_DTLB_ARF_WAYS: u32 = 0;
pub const XCHAL_DTLB_SETS: u32 = 1;
pub const XCHAL_DTLB_WAY0_SET: u32 = 0;
pub const XCHAL_DTLB_ARF_SETS: u32 = 0;
pub const XCHAL_DTLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_DTLB_SET0_WAY: u32 = 0;
pub const XCHAL_DTLB_SET0_WAYS: u32 = 1;
pub const XCHAL_DTLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_DTLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_DTLB_SET0_ARF: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_DTLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_DTLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_DTLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_CP_NUM: u32 = 0;
pub const XCHAL_CP_MAX: u32 = 0;
pub const XCHAL_CP_MASK: u32 = 0;
pub const XCHAL_CP_PORT_MASK: u32 = 0;
pub const XCHAL_NCP_SA_SIZE: u32 = 0;
pub const XCHAL_NCP_SA_ALIGN: u32 = 1;
pub const XCHAL_TOTAL_SA_SIZE: u32 = 0;
pub const XCHAL_TOTAL_SA_ALIGN: u32 = 1;
pub const XCHAL_NCP_SA_NUM: u32 = 0;
pub const XCHAL_CP0_SA_NUM: u32 = 0;
pub const XCHAL_CP1_SA_NUM: u32 = 0;
pub const XCHAL_CP2_SA_NUM: u32 = 0;
pub const XCHAL_CP3_SA_NUM: u32 = 0;
pub const XCHAL_CP4_SA_NUM: u32 = 0;
pub const XCHAL_CP5_SA_NUM: u32 = 0;
pub const XCHAL_CP6_SA_NUM: u32 = 0;
pub const XCHAL_CP7_SA_NUM: u32 = 0;
pub const XCHAL_HAVE_LE: u32 = 1;
pub const XCHAL_MEMORY_ORDER: u32 = 0;
pub const XCHAL_HAVE_HIGHLEVEL_INTERRUPTS: u32 = 1;
pub const XCHAL_NUM_LOWPRI_LEVELS: u32 = 1;
pub const XCHAL_FIRST_HIGHPRI_LEVEL: u32 = 2;
pub const XCHAL_INTLEVEL0_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_MASK: u32 = 0;
pub const XCHAL_INTLEVEL9_MASK: u32 = 0;
pub const XCHAL_INTLEVEL10_MASK: u32 = 0;
pub const XCHAL_INTLEVEL11_MASK: u32 = 0;
pub const XCHAL_INTLEVEL12_MASK: u32 = 0;
pub const XCHAL_INTLEVEL13_MASK: u32 = 0;
pub const XCHAL_INTLEVEL14_MASK: u32 = 0;
pub const XCHAL_INTLEVEL15_MASK: u32 = 0;
pub const XCHAL_INTLEVEL0_ANDBELOW_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL9_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL10_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL11_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL12_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL13_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL14_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL15_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_LOWPRI_MASK: u32 = 16383;
pub const XCHAL_INTCLEARABLE_MASK: u32 = 16256;
pub const XCHAL_INTSETTABLE_MASK: u32 = 128;
pub const XCHAL_INT15_LEVEL: u32 = 0;
pub const XCHAL_INT15_TYPE: u32 = 0;
pub const XCHAL_INT16_LEVEL: u32 = 0;
pub const XCHAL_INT16_TYPE: u32 = 0;
pub const XCHAL_INT17_LEVEL: u32 = 0;
pub const XCHAL_INT17_TYPE: u32 = 0;
pub const XCHAL_INT18_LEVEL: u32 = 0;
pub const XCHAL_INT18_TYPE: u32 = 0;
pub const XCHAL_INT19_LEVEL: u32 = 0;
pub const XCHAL_INT19_TYPE: u32 = 0;
pub const XCHAL_INT20_LEVEL: u32 = 0;
pub const XCHAL_INT20_TYPE: u32 = 0;
pub const XCHAL_INT21_LEVEL: u32 = 0;
pub const XCHAL_INT21_TYPE: u32 = 0;
pub const XCHAL_INT22_LEVEL: u32 = 0;
pub const XCHAL_INT22_TYPE: u32 = 0;
pub const XCHAL_INT23_LEVEL: u32 = 0;
pub const XCHAL_INT23_TYPE: u32 = 0;
pub const XCHAL_INT24_LEVEL: u32 = 0;
pub const XCHAL_INT24_TYPE: u32 = 0;
pub const XCHAL_INT25_LEVEL: u32 = 0;
pub const XCHAL_INT25_TYPE: u32 = 0;
pub const XCHAL_INT26_LEVEL: u32 = 0;
pub const XCHAL_INT26_TYPE: u32 = 0;
pub const XCHAL_INT27_LEVEL: u32 = 0;
pub const XCHAL_INT27_TYPE: u32 = 0;
pub const XCHAL_INT28_LEVEL: u32 = 0;
pub const XCHAL_INT28_TYPE: u32 = 0;
pub const XCHAL_INT29_LEVEL: u32 = 0;
pub const XCHAL_INT29_TYPE: u32 = 0;
pub const XCHAL_INT30_LEVEL: u32 = 0;
pub const XCHAL_INT30_TYPE: u32 = 0;
pub const XCHAL_INT31_LEVEL: u32 = 0;
pub const XCHAL_INT31_TYPE: u32 = 0;
pub const XCHAL_EXTINT0_MASK: u32 = 1;
pub const XCHAL_EXTINT1_MASK: u32 = 2;
pub const XCHAL_EXTINT2_MASK: u32 = 4;
pub const XCHAL_EXTINT3_MASK: u32 = 8;
pub const XCHAL_EXTINT4_MASK: u32 = 16;
pub const XCHAL_EXTINT5_MASK: u32 = 32;
pub const XCHAL_EXTINT6_MASK: u32 = 256;
pub const XCHAL_EXTINT7_MASK: u32 = 512;
pub const XCHAL_EXTINT8_MASK: u32 = 1024;
pub const XCHAL_EXTINT9_MASK: u32 = 2048;
pub const XCHAL_EXTINT10_MASK: u32 = 4096;
pub const XCHAL_EXTINT11_MASK: u32 = 8192;
pub const XCHAL_EXTINT12_MASK: u32 = 16384;
pub const XCHAL_HAVE_OLD_EXC_ARCH: u32 = 0;
pub const XCHAL_HAVE_EXCM: u32 = 1;
pub const XCHAL_PROGRAMEXC_VECTOR_VADDR: u32 = 1073741904;
pub const XCHAL_USEREXC_VECTOR_VADDR: u32 = 1073741904;
pub const XCHAL_PROGRAMEXC_VECTOR_PADDR: u32 = 1073741904;
pub const XCHAL_USEREXC_VECTOR_PADDR: u32 = 1073741904;
pub const XCHAL_STACKEDEXC_VECTOR_VADDR: u32 = 1073741872;
pub const XCHAL_KERNELEXC_VECTOR_VADDR: u32 = 1073741872;
pub const XCHAL_STACKEDEXC_VECTOR_PADDR: u32 = 1073741872;
pub const XCHAL_KERNELEXC_VECTOR_PADDR: u32 = 1073741872;
pub const XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION: u32 = 0;
pub const XCHAL_EXCCAUSE_SYSTEM_CALL: u32 = 1;
pub const XCHAL_EXCCAUSE_INSTRUCTION_FETCH_ERROR: u32 = 2;
pub const XCHAL_EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const XCHAL_EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const XCHAL_EXCCAUSE_ALLOCA: u32 = 5;
pub const XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO: u32 = 6;
pub const XCHAL_EXCCAUSE_SPECULATION: u32 = 7;
pub const XCHAL_EXCCAUSE_PRIVILEGED: u32 = 8;
pub const XCHAL_EXCCAUSE_UNALIGNED: u32 = 9;
pub const XCHAL_EXCCAUSE_ITLB_MISS: u32 = 16;
pub const XCHAL_EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const XCHAL_EXCCAUSE_ITLB_PRIVILEGE: u32 = 18;
pub const XCHAL_EXCCAUSE_ITLB_SIZE_RESTRICTION: u32 = 19;
pub const XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE: u32 = 20;
pub const XCHAL_EXCCAUSE_DTLB_MISS: u32 = 24;
pub const XCHAL_EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const XCHAL_EXCCAUSE_DTLB_PRIVILEGE: u32 = 26;
pub const XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION: u32 = 27;
pub const XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE: u32 = 28;
pub const XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE: u32 = 29;
pub const XCHAL_EXCCAUSE_COPROCESSOR0_DISABLED: u32 = 32;
pub const XCHAL_EXCCAUSE_COPROCESSOR1_DISABLED: u32 = 33;
pub const XCHAL_EXCCAUSE_COPROCESSOR2_DISABLED: u32 = 34;
pub const XCHAL_EXCCAUSE_COPROCESSOR3_DISABLED: u32 = 35;
pub const XCHAL_EXCCAUSE_COPROCESSOR4_DISABLED: u32 = 36;
pub const XCHAL_EXCCAUSE_COPROCESSOR5_DISABLED: u32 = 37;
pub const XCHAL_EXCCAUSE_COPROCESSOR6_DISABLED: u32 = 38;
pub const XCHAL_EXCCAUSE_COPROCESSOR7_DISABLED: u32 = 39;
pub const XCHAL_EXCCAUSE_FLOATING_POINT: u32 = 40;
pub const XCHAL_DBREAKC_VALIDMASK: u32 = 3221225535;
pub const XCHAL_DBREAKC_MASK_BITS: u32 = 6;
pub const XCHAL_DBREAKC_MASK_NUM: u32 = 64;
pub const XCHAL_DBREAKC_MASK_SHIFT: u32 = 0;
pub const XCHAL_DBREAKC_MASK_MASK: u32 = 63;
pub const XCHAL_DBREAKC_LOADBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_LOADBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const XCHAL_DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const XCHAL_DBREAKC_STOREBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_STOREBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const XCHAL_DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const XCHAL_PS_VALIDMASK: u32 = 462655;
pub const XCHAL_PS_INTLEVEL_BITS: u32 = 4;
pub const XCHAL_PS_INTLEVEL_NUM: u32 = 16;
pub const XCHAL_PS_INTLEVEL_SHIFT: u32 = 0;
pub const XCHAL_PS_INTLEVEL_MASK: u32 = 15;
pub const XCHAL_PS_EXCM_BITS: u32 = 1;
pub const XCHAL_PS_EXCM_NUM: u32 = 2;
pub const XCHAL_PS_EXCM_SHIFT: u32 = 4;
pub const XCHAL_PS_EXCM_MASK: u32 = 16;
pub const XCHAL_PS_UM_BITS: u32 = 1;
pub const XCHAL_PS_UM_NUM: u32 = 2;
pub const XCHAL_PS_UM_SHIFT: u32 = 5;
pub const XCHAL_PS_UM_MASK: u32 = 32;
pub const XCHAL_PS_RING_BITS: u32 = 2;
pub const XCHAL_PS_RING_NUM: u32 = 4;
pub const XCHAL_PS_RING_SHIFT: u32 = 6;
pub const XCHAL_PS_RING_MASK: u32 = 192;
pub const XCHAL_PS_OWB_BITS: u32 = 4;
pub const XCHAL_PS_OWB_NUM: u32 = 16;
pub const XCHAL_PS_OWB_SHIFT: u32 = 8;
pub const XCHAL_PS_OWB_MASK: u32 = 3840;
pub const XCHAL_PS_CALLINC_BITS: u32 = 2;
pub const XCHAL_PS_CALLINC_NUM: u32 = 4;
pub const XCHAL_PS_CALLINC_SHIFT: u32 = 16;
pub const XCHAL_PS_CALLINC_MASK: u32 = 196608;
pub const XCHAL_PS_WOE_BITS: u32 = 1;
pub const XCHAL_PS_WOE_NUM: u32 = 2;
pub const XCHAL_PS_WOE_SHIFT: u32 = 18;
pub const XCHAL_PS_WOE_MASK: u32 = 262144;
pub const XCHAL_EXCCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_EXCCAUSE_BITS: u32 = 6;
pub const XCHAL_EXCCAUSE_NUM: u32 = 64;
pub const XCHAL_EXCCAUSE_SHIFT: u32 = 0;
pub const XCHAL_EXCCAUSE_MASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_ICOUNT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_ICOUNT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const XCHAL_DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const XCHAL_DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const XCHAL_DEBUGCAUSE_BREAKN_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAKN_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const XCHAL_NUM_IROM: u32 = 1;
pub const XCHAL_NUM_IRAM: u32 = 2;
pub const XCHAL_NUM_DROM: u32 = 1;
pub const XCHAL_NUM_DRAM: u32 = 2;
pub const XCHAL_IROM0_VADDR: u32 = 1075838976;
pub const XCHAL_IROM0_PADDR: u32 = 1075838976;
pub const XCHAL_IROM0_SIZE: u32 = 1048576;
pub const XCHAL_IRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_SIZE: u32 = 1048576;
pub const XCHAL_IRAM1_VADDR: u32 = 1074790400;
pub const XCHAL_IRAM1_PADDR: u32 = 1074790400;
pub const XCHAL_IRAM1_SIZE: u32 = 1048576;
pub const XCHAL_DROM0_VADDR: u32 = 1072955392;
pub const XCHAL_DROM0_PADDR: u32 = 1072955392;
pub const XCHAL_DROM0_SIZE: u32 = 262144;
pub const XCHAL_DRAM0_VADDR: u32 = 1073479680;
pub const XCHAL_DRAM0_PADDR: u32 = 1073479680;
pub const XCHAL_DRAM0_SIZE: u32 = 262144;
pub const XCHAL_DRAM1_VADDR: u32 = 1073217536;
pub const XCHAL_DRAM1_PADDR: u32 = 1073217536;
pub const XCHAL_DRAM1_SIZE: u32 = 262144;
pub const XCHAL_CACHE_PREFCTL_DEFAULT: u32 = 68;
pub const XCHAL_CACHE_LINEWIDTH_MAX: u32 = 2;
pub const XCHAL_CACHE_LINESIZE_MAX: u32 = 4;
pub const XCHAL_ICACHE_SETSIZE: u32 = 1;
pub const XCHAL_DCACHE_SETSIZE: u32 = 1;
pub const XCHAL_CACHE_SETWIDTH_MAX: u32 = 0;
pub const XCHAL_CACHE_SETSIZE_MAX: u32 = 1;
pub const XCHAL_ICACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_V: u32 = 1;
pub const XCHAL_ICACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_F: u32 = 0;
pub const XCHAL_ICACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_L: u32 = 0;
pub const XCHAL_DCACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_V: u32 = 1;
pub const XCHAL_DCACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_F: u32 = 0;
pub const XCHAL_DCACHE_TAG_D_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_D: u32 = 0;
pub const XCHAL_DCACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_L: u32 = 0;
pub const XCHAL_ALIGN_MAX: u32 = 4;
pub const XCHAL_HW_RELEASE_MAJOR: u32 = 2300;
pub const XCHAL_HW_RELEASE_MINOR: u32 = 1;
pub const XCHAL_HW_RELEASE_NAME: &'static [u8; 8usize] = b"LX3.0.1\0";
pub const XCHAL_EXTRA_SA_SIZE: u32 = 0;
pub const XCHAL_EXTRA_SA_ALIGN: u32 = 1;
pub const XCHAL_CPEXTRA_SA_SIZE: u32 = 0;
pub const XCHAL_CPEXTRA_SA_ALIGN: u32 = 1;
pub const XCHAL_CP0_NAME: u32 = 0;
pub const XCHAL_CP0_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP1_NAME: u32 = 0;
pub const XCHAL_CP1_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP2_NAME: u32 = 0;
pub const XCHAL_CP2_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP3_NAME: u32 = 0;
pub const XCHAL_CP3_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP4_NAME: u32 = 0;
pub const XCHAL_CP4_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP5_NAME: u32 = 0;
pub const XCHAL_CP5_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP6_NAME: u32 = 0;
pub const XCHAL_CP6_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP7_NAME: u32 = 0;
pub const XCHAL_CP7_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP0_SA_SIZE: u32 = 0;
pub const XCHAL_CP0_SA_ALIGN: u32 = 1;
pub const XCHAL_CP1_SA_SIZE: u32 = 0;
pub const XCHAL_CP1_SA_ALIGN: u32 = 1;
pub const XCHAL_CP2_SA_SIZE: u32 = 0;
pub const XCHAL_CP2_SA_ALIGN: u32 = 1;
pub const XCHAL_CP3_SA_SIZE: u32 = 0;
pub const XCHAL_CP3_SA_ALIGN: u32 = 1;
pub const XCHAL_CP4_SA_SIZE: u32 = 0;
pub const XCHAL_CP4_SA_ALIGN: u32 = 1;
pub const XCHAL_CP5_SA_SIZE: u32 = 0;
pub const XCHAL_CP5_SA_ALIGN: u32 = 1;
pub const XCHAL_CP6_SA_SIZE: u32 = 0;
pub const XCHAL_CP6_SA_ALIGN: u32 = 1;
pub const XCHAL_CP7_SA_SIZE: u32 = 0;
pub const XCHAL_CP7_SA_ALIGN: u32 = 1;
pub const XCHAL_CPEXTRA_SA_SIZE_TOR2: u32 = 0;
pub const XCHAL_INST_ILLN: u32 = 61549;
pub const XCHAL_INST_ILLN_BYTE0: u32 = 109;
pub const XCHAL_INST_ILLN_BYTE1: u32 = 240;
pub const XTHAL_INST_ILL: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_SHIFT: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_MASK: u32 = 63;
pub const EXCCAUSE_ILLEGAL: u32 = 0;
pub const EXCCAUSE_SYSCALL: u32 = 1;
pub const EXCCAUSE_INSTR_ERROR: u32 = 2;
pub const EXCCAUSE_IFETCHERROR: u32 = 2;
pub const EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const EXCCAUSE_LOADSTOREERROR: u32 = 3;
pub const EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const EXCCAUSE_LEVEL1INTERRUPT: u32 = 4;
pub const EXCCAUSE_ALLOCA: u32 = 5;
pub const EXCCAUSE_DIVIDE_BY_ZERO: u32 = 6;
pub const EXCCAUSE_SPECULATION: u32 = 7;
pub const EXCCAUSE_PRIVILEGED: u32 = 8;
pub const EXCCAUSE_UNALIGNED: u32 = 9;
pub const EXCCAUSE_INSTR_DATA_ERROR: u32 = 12;
pub const EXCCAUSE_LOAD_STORE_DATA_ERROR: u32 = 13;
pub const EXCCAUSE_INSTR_ADDR_ERROR: u32 = 14;
pub const EXCCAUSE_LOAD_STORE_ADDR_ERROR: u32 = 15;
pub const EXCCAUSE_ITLB_MISS: u32 = 16;
pub const EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const EXCCAUSE_INSTR_RING: u32 = 18;
pub const EXCCAUSE_INSTR_PROHIBITED: u32 = 20;
pub const EXCCAUSE_DTLB_MISS: u32 = 24;
pub const EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const EXCCAUSE_LOAD_STORE_RING: u32 = 26;
pub const EXCCAUSE_LOAD_PROHIBITED: u32 = 28;
pub const EXCCAUSE_STORE_PROHIBITED: u32 = 29;
pub const EXCCAUSE_CP0_DISABLED: u32 = 32;
pub const EXCCAUSE_CP1_DISABLED: u32 = 33;
pub const EXCCAUSE_CP2_DISABLED: u32 = 34;
pub const EXCCAUSE_CP3_DISABLED: u32 = 35;
pub const EXCCAUSE_CP4_DISABLED: u32 = 36;
pub const EXCCAUSE_CP5_DISABLED: u32 = 37;
pub const EXCCAUSE_CP6_DISABLED: u32 = 38;
pub const EXCCAUSE_CP7_DISABLED: u32 = 39;
pub const PS_WOE_SHIFT: u32 = 18;
pub const PS_WOE_MASK: u32 = 262144;
pub const PS_WOE: u32 = 262144;
pub const PS_CALLINC_SHIFT: u32 = 16;
pub const PS_CALLINC_MASK: u32 = 196608;
pub const PS_OWB_SHIFT: u32 = 8;
pub const PS_OWB_MASK: u32 = 3840;
pub const PS_RING_SHIFT: u32 = 6;
pub const PS_RING_MASK: u32 = 192;
pub const PS_UM_SHIFT: u32 = 5;
pub const PS_UM_MASK: u32 = 32;
pub const PS_UM: u32 = 32;
pub const PS_EXCM_SHIFT: u32 = 4;
pub const PS_EXCM_MASK: u32 = 16;
pub const PS_EXCM: u32 = 16;
pub const PS_INTLEVEL_SHIFT: u32 = 0;
pub const PS_INTLEVEL_MASK: u32 = 15;
pub const PS_PROGSTACK_SHIFT: u32 = 5;
pub const PS_PROGSTACK_MASK: u32 = 32;
pub const PS_PROG_SHIFT: u32 = 5;
pub const PS_PROG_MASK: u32 = 32;
pub const PS_PROG: u32 = 32;
pub const DBREAKC_MASK_SHIFT: u32 = 0;
pub const DBREAKC_MASK_MASK: u32 = 63;
pub const DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const MESR_MEME: u32 = 1;
pub const MESR_MEME_SHIFT: u32 = 0;
pub const MESR_DME: u32 = 2;
pub const MESR_DME_SHIFT: u32 = 1;
pub const MESR_RCE: u32 = 16;
pub const MESR_RCE_SHIFT: u32 = 4;
pub const MESR_ERRENAB: u32 = 256;
pub const MESR_ERRENAB_SHIFT: u32 = 8;
pub const MESR_ERRTEST: u32 = 512;
pub const MESR_ERRTEST_SHIFT: u32 = 9;
pub const MESR_DATEXC: u32 = 1024;
pub const MESR_DATEXC_SHIFT: u32 = 10;
pub const MESR_INSEXC: u32 = 2048;
pub const MESR_INSEXC_SHIFT: u32 = 11;
pub const MESR_WAYNUM_SHIFT: u32 = 16;
pub const MESR_ACCTYPE_SHIFT: u32 = 20;
pub const MESR_MEMTYPE_SHIFT: u32 = 24;
pub const MESR_ERRTYPE_SHIFT: u32 = 30;
pub const SAR: u32 = 3;
pub const LITBASE: u32 = 5;
pub const IBREAKENABLE: u32 = 96;
pub const DDR: u32 = 104;
pub const IBREAKA_0: u32 = 128;
pub const DBREAKA_0: u32 = 144;
pub const DBREAKC_0: u32 = 160;
pub const EPC_1: u32 = 177;
pub const EPC_2: u32 = 178;
pub const EPC_3: u32 = 179;
pub const DEPC: u32 = 192;
pub const EPS_2: u32 = 194;
pub const EPS_3: u32 = 195;
pub const EXCSAVE_1: u32 = 209;
pub const EXCSAVE_2: u32 = 210;
pub const EXCSAVE_3: u32 = 211;
pub const INTERRUPT: u32 = 226;
pub const INTENABLE: u32 = 228;
pub const PS: u32 = 230;
pub const VECBASE: u32 = 231;
pub const EXCCAUSE: u32 = 232;
pub const DEBUGCAUSE: u32 = 233;
pub const CCOUNT: u32 = 234;
pub const PRID: u32 = 235;
pub const ICOUNT: u32 = 236;
pub const ICOUNTLEVEL: u32 = 237;
pub const EXCVADDR: u32 = 238;
pub const CCOMPARE_0: u32 = 240;
pub const IBREAKA: u32 = 128;
pub const DBREAKA: u32 = 144;
pub const DBREAKC: u32 = 160;
pub const EPC: u32 = 176;
pub const EPS: u32 = 192;
pub const EXCSAVE: u32 = 208;
pub const CCOMPARE: u32 = 240;
pub const INTREAD: u32 = 226;
pub const INTSET: u32 = 226;
pub const INTCLEAR: u32 = 227;
pub const XSHAL_USE_ABSOLUTE_LITERALS: u32 = 0;
pub const XTHAL_ABI_WINDOWED: u32 = 0;
pub const XTHAL_ABI_CALL0: u32 = 1;
pub const XTHAL_CLIB_NEWLIB: u32 = 0;
pub const XTHAL_CLIB_UCLIBC: u32 = 1;
pub const XSHAL_USE_FLOATING_POINT: u32 = 1;
pub const XSHAL_IOBLOCK_CACHED_VADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_PADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_SIZE: u32 = 234881024;
pub const XSHAL_IOBLOCK_BYPASS_VADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_PADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_SIZE: u32 = 234881024;
pub const XSHAL_ROM_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_PADDR: u32 = 1342177280;
pub const XSHAL_ROM_SIZE: u32 = 16777216;
pub const XSHAL_ROM_AVAIL_VADDR: u32 = 1342178048;
pub const XSHAL_ROM_AVAIL_VSIZE: u32 = 16776448;
pub const XSHAL_RAM_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_PADDR: u32 = 1610612736;
pub const XSHAL_RAM_VSIZE: u32 = 67108864;
pub const XSHAL_RAM_PSIZE: u32 = 67108864;
pub const XSHAL_RAM_SIZE: u32 = 67108864;
pub const XSHAL_RAM_AVAIL_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_AVAIL_VSIZE: u32 = 67108864;
pub const XSHAL_RAM_BYPASS_VADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PSIZE: u32 = 67108864;
pub const XSHAL_SIMIO_CACHED_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_BYPASS_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_PADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_SIZE: u32 = 536870912;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEBACK: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEALLOC: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITETHRU: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_BYPASS: u32 = 572662306;
pub const XSHAL_ALLVALID_CACHEATTR_DEFAULT: u32 = 572657938;
pub const XSHAL_STRICT_CACHEATTR_WRITEBACK: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITEALLOC: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITETHRU: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_BYPASS: u32 = 4294910511;
pub const XSHAL_STRICT_CACHEATTR_DEFAULT: u32 = 4294906143;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_TRAPNULL_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_ISS_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_PIPE_REGIONS: u32 = 0;
pub const XSHAL_ISS_SDRAM_REGIONS: u32 = 0;
pub const XSHAL_XT2000_CACHEATTR_WRITEBACK: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITEALLOC: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITETHRU: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_BYPASS: u32 = 4280427055;
pub const XSHAL_XT2000_CACHEATTR_DEFAULT: u32 = 4280422687;
pub const XSHAL_XT2000_PIPE_REGIONS: u32 = 0;
pub const XSHAL_XT2000_SDRAM_REGIONS: u32 = 1088;
pub const XSHAL_VECTORS_PACKED: u32 = 0;
pub const XSHAL_STATIC_VECTOR_SELECT: u32 = 0;
pub const XSHAL_RESET_VECTOR_VADDR: u32 = 1342177280;
pub const XSHAL_RESET_VECTOR_PADDR: u32 = 1342177280;
pub const XSHAL_RESET_VECTOR_SIZE: u32 = 768;
pub const XSHAL_RESET_VECTOR_ISROM: u32 = 1;
pub const XSHAL_USER_VECTOR_SIZE: u32 = 28;
pub const XSHAL_USER_VECTOR_ISROM: u32 = 0;
pub const XSHAL_PROGRAMEXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_USEREXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_KERNEL_VECTOR_SIZE: u32 = 28;
pub const XSHAL_KERNEL_VECTOR_ISROM: u32 = 0;
pub const XSHAL_STACKEDEXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_KERNELEXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_DOUBLEEXC_VECTOR_SIZE: u32 = 16;
pub const XSHAL_DOUBLEEXC_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL2_VECTOR_SIZE: u32 = 12;
pub const XSHAL_INTLEVEL2_VECTOR_ISROM: u32 = 0;
pub const XSHAL_DEBUG_VECTOR_SIZE: u32 = 12;
pub const XSHAL_DEBUG_VECTOR_ISROM: u32 = 0;
pub const XSHAL_NMI_VECTOR_SIZE: u32 = 12;
pub const XSHAL_NMI_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL3_VECTOR_SIZE: u32 = 12;
pub const SYS_nop: u32 = 0;
pub const SYS_exit: u32 = 1;
pub const SYS_fork: u32 = 2;
pub const SYS_read: u32 = 3;
pub const SYS_write: u32 = 4;
pub const SYS_open: u32 = 5;
pub const SYS_close: u32 = 6;
pub const SYS_rename: u32 = 7;
pub const SYS_creat: u32 = 8;
pub const SYS_link: u32 = 9;
pub const SYS_unlink: u32 = 10;
pub const SYS_execv: u32 = 11;
pub const SYS_execve: u32 = 12;
pub const SYS_pipe: u32 = 13;
pub const SYS_stat: u32 = 14;
pub const SYS_chmod: u32 = 15;
pub const SYS_chown: u32 = 16;
pub const SYS_utime: u32 = 17;
pub const SYS_wait: u32 = 18;
pub const SYS_lseek: u32 = 19;
pub const SYS_getpid: u32 = 20;
pub const SYS_isatty: u32 = 21;
pub const SYS_fstat: u32 = 22;
pub const SYS_time: u32 = 23;
pub const SYS_gettimeofday: u32 = 24;
pub const SYS_times: u32 = 25;
pub const SYS_socket: u32 = 26;
pub const SYS_sendto: u32 = 27;
pub const SYS_recvfrom: u32 = 28;
pub const SYS_select_one: u32 = 29;
pub const SYS_bind: u32 = 30;
pub const SYS_ioctl: u32 = 31;
pub const SYS_iss_argc: u32 = 1000;
pub const SYS_iss_argv_size: u32 = 1001;
pub const SYS_iss_set_argv: u32 = 1002;
pub const SYS_memset: u32 = 1004;
pub const SYS_ferret: u32 = 1010;
pub const SYS_malloc: u32 = 1011;
pub const SYS_free: u32 = 1012;
pub const SYS_more_heap: u32 = 1013;
pub const SYS_no_heap: u32 = 1014;
pub const SYS_enter_ferret: u32 = 1015;
pub const SYS_leave_ferret: u32 = 1016;
pub const SYS_profile_enable: u32 = 1020;
pub const SYS_profile_disable: u32 = 1021;
pub const SYS_trace_level: u32 = 1022;
pub const SYS_client_command: u32 = 1023;
pub const SYS_sim_mode_switch: u32 = 1030;
pub const SYS_event_fire: u32 = 1040;
pub const SYS_event_stall: u32 = 1041;
pub const SYS_callback_first: u32 = 100;
pub const SYS_callback_last: u32 = 999;
pub const SYS_user_simcall: u32 = 100;
pub const SYS_xmpa_errinfo: u32 = 200;
pub const SYS_xmpa_proc_status: u32 = 201;
pub const SYS_xmpa_proc_start: u32 = 202;
pub const SYS_xmpa_proc_stop: u32 = 203;
pub const SYS_xmpa_proc_mem_read: u32 = 204;
pub const SYS_xmpa_proc_mem_write: u32 = 205;
pub const SYS_xmpa_proc_mem_fill: u32 = 206;
pub const SYS_xmpa_proc_reg_read: u32 = 207;
pub const SYS_xmpa_proc_reg_write: u32 = 208;
pub const SYS_gdb_break: i32 = -1;
pub const SYS_xmon_out: i32 = -2;
pub const SYS_xmon_in: i32 = -3;
pub const SYS_xmon_flush: i32 = -4;
pub const SYS_gdb_abort: i32 = -5;
pub const SYS_gdb_illegal_inst: i32 = -6;
pub const SYS_xmon_init: i32 = -7;
pub const SYS_gdb_enter_sktloop: i32 = -8;
pub const SYS_unhandled_kernel_exc: i32 = -9;
pub const SYS_unhandled_user_exc: i32 = -10;
pub const SYS_unhandled_double_exc: i32 = -11;
pub const SYS_unhandled_highpri_interrupt: i32 = -12;
pub const SYS_setup_ppp_pipes: i32 = -83;
pub const SYS_log_msg: i32 = -84;
pub const XTISS_SELECT_ONE_READ: u32 = 1;
pub const XTISS_SELECT_ONE_WRITE: u32 = 2;
pub const XTISS_SELECT_ONE_EXCEPT: u32 = 3;
pub const SYS_client: u32 = 3235826430;
pub const XT_INTEXC_HOOK_NUM: u32 = 4;
pub const XT_STK_EXIT: u32 = 0;
pub const XT_STK_PC: u32 = 4;
pub const XT_STK_PS: u32 = 8;
pub const XT_STK_A0: u32 = 12;
pub const XT_STK_A1: u32 = 16;
pub const XT_STK_A2: u32 = 20;
pub const XT_STK_A3: u32 = 24;
pub const XT_STK_A4: u32 = 28;
pub const XT_STK_A5: u32 = 32;
pub const XT_STK_A6: u32 = 36;
pub const XT_STK_A7: u32 = 40;
pub const XT_STK_A8: u32 = 44;
pub const XT_STK_A9: u32 = 48;
pub const XT_STK_A10: u32 = 52;
pub const XT_STK_A11: u32 = 56;
pub const XT_STK_A12: u32 = 60;
pub const XT_STK_A13: u32 = 64;
pub const XT_STK_A14: u32 = 68;
pub const XT_STK_A15: u32 = 72;
pub const XT_STK_SAR: u32 = 76;
pub const XT_STK_EXCCAUSE: u32 = 80;
pub const XT_STK_NEXT1: u32 = 80;
pub const XT_STK_NEXT2: u32 = 80;
pub const XT_STK_N_TMP: u32 = 3;
pub const XT_STK_TMP: u32 = 80;
pub const XT_STK_NEXT3: u32 = 92;
pub const XT_SOL_EXIT: u32 = 0;
pub const XT_SOL_PC: u32 = 4;
pub const XT_SOL_PS: u32 = 8;
pub const XT_SOL_NEXT: u32 = 12;
pub const XT_CP_SIZE: u32 = 0;
pub const XT_TIMER_INDEX: u32 = 0;
pub const XT_CCOMPARE: u32 = 240;
pub const XT_TICK_PER_SEC: u32 = 100;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 4;
pub const portBYTE_ALIGNMENT_MASK: u32 = 3;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const pvMALLOC_DRAM: u32 = 14;
pub const pvMALLOC_IRAM: u32 = 2;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const INCLUDE_xTaskAbortDelay: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const INCLUDE_xTaskGetHandle: u32 = 0;
pub const INCLUDE_eTaskGetState: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const configASSERT_DEFINED: u32 = 0;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_QUEUE_SETS: u32 = 0;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 0;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 0;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const IR_RX_NEC_BIT_NUM: u32 = 8;
pub const IR_RX_NEC_HEADER_US: u32 = 13500;
pub const IR_RX_NEC_DATA0_US: u32 = 1120;
pub const IR_RX_NEC_DATA1_US: u32 = 2250;
pub const IR_RX_NEC_TM1_REP_US: u32 = 20000;
pub const IR_RX_NEC_TM2_REP_US: u32 = 11250;
pub const IR_RX_ERROR_US: u32 = 200;
pub const IR_TX_NEC_BIT_NUM: u32 = 8;
pub const IR_TX_NEC_HEADER_HIGH_US: u32 = 9000;
pub const IR_TX_NEC_HEADER_LOW_US: u32 = 4500;
pub const IR_TX_NEC_DATA_HIGH_US: u32 = 560;
pub const IR_TX_NEC_DATA_LOW_1_US: u32 = 1690;
pub const IR_TX_NEC_DATA_LOW_0_US: u32 = 560;
pub const IR_TX_NEC_REP_HIGH_US: u32 = 9000;
pub const IR_TX_NEC_REP_LOW_US: u32 = 2250;
pub const IR_TX_NEC_REP_STOP_US: u32 = 562;
pub const IR_TX_NEC_REP_CYCLE: u32 = 108000;
pub const IR_TX_WDEV_TIMER_ERROR_US: u32 = 5;
pub const IR_TX_HW_TIMER_ERROR_US: u32 = 40;
pub const PERIPH_LEDC_MODULE: u32 = 0;
pub const LEDC_APB_CLK_HZ: u32 = 80000000;
pub const LEDC_REF_CLK_HZ: u32 = 1000000;
pub const LEDC_ERR_DUTY: u32 = 4294967295;
pub const LEDC_ERR_VAL: i32 = -1;
pub const SPI_NUM_MAX: u32 = 2;
pub const SPI_CPOL_LOW: u32 = 0;
pub const SPI_CPOL_HIGH: u32 = 1;
pub const SPI_CPHA_LOW: u32 = 0;
pub const SPI_CPHA_HIGH: u32 = 1;
pub const SPI_BIT_ORDER_MSB_FIRST: u32 = 1;
pub const SPI_BIT_ORDER_LSB_FIRST: u32 = 0;
pub const SPI_BYTE_ORDER_MSB_FIRST: u32 = 1;
pub const SPI_BYTE_ORDER_LSB_FIRST: u32 = 0;
pub const SPI_DEFAULT_INTERFACE: u32 = 448;
pub const SPI_MASTER_DEFAULT_INTR_ENABLE: u32 = 16;
pub const SPI_SLAVE_DEFAULT_INTR_ENABLE: u32 = 15;
pub const SPI_INIT_EVENT: u32 = 0;
pub const SPI_TRANS_START_EVENT: u32 = 1;
pub const SPI_TRANS_DONE_EVENT: u32 = 2;
pub const SPI_DEINIT_EVENT: u32 = 3;
pub const SPI_MASTER_WRITE_DATA_TO_SLAVE_CMD: u32 = 2;
pub const SPI_MASTER_READ_DATA_FROM_SLAVE_CMD: u32 = 3;
pub const SPI_MASTER_WRITE_STATUS_TO_SLAVE_CMD: u32 = 1;
pub const SPI_MASTER_READ_STATUS_FROM_SLAVE_CMD: u32 = 4;
pub const LOG_LOCAL_LEVEL: u32 = 3;
pub const LOG_COLOR_BLACK: &'static [u8; 3usize] = b"30\0";
pub const LOG_COLOR_RED: &'static [u8; 3usize] = b"31\0";
pub const LOG_COLOR_GREEN: &'static [u8; 3usize] = b"32\0";
pub const LOG_COLOR_BROWN: &'static [u8; 3usize] = b"33\0";
pub const LOG_COLOR_BLUE: &'static [u8; 3usize] = b"34\0";
pub const LOG_COLOR_PURPLE: &'static [u8; 3usize] = b"35\0";
pub const LOG_COLOR_CYAN: &'static [u8; 3usize] = b"36\0";
pub const LOG_RESET_COLOR: &'static [u8; 5usize] = b"\x1B[0m\0";
pub const UART_FIFO_LEN: u32 = 128;
pub const UART_INTR_MASK: u32 = 511;
pub const UART_LINE_INV_MASK: u32 = 33030144;
pub const UART_INVERSE_DISABLE: u32 = 0;
pub type __int8_t = c_types::c_schar;
pub type __uint8_t = c_types::c_uchar;
pub type __int16_t = c_types::c_short;
pub type __uint16_t = c_types::c_ushort;
pub type __int32_t = c_types::c_int;
pub type __uint32_t = c_types::c_uint;
pub type __int64_t = c_types::c_longlong;
pub type __uint64_t = c_types::c_ulonglong;
pub type __int_least8_t = c_types::c_schar;
pub type __uint_least8_t = c_types::c_uchar;
pub type __int_least16_t = c_types::c_short;
pub type __uint_least16_t = c_types::c_ushort;
pub type __int_least32_t = c_types::c_int;
pub type __uint_least32_t = c_types::c_uint;
pub type __int_least64_t = c_types::c_longlong;
pub type __uint_least64_t = c_types::c_ulonglong;
pub type __intmax_t = c_types::c_longlong;
pub type __uintmax_t = c_types::c_ulonglong;
pub type __intptr_t = c_types::c_int;
pub type __uintptr_t = c_types::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = c_types::c_schar;
pub type uint_fast8_t = c_types::c_uchar;
pub type int_fast16_t = c_types::c_short;
pub type uint_fast16_t = c_types::c_ushort;
pub type int_fast32_t = c_types::c_int;
pub type uint_fast32_t = c_types::c_uint;
pub type int_fast64_t = c_types::c_longlong;
pub type uint_fast64_t = c_types::c_ulonglong;
pub type size_t = c_types::c_uint;
pub type wchar_t = c_types::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: c_types::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type _lock_t = c_types::c_int;
pub type _LOCK_RECURSIVE_T = _lock_t;
pub type _LOCK_T = _lock_t;
extern "C" {
    pub fn _lock_init(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_acquire_recursive(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_try_acquire(lock: *mut _lock_t) -> c_types::c_int;
}
extern "C" {
    pub fn _lock_try_acquire_recursive(lock: *mut _lock_t) -> c_types::c_int;
}
extern "C" {
    pub fn _lock_release(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release_recursive(lock: *mut _lock_t);
}
pub type __blkcnt_t = c_types::c_long;
pub type __blksize_t = c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = c_types::c_long;
pub type __pid_t = c_types::c_int;
pub type __dev_t = c_types::c_short;
pub type __uid_t = c_types::c_ushort;
pub type __gid_t = c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = c_types::c_long;
pub type _fpos_t = c_types::c_long;
pub type __size_t = c_types::c_uint;
pub type _ssize_t = c_types::c_int;
pub type __ssize_t = _ssize_t;
pub type wint_t = c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [c_types::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut c_types::c_void;
pub type __clock_t = c_types::c_ulong;
pub type __time_t = c_types::c_long;
pub type __clockid_t = c_types::c_ulong;
pub type __timer_t = c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = c_types::c_ushort;
pub type __suseconds_t = c_types::c_long;
pub type __useconds_t = c_types::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: c_types::c_int,
    pub _maxwds: c_types::c_int,
    pub _sign: c_types::c_int,
    pub _wds: c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: c_types::c_int,
    pub __tm_min: c_types::c_int,
    pub __tm_hour: c_types::c_int,
    pub __tm_mday: c_types::c_int,
    pub __tm_mon: c_types::c_int,
    pub __tm_year: c_types::c_int,
    pub __tm_wday: c_types::c_int,
    pub __tm_yday: c_types::c_int,
    pub __tm_isdst: c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut c_types::c_void; 32usize],
    pub _dso_handle: [*mut c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut c_types::c_uchar,
    pub _size: c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut c_types::c_uchar,
    pub _r: c_types::c_int,
    pub _w: c_types::c_int,
    pub _flags: c_types::c_short,
    pub _file: c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: c_types::c_int,
    pub _data: *mut _reent,
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut c_types::c_uchar,
    pub _r: c_types::c_int,
    pub _w: c_types::c_int,
    pub _flags: c_types::c_short,
    pub _file: c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut c_types::c_void,
            arg3: *mut c_types::c_char,
            arg4: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut c_types::c_void,
            arg3: *const c_types::c_char,
            arg4: c_types::c_int,
        ) -> c_types::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut c_types::c_void,
            arg3: _fpos_t,
            arg4: c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut c_types::c_void) -> c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut c_types::c_uchar,
    pub _ur: c_types::c_int,
    pub _ubuf: [c_types::c_uchar; 3usize],
    pub _nbuf: [c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: c_types::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: c_types::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [c_types::c_ushort; 3usize],
    pub _mult: [c_types::c_ushort; 3usize],
    pub _add: c_types::c_ushort,
    pub _rand_next: c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [c_types::c_char; 8usize],
    pub _getdate_err: c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: c_types::c_int,
    pub _emergency: *mut c_types::c_char,
    pub __sdidinit: c_types::c_int,
    pub _unspecified_locale_info: c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: c_types::c_int,
    pub _cvtlen: c_types::c_int,
    pub _cvtbuf: *mut c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut c_types::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: c_types::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut c_types::c_char,
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = c_types::c_int;
pub type __sigset_t = c_types::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = c_types::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: c_types::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type fd_mask = c_types::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: c_types::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn pselect(
        __n: c_types::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> c_types::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = c_types::c_uchar;
pub type u_short = c_types::c_ushort;
pub type u_int = c_types::c_uint;
pub type u_long = c_types::c_ulong;
pub type ushort = c_types::c_ushort;
pub type uint = c_types::c_uint;
pub type ulong = c_types::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = c_types::c_ulong;
pub type daddr_t = c_types::c_long;
pub type caddr_t = *mut c_types::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: c_types::c_int,
}
extern "C" {
    pub fn sched_yield() -> c_types::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: c_types::c_int,
    pub stackaddr: *mut c_types::c_void,
    pub stacksize: c_types::c_int,
    pub contentionscope: c_types::c_int,
    pub inheritsched: c_types::c_int,
    pub schedpolicy: c_types::c_int,
    pub schedparam: sched_param,
    pub detachstate: c_types::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: c_types::c_int,
    pub type_: c_types::c_int,
    pub recursive: c_types::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: c_types::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: c_types::c_int,
    pub init_executed: c_types::c_int,
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn printf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const c_types::c_char, arg2: __builtin_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut c_types::c_char,
        arg2: c_types::c_int,
        arg3: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn fputc(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const c_types::c_char, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar() -> c_types::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn putc(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn puts(arg1: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn ungetc(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut c_types::c_void,
        _size: c_types::c_uint,
        _n: c_types::c_uint,
        arg2: *mut FILE,
    ) -> c_types::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const c_types::c_void,
        _size: c_types::c_uint,
        _n: c_types::c_uint,
        arg2: *mut FILE,
    ) -> c_types::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: c_types::c_long, arg3: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> c_types::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn perror(arg1: *const c_types::c_char);
}
extern "C" {
    pub fn fopen(_name: *const c_types::c_char, _type: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut c_types::c_char, arg2: *const c_types::c_char, ...)
        -> c_types::c_int;
}
extern "C" {
    pub fn remove(arg1: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn rename(arg1: *const c_types::c_char, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut c_types::c_char,
        arg2: c_types::c_uint,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut c_types::c_char,
        arg2: c_types::c_uint,
        arg3: *const c_types::c_char,
        arg4: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const c_types::c_char, arg2: __builtin_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __builtin_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn diprintf(arg1: c_types::c_int, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut c_types::c_char,
        arg2: size_t,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: c_types::c_int,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const c_types::c_char, arg2: __gnuc_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const c_types::c_char, arg2: __gnuc_va_list) -> c_types::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut c_types::c_char,
        arg2: size_t,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fdopen(arg1: c_types::c_int, arg2: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn popen(arg1: *const c_types::c_char, arg2: *const c_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut c_types::c_char, arg3: c_types::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putw(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> c_types::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn dprintf(arg1: c_types::c_int, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut c_types::c_void,
        arg2: size_t,
        arg3: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut c_types::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: c_types::c_int,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: c_types::c_int,
        arg2: *const c_types::c_char,
        arg3: c_types::c_int,
        arg4: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> c_types::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> c_types::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        arg3: size_t,
        arg4: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: c_types::c_long,
        arg4: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> c_types::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> c_types::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const c_types::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *mut FILE,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const c_types::c_char,
        _new: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        ...
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *mut size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: size_t,
        arg4: *const c_types::c_char,
        arg5: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *const c_types::c_char,
        arg4: __gnuc_va_list,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: c_types::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut c_types::c_char,
        arg2: *mut size_t,
        arg3: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: c_types::c_int, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const c_types::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: c_types::c_int, arg3: *mut FILE) -> c_types::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *mut c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *const c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __off: fpos_t,
                __whence: c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut c_types::c_void) -> c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *mut c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __buf: *const c_types::c_char,
                __n: c_types::c_int,
            ) -> c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut c_types::c_void,
                __off: fpos_t,
                __whence: c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut c_types::c_void) -> c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __assert(
        arg1: *const c_types::c_char,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const c_types::c_char,
        arg2: c_types::c_int,
        arg3: *const c_types::c_char,
        arg4: *const c_types::c_char,
    );
}
pub type esp_err_t = i32;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table and"]
    #[doc = " returns its string representation."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table of"]
    #[doc = " esp_err_t errors and returns its string representation. If the error code"]
    #[doc = " is not found then it is attempted to be found among system errors."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @param[out] buf buffer where the error message should be written"]
    #[doc = " @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte)."]
    #[doc = " @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut c_types::c_char,
        buflen: size_t,
    ) -> *const c_types::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const c_types::c_char,
        line: c_types::c_int,
        function: *const c_types::c_char,
        expression: *const c_types::c_char,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const c_types::c_char,
        line: c_types::c_int,
        function: *const c_types::c_char,
        expression: *const c_types::c_char,
    );
}
extern "C" {
    #[doc = " Return full IDF version string, same as 'git describe' output."]
    #[doc = ""]
    #[doc = " @note If you are printing the ESP-IDF version in a log file or other information,"]
    #[doc = " this function provides more information than using the numerical version macros."]
    #[doc = " For example, numerical version macros don't differentiate between development,"]
    #[doc = " pre-release and release versions, but the output of this function does."]
    #[doc = ""]
    #[doc = " @return constant string from IDF_VER"]
    pub fn esp_get_idf_version() -> *const c_types::c_char;
}
pub const esp_mac_type_t_ESP_MAC_WIFI_STA: esp_mac_type_t = 0;
pub const esp_mac_type_t_ESP_MAC_WIFI_SOFTAP: esp_mac_type_t = 1;
pub type esp_mac_type_t = c_types::c_uint;
#[doc = "!< Reset reason can not be determined"]
pub const esp_reset_reason_t_ESP_RST_UNKNOWN: esp_reset_reason_t = 0;
#[doc = "!< Reset due to power-on event"]
pub const esp_reset_reason_t_ESP_RST_POWERON: esp_reset_reason_t = 1;
#[doc = "!< Reset by external pin (not applicable for ESP8266)"]
pub const esp_reset_reason_t_ESP_RST_EXT: esp_reset_reason_t = 2;
#[doc = "!< Software reset via esp_restart"]
pub const esp_reset_reason_t_ESP_RST_SW: esp_reset_reason_t = 3;
#[doc = "!< Software reset due to exception/panic"]
pub const esp_reset_reason_t_ESP_RST_PANIC: esp_reset_reason_t = 4;
#[doc = "!< Reset (software or hardware) due to interrupt watchdog"]
pub const esp_reset_reason_t_ESP_RST_INT_WDT: esp_reset_reason_t = 5;
#[doc = "!< Reset due to task watchdog"]
pub const esp_reset_reason_t_ESP_RST_TASK_WDT: esp_reset_reason_t = 6;
#[doc = "!< Reset due to other watchdogs"]
pub const esp_reset_reason_t_ESP_RST_WDT: esp_reset_reason_t = 7;
#[doc = "!< Reset after exiting deep sleep mode"]
pub const esp_reset_reason_t_ESP_RST_DEEPSLEEP: esp_reset_reason_t = 8;
#[doc = "!< Brownout reset (software or hardware)"]
pub const esp_reset_reason_t_ESP_RST_BROWNOUT: esp_reset_reason_t = 9;
#[doc = "!< Reset over SDIO"]
pub const esp_reset_reason_t_ESP_RST_SDIO: esp_reset_reason_t = 10;
#[doc = " @brief Reset reasons"]
pub type esp_reset_reason_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief  Set base MAC address with the MAC address which is stored in EFUSE or"]
    #[doc = "         external storage e.g. flash and EEPROM."]
    #[doc = ""]
    #[doc = " Base MAC address is used to generate the MAC addresses used by the networking interfaces."]
    #[doc = " If using base MAC address stored in EFUSE or external storage, call this API to set base MAC"]
    #[doc = " address with the MAC address which is stored in EFUSE or external storage before initializing"]
    #[doc = " WiFi."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_base_mac_addr_set(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is set using esp_base_mac_addr_set."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    #[doc = "         ESP_ERR_INVALID_MAC base MAC address has not been set"]
    pub fn esp_base_mac_addr_get(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is factory-programmed by Espressif in EFUSE."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_efuse_mac_get_default(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read base MAC address and set MAC address of the interface."]
    #[doc = ""]
    #[doc = " This function first get base MAC address using esp_base_mac_addr_get or reads base MAC address"]
    #[doc = " from EFUSE. Then set the MAC address of the interface including wifi station and wifi softap."]
    #[doc = ""]
    #[doc = " @param  mac  MAC address of the interface, length: 6 bytes."]
    #[doc = " @param  type  type of MAC address, 0:wifi station, 1:wifi softap."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_read_mac(mac: *mut u8, type_: esp_mac_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Derive local MAC address from universal MAC address."]
    #[doc = ""]
    #[doc = " This function derives a local MAC address from an universal MAC address."]
    #[doc = " A `definition of local vs universal MAC address can be found on Wikipedia"]
    #[doc = " <https://en.wikipedia.org/wiki/MAC_address#Universal_vs._local>`."]
    #[doc = " In ESP8266, universal MAC address is generated from base MAC address in EFUSE or other external storage."]
    #[doc = " Local MAC address is derived from the universal MAC address."]
    #[doc = ""]
    #[doc = " @param  local_mac  Derived local MAC address, length: 6 bytes."]
    #[doc = " @param  universal_mac  Source universal MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_derive_local_mac(local_mac: *mut u8, universal_mac: *const u8) -> esp_err_t;
}
#[doc = "!< 80 MHz"]
pub const esp_cpu_freq_t_ESP_CPU_FREQ_80M: esp_cpu_freq_t = 1;
#[doc = "!< 160 MHz"]
pub const esp_cpu_freq_t_ESP_CPU_FREQ_160M: esp_cpu_freq_t = 2;
#[doc = " @brief CPU frequency values"]
pub type esp_cpu_freq_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Switch CPU frequency"]
    #[doc = ""]
    #[doc = " If a PLL-derived frequency is requested (80, 160), this function"]
    #[doc = " will enable the PLL. Otherwise, PLL will be disabled."]
    #[doc = " Note: this function is not optimized for switching speed. It may take several"]
    #[doc = " hundred microseconds to perform frequency switch."]
    #[doc = ""]
    #[doc = " @param cpu_freq  new CPU frequency"]
    pub fn esp_set_cpu_freq(cpu_freq: esp_cpu_freq_t);
}
extern "C" {
    #[doc = " @brief  Reset to default settings."]
    pub fn system_restore();
}
extern "C" {
    #[doc = " @brief  Restart CPU."]
    #[doc = ""]
    #[doc = " This function does not return."]
    pub fn esp_restart();
}
extern "C" {
    #[doc = " @brief  Get reason of last reset"]
    #[doc = " @return See description of esp_reset_reason_t for explanation of each value."]
    pub fn esp_reset_reason() -> esp_reset_reason_t;
}
extern "C" {
    #[doc = " @brief  Get the size of available heap."]
    #[doc = ""]
    #[doc = " Note that the returned value may be larger than the maximum contiguous block"]
    #[doc = " which can be allocated."]
    #[doc = ""]
    #[doc = " @return Available heap size, in bytes."]
    pub fn esp_get_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief Get the minimum heap that has ever been available"]
    #[doc = ""]
    #[doc = " @return Minimum free heap ever available"]
    pub fn esp_get_minimum_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief  Get one random 32-bit word from hardware RNG"]
    #[doc = ""]
    #[doc = " @return Random value between 0 and UINT32_MAX"]
    pub fn esp_random() -> u32;
}
extern "C" {
    #[doc = " @brief Fill a buffer with random bytes from hardware RNG"]
    #[doc = ""]
    #[doc = " @note This function has the same restrictions regarding available entropy as esp_random()"]
    #[doc = ""]
    #[doc = " @param buf Pointer to buffer to fill with random numbers."]
    #[doc = " @param len Length of buffer in bytes"]
    pub fn esp_fill_random(buf: *mut c_types::c_void, len: size_t);
}
#[doc = "<  Flash size : 4Mbits. Map : 256KBytes + 256KBytes"]
pub const flash_size_map_FLASH_SIZE_4M_MAP_256_256: flash_size_map = 0;
#[doc = "<  Flash size : 2Mbits. Map : 256KBytes"]
pub const flash_size_map_FLASH_SIZE_2M: flash_size_map = 1;
#[doc = "<  Flash size : 8Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_8M_MAP_512_512: flash_size_map = 2;
#[doc = "<  Flash size : 16Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_16M_MAP_512_512: flash_size_map = 3;
#[doc = "<  Flash size : 32Mbits. Map : 512KBytes + 512KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_512_512: flash_size_map = 4;
#[doc = "<  Flash size : 16Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_16M_MAP_1024_1024: flash_size_map = 5;
#[doc = "<  Flash size : 32Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_1024_1024: flash_size_map = 6;
#[doc = "<  attention: don't support now ,just compatible for nodemcu;"]
#[doc = "Flash size : 32Mbits. Map : 2048KBytes + 2048KBytes"]
pub const flash_size_map_FLASH_SIZE_32M_MAP_2048_2048: flash_size_map = 7;
#[doc = "<  Flash size : 64Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_64M_MAP_1024_1024: flash_size_map = 8;
#[doc = "<  Flash size : 128Mbits. Map : 1024KBytes + 1024KBytes"]
pub const flash_size_map_FLASH_SIZE_128M_MAP_1024_1024: flash_size_map = 9;
pub const flash_size_map_FALSH_SIZE_MAP_MAX: flash_size_map = 10;
pub type flash_size_map = c_types::c_uint;
#[doc = "!< ESP8266"]
pub const esp_chip_model_t_CHIP_ESP8266: esp_chip_model_t = 0;
#[doc = "!< ESP32"]
pub const esp_chip_model_t_CHIP_ESP32: esp_chip_model_t = 1;
#[doc = " @brief Chip models"]
pub type esp_chip_model_t = c_types::c_uint;
#[doc = " @brief The structure represents information about the chip"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_chip_info_t {
    #[doc = "!< chip model, one of esp_chip_model_t"]
    pub model: esp_chip_model_t,
    #[doc = "!< bit mask of CHIP_FEATURE_x feature flags"]
    pub features: u32,
    #[doc = "!< number of CPU cores"]
    pub cores: u8,
    #[doc = "!< chip revision number"]
    pub revision: u8,
}
extern "C" {
    #[doc = " @brief Fill an esp_chip_info_t structure with information about the chip"]
    #[doc = " @param[out] out_info structure to be filled"]
    pub fn esp_chip_info(out_info: *mut esp_chip_info_t);
}
extern "C" {
    #[doc = " @brief  Get the current Flash size and Flash map."]
    #[doc = ""]
    #[doc = "         Flash map depends on the selection when compiling, more details in document"]
    #[doc = "         \"2A-ESP8266__IOT_SDK_User_Manual\""]
    #[doc = ""]
    #[doc = " @return enum flash_size_map"]
    pub fn system_get_flash_size_map() -> flash_size_map;
}
pub type esp_aio_cb_t =
    ::core::option::Option<unsafe extern "C" fn(aio: *mut esp_aio) -> c_types::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_aio {
    pub fd: c_types::c_int,
    pub pbuf: *const c_types::c_char,
    pub len: size_t,
    pub cb: esp_aio_cb_t,
    pub arg: *mut c_types::c_void,
    pub ret: c_types::c_int,
}
pub type esp_aio_t = esp_aio;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_aio_data {
    pub pbuf: *const c_types::c_char,
    pub len: size_t,
    pub status: c_types::c_int,
}
pub type esp_aio_data_t = esp_aio_data;
extern "C" {
    #[doc = " @brief Return current CPU clock frequency"]
    #[doc = " When frequency switching is performed, this frequency may change."]
    #[doc = " However it is guaranteed that the frequency never changes with a critical"]
    #[doc = " section."]
    #[doc = ""]
    #[doc = " @return CPU clock frequency, in Hz"]
    pub fn esp_clk_cpu_freq() -> c_types::c_int;
}
#[doc = "< ESP8266 station interface"]
pub const esp_interface_t_ESP_IF_WIFI_STA: esp_interface_t = 0;
#[doc = "< ESP8266 soft-AP interface"]
pub const esp_interface_t_ESP_IF_WIFI_AP: esp_interface_t = 1;
pub const esp_interface_t_ESP_IF_MAX: esp_interface_t = 2;
pub type esp_interface_t = c_types::c_uint;
pub type esp_tick_t = u32;
pub type esp_irqflag_t = u32;
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = c_types::c_uint;
extern "C" {
    pub fn vPortETSIntrLock();
}
extern "C" {
    pub fn vPortETSIntrUnlock();
}
extern "C" {
    #[doc = " @brief  Delay function, maximum value: 65535 us."]
    #[doc = ""]
    #[doc = " @param  uint16_t us : delay time, uint: us, maximum value: 65535 us"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_delay_us(us: u16);
}
extern "C" {
    #[doc = " @brief  CPU do while loop for some time."]
    #[doc = "         In FreeRTOS task, please call FreeRTOS apis."]
    #[doc = ""]
    #[doc = " @param  uint32_t us : Delay time in us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_delay_us(us: u32);
}
extern "C" {
    #[doc = " @brief  Printf the strings to uart or other devices, similar with printf, simple than printf."]
    #[doc = "         Can not print float point data format, or longlong data format."]
    #[doc = ""]
    #[doc = " @param  const char *fmt : See printf."]
    #[doc = ""]
    #[doc = " @param  ... : See printf."]
    #[doc = ""]
    #[doc = " @return int : the length printed to the output device."]
    pub fn ets_printf(fmt: *const c_types::c_char, ...) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief     Register the print output function."]
    #[doc = ""]
    #[doc = " @attention os_install_putc1((void *)uart1_write_char) in uart_init will set"]
    #[doc = "            printf to print from UART 1, otherwise, printf will start from"]
    #[doc = "            UART 0 by default."]
    #[doc = ""]
    #[doc = " @param     void(*p)(char c) - pointer of print function"]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn os_install_putc1(p: ::core::option::Option<unsafe extern "C" fn(c: c_types::c_char)>);
}
extern "C" {
    #[doc = " @brief  Print a character. Start from from UART0 by default."]
    #[doc = ""]
    #[doc = " @param  char c - character to be printed"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_putc(c: c_types::c_char);
}
pub type os_timer_func_t =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut c_types::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _os_timer_t {
    pub timer_next: *mut _os_timer_t,
    pub timer_handle: *mut c_types::c_void,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: os_timer_func_t,
    pub timer_repeat_flag: bool,
    pub timer_arg: *mut c_types::c_void,
}
pub type os_timer_t = _os_timer_t;
extern "C" {
    #[doc = " @brief     Set the timer callback function."]
    #[doc = ""]
    #[doc = " @attention 1. The callback function must be set in order to enable the timer."]
    #[doc = " @attention 2. Operating system scheduling is disabled in timer callback."]
    #[doc = ""]
    #[doc = " @param     os_timer_t *ptimer : Timer structure"]
    #[doc = " @param     os_timer_func_t *pfunction : timer callback function"]
    #[doc = " @param     void *parg : callback function parameter"]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn os_timer_setfn(
        ptimer: *mut os_timer_t,
        pfunction: os_timer_func_t,
        parg: *mut c_types::c_void,
    );
}
extern "C" {
    #[doc = " @brief  Enable the millisecond timer."]
    #[doc = ""]
    #[doc = " @param  os_timer_t *ptimer : timer structure"]
    #[doc = " @param  uint32_t milliseconds : Timing, unit: millisecond, range: 5 ~ 0x68DB8"]
    #[doc = " @param  bool repeat_flag : Whether the timer will be invoked repeatedly or not"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_timer_arm(ptimer: *mut os_timer_t, msec: u32, repeat_flag: bool);
}
extern "C" {
    #[doc = " @brief  Disarm the timer"]
    #[doc = ""]
    #[doc = " @param  os_timer_t *ptimer : Timer structure"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_timer_disarm(ptimer: *mut os_timer_t);
}
#[doc = " First type memory block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_blk {
    #[doc = "< Point to previous memory block"]
    pub prev: *mut mem_blk,
    #[doc = "< Point to next memory block"]
    pub next: *mut mem_blk,
}
#[doc = " First type memory block."]
pub type mem_blk_t = mem_blk;
#[doc = " Second type memory block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_blk2 {
    #[doc = "< Point to previous memory block"]
    pub prev: *mut mem_blk2,
    #[doc = "< Point to next memory block"]
    pub next: *mut mem_blk2,
    #[doc = "< Which \"file\" allocate the memory block"]
    pub file: *const c_types::c_char,
    #[doc = "< Which \"line\" allocate the memory block"]
    pub line: size_t,
}
#[doc = " Second type memory block."]
pub type mem2_blk_t = mem_blk2;
#[doc = " User region information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heap_region {
    #[doc = "< Heap region start address"]
    pub start_addr: *mut c_types::c_void,
    #[doc = "< Heap region total size by byte"]
    pub total_size: size_t,
    #[doc = "< Heap capacity"]
    pub caps: u32,
    #[doc = "< First free memory block"]
    pub free_blk: *mut c_types::c_void,
    #[doc = "< Current free heap size by byte"]
    pub free_bytes: size_t,
    #[doc = "< Minimum free heap size by byte ever"]
    pub min_free_bytes: size_t,
}
#[doc = " User region information."]
pub type heap_region_t = heap_region;
extern "C" {
    #[doc = " @brief Get the total free size of all the regions that have the given capabilities"]
    #[doc = ""]
    #[doc = " This function takes all regions capable of having the given capabilities allocated in them"]
    #[doc = " and adds up the free space they have."]
    #[doc = ""]
    #[doc = " @param caps Bitwise OR of MALLOC_CAP_* flags indicating the type of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the total minimum free memory of all regions with the given capabilities"]
    #[doc = ""]
    #[doc = " This adds all the low water marks of the regions capable of delivering the memory"]
    #[doc = " with the given capabilities."]
    #[doc = ""]
    #[doc = " @param caps Bitwise OR of MALLOC_CAP_* flags indicating the type of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Initialize regions of memory to the collection of heaps at runtime."]
    #[doc = ""]
    #[doc = " @param region region table head point"]
    #[doc = " @param max_num region table size"]
    pub fn esp_heap_caps_init_region(region: *mut heap_region_t, max_num: size_t);
}
extern "C" {
    pub fn _heap_caps_malloc(
        size: size_t,
        caps: u32,
        file: *const c_types::c_char,
        line: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _heap_caps_free(ptr: *mut c_types::c_void, file: *const c_types::c_char, line: size_t);
}
extern "C" {
    pub fn _heap_caps_calloc(
        count: size_t,
        size: size_t,
        caps: u32,
        file: *const c_types::c_char,
        line: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _heap_caps_realloc(
        mem: *mut c_types::c_void,
        newsize: size_t,
        caps: u32,
        file: *const c_types::c_char,
        line: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _heap_caps_zalloc(
        size: size_t,
        caps: u32,
        file: *const c_types::c_char,
        line: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn os_get_random(buf: *mut c_types::c_uchar, len: size_t) -> i32;
}
extern "C" {
    #[doc = " @brief  put a character to uart or other devices, similar with putc."]
    #[doc = ""]
    #[doc = " @param  c : a character."]
    #[doc = ""]
    #[doc = " @return int : the character written as an unsigned char cast to an int or EOF on error."]
    pub fn ets_putc(c: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief  Printf the strings to uart or other devices, similar with vprintf, simple than vprintf."]
    #[doc = "         Can not print float point data format, or longlong data format."]
    #[doc = ""]
    #[doc = " @param  const char *fmt : See vprintf."]
    #[doc = ""]
    #[doc = " @param  ap : parameter list, see vprintf."]
    #[doc = ""]
    #[doc = " @return int : the length printed to the output device."]
    pub fn ets_vprintf(fmt: *const c_types::c_char, ap: va_list) -> c_types::c_int;
}
#[doc = "< null mode"]
pub const wifi_mode_t_WIFI_MODE_NULL: wifi_mode_t = 0;
#[doc = "< WiFi station mode"]
pub const wifi_mode_t_WIFI_MODE_STA: wifi_mode_t = 1;
#[doc = "< WiFi soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_AP: wifi_mode_t = 2;
#[doc = "< WiFi station + soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_APSTA: wifi_mode_t = 3;
pub const wifi_mode_t_WIFI_MODE_MAX: wifi_mode_t = 4;
pub type wifi_mode_t = c_types::c_uint;
pub use self::esp_interface_t as wifi_interface_t;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_AUTO: wifi_country_policy_t = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_MANUAL: wifi_country_policy_t = 1;
pub type wifi_country_policy_t = c_types::c_uint;
#[doc = " @brief Structure describing WiFi country-based regional restrictions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< country code string"]
    pub cc: [c_types::c_char; 3usize],
    #[doc = "< start channel"]
    pub schan: u8,
    #[doc = "< total channel number"]
    pub nchan: u8,
    #[doc = "< maximum tx power"]
    pub max_tx_power: i8,
    #[doc = "< country policy"]
    pub policy: wifi_country_policy_t,
}
#[doc = "< authenticate mode : open"]
pub const wifi_auth_mode_t_WIFI_AUTH_OPEN: wifi_auth_mode_t = 0;
#[doc = "< authenticate mode : WEP"]
pub const wifi_auth_mode_t_WIFI_AUTH_WEP: wifi_auth_mode_t = 1;
#[doc = "< authenticate mode : WPA_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_PSK: wifi_auth_mode_t = 2;
#[doc = "< authenticate mode : WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_PSK: wifi_auth_mode_t = 3;
#[doc = "< authenticate mode : WPA_WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_WPA2_PSK: wifi_auth_mode_t = 4;
#[doc = "< authenticate mode : WPA2_ENTERPRISE"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_ENTERPRISE: wifi_auth_mode_t = 5;
pub const wifi_auth_mode_t_WIFI_AUTH_MAX: wifi_auth_mode_t = 6;
pub type wifi_auth_mode_t = c_types::c_uint;
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED: wifi_err_reason_t = 1;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_EXPIRE: wifi_err_reason_t = 2;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_LEAVE: wifi_err_reason_t = 3;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_EXPIRE: wifi_err_reason_t = 4;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_TOOMANY: wifi_err_reason_t = 5;
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHED: wifi_err_reason_t = 6;
pub const wifi_err_reason_t_WIFI_REASON_NOT_ASSOCED: wifi_err_reason_t = 7;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_LEAVE: wifi_err_reason_t = 8;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_NOT_AUTHED: wifi_err_reason_t = 9;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_PWRCAP_BAD: wifi_err_reason_t = 10;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_SUPCHAN_BAD: wifi_err_reason_t = 11;
pub const wifi_err_reason_t_WIFI_REASON_IE_INVALID: wifi_err_reason_t = 13;
pub const wifi_err_reason_t_WIFI_REASON_MIC_FAILURE: wifi_err_reason_t = 14;
pub const wifi_err_reason_t_WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 15;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT: wifi_err_reason_t = 16;
pub const wifi_err_reason_t_WIFI_REASON_IE_IN_4WAY_DIFFERS: wifi_err_reason_t = 17;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_CIPHER_INVALID: wifi_err_reason_t = 18;
pub const wifi_err_reason_t_WIFI_REASON_PAIRWISE_CIPHER_INVALID: wifi_err_reason_t = 19;
pub const wifi_err_reason_t_WIFI_REASON_AKMP_INVALID: wifi_err_reason_t = 20;
pub const wifi_err_reason_t_WIFI_REASON_UNSUPP_RSN_IE_VERSION: wifi_err_reason_t = 21;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_RSN_IE_CAP: wifi_err_reason_t = 22;
pub const wifi_err_reason_t_WIFI_REASON_802_1X_AUTH_FAILED: wifi_err_reason_t = 23;
pub const wifi_err_reason_t_WIFI_REASON_CIPHER_SUITE_REJECTED: wifi_err_reason_t = 24;
pub const wifi_err_reason_t_WIFI_REASON_BEACON_TIMEOUT: wifi_err_reason_t = 200;
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND: wifi_err_reason_t = 201;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_FAIL: wifi_err_reason_t = 202;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_FAIL: wifi_err_reason_t = 203;
pub const wifi_err_reason_t_WIFI_REASON_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 204;
pub const wifi_err_reason_t_WIFI_REASON_BASIC_RATE_NOT_SUPPORT: wifi_err_reason_t = 205;
pub type wifi_err_reason_t = c_types::c_uint;
#[doc = "< the channel width is HT20"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_NONE: wifi_second_chan_t = 0;
#[doc = "< the channel width is HT40 and the second channel is above the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_ABOVE: wifi_second_chan_t = 1;
#[doc = "< the channel width is HT40 and the second channel is below the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_BELOW: wifi_second_chan_t = 2;
pub type wifi_second_chan_t = c_types::c_uint;
#[doc = "< active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
pub type wifi_scan_type_t = c_types::c_uint;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< maximum active scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_scan_time_t {
    #[doc = "< active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< passive scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub passive: u32,
    _bindgen_union_align: [u32; 2usize],
}
#[doc = " @brief Parameters for an SSID scan."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_config_t {
    #[doc = "< SSID of AP"]
    pub ssid: *mut u8,
    #[doc = "< MAC address of AP"]
    pub bssid: *mut u8,
    #[doc = "< channel, scan the specific channel"]
    pub channel: u8,
    #[doc = "< enable to scan AP whose SSID is hidden"]
    pub show_hidden: bool,
    #[doc = "< scan type, active or passive"]
    pub scan_type: wifi_scan_type_t,
    #[doc = "< scan time per channel"]
    pub scan_time: wifi_scan_time_t,
}
#[doc = "< the cipher type is none"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_NONE: wifi_cipher_type_t = 0;
#[doc = "< the cipher type is WEP40"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP40: wifi_cipher_type_t = 1;
#[doc = "< the cipher type is WEP104"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP104: wifi_cipher_type_t = 2;
#[doc = "< the cipher type is TKIP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP: wifi_cipher_type_t = 3;
#[doc = "< the cipher type is CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_CCMP: wifi_cipher_type_t = 4;
#[doc = "< the cipher type is TKIP and CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP_CCMP: wifi_cipher_type_t = 5;
#[doc = "< the cipher type is unknown"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_UNKNOWN: wifi_cipher_type_t = 6;
pub type wifi_cipher_type_t = c_types::c_uint;
#[doc = "< WiFi antenna 0"]
pub const wifi_ant_t_WIFI_ANT_ANT0: wifi_ant_t = 0;
#[doc = "< WiFi antenna 1"]
pub const wifi_ant_t_WIFI_ANT_ANT1: wifi_ant_t = 1;
#[doc = "< Invalid WiFi antenna"]
pub const wifi_ant_t_WIFI_ANT_MAX: wifi_ant_t = 2;
pub type wifi_ant_t = c_types::c_uint;
#[doc = " @brief Description of a WiFi AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_record_t {
    #[doc = "< MAC address of AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 33usize],
    #[doc = "< channel of AP"]
    pub primary: u8,
    #[doc = "< secondary channel of AP"]
    pub second: wifi_second_chan_t,
    #[doc = "< signal strength of AP"]
    pub rssi: i8,
    #[doc = "< authmode of AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< pairwise cipher of AP"]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< group cipher of AP"]
    pub group_cipher: wifi_cipher_type_t,
    #[doc = "< antenna used to receive beacon from AP"]
    pub ant: wifi_ant_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< country information of AP"]
    pub country: wifi_country_t,
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        wps: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Do fast scan, scan will end after find SSID match AP"]
pub const wifi_scan_method_t_WIFI_FAST_SCAN: wifi_scan_method_t = 0;
#[doc = "< All channel scan, scan will end after scan all the channel"]
pub const wifi_scan_method_t_WIFI_ALL_CHANNEL_SCAN: wifi_scan_method_t = 1;
pub type wifi_scan_method_t = c_types::c_uint;
#[doc = "< Sort match AP in scan list by RSSI"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SIGNAL: wifi_sort_method_t = 0;
#[doc = "< Sort match AP in scan list by security mode"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SECURITY: wifi_sort_method_t = 1;
pub type wifi_sort_method_t = c_types::c_uint;
#[doc = " @brief Structure describing parameters for a WiFi fast scan"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_fast_scan_threshold_t {
    #[doc = "< The minimum rssi to accept in the fast scan mode"]
    pub rssi: i8,
    #[doc = "< The weakest authmode to accept in the fast scan mode"]
    pub authmode: wifi_auth_mode_t,
}
pub const wifi_state_t_WIFI_STATE_DEINIT: wifi_state_t = 0;
pub const wifi_state_t_WIFI_STATE_INIT: wifi_state_t = 1;
pub const wifi_state_t_WIFI_STATE_START: wifi_state_t = 2;
pub type wifi_state_t = c_types::c_uint;
#[doc = "< No power save"]
pub const wifi_ps_type_t_WIFI_PS_NONE: wifi_ps_type_t = 0;
#[doc = "< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period"]
pub const wifi_ps_type_t_WIFI_PS_MIN_MODEM: wifi_ps_type_t = 1;
#[doc = "< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval"]
#[doc = "parameter in wifi_sta_config_t."]
#[doc = "Attention: Using this option may cause ping failures. Not recommended"]
pub const wifi_ps_type_t_WIFI_PS_MAX_MODEM: wifi_ps_type_t = 2;
pub type wifi_ps_type_t = c_types::c_uint;
#[doc = " @brief Power management config for ESP8266"]
#[doc = ""]
#[doc = " Pass a pointer to this structure as an argument to esp_pm_configure function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_pm_config_esp8266_t {
    #[doc = "< Not used in ESP8266"]
    pub max_freq_mhz: c_types::c_int,
    #[doc = "< Not used in ESP8266"]
    pub min_freq_mhz: c_types::c_int,
    #[doc = "< Enter light sleep when no locks are taken"]
    pub light_sleep_enable: bool,
}
pub const wifi_bandwidth_t_WIFI_BW_HT20: wifi_bandwidth_t = 1;
pub const wifi_bandwidth_t_WIFI_BW_HT40: wifi_bandwidth_t = 2;
pub type wifi_bandwidth_t = c_types::c_uint;
#[doc = " @brief Soft-AP configuration settings for the ESP8266"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_config_t {
    #[doc = "< SSID of ESP8266 soft-AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of ESP8266 soft-AP"]
    pub password: [u8; 64usize],
    #[doc = "< Length of SSID. If softap_config.ssid_len==0, check the SSID until there is a termination character; otherwise, set the SSID length according to softap_config.ssid_len."]
    pub ssid_len: u8,
    #[doc = "< Channel of ESP8266 soft-AP"]
    pub channel: u8,
    #[doc = "< Auth mode of ESP8266 soft-AP. Do not support AUTH_WEP in soft-AP mode"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Broadcast SSID or not, default 0, broadcast the SSID"]
    pub ssid_hidden: u8,
    #[doc = "< Max number of stations allowed to connect in, default 4, max 4"]
    pub max_connection: u8,
    #[doc = "< Beacon interval, 100 ~ 60000 ms, default 100 ms"]
    pub beacon_interval: u16,
}
#[doc = " @brief STA configuration settings for the ESP8266"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_config_t {
    #[doc = "< SSID of target AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< password of target AP"]
    pub password: [u8; 64usize],
    #[doc = "< do all channel scan or fast scan"]
    pub scan_method: wifi_scan_method_t,
    #[doc = "< whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of target AP. Set to 1~13 to scan starting from the specified channel before connecting to AP. If the channel of AP is unknown, set it to 0."]
    pub channel: u8,
    #[doc = "< Listen interval for ESP8266 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0."]
    pub listen_interval: u16,
    #[doc = "< sort the connect AP in the list by rssi or security mode"]
    pub sort_method: wifi_sort_method_t,
    #[doc = "< When scan_method is set to WIFI_FAST_SCAN, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used."]
    pub threshold: wifi_fast_scan_threshold_t,
}
#[doc = " @brief Configuration data for ESP8266 AP or STA."]
#[doc = ""]
#[doc = " The usage of this union (for ap or sta configuration) is determined by the accompanying"]
#[doc = " interface argument passed to esp_wifi_set_config() or esp_wifi_get_config()"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    #[doc = "< configuration of AP"]
    pub ap: wifi_ap_config_t,
    #[doc = "< configuration of STA"]
    pub sta: wifi_sta_config_t,
    _bindgen_union_align: [u32; 31usize],
}
#[doc = " @brief Description of STA associated with AP"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_sta_info_t {
    #[doc = "< mac address"]
    pub mac: [u8; 6usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief List of stations associated with the ESP8266 Soft-AP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_sta_list_t {
    #[doc = "< station list"]
    pub sta: [wifi_sta_info_t; 10usize],
    #[doc = "< number of stations in the list (other entries are invalid)"]
    pub num: c_types::c_int,
}
#[doc = "< all configuration will strore in both memory and flash"]
pub const wifi_storage_t_WIFI_STORAGE_FLASH: wifi_storage_t = 0;
#[doc = "< all configuration will only store in the memory"]
pub const wifi_storage_t_WIFI_STORAGE_RAM: wifi_storage_t = 1;
pub type wifi_storage_t = c_types::c_uint;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_BEACON: wifi_vendor_ie_type_t = 0;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_REQ: wifi_vendor_ie_type_t = 1;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_RESP: wifi_vendor_ie_type_t = 2;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_REQ: wifi_vendor_ie_type_t = 3;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_RESP: wifi_vendor_ie_type_t = 4;
#[doc = " @brief     Vendor Information Element type"]
#[doc = ""]
#[doc = " Determines the frame type that the IE will be associated with."]
pub type wifi_vendor_ie_type_t = c_types::c_uint;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_0: wifi_vendor_ie_id_t = 0;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_1: wifi_vendor_ie_id_t = 1;
#[doc = " @brief     Vendor Information Element index"]
#[doc = ""]
#[doc = " Each IE type can have up to two associated vendor ID elements."]
pub type wifi_vendor_ie_id_t = c_types::c_uint;
#[doc = " @brief Vendor Information Element header"]
#[doc = ""]
#[doc = " The first bytes of the Information Element will match this header. Payload follows."]
#[repr(C)]
#[derive(Debug)]
pub struct vendor_ie_data_t {
    #[doc = "< Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    pub element_id: u8,
    #[doc = "< Length of all bytes in the element data following this field. Minimum 4."]
    pub length: u8,
    #[doc = "< Vendor identifier (OUI)."]
    pub vendor_oui: [u8; 3usize],
    #[doc = "< Vendor-specific OUI type."]
    pub vendor_oui_type: u8,
    #[doc = "< Payload. Length is equal to value in 'length' field, minus 4."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = " @brief Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize], u16>,
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn is_group(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_group(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn legacy_length(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_legacy_length(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn damatch0(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_damatch0(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn damatch1(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_damatch1(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bssidmatch0(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bssidmatch0(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bssidmatch1(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bssidmatch1(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HT_length(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_HT_length(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxend_state(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rxend_state(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn noise_floor(&self) -> c_types::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(88usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_noise_floor(&mut self, val: c_types::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(88usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rssi: c_types::c_int,
        rate: c_types::c_uint,
        is_group: c_types::c_uint,
        sig_mode: c_types::c_uint,
        legacy_length: c_types::c_uint,
        damatch0: c_types::c_uint,
        damatch1: c_types::c_uint,
        bssidmatch0: c_types::c_uint,
        bssidmatch1: c_types::c_uint,
        mcs: c_types::c_uint,
        cwb: c_types::c_uint,
        HT_length: c_types::c_uint,
        smoothing: c_types::c_uint,
        not_sounding: c_types::c_uint,
        aggregation: c_types::c_uint,
        stbc: c_types::c_uint,
        fec_coding: c_types::c_uint,
        sgi: c_types::c_uint,
        rxend_state: c_types::c_uint,
        ampdu_cnt: c_types::c_uint,
        channel: c_types::c_uint,
        noise_floor: c_types::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 12usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rssi: u32 = unsafe { ::core::mem::transmute(rssi) };
            rssi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let rate: u32 = unsafe { ::core::mem::transmute(rate) };
            rate as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let is_group: u32 = unsafe { ::core::mem::transmute(is_group) };
            is_group as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let sig_mode: u32 = unsafe { ::core::mem::transmute(sig_mode) };
            sig_mode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let legacy_length: u32 = unsafe { ::core::mem::transmute(legacy_length) };
            legacy_length as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let damatch0: u32 = unsafe { ::core::mem::transmute(damatch0) };
            damatch0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let damatch1: u32 = unsafe { ::core::mem::transmute(damatch1) };
            damatch1 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let bssidmatch0: u32 = unsafe { ::core::mem::transmute(bssidmatch0) };
            bssidmatch0 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bssidmatch1: u32 = unsafe { ::core::mem::transmute(bssidmatch1) };
            bssidmatch1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 7u8, {
            let mcs: u32 = unsafe { ::core::mem::transmute(mcs) };
            mcs as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let cwb: u32 = unsafe { ::core::mem::transmute(cwb) };
            cwb as u64
        });
        __bindgen_bitfield_unit.set(40usize, 16u8, {
            let HT_length: u32 = unsafe { ::core::mem::transmute(HT_length) };
            HT_length as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let smoothing: u32 = unsafe { ::core::mem::transmute(smoothing) };
            smoothing as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let not_sounding: u32 = unsafe { ::core::mem::transmute(not_sounding) };
            not_sounding as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let aggregation: u32 = unsafe { ::core::mem::transmute(aggregation) };
            aggregation as u64
        });
        __bindgen_bitfield_unit.set(60usize, 2u8, {
            let stbc: u32 = unsafe { ::core::mem::transmute(stbc) };
            stbc as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fec_coding: u32 = unsafe { ::core::mem::transmute(fec_coding) };
            fec_coding as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sgi: u32 = unsafe { ::core::mem::transmute(sgi) };
            sgi as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let rxend_state: u32 = unsafe { ::core::mem::transmute(rxend_state) };
            rxend_state as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let ampdu_cnt: u32 = unsafe { ::core::mem::transmute(ampdu_cnt) };
            ampdu_cnt as u64
        });
        __bindgen_bitfield_unit.set(80usize, 4u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(88usize, 8u8, {
            let noise_floor: u32 = unsafe { ::core::mem::transmute(noise_floor) };
            noise_floor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Payload passed to 'buf' parameter of promiscuous mode RX callback."]
#[repr(C)]
#[derive(Debug)]
pub struct wifi_promiscuous_pkt_t {
    #[doc = "< metadata header"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< Data or management frame payload. Length of payload is"]
    #[doc = "min(112, (pkt->rx_ctrl.sig_mode ? pkt->rx_ctrl.HT_length : pkt->rx_ctrl.legacy_length))"]
    #[doc = "Type of content determined by packet type argument of callback."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Management frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MGMT: wifi_promiscuous_pkt_type_t = 0;
#[doc = "< Control frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_CTRL: wifi_promiscuous_pkt_type_t = 1;
#[doc = "< Data frame, indiciates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_DATA: wifi_promiscuous_pkt_type_t = 2;
#[doc = "< Other type, such as MIMO etc. 'buf' argument is wifi_promiscuous_pkt_t but the payload is zero length."]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MISC: wifi_promiscuous_pkt_type_t = 3;
#[doc = " @brief Promiscuous frame type"]
#[doc = ""]
#[doc = " Passed to promiscuous mode RX callback to indicate the type of parameter in the buffer."]
#[doc = ""]
pub type wifi_promiscuous_pkt_type_t = c_types::c_uint;
#[doc = " @brief Mask for filtering different packet types in promiscuous mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_promiscuous_filter_t {
    #[doc = "< OR of one or more filter values WIFI_PROMIS_FILTER_*"]
    pub filter_mask: u32,
}
pub const wifi_tx_result_t_TX_STATUS_SUCCESS: wifi_tx_result_t = 1;
pub const wifi_tx_result_t_TX_STATUS_SRC_EXCEED: wifi_tx_result_t = 2;
pub const wifi_tx_result_t_TX_STATUS_LRC_EXCEED: wifi_tx_result_t = 3;
pub const wifi_tx_result_t_TX_STATUS_DISCARD: wifi_tx_result_t = 4;
#[doc = " @brief WIFI hardware TX result code"]
pub type wifi_tx_result_t = c_types::c_uint;
pub const wifi_tx_rate_t_PHY_RATE_1_LONG: wifi_tx_rate_t = 0;
pub const wifi_tx_rate_t_PHY_RATE_2_LONG: wifi_tx_rate_t = 1;
pub const wifi_tx_rate_t_PHY_RATE_5_LONG: wifi_tx_rate_t = 2;
pub const wifi_tx_rate_t_PHY_RATE_11_LONG: wifi_tx_rate_t = 3;
pub const wifi_tx_rate_t_PHY_RATE_RESERVED: wifi_tx_rate_t = 4;
pub const wifi_tx_rate_t_PHY_RATE_2_SHORT: wifi_tx_rate_t = 5;
pub const wifi_tx_rate_t_PHY_RATE_5_SHORT: wifi_tx_rate_t = 6;
pub const wifi_tx_rate_t_PHY_RATE_11_SHORT: wifi_tx_rate_t = 7;
pub const wifi_tx_rate_t_PHY_RATE_48: wifi_tx_rate_t = 8;
pub const wifi_tx_rate_t_PHY_RATE_24: wifi_tx_rate_t = 9;
pub const wifi_tx_rate_t_PHY_RATE_12: wifi_tx_rate_t = 10;
pub const wifi_tx_rate_t_PHY_RATE_6: wifi_tx_rate_t = 11;
pub const wifi_tx_rate_t_PHY_RATE_54: wifi_tx_rate_t = 12;
pub const wifi_tx_rate_t_PHY_RATE_36: wifi_tx_rate_t = 13;
pub const wifi_tx_rate_t_PHY_RATE_18: wifi_tx_rate_t = 14;
pub const wifi_tx_rate_t_PHY_RATE_9: wifi_tx_rate_t = 15;
#[doc = " @brief WIFI hardware TX rate"]
pub type wifi_tx_rate_t = c_types::c_uint;
#[doc = " @brief WIFI hardware TX status"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_tx_status_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl wifi_tx_status_t {
    #[inline]
    pub fn wifi_tx_result(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_tx_result(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_tx_src(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_tx_src(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_tx_lrc(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_tx_lrc(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_tx_rate(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_wifi_tx_rate(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wifi_tx_result: c_types::c_uint,
        wifi_tx_src: c_types::c_uint,
        wifi_tx_lrc: c_types::c_uint,
        wifi_tx_rate: c_types::c_uint,
        unused: c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let wifi_tx_result: u32 = unsafe { ::core::mem::transmute(wifi_tx_result) };
            wifi_tx_result as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let wifi_tx_src: u32 = unsafe { ::core::mem::transmute(wifi_tx_src) };
            wifi_tx_src as u64
        });
        __bindgen_bitfield_unit.set(14usize, 6u8, {
            let wifi_tx_lrc: u32 = unsafe { ::core::mem::transmute(wifi_tx_lrc) };
            wifi_tx_lrc as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let wifi_tx_rate: u32 = unsafe { ::core::mem::transmute(wifi_tx_rate) };
            wifi_tx_rate as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let unused: u32 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type sys_prot_t = c_types::c_int;
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type s32_t = i32;
pub type mem_ptr_t = usize;
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const c_types::c_char,
        arg2: *mut *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut *mut c_types::c_char,
        arg4: c_types::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const c_types::c_char,
        arg2: *mut *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut *mut c_types::c_char,
        arg4: c_types::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: c_types::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: c_types::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: c_types::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: c_types::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn strtoimax_l(
        arg1: *const c_types::c_char,
        _restrict: *mut *mut c_types::c_char,
        arg2: c_types::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax_l(
        arg1: *const c_types::c_char,
        _restrict: *mut *mut c_types::c_char,
        arg2: c_types::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: c_types::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: c_types::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
extern "C" {
    pub fn lwip_itoa(result: *mut c_types::c_char, bufsize: size_t, number: c_types::c_int);
}
extern "C" {
    pub fn lwip_strnicmp(
        str1: *const c_types::c_char,
        str2: *const c_types::c_char,
        len: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn lwip_stricmp(
        str1: *const c_types::c_char,
        str2: *const c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn lwip_strnstr(
        buffer: *const c_types::c_char,
        token: *const c_types::c_char,
        n: size_t,
    ) -> *mut c_types::c_char;
}
#[doc = " This is the aligned version of ip4_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[doc = " ip4_addr_t uses a struct for convenience only, so that the same defines can"]
#[doc = " operate both on ip4_addr_t as well as on ip4_addr_p_t."]
pub type ip4_addr_t = ip4_addr;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr2 {
    pub addrw: [u16_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ip4_addr_isbroadcast_u32(addr: u32_t, netif: *const netif) -> u8_t;
}
extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
extern "C" {
    pub fn ipaddr_addr(cp: *const c_types::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(cp: *const c_types::c_char, addr: *mut ip4_addr_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut c_types::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut c_types::c_char,
        buflen: c_types::c_int,
    ) -> *mut c_types::c_char;
}
#[doc = " IPv4"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V4: lwip_ip_addr_type = 0;
#[doc = " IPv6"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V6: lwip_ip_addr_type = 6;
#[doc = " IPv4+IPv6 (\"dual-stack\")"]
pub const lwip_ip_addr_type_IPADDR_TYPE_ANY: lwip_ip_addr_type = 46;
#[doc = " @ingroup ipaddr"]
#[doc = " IP address types for use in ip_addr_t.type member."]
#[doc = " @see tcp_new_ip_type(), udp_new_ip_type(), raw_new_ip_type()."]
pub type lwip_ip_addr_type = c_types::c_uint;
pub type ip_addr_t = ip4_addr_t;
extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_state {
    pub state: s16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dhcps_msg {
    pub op: u8_t,
    pub htype: u8_t,
    pub hlen: u8_t,
    pub hops: u8_t,
    pub xid: [u8_t; 4usize],
    pub secs: u16_t,
    pub flags: u16_t,
    pub ciaddr: [u8_t; 4usize],
    pub yiaddr: [u8_t; 4usize],
    pub siaddr: [u8_t; 4usize],
    pub giaddr: [u8_t; 4usize],
    pub chaddr: [u8_t; 16usize],
    pub sname: [u8_t; 64usize],
    pub file: [u8_t; 128usize],
    pub options: [u8_t; 312usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_lease_t {
    pub enable: bool,
    pub start_ip: ip4_addr_t,
    pub end_ip: ip4_addr_t,
}
pub const dhcps_offer_option_OFFER_START: dhcps_offer_option = 0;
pub const dhcps_offer_option_OFFER_ROUTER: dhcps_offer_option = 1;
pub const dhcps_offer_option_OFFER_DNS: dhcps_offer_option = 2;
pub const dhcps_offer_option_OFFER_END: dhcps_offer_option = 3;
pub type dhcps_offer_option = c_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_pool {
    pub ip: ip4_addr_t,
    pub mac: [u8_t; 6usize],
    pub lease_timer: u32_t,
}
pub type dhcps_time_t = u32_t;
pub type dhcps_offer_t = u8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_options_t {
    pub dhcps_offer: dhcps_offer_t,
    pub dhcps_dns: dhcps_offer_t,
    pub dhcps_time: dhcps_time_t,
    pub dhcps_poll: dhcps_lease_t,
}
pub type dhcps_cb_t = ::core::option::Option<unsafe extern "C" fn(client_ip: *mut u8_t)>;
extern "C" {
    pub fn dhcps_start(netif: *mut netif, ip: ip4_addr_t);
}
extern "C" {
    pub fn dhcps_stop(netif: *mut netif);
}
extern "C" {
    pub fn dhcps_option_info(op_id: u8_t, opt_len: u32_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn dhcps_set_option_info(op_id: u8_t, opt_info: *mut c_types::c_void, opt_len: u32_t);
}
extern "C" {
    pub fn dhcp_search_ip_on_mac(mac: *mut u8_t, ip: *mut ip4_addr_t) -> bool;
}
extern "C" {
    pub fn dhcps_dns_setserver(dnsserver: *const ip_addr_t);
}
extern "C" {
    pub fn dhcps_dns_getserver() -> ip4_addr_t;
}
extern "C" {
    pub fn dhcps_set_new_lease_cb(cb: dhcps_cb_t);
}
extern "C" {
    pub fn dhcps_coarse_tmr();
}
#[doc = "  @brief TCP-IP adapter IPV4 address information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_ip_info_t {
    #[doc = "< TCP-IP adatpter IPV4 addresss"]
    pub ip: ip4_addr_t,
    #[doc = "< TCP-IP adatpter IPV4 netmask"]
    pub netmask: ip4_addr_t,
    #[doc = "< TCP-IP adatpter IPV4 gateway"]
    pub gw: ip4_addr_t,
}
#[doc = "  @brief TCP-IP adapter IPV6 address information if disable IPV6 of LwIP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_ip6_info_t {
    #[doc = "< TCP-IP adatpter IPV4 addresss"]
    pub ip: tcpip_adapter_ip6_info_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_ip6_info_t__bindgen_ty_1 {
    #[doc = "< TCP-IP adatpter IPV4 addresss data"]
    pub addr: [u32; 4usize],
}
pub type tcpip_adapter_dhcps_lease_t = dhcps_lease_t;
#[doc = "  @brief TCP-IP adapter station information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_sta_info_t {
    #[doc = "< TCP-IP adatpter station MAC address"]
    pub mac: [u8; 6usize],
    #[doc = "< TCP-IP adatpter station IPV4 addresss"]
    pub ip: ip4_addr_t,
}
#[doc = "  @brief TCP-IP adapter station information table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_sta_list_t {
    #[doc = "< adapter station information array"]
    pub sta: [tcpip_adapter_sta_info_t; 10usize],
    #[doc = "< adapter station information number"]
    pub num: c_types::c_int,
}
#[doc = "< TCP-IP adatpter station interface"]
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_STA: tcpip_adapter_if_t = 0;
#[doc = "< TCP-IP adatpter soft-AP interface"]
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_AP: tcpip_adapter_if_t = 1;
#[doc = "< TCP-IP adatpter ethernet interface"]
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_ETH: tcpip_adapter_if_t = 2;
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_MAX: tcpip_adapter_if_t = 3;
pub type tcpip_adapter_if_t = c_types::c_uint;
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_MAIN: tcpip_adapter_dns_type_t = 0;
#[doc = "DNS main server address"]
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_BACKUP: tcpip_adapter_dns_type_t = 1;
#[doc = "DNS backup server address,for STA only,support soft-AP in future"]
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_FALLBACK: tcpip_adapter_dns_type_t = 2;
#[doc = "DNS fallback server address,for STA only"]
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_MAX: tcpip_adapter_dns_type_t = 3;
pub type tcpip_adapter_dns_type_t = c_types::c_uint;
#[doc = "  @brief TCP-IP adapter DNS server information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_dns_info_t {
    #[doc = "< DNS IP addresss"]
    pub ip: ip_addr_t,
}
#[doc = "< DHCP client/server in initial state"]
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_INIT: tcpip_adapter_dhcp_status_t = 0;
#[doc = "< DHCP client/server already been started"]
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_STARTED: tcpip_adapter_dhcp_status_t = 1;
#[doc = "< DHCP client/server already been stopped"]
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_STOPPED: tcpip_adapter_dhcp_status_t = 2;
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_STATUS_MAX: tcpip_adapter_dhcp_status_t =
    3;
pub type tcpip_adapter_dhcp_status_t = c_types::c_uint;
pub const tcpip_adapter_option_mode_t_TCPIP_ADAPTER_OP_START: tcpip_adapter_option_mode_t = 0;
#[doc = "< set option mode"]
pub const tcpip_adapter_option_mode_t_TCPIP_ADAPTER_OP_SET: tcpip_adapter_option_mode_t = 1;
#[doc = "< get option mode"]
pub const tcpip_adapter_option_mode_t_TCPIP_ADAPTER_OP_GET: tcpip_adapter_option_mode_t = 2;
pub const tcpip_adapter_option_mode_t_TCPIP_ADAPTER_OP_MAX: tcpip_adapter_option_mode_t = 3;
pub type tcpip_adapter_option_mode_t = c_types::c_uint;
#[doc = "< domain name server"]
pub const tcpip_adapter_option_id_t_TCPIP_ADAPTER_DOMAIN_NAME_SERVER: tcpip_adapter_option_id_t = 6;
#[doc = "< solicitation router address"]
pub const tcpip_adapter_option_id_t_TCPIP_ADAPTER_ROUTER_SOLICITATION_ADDRESS:
    tcpip_adapter_option_id_t = 32;
#[doc = "< request IP address pool"]
pub const tcpip_adapter_option_id_t_TCPIP_ADAPTER_REQUESTED_IP_ADDRESS: tcpip_adapter_option_id_t =
    50;
#[doc = "< request IP address lease time"]
pub const tcpip_adapter_option_id_t_TCPIP_ADAPTER_IP_ADDRESS_LEASE_TIME: tcpip_adapter_option_id_t =
    51;
#[doc = "< request IP address retry counter"]
pub const tcpip_adapter_option_id_t_TCPIP_ADAPTER_IP_REQUEST_RETRY_TIME: tcpip_adapter_option_id_t =
    52;
pub type tcpip_adapter_option_id_t = c_types::c_uint;
pub type tcpip_adapter_api_fn = ::core::option::Option<
    unsafe extern "C" fn(msg: *mut tcpip_adapter_api_msg_s) -> c_types::c_int,
>;
#[doc = "  @brief TCP-IP adapter async messsage"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_api_msg_s {
    #[doc = "< TCP-IP adatpter API message type"]
    pub type_: c_types::c_int,
    #[doc = "< TCP-IP adatpter API message process result"]
    pub ret: c_types::c_int,
    #[doc = "< TCP-IP adatpter API message function"]
    pub api_fn: tcpip_adapter_api_fn,
    #[doc = "< TCP-IP adatpter API message interface type"]
    pub tcpip_if: tcpip_adapter_if_t,
    #[doc = "< TCP-IP adatpter API message IP information"]
    pub ip_info: *mut tcpip_adapter_ip_info_t,
    #[doc = "< TCP-IP adatpter API message MAC address"]
    pub mac: *mut u8,
    #[doc = "< TCP-IP adatpter API message MAC private data"]
    pub data: *mut c_types::c_void,
}
#[doc = "  @brief TCP-IP adapter async messsage"]
pub type tcpip_adapter_api_msg_t = tcpip_adapter_api_msg_s;
#[doc = "  @brief TCP-IP adapter DNS parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_dns_param_s {
    #[doc = "< DNS type"]
    pub dns_type: tcpip_adapter_dns_type_t,
    #[doc = "< DNS information"]
    pub dns_info: *mut tcpip_adapter_dns_info_t,
}
#[doc = "  @brief TCP-IP adapter DNS parameters"]
pub type tcpip_adapter_dns_param_t = tcpip_adapter_dns_param_s;
#[doc = "  @brief TCP-IP adapter IP lost checking timer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adatper_ip_lost_timer_s {
    #[doc = "< check if the timer if running"]
    pub timer_running: bool,
}
#[doc = "  @brief TCP-IP adapter IP lost checking timer"]
pub type tcpip_adapter_ip_lost_timer_t = tcpip_adatper_ip_lost_timer_s;
extern "C" {
    #[doc = " @brief  Initialize tcpip adapter"]
    #[doc = ""]
    #[doc = " This will initialize TCPIP stack inside."]
    pub fn tcpip_adapter_init();
}
extern "C" {
    #[doc = " @brief  Start the Wi-Fi station/AP interface with specific MAC and IP"]
    #[doc = ""]
    #[doc = " Station/AP interface will be initialized, connect WiFi stack with TCPIP stack."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: Station/AP interface"]
    #[doc = " @param[in]  mac: set MAC address of this interface"]
    #[doc = " @param[in]  ip_info: set IP address of this interface"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         ESP_ERR_NO_MEM"]
    pub fn tcpip_adapter_start(
        tcpip_if: tcpip_adapter_if_t,
        mac: *mut u8,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop an interface"]
    #[doc = ""]
    #[doc = " The interface will be cleanup in this API, if DHCP server/client are started, will be stopped."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which will be started"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Bring up an interface"]
    #[doc = ""]
    #[doc = " Only station interface need to be brought up, since station interface will be shut down when disconnect."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which will be up"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_up(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Shut down an interface"]
    #[doc = ""]
    #[doc = " Only station interface need to be shut down, since station interface will be brought up when connect."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which will be down"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_down(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface's IP information"]
    #[doc = ""]
    #[doc = " There has an IP information copy in adapter library, if interface is up, get IP information from"]
    #[doc = " interface, otherwise get from copy."]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if: the interface which we want to get IP information"]
    #[doc = " @param[out]  ip_info: If successful, IP information will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_get_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface's IP information"]
    #[doc = ""]
    #[doc = " There has an IP information copy in adapter library, if interface is up, also set interface's IP."]
    #[doc = " DHCP client/server should be stopped before set new IP information."]
    #[doc = ""]
    #[doc = " This function is mainly used for setting static IP."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we want to set IP information"]
    #[doc = " @param[in]  ip_info: store the IP information which needs to be set to specified interface"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_set_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set DNS Server's information"]
    #[doc = ""]
    #[doc = " There has an DNS Server information copy in adapter library, set DNS Server for appointed interface and type."]
    #[doc = ""]
    #[doc = " 1.In station mode, if dhcp client is enabled, then only the fallback DNS server can be set(TCPIP_ADAPTER_DNS_FALLBACK)."]
    #[doc = "   Fallback DNS server is only used if no DNS servers are set via DHCP."]
    #[doc = "   If dhcp client is disabled, then need to set main/backup dns server(TCPIP_ADAPTER_DNS_MAIN, TCPIP_ADAPTER_DNS_BACKUP)."]
    #[doc = ""]
    #[doc = " 2.In soft-AP mode, the DNS Server's main dns server offered to the station is the IP address of soft-AP,"]
    #[doc = "   if the application don't want to use the IP address of soft-AP, they can set the main dns server."]
    #[doc = ""]
    #[doc = " This function is mainly used for setting static or Fallback DNS Server."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we want to set DNS Server information"]
    #[doc = " @param[in]  type: the type of DNS Server,including TCPIP_ADAPTER_DNS_MAIN, TCPIP_ADAPTER_DNS_BACKUP, TCPIP_ADAPTER_DNS_FALLBACK"]
    #[doc = " @param[in]  dns:  the DNS Server address to be set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS invalid params"]
    pub fn tcpip_adapter_set_dns_info(
        tcpip_if: tcpip_adapter_if_t,
        type_: tcpip_adapter_dns_type_t,
        dns: *mut tcpip_adapter_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DNS Server's information"]
    #[doc = ""]
    #[doc = " When set the DNS Server information successfully, can get the DNS Server's information via the appointed tcpip_if and type"]
    #[doc = ""]
    #[doc = " This function is mainly used for getting DNS Server information."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we want to get DNS Server information"]
    #[doc = " @param[in]  type: the type of DNS Server,including TCPIP_ADAPTER_DNS_MAIN, TCPIP_ADAPTER_DNS_BACKUP, TCPIP_ADAPTER_DNS_FALLBACK"]
    #[doc = " @param[in]  dns:  the DNS Server address to be get"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS invalid params"]
    pub fn tcpip_adapter_get_dns_info(
        tcpip_if: tcpip_adapter_if_t,
        type_: tcpip_adapter_dns_type_t,
        dns: *mut tcpip_adapter_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface's old IP information"]
    #[doc = ""]
    #[doc = " When the interface successfully gets a valid IP from DHCP server or static configured, a copy of"]
    #[doc = " the IP information is set to the old IP information. When IP lost timer expires, the old IP"]
    #[doc = " information is reset to 0."]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if: the interface which we want to get old IP information"]
    #[doc = " @param[out]  ip_info: If successful, IP information will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_get_old_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface's old IP information"]
    #[doc = ""]
    #[doc = " When the interface successfully gets a valid IP from DHCP server or static configured, a copy of"]
    #[doc = " the IP information is set to the old IP information. When IP lost timer expires, the old IP"]
    #[doc = " information is reset to 0."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we want to set old IP information"]
    #[doc = " @param[in]  ip_info: store the IP information which needs to be set to specified interface"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_set_old_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  create interface's linklocal IPv6 information"]
    #[doc = ""]
    #[doc = " @note this function will create a linklocal IPv6 address about input interface,"]
    #[doc = "       if this address status changed to preferred, will call event call back ,"]
    #[doc = "       notify user linklocal IPv6 address has been verified"]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we want to set IP information"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_create_ip6_linklocal(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP server's status"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if: the interface which we will get status of DHCP server"]
    #[doc = " @param[out]  status: If successful, the status of DHCP server will be return in this argument."]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    pub fn tcpip_adapter_dhcps_get_status(
        tcpip_if: tcpip_adapter_if_t,
        status: *mut tcpip_adapter_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP server's option"]
    #[doc = ""]
    #[doc = " @param[in]  opt_op: option operate type, 1 for SET, 2 for GET."]
    #[doc = " @param[in]  opt_id: option index, 32 for ROUTER, 50 for IP POLL, 51 for LEASE TIME, 52 for REQUEST TIME"]
    #[doc = " @param[in]  opt_val: option parameter"]
    #[doc = " @param[in]  opt_len: option length"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED"]
    pub fn tcpip_adapter_dhcps_option(
        opt_op: tcpip_adapter_option_mode_t,
        opt_id: tcpip_adapter_option_id_t,
        opt_val: *mut c_types::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start DHCP server"]
    #[doc = ""]
    #[doc = " @note   Currently DHCP server is bind to softAP interface."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we will start DHCP server"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED"]
    pub fn tcpip_adapter_dhcps_start(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP server"]
    #[doc = ""]
    #[doc = " @note   Currently DHCP server is bind to softAP interface."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we will stop DHCP server"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPED"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_dhcps_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP client status"]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we will get status of DHCP client"]
    #[doc = " @param[out]  status: If successful, the status of DHCP client will be return in this argument."]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    pub fn tcpip_adapter_dhcpc_get_status(
        tcpip_if: tcpip_adapter_if_t,
        status: *mut tcpip_adapter_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP client's option"]
    #[doc = ""]
    #[doc = " @note   This function is not implement now."]
    #[doc = ""]
    #[doc = " @param[in]  opt_op: option operate type, 1 for SET, 2 for GET."]
    #[doc = " @param[in]  opt_id: option index, 32 for ROUTER, 50 for IP POLL, 51 for LEASE TIME, 52 for REQUEST TIME"]
    #[doc = " @param[in]  opt_val: option parameter"]
    #[doc = " @param[in]  opt_len: option length"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    pub fn tcpip_adapter_dhcpc_option(
        opt_op: tcpip_adapter_option_mode_t,
        opt_id: tcpip_adapter_option_id_t,
        opt_val: *mut c_types::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start DHCP client"]
    #[doc = ""]
    #[doc = " @note   Currently DHCP client is bind to station interface."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we will start DHCP client"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED"]
    pub fn tcpip_adapter_dhcpc_start(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP client"]
    #[doc = ""]
    #[doc = " @note   Currently DHCP client is bind to station interface."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if: the interface which we will stop DHCP client"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPED"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_dhcpc_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    pub fn tcpip_adapter_eth_input(
        buffer: *mut c_types::c_void,
        len: u16,
        eb: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get data from station interface"]
    #[doc = ""]
    #[doc = " This function should be installed by esp_wifi_reg_rxcb, so WiFi packets will be forward to TCPIP stack."]
    #[doc = ""]
    #[doc = " @param[in]  buffer: the received data point"]
    #[doc = " @param[in]  len: the received data length"]
    #[doc = " @param[in]  eb: parameter"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    pub fn tcpip_adapter_sta_input(
        buffer: *mut c_types::c_void,
        len: u16,
        eb: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get data from softAP interface"]
    #[doc = ""]
    #[doc = " This function should be installed by esp_wifi_reg_rxcb, so WiFi packets will be forward to TCPIP stack."]
    #[doc = ""]
    #[doc = " @param[in]  buffer: the received data point"]
    #[doc = " @param[in]  len: the received data length"]
    #[doc = " @param[in]  eb: parameter"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    pub fn tcpip_adapter_ap_input(
        buffer: *mut c_types::c_void,
        len: u16,
        eb: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get WiFi interface index"]
    #[doc = ""]
    #[doc = " Get WiFi interface from TCPIP interface struct pointer."]
    #[doc = ""]
    #[doc = " @param[in]  dev: adapter interface"]
    #[doc = ""]
    #[doc = " @return ESP_IF_WIFI_STA"]
    #[doc = "         ESP_IF_WIFI_AP"]
    #[doc = "ESP_IF_ETH"]
    #[doc = "         ESP_IF_MAX"]
    pub fn tcpip_adapter_get_esp_if(dev: *mut c_types::c_void) -> esp_interface_t;
}
extern "C" {
    #[doc = " @brief  Get the station information list"]
    #[doc = ""]
    #[doc = " @param[in]   wifi_sta_list: station list info"]
    #[doc = " @param[out]  tcpip_sta_list: station list info"]
    #[doc = ""]
    #[doc = " @return ESP_OK"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_NO_MEM"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_get_sta_list(
        wifi_sta_list: *mut wifi_sta_list_t,
        tcpip_sta_list: *mut tcpip_adapter_sta_list_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set the hostname to the interface"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if: the interface which we will set the hostname"]
    #[doc = " @param[in]   hostname: the host name for set the interface, the max length of hostname is 32 bytes"]
    #[doc = ""]
    #[doc = " @return ESP_OK:success"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY:interface status error"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS:parameter error"]
    pub fn tcpip_adapter_set_hostname(
        tcpip_if: tcpip_adapter_if_t,
        hostname: *const c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get the hostname from the interface"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if: the interface which we will get the hostname"]
    #[doc = " @param[in]   hostname: the host name from the interface"]
    #[doc = ""]
    #[doc = " @return ESP_OK:success"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY:interface status error"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS:parameter error"]
    pub fn tcpip_adapter_get_hostname(
        tcpip_if: tcpip_adapter_if_t,
        hostname: *mut *const c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get the LwIP netif* that is assigned to the interface"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if: the interface which we will get the hostname"]
    #[doc = " @param[out]  netif: pointer to fill the resulting interface"]
    #[doc = ""]
    #[doc = " @return ESP_OK:success"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY:interface status error"]
    #[doc = "         ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS:parameter error"]
    pub fn tcpip_adapter_get_netif(
        tcpip_if: tcpip_adapter_if_t,
        netif: *mut *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Test if supplied interface is up or down"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if: the interface which we will get the hostname"]
    #[doc = ""]
    #[doc = " @return  true:  tcpip_if is UP"]
    #[doc = "          false: tcpip_if id DOWN"]
    pub fn tcpip_adapter_is_netif_up(tcpip_if: tcpip_adapter_if_t) -> bool;
}
extern "C" {
    #[doc = " @brief  Wrapper API to call \"tcpip_adapter_init()\" really"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK on success"]
    #[doc = ""]
    #[doc = " @note This function should be called exactly once from application code, when the application starts up."]
    pub fn esp_netif_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Empty function"]
    #[doc = ""]
    #[doc = "          Note: Deinitialization is not supported yet"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK on success"]
    pub fn esp_netif_deinit() -> esp_err_t;
}
#[doc = "< Send ESPNOW data successfully"]
pub const esp_now_send_status_t_ESP_NOW_SEND_SUCCESS: esp_now_send_status_t = 0;
#[doc = "< Send ESPNOW data fail"]
pub const esp_now_send_status_t_ESP_NOW_SEND_FAIL: esp_now_send_status_t = 1;
#[doc = " @brief Status of sending ESPNOW data ."]
pub type esp_now_send_status_t = c_types::c_uint;
#[doc = " @brief ESPNOW peer information parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_now_peer_info {
    #[doc = "< ESPNOW peer MAC address that is also the MAC address of station or softap"]
    pub peer_addr: [u8; 6usize],
    #[doc = "< ESPNOW peer local master key that is used to encrypt data"]
    pub lmk: [u8; 16usize],
    #[doc = "< Wi-Fi channel that peer uses to send/receive ESPNOW data. If the value is 0,"]
    #[doc = "use the current channel which station or softap is on. Otherwise, it must be"]
    #[doc = "set as the channel that station or softap is on."]
    pub channel: u8,
    #[doc = "< Wi-Fi interface that peer uses to send/receive ESPNOW data"]
    pub ifidx: wifi_interface_t,
    #[doc = "< ESPNOW data that this peer sends/receives is encrypted or not"]
    pub encrypt: bool,
    #[doc = "< ESPNOW peer private data"]
    pub priv_: *mut c_types::c_void,
}
#[doc = " @brief ESPNOW peer information parameters."]
pub type esp_now_peer_info_t = esp_now_peer_info;
#[doc = " @brief Number of ESPNOW peers which exist currently."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_now_peer_num {
    #[doc = "< Total number of ESPNOW peers, maximum value is ESP_NOW_MAX_TOTAL_PEER_NUM"]
    pub total_num: c_types::c_int,
    #[doc = "< Number of encrypted ESPNOW peers, maximum value is ESP_NOW_MAX_ENCRYPT_PEER_NUM"]
    pub encrypt_num: c_types::c_int,
}
#[doc = " @brief Number of ESPNOW peers which exist currently."]
pub type esp_now_peer_num_t = esp_now_peer_num;
#[doc = " @brief     Callback function of receiving ESPNOW data"]
#[doc = " @param     mac_addr peer MAC address"]
#[doc = " @param     data received data"]
#[doc = " @param     data_len length of received data"]
pub type esp_now_recv_cb_t = ::core::option::Option<
    unsafe extern "C" fn(mac_addr: *const u8, data: *const u8, data_len: c_types::c_int),
>;
#[doc = " @brief     Callback function of sending ESPNOW data"]
#[doc = " @param     mac_addr peer MAC address"]
#[doc = " @param     status status of sending ESPNOW data (succeed or fail)"]
pub type esp_now_send_cb_t = ::core::option::Option<
    unsafe extern "C" fn(mac_addr: *const u8, status: esp_now_send_status_t),
>;
extern "C" {
    #[doc = " @brief     Initialize ESPNOW function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : Internal error"]
    pub fn esp_now_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     De-initialize ESPNOW function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    pub fn esp_now_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the version of ESPNOW"]
    #[doc = ""]
    #[doc = " @param     version  ESPNOW version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_version(version: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of receiving ESPNOW data"]
    #[doc = ""]
    #[doc = " @param     cb  callback function of receiving ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_recv_cb(cb: esp_now_recv_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of receiving ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_recv_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Register callback function of sending ESPNOW data"]
    #[doc = ""]
    #[doc = " @param     cb  callback function of sending ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    pub fn esp_now_register_send_cb(cb: esp_now_send_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Unregister callback function of sending ESPNOW data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    pub fn esp_now_unregister_send_cb() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send ESPNOW data"]
    #[doc = ""]
    #[doc = " @attention 1. If peer_addr is not NULL, send data to the peer whose MAC address matches peer_addr"]
    #[doc = " @attention 2. If peer_addr is NULL, send data to all of the peers that are added to the peer list"]
    #[doc = " @attention 3. The maximum length of data must be less than ESP_NOW_MAX_DATA_LEN"]
    #[doc = " @attention 4. The buffer pointed to by data argument does not need to be valid after esp_now_send returns"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = " @param     data  data to send"]
    #[doc = " @param     len  length of data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_INTERNAL : internal error"]
    #[doc = "          - ESP_ERR_ESPNOW_NO_MEM : out of memory"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    #[doc = "          - ESP_ERR_ESPNOW_IF : current WiFi interface doesn't match that of peer"]
    pub fn esp_now_send(peer_addr: *const u8, data: *const u8, len: size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Add a peer to peer list"]
    #[doc = ""]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_FULL : peer list is full"]
    #[doc = "          - ESP_ERR_ESPNOW_NO_MEM : out of memory"]
    #[doc = "          - ESP_ERR_ESPNOW_EXIST : peer has existed"]
    pub fn esp_now_add_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Delete a peer from peer list"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_del_peer(peer_addr: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Modify a peer"]
    #[doc = ""]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_FULL : peer list is full"]
    pub fn esp_now_mod_peer(peer: *const esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get a peer whose MAC address matches peer_addr from peer list"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_get_peer(peer_addr: *const u8, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Fetch a peer from peer list"]
    #[doc = ""]
    #[doc = " @param     from_head  fetch from head of list or not"]
    #[doc = " @param     peer  peer information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_FOUND : peer is not found"]
    pub fn esp_now_fetch_peer(from_head: bool, peer: *mut esp_now_peer_info_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Peer exists or not"]
    #[doc = ""]
    #[doc = " @param     peer_addr  peer MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - true : peer exists"]
    #[doc = "          - false : peer not exists"]
    pub fn esp_now_is_peer_exist(peer_addr: *const u8) -> bool;
}
extern "C" {
    #[doc = " @brief     Get the number of peers"]
    #[doc = ""]
    #[doc = " @param     num  number of peers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_get_peer_num(num: *mut esp_now_peer_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the primary master key"]
    #[doc = ""]
    #[doc = " @param     pmk  primary master key"]
    #[doc = ""]
    #[doc = " @attention 1. primary master key is used to encrypt local master key"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK : succeed"]
    #[doc = "          - ESP_ERR_ESPNOW_NOT_INIT : ESPNOW is not initialized"]
    #[doc = "          - ESP_ERR_ESPNOW_ARG : invalid argument"]
    pub fn esp_now_set_pmk(pmk: *const u8) -> esp_err_t;
}
#[doc = " @brief Structure holding PHY init parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_init_data_t {
    #[doc = "< opaque PHY initialization parameters"]
    pub params: [u8; 128usize],
}
#[doc = " @brief Opaque PHY calibration data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_calibration_data_t {
    #[doc = "< calibration data"]
    pub rf_cal_data: [u8; 128usize],
    pub rx_gain_dc_table: [u32; 125usize],
}
#[doc = "< Do part of RF calibration. This should be used after power-on reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_PARTIAL: esp_phy_calibration_mode_t = 0;
#[doc = "< Don't do any RF calibration. This mode is only suggested to be used after deep sleep reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_NONE: esp_phy_calibration_mode_t = 1;
#[doc = "< Do full RF calibration. Produces best results, but also consumes a lot of time and current. Suggested to be used once."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_FULL: esp_phy_calibration_mode_t = 2;
pub type esp_phy_calibration_mode_t = c_types::c_uint;
#[doc = "!< Wi-Fi Station used"]
pub const modem_sleep_module_t_MODEM_WIFI_STATION_MODULE: modem_sleep_module_t = 0;
#[doc = "!< Wi-Fi SoftAP used"]
pub const modem_sleep_module_t_MODEM_WIFI_SOFTAP_MODULE: modem_sleep_module_t = 1;
#[doc = "!< Wi-Fi Sniffer used"]
pub const modem_sleep_module_t_MODEM_WIFI_SNIFFER_MODULE: modem_sleep_module_t = 2;
#[doc = "!< User used"]
pub const modem_sleep_module_t_MODEM_USER_MODULE: modem_sleep_module_t = 3;
#[doc = "!< Number of items"]
pub const modem_sleep_module_t_MODEM_MODULE_COUNT: modem_sleep_module_t = 4;
#[doc = " @brief Modules for modem sleep"]
pub type modem_sleep_module_t = c_types::c_uint;
#[doc = "!< Wi-Fi used"]
pub const phy_rf_module_t_PHY_WIFI_MODULE: phy_rf_module_t = 0;
#[doc = "!< Modem sleep used"]
pub const phy_rf_module_t_PHY_MODEM_MODULE: phy_rf_module_t = 1;
#[doc = "!< Number of items"]
pub const phy_rf_module_t_PHY_MODULE_COUNT: phy_rf_module_t = 2;
#[doc = " @brief Modules needing to call phy_rf_init"]
pub type phy_rf_module_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Get PHY init data"]
    #[doc = ""]
    #[doc = " If \"Use a partition to store PHY init data\" option is set in menuconfig,"]
    #[doc = " This function will load PHY init data from a partition. Otherwise,"]
    #[doc = " PHY init data will be compiled into the application itself, and this function"]
    #[doc = " will return a pointer to PHY init data located in read-only memory (DROM)."]
    #[doc = ""]
    #[doc = " If \"Use a partition to store PHY init data\" option is enabled, this function"]
    #[doc = " may return NULL if the data loaded from flash is not valid."]
    #[doc = ""]
    #[doc = " @note Call esp_phy_release_init_data to release the pointer obtained using"]
    #[doc = " this function after the call to esp_wifi_init."]
    #[doc = ""]
    #[doc = " @return pointer to PHY init data structure"]
    pub fn esp_phy_get_init_data() -> *const esp_phy_init_data_t;
}
extern "C" {
    #[doc = " @brief Release PHY init data"]
    #[doc = " @param data  pointer to PHY init data structure obtained from"]
    #[doc = "              esp_phy_get_init_data function"]
    pub fn esp_phy_release_init_data(data: *const esp_phy_init_data_t);
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_init to load PHY calibration data"]
    #[doc = ""]
    #[doc = " This is a convenience function which can be used to load PHY calibration"]
    #[doc = " data from NVS. Data can be stored to NVS using esp_phy_store_cal_data_to_nvs"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " If calibration data is not present in the NVS, or"]
    #[doc = " data is not valid (was obtained for a chip with a different MAC address,"]
    #[doc = " or obtained for a different version of software), this function will"]
    #[doc = " return an error."]
    #[doc = ""]
    #[doc = " @param out_cal_data pointer to calibration data structure to be filled with"]
    #[doc = "                     loaded data."]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_phy_load_cal_data_from_nvs(
        out_cal_data: *mut esp_phy_calibration_data_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_init to store PHY calibration data"]
    #[doc = ""]
    #[doc = " This is a convenience function which can be used to store PHY calibration"]
    #[doc = " data to the NVS. Calibration data is returned by phy function."]
    #[doc = " Data saved using this function to the NVS can later be loaded using"]
    #[doc = " esp_phy_store_cal_data_to_nvs function."]
    #[doc = ""]
    #[doc = " @param cal_data pointer to calibration data which has to be saved."]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_phy_store_cal_data_to_nvs(cal_data: *const esp_phy_calibration_data_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize PHY and RF module"]
    #[doc = ""]
    #[doc = " PHY and RF module should be initialized in order to use WiFi."]
    #[doc = " Now PHY and RF initializing job is done automatically when start WiFi. Users should not"]
    #[doc = " call this API in their application."]
    #[doc = ""]
    #[doc = " @param init_data  PHY parameters. Default set of parameters can"]
    #[doc = "                   be obtained by calling esp_phy_get_default_init_data"]
    #[doc = "                   function."]
    #[doc = " @param mode  Calibration mode (Full, partial, or no calibration)"]
    #[doc = " @param[inout] calibration_data"]
    #[doc = " @return ESP_OK on success."]
    #[doc = " @return ESP_FAIL on fail."]
    pub fn esp_phy_rf_init(
        init_data: *const esp_phy_init_data_t,
        mode: esp_phy_calibration_mode_t,
        calibration_data: *mut esp_phy_calibration_data_t,
        module: phy_rf_module_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize PHY and RF module"]
    #[doc = ""]
    #[doc = " PHY module should be de-initialized in order to shutdown WiFi."]
    #[doc = " Now PHY and RF de-initializing job is done automatically when stop WiFi. Users should not"]
    #[doc = " call this API in their application."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success."]
    pub fn esp_phy_rf_deinit(module: phy_rf_module_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Load calibration data from NVS and initialize PHY and RF module"]
    pub fn esp_phy_load_cal_and_init(module: phy_rf_module_t);
}
#[doc = "< GPIO0, input and output"]
pub const gpio_num_t_GPIO_NUM_0: gpio_num_t = 0;
#[doc = "< GPIO1, input and output"]
pub const gpio_num_t_GPIO_NUM_1: gpio_num_t = 1;
#[doc = "< GPIO2, input and output"]
pub const gpio_num_t_GPIO_NUM_2: gpio_num_t = 2;
#[doc = "< GPIO3, input and output"]
pub const gpio_num_t_GPIO_NUM_3: gpio_num_t = 3;
#[doc = "< GPIO4, input and output"]
pub const gpio_num_t_GPIO_NUM_4: gpio_num_t = 4;
#[doc = "< GPIO5, input and output"]
pub const gpio_num_t_GPIO_NUM_5: gpio_num_t = 5;
#[doc = "< GPIO6, input and output"]
pub const gpio_num_t_GPIO_NUM_6: gpio_num_t = 6;
#[doc = "< GPIO7, input and output"]
pub const gpio_num_t_GPIO_NUM_7: gpio_num_t = 7;
#[doc = "< GPIO8, input and output"]
pub const gpio_num_t_GPIO_NUM_8: gpio_num_t = 8;
#[doc = "< GPIO9, input and output"]
pub const gpio_num_t_GPIO_NUM_9: gpio_num_t = 9;
#[doc = "< GPIO10, input and output"]
pub const gpio_num_t_GPIO_NUM_10: gpio_num_t = 10;
#[doc = "< GPIO11, input and output"]
pub const gpio_num_t_GPIO_NUM_11: gpio_num_t = 11;
#[doc = "< GPIO12, input and output"]
pub const gpio_num_t_GPIO_NUM_12: gpio_num_t = 12;
#[doc = "< GPIO13, input and output"]
pub const gpio_num_t_GPIO_NUM_13: gpio_num_t = 13;
#[doc = "< GPIO14, input and output"]
pub const gpio_num_t_GPIO_NUM_14: gpio_num_t = 14;
#[doc = "< GPIO15, input and output"]
pub const gpio_num_t_GPIO_NUM_15: gpio_num_t = 15;
#[doc = "< GPIO16, input and output"]
pub const gpio_num_t_GPIO_NUM_16: gpio_num_t = 16;
pub const gpio_num_t_GPIO_NUM_MAX: gpio_num_t = 17;
pub type gpio_num_t = c_types::c_uint;
#[doc = "< Disable GPIO interrupt"]
pub const gpio_int_type_t_GPIO_INTR_DISABLE: gpio_int_type_t = 0;
#[doc = "< GPIO interrupt type : rising edge"]
pub const gpio_int_type_t_GPIO_INTR_POSEDGE: gpio_int_type_t = 1;
#[doc = "< GPIO interrupt type : falling edge"]
pub const gpio_int_type_t_GPIO_INTR_NEGEDGE: gpio_int_type_t = 2;
#[doc = "< GPIO interrupt type : both rising and falling edge"]
pub const gpio_int_type_t_GPIO_INTR_ANYEDGE: gpio_int_type_t = 3;
#[doc = "< GPIO interrupt type : input low level trigger"]
pub const gpio_int_type_t_GPIO_INTR_LOW_LEVEL: gpio_int_type_t = 4;
#[doc = "< GPIO interrupt type : input high level trigger"]
pub const gpio_int_type_t_GPIO_INTR_HIGH_LEVEL: gpio_int_type_t = 5;
pub const gpio_int_type_t_GPIO_INTR_MAX: gpio_int_type_t = 6;
pub type gpio_int_type_t = c_types::c_uint;
#[doc = "< GPIO mode : disable input and output"]
pub const gpio_mode_t_GPIO_MODE_DISABLE: gpio_mode_t = 0;
#[doc = "< GPIO mode : input only"]
pub const gpio_mode_t_GPIO_MODE_INPUT: gpio_mode_t = 1;
#[doc = "< GPIO mode : output only mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT: gpio_mode_t = 2;
#[doc = "< GPIO mode : output only with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT_OD: gpio_mode_t = 6;
pub type gpio_mode_t = c_types::c_uint;
#[doc = "< Pad pull up"]
pub const gpio_pull_mode_t_GPIO_PULLUP_ONLY: gpio_pull_mode_t = 0;
#[doc = "< Pad pull down"]
pub const gpio_pull_mode_t_GPIO_PULLDOWN_ONLY: gpio_pull_mode_t = 1;
#[doc = "< Pad floating"]
pub const gpio_pull_mode_t_GPIO_FLOATING: gpio_pull_mode_t = 2;
pub type gpio_pull_mode_t = c_types::c_uint;
#[doc = "< Disable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_DISABLE: gpio_pullup_t = 0;
#[doc = "< Enable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_ENABLE: gpio_pullup_t = 1;
pub type gpio_pullup_t = c_types::c_uint;
#[doc = "< Disable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_DISABLE: gpio_pulldown_t = 0;
#[doc = "< Enable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_ENABLE: gpio_pulldown_t = 1;
pub type gpio_pulldown_t = c_types::c_uint;
#[doc = " @brief Configuration parameters of GPIO pad for gpio_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_config_t {
    #[doc = "< GPIO pin: set with bit mask, each bit maps to a GPIO"]
    pub pin_bit_mask: u32,
    #[doc = "< GPIO mode: set input/output mode"]
    pub mode: gpio_mode_t,
    #[doc = "< GPIO pull-up"]
    pub pull_up_en: gpio_pullup_t,
    #[doc = "< GPIO pull-down"]
    pub pull_down_en: gpio_pulldown_t,
    #[doc = "< GPIO interrupt type"]
    pub intr_type: gpio_int_type_t,
}
pub type gpio_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>;
pub type gpio_isr_handle_t = *mut c_types::c_void;
extern "C" {
    #[doc = " @brief GPIO common configuration"]
    #[doc = ""]
    #[doc = " Configure GPIO's Mode,pull-up,PullDown,IntrType"]
    #[doc = ""]
    #[doc = " @param  gpio_cfg  Pointer to GPIO configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_config(gpio_cfg: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set interrupt trigger type"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO12, gpio_num should be GPIO_NUM_12 (12);"]
    #[doc = " @param  intr_type Interrupt type, select from gpio_int_type_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK  Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set output level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the output level of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  level Output level. 0: low ; 1: high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO number error"]
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO get input level"]
    #[doc = ""]
    #[doc = " @note   If the pad is not configured for input (or input and output) the returned value is always 0."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to get the logic level of e.g. pin GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 the GPIO input level is 0"]
    #[doc = "     - 1 the GPIO input level is 1"]
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief  GPIO set direction"]
    #[doc = ""]
    #[doc = " Configure GPIO direction,such as output_only,input_only"]
    #[doc = ""]
    #[doc = " @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  pull GPIO pull up/down mode."]
    #[doc = ""]
    #[doc = " @note   The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG : Parameter error"]
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @note RTC IO can not use the wakeup function"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @note RTC IO can not use the wakeup function"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register GPIO interrupt handler, the handler is an ISR."]
    #[doc = ""]
    #[doc = " This ISR function is called whenever any GPIO interrupt occurs. See"]
    #[doc = " the alternative gpio_install_isr_service() and"]
    #[doc = " gpio_isr_handler_add() API in order to have the driver support"]
    #[doc = " per-GPIO ISRs."]
    #[doc = ""]
    #[doc = " @param  fn  Interrupt handler function."]
    #[doc = " @param  no_use In order to be compatible with esp32, the parameter has no practical meaning and can be filled with 0."]
    #[doc = " @param  arg  Parameter for handler function"]
    #[doc = " @param  handle_no_use Pointer to return handle. In order to be compatible with esp32,the parameter has no practical meaning and can be filled with NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    pub fn gpio_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
        no_use: c_types::c_int,
        handle_no_use: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers."]
    #[doc = ""]
    #[doc = " This function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function."]
    #[doc = ""]
    #[doc = " @param  no_use In order to be compatible with esp32, the parameter has no practical meaning and can be filled with 0."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM No memory to install this service"]
    #[doc = "     - ESP_ERR_INVALID_STATE ISR service already installed."]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_install_isr_service(no_use: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the driver's GPIO ISR service, freeing related resources."]
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    #[doc = " @brief Add ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " Call this function after using gpio_install_isr_service() to"]
    #[doc = " install the driver's GPIO ISR handler service."]
    #[doc = ""]
    #[doc = " This ISR handler will be called from an ISR. So there is a stack"]
    #[doc = " size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = " limit is smaller compared to a global GPIO interrupt handler due"]
    #[doc = " to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = " @param isr_handler ISR handler function for the corresponding GPIO number."]
    #[doc = " @param args parameter for ISR handler."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
pub const wifi_sleep_type_t_WIFI_NONE_SLEEP_T: wifi_sleep_type_t = 0;
pub const wifi_sleep_type_t_WIFI_LIGHT_SLEEP_T: wifi_sleep_type_t = 1;
pub const wifi_sleep_type_t_WIFI_MODEM_SLEEP_T: wifi_sleep_type_t = 2;
pub type wifi_sleep_type_t = c_types::c_uint;
pub const esp_sleep_mode_ESP_CPU_WAIT: esp_sleep_mode = 0;
pub const esp_sleep_mode_ESP_CPU_LIGHTSLEEP: esp_sleep_mode = 1;
pub type esp_sleep_mode = c_types::c_uint;
pub use self::esp_sleep_mode as esp_sleep_mode_t;
pub type fpm_wakeup_cb = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "!< In case of deep sleep, reset was not caused by exit from deep sleep"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_UNDEFINED: esp_sleep_source_t = 0;
#[doc = "!< Not a wakeup cause, used to disable all wakeup sources with esp_sleep_disable_wakeup_source"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_ALL: esp_sleep_source_t = 1;
#[doc = "!< Wakeup caused by timer"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_TIMER: esp_sleep_source_t = 2;
#[doc = "!< Wakeup caused by GPIO (light sleep only)"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_GPIO: esp_sleep_source_t = 3;
#[doc = " @brief Sleep wakeup cause"]
pub type esp_sleep_source_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief     Enter deep-sleep mode."]
    #[doc = ""]
    #[doc = "            The device will automatically wake up after the deep-sleep time set"]
    #[doc = "            by the users. Upon waking up, the device boots up from user_init."]
    #[doc = ""]
    #[doc = " @attention 1. XPD_DCDC should be connected to EXT_RSTB through 0 ohm resistor"]
    #[doc = "               in order to support deep-sleep wakeup."]
    #[doc = " @attention 2. system_deep_sleep(0): there is no wake up timer; in order to wake"]
    #[doc = "               up, connect a GPIO to pin RST, the chip will wake up by a falling-edge"]
    #[doc = "               on pin RST"]
    #[doc = " @attention 3. esp_deep_sleep does not shut down WiFi and higher level protocol"]
    #[doc = "               connections gracefully. Make sure esp_wifi_stop are called to close any"]
    #[doc = "               connections and deinitialize the peripherals."]
    #[doc = ""]
    #[doc = " @param     time_in_us  deep-sleep time, unit: microsecond"]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn esp_deep_sleep(time_in_us: u32);
}
extern "C" {
    #[doc = " @brief Set implementation-specific power management configuration"]
    #[doc = " @param config pointer to implementation-specific configuration structure (e.g. esp_pm_config_esp32)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the configuration values are not correct"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if certain combination of values is not supported."]
    pub fn esp_pm_configure(config: *const c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Call this API before esp_deep_sleep and esp_wifi_init to set the activity after the"]
    #[doc = "         next deep-sleep wakeup."]
    #[doc = ""]
    #[doc = "         If this API is not called, default to be esp_deep_sleep_set_rf_option(1)."]
    #[doc = ""]
    #[doc = " @param  option  radio option"]
    #[doc = "                 0 : Radio calibration after the deep-sleep wakeup is decided by byte"]
    #[doc = "                     108 of esp_init_data_default.bin (0~127byte)."]
    #[doc = "                 1 : Radio calibration will be done after the deep-sleep wakeup. This"]
    #[doc = "                     will lead to stronger current."]
    #[doc = "                 2 : Radio calibration will not be done after the deep-sleep wakeup."]
    #[doc = "                     This will lead to weaker current."]
    #[doc = "                 4 : Disable radio calibration after the deep-sleep wakeup (the same"]
    #[doc = "                     as modem-sleep). This will lead to the weakest current, but the device"]
    #[doc = "                     can't receive or transmit data after waking up."]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn esp_deep_sleep_set_rf_option(option: u8);
}
extern "C" {
    #[doc = " @brief     Enable force sleep function."]
    #[doc = ""]
    #[doc = " @attention Force sleep function is disabled by default."]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn esp_wifi_fpm_open();
}
extern "C" {
    #[doc = " @brief  Disable force sleep function."]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn esp_wifi_fpm_close();
}
extern "C" {
    #[doc = " @brief     Wake ESP8266 up from MODEM_SLEEP_T force sleep."]
    #[doc = ""]
    #[doc = " @attention This API can only be called when MODEM_SLEEP_T force sleep function"]
    #[doc = "            is enabled, after calling wifi_fpm_open."]
    #[doc = "            This API can not be called after calling wifi_fpm_close."]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn esp_wifi_fpm_do_wakeup();
}
extern "C" {
    #[doc = " @brief     Set a callback of waken up from force sleep because of time out."]
    #[doc = ""]
    #[doc = " @attention 1. This API can only be called when force sleep function is enabled,"]
    #[doc = "               after calling wifi_fpm_open. This API can not be called after calling"]
    #[doc = "               wifi_fpm_close."]
    #[doc = " @attention 2. fpm_wakeup_cb_func will be called after system woke up only if the"]
    #[doc = "               force sleep time out (wifi_fpm_do_sleep and the parameter is not 0xFFFFFFF)."]
    #[doc = " @attention 3. fpm_wakeup_cb_func will not be called if woke up by wifi_fpm_do_wakeup"]
    #[doc = "               from MODEM_SLEEP_T type force sleep."]
    #[doc = ""]
    #[doc = " @param     cb  callback of waken up"]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn esp_wifi_fpm_set_wakeup_cb(cb: fpm_wakeup_cb);
}
extern "C" {
    #[doc = " @brief     Force ESP8266 enter sleep mode, and it will wake up automatically when time out."]
    #[doc = ""]
    #[doc = " @attention 1. This API can only be called when force sleep function is enabled, after"]
    #[doc = "               calling wifi_fpm_open. This API can not be called after calling wifi_fpm_close."]
    #[doc = " @attention 2. If this API returned 0 means that the configuration is set successfully,"]
    #[doc = "               but the ESP8266 will not enter sleep mode immediately, it is going to sleep"]
    #[doc = "               in the system idle task. Please do not call other WiFi related function right"]
    #[doc = "               after calling this API."]
    #[doc = ""]
    #[doc = " @param     sleep_time_in_us  sleep time, ESP8266 will wake up automatically"]
    #[doc = "                              when time out. Unit: us. Range: 10000 ~ 268435455(0xFFFFFFF)."]
    #[doc = "                              - If sleep_time_in_us is 0xFFFFFFF, the ESP8266 will sleep till"]
    #[doc = "                              - if wifi_fpm_set_sleep_type is set to be LIGHT_SLEEP_T, ESP8266 can wake up by GPIO."]
    #[doc = "                              - if wifi_fpm_set_sleep_type is set to be MODEM_SLEEP_T, ESP8266 can wake up by wifi_fpm_do_wakeup."]
    #[doc = ""]
    #[doc = " @return  ESP_OK, setting succeed;"]
    #[doc = " @return  ESP_ERR_WIFI_FPM_MODE, fail to sleep, force sleep function is not enabled."]
    #[doc = " @return  ESP_ERR_WIFI_PM_MODE_OPEN, fail to sleep, Please call esp_wifi_set_ps(WIFI_PS_NONE) first."]
    #[doc = " @return  ESP_ERR_WIFI_MODE, fail to sleep, Please call esp_wifi_set_mode(WIFI_MODE_NULL) first."]
    pub fn esp_wifi_fpm_do_sleep(sleep_time_in_us: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set sleep type for force sleep function."]
    #[doc = ""]
    #[doc = " @attention This API can only be called before wifi_fpm_open."]
    #[doc = ""]
    #[doc = " @param     type  sleep type"]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn esp_wifi_fpm_set_sleep_type(type_: wifi_sleep_type_t);
}
extern "C" {
    #[doc = " @brief  Get sleep type of force sleep function."]
    #[doc = ""]
    #[doc = " @return sleep type"]
    pub fn esp_wifi_fpm_get_sleep_type() -> wifi_sleep_type_t;
}
extern "C" {
    #[doc = " @brief  Set a GPIO to wake the ESP8266 up from light-sleep mode"]
    #[doc = "         ESP8266 will be wakened from Light-sleep, when the GPIO is in low-level."]
    #[doc = ""]
    #[doc = " If the ESP8266 enters light-sleep automatically(esp_wifi_set_sleep_type(LIGHT_SLEEP_T);),"]
    #[doc = " after being waken up by GPIO, when the chip attempts to sleep again, it will check the status of the GPIO:"]
    #[doc = " Note:"]
    #[doc = "  If the GPIO is still in the wakeup status, the EP8266 will enter modem-sleep mode instead;"]
    #[doc = "  If the GPIO is NOT in the wakeup status, the ESP8266 will enter light-sleep mode"]
    #[doc = ""]
    #[doc = " @param gpio_num     GPIO number, range: [0, 15]."]
    #[doc = "                     gpio_int_type_t intr_status: status of GPIO interrupt to trigger the wakeup process."]
    #[doc = "                     - if esp_wifi_fpm_set_sleep_type is set to be LIGHT_SLEEP_T, ESP8266 can wake up by GPIO."]
    #[doc = "                     - if esp_wifi_fpm_set_sleep_type is set to be MODEM_SLEEP_T, ESP8266 can wake up by esp_wifi_fpm_do_wakeup."]
    #[doc = " @param intr_status  GPIO interrupt type"]
    #[doc = ""]
    #[doc = " @return   null"]
    pub fn esp_wifi_enable_gpio_wakeup(gpio_num: u32, intr_status: gpio_int_type_t);
}
extern "C" {
    #[doc = " @brief  Disable the function that the GPIO can wake the ESP8266 up from light-sleep mode."]
    pub fn esp_wifi_disable_gpio_wakeup();
}
extern "C" {
    #[doc = " @brief Enable wakeup by timer"]
    #[doc = " @param time_in_us  time before wakeup, in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if value is out of range (TBD)"]
    pub fn esp_sleep_enable_timer_wakeup(time_in_us: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enter light sleep with the configured wakeup options"]
    #[doc = ""]
    #[doc = " @attention esp_deep_sleep does not shut down WiFi and higher level protocol"]
    #[doc = "               connections gracefully. Make sure esp_wifi_stop are called to close any"]
    #[doc = "               connections and deinitialize the peripherals."]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success (returned after wakeup)"]
    #[doc = "  - ESP_ERR_INVALID_STATE if WiFi is not stopped"]
    pub fn esp_light_sleep_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Operation system start check time and enter sleep"]
    #[doc = ""]
    #[doc = " @note This function is called by system, user should not call this"]
    pub fn esp_sleep_start();
}
extern "C" {
    #[doc = " @brief Enable wakeup from light sleep using GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if wakeup triggers conflict"]
    pub fn esp_sleep_enable_gpio_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable wakeup source"]
    #[doc = ""]
    #[doc = " This function is used to deactivate wake up trigger for source"]
    #[doc = " defined as parameter of the function."]
    #[doc = ""]
    #[doc = " @note This function does not modify wake up configuration in RTC."]
    #[doc = "       It will be performed in esp_sleep_start function."]
    #[doc = ""]
    #[doc = " @param source - number of source to disable of type esp_sleep_source_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if trigger was not active"]
    pub fn esp_sleep_disable_wakeup_source(source: esp_sleep_source_t) -> esp_err_t;
}
#[doc = "< Waiting to start connect"]
pub const smartconfig_status_t_SC_STATUS_WAIT: smartconfig_status_t = 0;
#[doc = "< Finding target channel"]
pub const smartconfig_status_t_SC_STATUS_FIND_CHANNEL: smartconfig_status_t = 1;
#[doc = "< Getting SSID and password of target AP"]
pub const smartconfig_status_t_SC_STATUS_GETTING_SSID_PSWD: smartconfig_status_t = 2;
#[doc = "< Connecting to target AP"]
pub const smartconfig_status_t_SC_STATUS_LINK: smartconfig_status_t = 3;
#[doc = "< Connected to AP successfully"]
pub const smartconfig_status_t_SC_STATUS_LINK_OVER: smartconfig_status_t = 4;
pub type smartconfig_status_t = c_types::c_uint;
#[doc = "< protocol: ESPTouch"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH: smartconfig_type_t = 0;
#[doc = "< protocol: AirKiss"]
pub const smartconfig_type_t_SC_TYPE_AIRKISS: smartconfig_type_t = 1;
#[doc = "< protocol: ESPTouch and AirKiss"]
pub const smartconfig_type_t_SC_TYPE_ESPTOUCH_AIRKISS: smartconfig_type_t = 2;
pub type smartconfig_type_t = c_types::c_uint;
#[doc = " @brief  The callback of SmartConfig, executed when smart-config status changed."]
#[doc = ""]
#[doc = " @param  status  Status of SmartConfig:"]
#[doc = "    - SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type."]
#[doc = "    - SC_STATUS_LINK : pdata is a pointer of struct station_config."]
#[doc = "    - SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL."]
#[doc = "    - otherwise : parameter void *pdata is NULL."]
#[doc = " @param  pdata  According to the different status have different values."]
#[doc = ""]
pub type sc_callback_t = ::core::option::Option<
    unsafe extern "C" fn(status: smartconfig_status_t, pdata: *mut c_types::c_void),
>;
extern "C" {
    #[doc = " @brief  Get the version of SmartConfig."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - SmartConfig version const char."]
    pub fn esp_smartconfig_get_version() -> *const c_types::c_char;
}
extern "C" {
    #[doc = " @brief     Start SmartConfig, config ESP device to connect AP. You need to broadcast information by phone APP."]
    #[doc = "            Device sniffer special packets from the air that containing SSID and password of target AP."]
    #[doc = ""]
    #[doc = " @attention 1. This API can be called in station or softAP-station mode."]
    #[doc = " @attention 2. Can not call esp_smartconfig_start twice before it finish, please call"]
    #[doc = "               esp_smartconfig_stop first."]
    #[doc = ""]
    #[doc = " @param     cb  SmartConfig callback function."]
    #[doc = " @param     ... log  1: UART output logs; 0: UART only outputs the result."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_start(cb: sc_callback_t, ...) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop SmartConfig, free the buffer taken by esp_smartconfig_start."]
    #[doc = ""]
    #[doc = " @attention Whether connect to AP succeed or not, this API should be called to free"]
    #[doc = "            memory taken by smartconfig_start."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set timeout of SmartConfig process."]
    #[doc = ""]
    #[doc = " @attention Timing starts from SC_STATUS_FIND_CHANNEL status. SmartConfig will restart if timeout."]
    #[doc = ""]
    #[doc = " @param     time_s  range 15s~255s, offset:45s."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_esptouch_set_timeout(time_s: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of SmartConfig."]
    #[doc = ""]
    #[doc = " @attention If users need to set the SmartConfig type, please set it before calling"]
    #[doc = "            esp_smartconfig_start."]
    #[doc = ""]
    #[doc = " @param     type  Choose from the smartconfig_type_t."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_set_type(type_: smartconfig_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mode of SmartConfig. default normal mode."]
    #[doc = ""]
    #[doc = " @attention 1. Please call it before API esp_smartconfig_start."]
    #[doc = " @attention 2. Fast mode have corresponding APP(phone)."]
    #[doc = " @attention 3. Two mode is compatible."]
    #[doc = ""]
    #[doc = " @param     enable  false-disable(default); true-enable;"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: succeed"]
    #[doc = "     - others: fail"]
    pub fn esp_smartconfig_fast_mode(enable: bool) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_s {
    pub cmd_str: *mut c_types::c_char,
    pub flag: u8,
    pub id: u8,
    pub cmd_func: ::core::option::Option<unsafe extern "C" fn()>,
    pub cmd_callback: ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>,
}
pub type ssc_cmd_t = cmd_s;
pub const SscBaudRate_SSC_BR_9600: SscBaudRate = 9600;
pub const SscBaudRate_SSC_BR_19200: SscBaudRate = 19200;
pub const SscBaudRate_SSC_BR_38400: SscBaudRate = 38400;
pub const SscBaudRate_SSC_BR_57600: SscBaudRate = 57600;
pub const SscBaudRate_SSC_BR_74880: SscBaudRate = 74880;
pub const SscBaudRate_SSC_BR_115200: SscBaudRate = 115200;
pub const SscBaudRate_SSC_BR_230400: SscBaudRate = 230400;
pub const SscBaudRate_SSC_BR_460800: SscBaudRate = 460800;
pub const SscBaudRate_SSC_BR_921600: SscBaudRate = 921600;
pub type SscBaudRate = c_types::c_uint;
extern "C" {
    #[doc = " @brief  Initial the ssc function."]
    #[doc = ""]
    #[doc = " @param  SscBaudRate bandrate : baud rate"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn ssc_attach(bandrate: SscBaudRate);
}
extern "C" {
    #[doc = " @brief   Get the length of the simple serial command."]
    #[doc = ""]
    #[doc = " @param   null"]
    #[doc = ""]
    #[doc = " @return  length of the command."]
    pub fn ssc_param_len() -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief   Get the simple serial command string."]
    #[doc = ""]
    #[doc = " @param   null"]
    #[doc = ""]
    #[doc = " @return  the command."]
    pub fn ssc_param_str() -> *mut c_types::c_char;
}
extern "C" {
    #[doc = " @brief   Parse the simple serial command (ssc)."]
    #[doc = ""]
    #[doc = " @param   char *pLine  : [input] the ssc string"]
    #[doc = " @param   char *argv[] : [output] parameters of the ssc"]
    #[doc = ""]
    #[doc = " @return  the number of parameters."]
    pub fn ssc_parse_param(
        pLine: *mut c_types::c_char,
        argv: *mut *mut c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief  Register the user-defined simple serial command (ssc) set."]
    #[doc = ""]
    #[doc = " @param  ssc_cmd_t *cmdset   : the ssc set"]
    #[doc = " @param  uint8 cmdnum        : number of commands"]
    #[doc = " @param  void (* help)(void) : callback of user-guide"]
    #[doc = ""]
    #[doc = " @return  null"]
    pub fn ssc_register(
        cmdset: *mut ssc_cmd_t,
        cmdnum: u8,
        help: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief  Initialize the Task Watchdog Timer (TWDT)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK: Initialization was successful"]
    #[doc = "     - ESP_ERR_NO_MEM: Initialization failed due to lack of memory"]
    #[doc = ""]
    #[doc = " @note  esp_task_wdt_init() must only be called after the scheduler"]
    #[doc = "        started"]
    pub fn esp_task_wdt_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Reset(Feed) the Task Watchdog Timer (TWDT) on behalf of the currently"]
    #[doc = "         running task"]
    pub fn esp_task_wdt_reset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single esp_timer"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type"]
#[doc = " @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>;
#[doc = "!< Callback is called from timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = " @brief Method for dispatching timer callback"]
pub type esp_timer_dispatch_t = c_types::c_uint;
#[doc = " @brief Timer configuration passed to esp_timer_create"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Function to call when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to the callback"]
    pub arg: *mut c_types::c_void,
    #[doc = "!< Call the callback from task or from ISR"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump function"]
    pub name: *const c_types::c_char,
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note This function is called from startup code. Applications do not need"]
    #[doc = " to call this function before using other esp_timer APIs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if allocation has failed"]
    #[doc = "      - ESP_ERR_INVALID_STATE if already initialized"]
    #[doc = "      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note Normally this function should not be called from applications"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance"]
    #[doc = ""]
    #[doc = " @note When done using the timer, delete it with esp_timer_delete function."]
    #[doc = ""]
    #[doc = " @param create_args   Pointer to a structure with timer creation arguments."]
    #[doc = "                      Not saved by the library, can be allocated on the stack."]
    #[doc = " @param[out] out_handle  Output, pointer to esp_timer_handle_t variable which"]
    #[doc = "                         will hold the created timer handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if some of the create_args are not valid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet"]
    #[doc = "      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start one-shot timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param timeout_us timer timeout, in microseconds relative to the current moment"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called. This function will"]
    #[doc = " start the timer which will trigger every 'period' microseconds."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param period timer period, in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the timer"]
    #[doc = ""]
    #[doc = " This function stops the timer previously started using esp_timer_start_once"]
    #[doc = " or esp_timer_start_periodic."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance"]
    #[doc = ""]
    #[doc = " The timer must be stopped before deleting. A one-shot timer which has expired"]
    #[doc = " does not need to be stopped."]
    #[doc = ""]
    #[doc = " @param timer timer handle allocated using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since RTOS starts"]
    #[doc = " @return number of microseconds since RTOS starts starts (this normally"]
    #[doc = "          happens much early during application startup)."]
    pub fn esp_timer_get_time() -> i64;
}
#[doc = " Opaque pointer type representing non-volatile storage handle"]
pub type nvs_handle = u32;
#[doc = "< Read only"]
pub const nvs_open_mode_NVS_READONLY: nvs_open_mode = 0;
#[doc = "< Read and write"]
pub const nvs_open_mode_NVS_READWRITE: nvs_open_mode = 1;
#[doc = " @brief Mode of opening the non-volatile storage"]
#[doc = ""]
pub type nvs_open_mode = c_types::c_uint;
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from the default NVS partition"]
    #[doc = ""]
    #[doc = " Multiple internal ESP-IDF and third party application modules can store"]
    #[doc = " their key-value pairs in the NVS module. In order to reduce possible"]
    #[doc = " conflicts on key names, each module can use its own namespace."]
    #[doc = " The default NVS partition is the one that is labelled \"nvs\" in the partition"]
    #[doc = " table."]
    #[doc = ""]
    #[doc = " @param[in]  name        Namespace name. Maximal length is determined by the"]
    #[doc = "                         underlying implementation, but is guaranteed to be"]
    #[doc = "                         at least 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  open_mode   NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will"]
    #[doc = "                         open a handle for reading only. All write requests will"]
    #[doc = "\t\t\t   be rejected for this handle."]
    #[doc = " @param[out] out_handle  If successful (return code is zero), handle will be"]
    #[doc = "                         returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if storage handle was opened successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized"]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with label \"nvs\" is not found"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and"]
    #[doc = "               mode is NVS_READONLY"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_open(
        name: *const c_types::c_char,
        open_mode: nvs_open_mode,
        out_handle: *mut nvs_handle,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from specified partition"]
    #[doc = ""]
    #[doc = " The behaviour is same as nvs_open() API. However this API can operate on a specified NVS"]
    #[doc = " partition instead of default NVS partition. Note that the specified partition must be registered"]
    #[doc = " with NVS using nvs_flash_init_partition() API."]
    #[doc = ""]
    #[doc = " @param[in]  part_name   Label (name) of the partition of interest for object read/write/erase"]
    #[doc = " @param[in]  name        Namespace name. Maximal length is determined by the"]
    #[doc = "                         underlying implementation, but is guaranteed to be"]
    #[doc = "                         at least 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  open_mode   NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will"]
    #[doc = "                         open a handle for reading only. All write requests will"]
    #[doc = "\t\t\t   be rejected for this handle."]
    #[doc = " @param[out] out_handle  If successful (return code is zero), handle will be"]
    #[doc = "                         returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if storage handle was opened successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized"]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with specified name is not found"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and"]
    #[doc = "               mode is NVS_READONLY"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_open_from_partition(
        part_name: *const c_types::c_char,
        name: *const c_types::c_char,
        open_mode: nvs_open_mode,
        out_handle: *mut nvs_handle,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " @brief      set value for given key"]
    #[doc = ""]
    #[doc = " This family of functions set value for the key, given its name. Note that"]
    #[doc = " actual storage will not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle obtained from nvs_open function."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = " @param[in]  key     Key name. Maximal length is determined by the underlying"]
    #[doc = "                     implementation, but is guaranteed to be at least"]
    #[doc = "                     15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  value   The value to set."]
    #[doc = "                     For strings, the maximum length (including null character) is"]
    #[doc = "                     1984 bytes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if value was set successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the"]
    #[doc = "               underlying storage to save the value"]
    #[doc = "             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash"]
    #[doc = "               write operation has failed. The value was written however, and"]
    #[doc = "               update will be finished after re-initialization of nvs, provided that"]
    #[doc = "               flash operation doesn't fail again."]
    #[doc = "             - ESP_ERR_NVS_VALUE_TOO_LONG if the string value is too long"]
    pub fn nvs_set_i8(handle: nvs_handle, key: *const c_types::c_char, value: i8) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u8(handle: nvs_handle, key: *const c_types::c_char, value: u8) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i16(handle: nvs_handle, key: *const c_types::c_char, value: i16) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u16(handle: nvs_handle, key: *const c_types::c_char, value: u16) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i32(handle: nvs_handle, key: *const c_types::c_char, value: i32) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u32(handle: nvs_handle, key: *const c_types::c_char, value: u32) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i64(handle: nvs_handle, key: *const c_types::c_char, value: i64) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u64(handle: nvs_handle, key: *const c_types::c_char, value: u64) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_str(
        handle: nvs_handle,
        key: *const c_types::c_char,
        value: *const c_types::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       set variable length binary value for given key"]
    #[doc = ""]
    #[doc = " This family of functions set value for the key, given its name. Note that"]
    #[doc = " actual storage will not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle obtained from nvs_open function."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = " @param[in]  key     Key name. Maximal length is 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  value   The value to set."]
    #[doc = " @param[in]  length  length of binary value to set, in bytes; Maximum length is"]
    #[doc = "                     1984 bytes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if value was set successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the"]
    #[doc = "               underlying storage to save the value"]
    #[doc = "             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash"]
    #[doc = "               write operation has failed. The value was written however, and"]
    #[doc = "               update will be finished after re-initialization of nvs, provided that"]
    #[doc = "               flash operation doesn't fail again."]
    #[doc = "             - ESP_ERR_NVS_VALUE_TOO_LONG if the value is too long"]
    pub fn nvs_set_blob(
        handle: nvs_handle,
        key: *const c_types::c_char,
        value: *const c_types::c_void,
        length: size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " @brief      get value for given key"]
    #[doc = ""]
    #[doc = " These functions retrieve value for the key, given its name. If key does not"]
    #[doc = " exist, or the requested variable type doesn't match the type which was used"]
    #[doc = " when setting a value, an error is returned."]
    #[doc = ""]
    #[doc = " In case of any error, out_value is not modified."]
    #[doc = ""]
    #[doc = " All functions expect out_value to be a pointer to an already allocated variable"]
    #[doc = " of the given type."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of using nvs_get_i32:"]
    #[doc = " int32_t max_buffer_size = 4096; // default value"]
    #[doc = " esp_err_t err = nvs_get_i32(my_handle, \"max_buffer_size\", &max_buffer_size);"]
    #[doc = " assert(err == ESP_OK || err == ESP_ERR_NVS_NOT_FOUND);"]
    #[doc = " // if ESP_ERR_NVS_NOT_FOUND was returned, max_buffer_size will still"]
    #[doc = " // have its default value."]
    #[doc = ""]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]     handle     Handle obtained from nvs_open function."]
    #[doc = " @param[in]     key        Key name. Maximal length is determined by the underlying"]
    #[doc = "                           implementation, but is guaranteed to be at least"]
    #[doc = "                           15 characters. Shouldn't be empty."]
    #[doc = " @param         out_value  Pointer to the output value."]
    #[doc = "                           May be NULL for nvs_get_str and nvs_get_blob, in this"]
    #[doc = "                           case required length will be returned in length argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the value was retrieved successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data"]
    pub fn nvs_get_i8(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut i8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u8(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i16(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut i16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u16(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut u16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i32(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut i32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u32(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i64(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut i64,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u64(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get value for given key"]
    #[doc = ""]
    #[doc = " These functions retrieve value for the key, given its name. If key does not"]
    #[doc = " exist, or the requested variable type doesn't match the type which was used"]
    #[doc = " when setting a value, an error is returned."]
    #[doc = ""]
    #[doc = " In case of any error, out_value is not modified."]
    #[doc = ""]
    #[doc = " All functions expect out_value to be a pointer to an already allocated variable"]
    #[doc = " of the given type."]
    #[doc = ""]
    #[doc = " nvs_get_str and nvs_get_blob functions support WinAPI-style length queries."]
    #[doc = " To get the size necessary to store the value, call nvs_get_str or nvs_get_blob"]
    #[doc = " with zero out_value and non-zero pointer to length. Variable pointed to"]
    #[doc = " by length argument will be set to the required length. For nvs_get_str,"]
    #[doc = " this length includes the zero terminator. When calling nvs_get_str and"]
    #[doc = " nvs_get_blob with non-zero out_value, length has to be non-zero and has to"]
    #[doc = " point to the length available in out_value."]
    #[doc = " It is suggested that nvs_get/set_str is used for zero-terminated C strings, and"]
    #[doc = " nvs_get/set_blob used for arbitrary data structures."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example (without error checking) of using nvs_get_str to get a string into dynamic array:"]
    #[doc = " size_t required_size;"]
    #[doc = " nvs_get_str(my_handle, \"server_name\", NULL, &required_size);"]
    #[doc = " char* server_name = malloc(required_size);"]
    #[doc = " nvs_get_str(my_handle, \"server_name\", server_name, &required_size);"]
    #[doc = ""]
    #[doc = " // Example (without error checking) of using nvs_get_blob to get a binary data"]
    #[doc = " into a static array:"]
    #[doc = " uint8_t mac_addr[6];"]
    #[doc = " size_t size = sizeof(mac_addr);"]
    #[doc = " nvs_get_blob(my_handle, \"dst_mac_addr\", mac_addr, &size);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]     handle     Handle obtained from nvs_open function."]
    #[doc = " @param[in]     key        Key name. Maximal length is determined by the underlying"]
    #[doc = "                           implementation, but is guaranteed to be at least"]
    #[doc = "                           15 characters. Shouldn't be empty."]
    #[doc = " @param         out_value  Pointer to the output value."]
    #[doc = "                           May be NULL for nvs_get_str and nvs_get_blob, in this"]
    #[doc = "                           case required length will be returned in length argument."]
    #[doc = " @param[inout]  length     A non-zero pointer to the variable holding the length of out_value."]
    #[doc = "                           In case out_value a zero, will be set to the length"]
    #[doc = "                           required to hold the value. In case out_value is not"]
    #[doc = "                           zero, will be set to the actual length of the value"]
    #[doc = "                           written. For nvs_get_str this includes zero terminator."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the value was retrieved successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data"]
    pub fn nvs_get_str(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut c_types::c_char,
        length: *mut size_t,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_blob(
        handle: nvs_handle,
        key: *const c_types::c_char,
        out_value: *mut c_types::c_void,
        length: *mut size_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase key-value pair with given key name."]
    #[doc = ""]
    #[doc = " Note that actual storage may not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @param[in]  key     Key name. Maximal length is determined by the underlying"]
    #[doc = "                     implementation, but is guaranteed to be at least"]
    #[doc = "                     15 characters. Shouldn't be empty."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "              - ESP_OK if erase operation was successful"]
    #[doc = "              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only"]
    #[doc = "              - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_key(handle: nvs_handle, key: *const c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase all key-value pairs in a namespace"]
    #[doc = ""]
    #[doc = " Note that actual storage may not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "              - ESP_OK if erase operation was successful"]
    #[doc = "              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only"]
    #[doc = "              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_all(handle: nvs_handle) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Write any pending changes to non-volatile storage"]
    #[doc = ""]
    #[doc = " After setting any values, nvs_commit() must be called to ensure changes are written"]
    #[doc = " to non-volatile storage. Individual implementations may write to storage at other times,"]
    #[doc = " but this is not guaranteed."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the changes have been written successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_commit(handle: nvs_handle) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Close the storage handle and free any allocated resources"]
    #[doc = ""]
    #[doc = " This function should be called for each handle opened with nvs_open once"]
    #[doc = " the handle is not in use any more. Closing the handle may not automatically"]
    #[doc = " write the changes to nonvolatile storage. This has to be done explicitly using"]
    #[doc = " nvs_commit function."]
    #[doc = " Once this function is called on a handle, the handle should no longer be used."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle to close"]
    pub fn nvs_close(handle: nvs_handle);
}
extern "C" {
    #[doc = " @brief Initialize the default NVS partition."]
    #[doc = ""]
    #[doc = " This API initialises the default NVS partition. The default NVS partition"]
    #[doc = " is the one that is labeled \"nvs\" in the partition table."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the specified partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition. Note that internally a reference to"]
    #[doc = "                               passed value is kept and it should be accessible for future operations"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if specified partition is not found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init_partition(partition_label: *const c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the default NVS partition"]
    #[doc = ""]
    #[doc = " Default NVS partition is the partition with \"nvs\" label in the partition table."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success (storage was deinitialized)"]
    #[doc = "      - ESP_ERR_NVS_NOT_INITIALIZED if the storage was not initialized prior to this call"]
    pub fn nvs_flash_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the given NVS partition"]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NVS_NOT_INITIALIZED if the storage for given partition was not"]
    #[doc = "        initialized prior to this call"]
    pub fn nvs_flash_deinit_partition(partition_label: *const c_types::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase the default NVS partition"]
    #[doc = ""]
    #[doc = " This function erases all contents of the default NVS partition (one with label \"nvs\")"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if there is no NVS partition labeled \"nvs\" in the"]
    #[doc = "        partition table"]
    pub fn nvs_flash_erase() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase specified NVS partition"]
    #[doc = ""]
    #[doc = " This function erases all contents of specified NVS partition"]
    #[doc = ""]
    #[doc = " @param[in]  part_name    Name (label) of the partition to be erased"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if there is no NVS partition with the specified name"]
    #[doc = "        in the partition table"]
    pub fn nvs_flash_erase_partition(part_name: *const c_types::c_char) -> esp_err_t;
}
pub const adc_mode_t_ADC_READ_TOUT_MODE: adc_mode_t = 0;
pub const adc_mode_t_ADC_READ_VDD_MODE: adc_mode_t = 1;
pub const adc_mode_t_ADC_READ_MAX_MODE: adc_mode_t = 2;
#[doc = " @brief ADC working mode enumeration"]
pub type adc_mode_t = c_types::c_uint;
#[doc = " @brief ADC initialization parameter structure type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_config_t {
    #[doc = "< ADC mode"]
    pub mode: adc_mode_t,
    #[doc = "< ADC sample collection clock=80M/clk_div, range[8, 32]"]
    pub clk_div: u8,
}
extern "C" {
    #[doc = " @brief Single measurement of TOUT(ADC) pin, unit : 1/1023 V or VDD pin, uint: 1 mV"]
    #[doc = ""]
    #[doc = " @note When measuring VDD pin voltage, the TOUT(ADC) pin must be left floating."]
    #[doc = ""]
    #[doc = " @param data Pointer to accept adc value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL adc has not been initialized yet"]
    pub fn adc_read(data: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Measure the input voltage of TOUT(ADC) pin, unit : 1/1023 V."]
    #[doc = ""]
    #[doc = " @note Wi-Fi and interrupts need to be turned off."]
    #[doc = ""]
    #[doc = " @param data Pointer to accept adc value. Input voltage of TOUT(ADC) pin, unit : 1/1023 V"]
    #[doc = " @param len Receiving length of ADC value, range [1, 65535]"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL adc has not been initialized yet"]
    pub fn adc_read_fast(data: *mut u16, len: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinit the adc"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL adc has not been initialized yet"]
    pub fn adc_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the adc"]
    #[doc = ""]
    #[doc = " @note First modify menuconfig->Component config->PHY->vdd33_const value, vdd33_const provides ADC mode settings,"]
    #[doc = "       i.e. selecting system voltage or external voltage measurements."]
    #[doc = "       When measuring system voltage, it must be set to 255."]
    #[doc = "       To read the external voltage on TOUT(ADC) pin, vdd33_const need less than 255"]
    #[doc = "       When the ADC reference voltage is set to the actual VDD33 power supply voltage, the value range of vdd33_const is [18,36], the unit is 0.1V."]
    #[doc = "       When the ADC reference voltage is set to the default value of 3.3V as the supply voltage, the range of vdd33_const is [0, 18] or (36, 255)."]
    #[doc = ""]
    #[doc = " @param config Pointer to deliver initialize configuration parameter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM malloc fail"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL adc has been initialized"]
    pub fn adc_init(config: *mut adc_config_t) -> esp_err_t;
}
pub type hw_timer_callback_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>;
pub const hw_timer_clkdiv_t_TIMER_CLKDIV_1: hw_timer_clkdiv_t = 0;
pub const hw_timer_clkdiv_t_TIMER_CLKDIV_16: hw_timer_clkdiv_t = 4;
pub const hw_timer_clkdiv_t_TIMER_CLKDIV_256: hw_timer_clkdiv_t = 8;
pub type hw_timer_clkdiv_t = c_types::c_uint;
pub const hw_timer_intr_type_t_TIMER_EDGE_INT: hw_timer_intr_type_t = 0;
pub const hw_timer_intr_type_t_TIMER_LEVEL_INT: hw_timer_intr_type_t = 1;
pub type hw_timer_intr_type_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Set the frequency division coefficient of hardware timer"]
    #[doc = ""]
    #[doc = " @param clkdiv frequency division coefficient"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL hardware timer has been initialized"]
    pub fn hw_timer_set_clkdiv(clkdiv: hw_timer_clkdiv_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the frequency division coefficient of hardware timer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 TIMER_CLKDIV_1"]
    #[doc = "     - 4 TIMER_CLKDIV_16"]
    #[doc = "     - 8 TIMER_CLKDIV_256"]
    pub fn hw_timer_get_clkdiv() -> u32;
}
extern "C" {
    #[doc = " @brief Set the interrupt type of hardware timer"]
    #[doc = ""]
    #[doc = " @param intr_type interrupt type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL hardware timer has been initialized"]
    pub fn hw_timer_set_intr_type(intr_type: hw_timer_intr_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the interrupt type of hardware timer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 TIMER_EDGE_INT"]
    #[doc = "     - 1 TIMER_LEVEL_INT"]
    pub fn hw_timer_get_intr_type() -> u32;
}
extern "C" {
    #[doc = " @brief Enable hardware timer reload"]
    #[doc = ""]
    #[doc = " @param reload false, one-shot mode; true, reload mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL hardware timer has been initialized"]
    pub fn hw_timer_set_reload(reload: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the hardware timer reload status"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - true reload mode"]
    #[doc = "     - false one-shot mode"]
    pub fn hw_timer_get_reload() -> bool;
}
extern "C" {
    #[doc = " @brief Enable hardware timer"]
    #[doc = ""]
    #[doc = " @param en false, hardware timer disable; true, hardware timer enable"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL hardware timer has been initialized"]
    pub fn hw_timer_enable(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the hardware timer enable status"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - true hardware timer has been enabled"]
    #[doc = "     - false hardware timer is not yet enabled"]
    pub fn hw_timer_get_enable() -> bool;
}
extern "C" {
    #[doc = " @brief Set the hardware timer load value"]
    #[doc = ""]
    #[doc = " @param load_data hardware timer load value"]
    #[doc = "     - FRC1 hardware timer, range : less than 0x1000000"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL hardware timer has been initialized"]
    pub fn hw_timer_set_load_data(load_data: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the hardware timer load value"]
    #[doc = ""]
    #[doc = " @return load value"]
    pub fn hw_timer_get_load_data() -> u32;
}
extern "C" {
    #[doc = " @brief Get the hardware timer count value"]
    #[doc = ""]
    #[doc = " @return count value"]
    pub fn hw_timer_get_count_data() -> u32;
}
extern "C" {
    #[doc = " @brief deinit the hardware timer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL hardware timer has not been initialized yet"]
    pub fn hw_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the hardware timer"]
    #[doc = ""]
    #[doc = " @param callback user hardware timer callback function"]
    #[doc = " @param arg parameter for ISR handler"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL hardware timer has been initialized"]
    pub fn hw_timer_init(callback: hw_timer_callback_t, arg: *mut c_types::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set a trigger timer us delay to enable this timer"]
    #[doc = ""]
    #[doc = " @param value"]
    #[doc = "     - If reload is true, range : 50 ~ 0x199999"]
    #[doc = "     - If reload is false, range : 10 ~ 0x199999"]
    #[doc = " @param reload false, one-shot mode; true, reload mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL hardware timer has not been initialized yet"]
    pub fn hw_timer_alarm_us(value: u32, reload: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief disable this timer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL hardware timer has not been initialized yet"]
    pub fn hw_timer_disarm() -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: c_types::c_int,
    pub rem: c_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: c_types::c_long,
    pub rem: c_types::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: c_types::c_longlong,
    pub rem: c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const c_types::c_void,
        arg2: *const c_types::c_void,
    ) -> c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> c_types::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut c_types::c_void, arg2: size_t);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const c_types::c_void,
        __base: *const c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: c_types::c_uint, __size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn div(__numer: c_types::c_int, __denom: c_types::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: c_types::c_int);
}
extern "C" {
    pub fn free(arg1: *mut c_types::c_void);
}
extern "C" {
    pub fn getenv(__string: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(arg1: *mut _reent, __string: *const c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const c_types::c_char,
        arg2: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut c_types::c_char,
        arg2: *const *mut c_types::c_char,
        arg3: *mut *mut c_types::c_char,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: c_types::c_long) -> c_types::c_long;
}
extern "C" {
    pub fn ldiv(__numer: c_types::c_long, __denom: c_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const c_types::c_char, arg2: size_t) -> c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: size_t,
        arg4: *mut _mbstate_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const c_types::c_char, arg3: size_t)
        -> c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut c_types::c_char, arg2: wchar_t) -> c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const c_types::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const c_types::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(arg1: *mut c_types::c_char, arg2: *const wchar_t, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: *const wchar_t,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut c_types::c_char, arg2: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
        arg4: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> c_types::c_int;
}
extern "C" {
    pub fn realloc(__r: *mut c_types::c_void, __size: c_types::c_uint) -> *mut c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut c_types::c_void, __size: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const c_types::c_char,
        resolved_path: *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: c_types::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const c_types::c_char, __end_PTR: *mut *mut c_types::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const c_types::c_char, __end_PTR: *mut *mut c_types::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const c_types::c_char) -> c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: c_types::c_long) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: c_types::c_long) -> *mut c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: c_types::c_int, arg2: *mut c_types::c_void),
        >,
        __arg: *mut c_types::c_void,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: c_types::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        arg3: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const c_types::c_char,
        __value: *const c_types::c_char,
        __overwrite: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const c_types::c_char,
        __value: *const c_types::c_char,
        __overwrite: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: c_types::c_int,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: c_types::c_uint,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: c_types::c_int,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: c_types::c_uint,
        arg2: *mut c_types::c_char,
        arg3: c_types::c_int,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut c_types::c_uint) -> c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> c_types::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut c_types::c_ushort) -> *mut c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(arg1: *mut _reent, arg2: *mut c_types::c_ushort) -> *mut c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: c_types::c_uint,
        arg2: *mut c_types::c_char,
        arg3: size_t,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn random() -> c_types::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut c_types::c_char) -> *mut c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: c_types::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const c_types::c_char) -> c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(arg1: *mut _reent, __nptr: *const c_types::c_char) -> c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: c_types::c_longlong) -> c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: c_types::c_longlong, __denom: c_types::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const c_types::c_char,
        __end_PTR: *mut *mut c_types::c_char,
        __base: c_types::c_int,
    ) -> c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut c_types::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(arg1: *mut _reent, __string: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut c_types::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: c_types::c_int,
        arg4: c_types::c_int,
        arg5: *mut c_types::c_int,
        arg6: *mut c_types::c_int,
        arg7: *mut *mut c_types::c_char,
    ) -> *mut c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: size_t, arg3: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut c_types::c_void,
        arg3: size_t,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut c_types::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const c_types::c_char) -> c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const c_types::c_char,
        arg2: *const c_types::c_char,
        arg3: c_types::c_uint,
        arg4: *const c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut c_types::c_void,
        __nmemb: size_t,
        __size: size_t,
        __thunk: *mut c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut c_types::c_void,
                arg2: *const c_types::c_void,
                arg3: *const c_types::c_void,
            ) -> c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const c_types::c_char,
        arg3: *mut *mut c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const c_types::c_char, arg2: *mut *mut c_types::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(arg1: size_t, arg2: size_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: c_types::c_int);
}
pub type TaskFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>;
extern "C" {
    pub static Xthal_rev_no: c_types::c_uint;
}
extern "C" {
    pub fn xthal_save_extra(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_extra(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cpregs(base: *mut c_types::c_void, arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_restore_cpregs(base: *mut c_types::c_void, arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_save_cp0(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp1(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp2(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp3(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp4(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp5(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp6(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_save_cp7(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp0(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp1(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp2(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp3(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp4(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp5(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp6(base: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_restore_cp7(base: *mut c_types::c_void);
}
extern "C" {
    pub static mut Xthal_cpregs_save_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_save_nw_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_nw_fn: [*mut c_types::c_void; 8usize];
}
extern "C" {
    pub static Xthal_extra_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_extra_align: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cpregs_size: [c_types::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_cpregs_align: [c_types::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_all_extra_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_all_extra_align: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_names: [*const c_types::c_char; 8usize];
}
extern "C" {
    pub fn xthal_init_mem_extra(arg1: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_init_mem_cp(arg1: *mut c_types::c_void, arg2: c_types::c_int);
}
extern "C" {
    pub static Xthal_num_coprocessors: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_num: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_max: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask: c_types::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs: c_types::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs_log2: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linewidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_linewidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linesize: c_types::c_ushort;
}
extern "C" {
    pub static Xthal_dcache_linesize: c_types::c_ushort;
}
extern "C" {
    pub static Xthal_icache_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_dcache_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_dcache_is_writeback: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_icache_region_invalidate(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_invalidate(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_invalidate(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_invalidate(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_line_writeback(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback_inv(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_line_writeback_inv(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_icache_sync();
}
extern "C" {
    pub fn xthal_dcache_sync();
}
extern "C" {
    pub fn xthal_cache_coherence_on();
}
extern "C" {
    pub fn xthal_cache_coherence_off();
}
extern "C" {
    pub fn xthal_cache_coherence_optin();
}
extern "C" {
    pub fn xthal_cache_coherence_optout();
}
extern "C" {
    pub fn xthal_set_cache_prefetch(arg1: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_get_cache_prefetch() -> c_types::c_int;
}
extern "C" {
    pub static Xthal_debug_configured: c_types::c_int;
}
extern "C" {
    pub fn xthal_set_soft_break(addr: *mut c_types::c_void) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_remove_soft_break(addr: *mut c_types::c_void, arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_disassemble(
        instr_buf: *mut c_types::c_uchar,
        tgt_addr: *mut c_types::c_void,
        buffer: *mut c_types::c_char,
        buflen: c_types::c_uint,
        options: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_disassemble_size(instr_buf: *mut c_types::c_uchar) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_memcpy(
        dst: *mut c_types::c_void,
        src: *const c_types::c_void,
        len: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn xthal_bcopy(
        src: *const c_types::c_void,
        dst: *mut c_types::c_void,
        len: c_types::c_uint,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn xthal_compare_and_set(
        addr: *mut c_types::c_int,
        test_val: c_types::c_int,
        compare_val: c_types::c_int,
    ) -> c_types::c_int;
}
extern "C" {
    pub static Xthal_release_major: c_types::c_uint;
}
extern "C" {
    pub static Xthal_release_minor: c_types::c_uint;
}
extern "C" {
    pub static Xthal_release_name: *const c_types::c_char;
}
extern "C" {
    pub static Xthal_release_internal: *const c_types::c_char;
}
extern "C" {
    pub static Xthal_memory_order: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_windowed: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_density: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_booleans: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_loops: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_nsa: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_minmax: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_sext: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_clamps: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_mac16: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_mul16: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_fp: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_speculation: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_threadptr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_pif: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_writebuffer_entries: c_types::c_ushort;
}
extern "C" {
    pub static Xthal_build_unique_id: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid0: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid1: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_major: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_minor: c_types::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_name: *const c_types::c_char;
}
extern "C" {
    pub static Xthal_hw_release_internal: *const c_types::c_char;
}
extern "C" {
    pub fn xthal_window_spill();
}
extern "C" {
    pub fn xthal_validate_cp(arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_invalidate_cp(arg1: c_types::c_int);
}
extern "C" {
    pub fn xthal_set_cpenable(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_cpenable() -> c_types::c_uint;
}
extern "C" {
    pub static Xthal_num_intlevels: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_interrupts: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_intlevel_mask: [c_types::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel_andbelow_mask: [c_types::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel: [c_types::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype: [c_types::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype_mask: [c_types::c_uint; 7usize];
}
extern "C" {
    pub static Xthal_timer_interrupt: [c_types::c_int; 4usize];
}
extern "C" {
    pub fn xthal_get_intenable() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_intenable(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_interrupt() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_intset(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_intclear(arg1: c_types::c_uint);
}
extern "C" {
    pub static Xthal_num_ibreak: c_types::c_int;
}
extern "C" {
    pub static Xthal_num_dbreak: c_types::c_int;
}
extern "C" {
    pub static Xthal_have_ccount: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_ccompare: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_get_ccount() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_ccompare(arg1: c_types::c_int, arg2: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_ccompare(arg1: c_types::c_int) -> c_types::c_uint;
}
extern "C" {
    pub static Xthal_have_prid: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_exceptions: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_xea_version: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_interrupts: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_highlevel_interrupts: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_nmi: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_get_prid() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_vpri_to_intlevel(vpri: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_intlevel_to_vpri(intlevel: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_int_enable(arg1: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_int_disable(arg1: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_int_vpri(intnum: c_types::c_int, vpri: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_get_int_vpri(intnum: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_vpri_locklevel(intlevel: c_types::c_uint);
}
extern "C" {
    pub fn xthal_get_vpri_locklevel() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri(vpri: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_get_vpri() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_intlevel(intlevel: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_lock() -> c_types::c_uint;
}
pub type XtHalVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut Xthal_tram_pending: c_types::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_enabled: c_types::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_sync: c_types::c_uint;
}
extern "C" {
    pub fn xthal_tram_pending_to_service() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_tram_done(serviced_mask: c_types::c_uint);
}
extern "C" {
    pub fn xthal_tram_set_sync(intnum: c_types::c_int, sync: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_set_tram_trigger_func(trigger_fn: XtHalVoidFunc) -> XtHalVoidFunc;
}
extern "C" {
    pub static Xthal_num_instrom: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_instram: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_datarom: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_dataram: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_num_xlmi: c_types::c_uchar;
}
extern "C" {
    pub static mut Xthal_instrom_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_vaddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_paddr: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_size: [c_types::c_uint; 0usize];
}
extern "C" {
    pub static Xthal_icache_setwidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_setwidth: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_icache_ways: c_types::c_uint;
}
extern "C" {
    pub static Xthal_dcache_ways: c_types::c_uint;
}
extern "C" {
    pub static Xthal_icache_line_lockable: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_line_lockable: c_types::c_uchar;
}
extern "C" {
    pub fn xthal_get_cacheattr() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_get_icacheattr() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_get_dcacheattr() -> c_types::c_uint;
}
extern "C" {
    pub fn xthal_set_cacheattr(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_icacheattr(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_dcacheattr(arg1: c_types::c_uint);
}
extern "C" {
    pub fn xthal_set_region_attribute(
        addr: *mut c_types::c_void,
        size: c_types::c_uint,
        cattr: c_types::c_uint,
        flags: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub fn xthal_icache_enable();
}
extern "C" {
    pub fn xthal_dcache_enable();
}
extern "C" {
    pub fn xthal_icache_disable();
}
extern "C" {
    pub fn xthal_dcache_disable();
}
extern "C" {
    pub fn xthal_icache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_writeback();
}
extern "C" {
    pub fn xthal_dcache_all_writeback_inv();
}
extern "C" {
    pub fn xthal_icache_region_lock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_lock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_lock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_lock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_icache_all_unlock();
}
extern "C" {
    pub fn xthal_dcache_all_unlock();
}
extern "C" {
    pub fn xthal_icache_region_unlock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_unlock(addr: *mut c_types::c_void, size: c_types::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_unlock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_unlock(addr: *mut c_types::c_void);
}
extern "C" {
    pub fn xthal_memep_inject_error(
        addr: *mut c_types::c_void,
        size: c_types::c_int,
        flags: c_types::c_int,
    );
}
extern "C" {
    pub static Xthal_have_spanning_way: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_identity_map: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_mimic_cacheattr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_xlt_cacheattr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_cacheattr: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_have_tlbs: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_kernel: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_rings: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ring_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_sr_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ca_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_max_pte_page_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_mmu_min_pte_page_size: c_types::c_uint;
}
extern "C" {
    pub static Xthal_itlb_way_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_ways: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_arf_ways: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_way_bits: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_ways: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_arf_ways: c_types::c_uchar;
}
extern "C" {
    #[doc = " WARNING: these two functions may go away in a future release; don't depend on them!"]
    pub fn xthal_static_v2p(vaddr: c_types::c_uint, paddrp: *mut c_types::c_uint)
        -> c_types::c_int;
}
extern "C" {
    pub fn xthal_static_p2v(
        paddr: c_types::c_uint,
        vaddrp: *mut c_types::c_uint,
        cached: c_types::c_uint,
    ) -> c_types::c_int;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP0_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP0_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP1_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP1_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP2_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP2_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP3_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP3_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP4_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP4_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP5_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP5_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP6_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP6_IDENT: c_types::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP7_IDENT: c_types::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP7_IDENT: c_types::c_uint;
}
pub type _xtos_handler_func = ::core::option::Option<unsafe extern "C" fn()>;
pub type _xtos_handler = _xtos_handler_func;
extern "C" {
    pub fn _xtos_ints_off(mask: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_ints_on(mask: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_set_intlevel(intlevel: c_types::c_int) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_set_min_intlevel(intlevel: c_types::c_int) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_restore_intlevel(restoreval: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_restore_just_intlevel(restoreval: c_types::c_uint) -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler(n: c_types::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler_arg(
        n: c_types::c_int,
        f: _xtos_handler,
        arg: *mut c_types::c_void,
    ) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_exception_handler(n: c_types::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_memep_initrams();
}
extern "C" {
    pub fn _xtos_memep_enable(flags: c_types::c_int);
}
extern "C" {
    pub fn _xtos_read_ints() -> c_types::c_uint;
}
extern "C" {
    pub fn _xtos_clear_ints(mask: c_types::c_uint);
}
extern "C" {
    pub fn _xtos_timer_0_delta(cycles: c_types::c_int);
}
extern "C" {
    pub fn _xt_int_enter();
}
extern "C" {
    pub fn _xt_int_exit();
}
extern "C" {
    pub fn _xt_timer_int();
}
pub type XT_INTEXC_HOOK =
    ::core::option::Option<unsafe extern "C" fn(cause: c_types::c_uint) -> c_types::c_uint>;
extern "C" {
    pub static mut _xt_intexc_hooks: [XT_INTEXC_HOOK; 4usize];
}
extern "C" {
    pub static mut _xt_tick_divisor: c_types::c_uint;
}
pub type portTickType = c_types::c_ulong;
pub type INT32U = c_types::c_uint;
extern "C" {
    pub fn PendSV(req: c_types::c_int);
}
extern "C" {
    pub static mut cpu_sr: c_types::c_uint;
}
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
extern "C" {
    pub fn PortDisableInt_NoNest();
}
extern "C" {
    pub fn PortEnableInt_NoNest();
}
extern "C" {
    pub fn _xt_user_exit();
}
extern "C" {
    pub fn _xt_tick_timer_init();
}
extern "C" {
    pub fn _xt_isr_unmask(unmask: u32);
}
extern "C" {
    pub fn _xt_isr_mask(mask: u32);
}
pub type _xt_isr = ::core::option::Option<unsafe extern "C" fn(arg: *mut c_types::c_void)>;
extern "C" {
    pub fn _xt_isr_attach(i: u8, func: _xt_isr, arg: *mut c_types::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xt_isr_entry_ {
    pub handler: _xt_isr,
    pub arg: *mut c_types::c_void,
}
pub type _xt_isr_entry = _xt_isr_entry_;
extern "C" {
    pub fn show_critical_info();
}
extern "C" {
    pub fn esp_mem_trace(
        ptr: *const c_types::c_void,
        trace: *const c_types::c_char,
        no: c_types::c_int,
    );
}
extern "C" {
    pub fn interrupt_is_disable() -> bool;
}
extern "C" {
    pub fn xPortGetTickRateHz() -> u32;
}
extern "C" {
    pub fn _xt_enter_first_task();
}
extern "C" {
    pub fn esp_increase_tick_cnt(ticks: c_types::c_ulong);
}
extern "C" {
    pub fn esp_vApplicationIdleHook();
}
extern "C" {
    pub fn esp_vApplicationTickHook();
}
extern "C" {
    pub static g_esp_ticks_per_us: u32;
}
extern "C" {
    pub fn prvGetExpectedIdleTime() -> c_types::c_ulong;
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut c_types::c_uchar,
        pxCode: TaskFunction_t,
        pvParameters: *mut c_types::c_void,
    ) -> *mut c_types::c_uchar;
}
extern "C" {
    pub fn xPortStartScheduler() -> c_types::c_long;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn xPortInIsrContext() -> c_types::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy1: c_types::c_ulong,
    pub pvDummy2: [*mut c_types::c_void; 4usize],
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy1: c_types::c_ulong,
    pub pvDummy2: [*mut c_types::c_void; 2usize],
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy1: c_types::c_ulong,
    pub pvDummy2: *mut c_types::c_void,
    pub xDummy3: StaticMiniListItem_t,
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut c_types::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: c_types::c_ulong,
    pub pxDummy6: *mut c_types::c_void,
    pub ucDummy7: [u8; 16usize],
    pub pxDummy8: *mut c_types::c_void,
    pub uxDummy12: [c_types::c_ulong; 2usize],
    pub pvDummy15: [*mut c_types::c_void; 1usize],
    pub ulDummy18: u32,
    pub ucDummy19: u8,
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut c_types::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [c_types::c_ulong; 3usize],
    pub ucDummy5: [u8; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut c_types::c_void,
    pub uxDummy2: c_types::c_ulong,
    _bindgen_union_align: u32,
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: c_types::c_ulong,
    pub xDummy2: StaticList_t,
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut c_types::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: c_types::c_ulong,
    pub uxDummy4: c_types::c_ulong,
    pub pvDummy5: [*mut c_types::c_void; 2usize],
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [size_t; 4usize],
    pub pvDummy2: [*mut c_types::c_void; 3usize],
    pub ucDummy3: u8,
}
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[doc = "< I2C master mode"]
pub const i2c_mode_t_I2C_MODE_MASTER: i2c_mode_t = 0;
pub const i2c_mode_t_I2C_MODE_MAX: i2c_mode_t = 1;
pub type i2c_mode_t = c_types::c_uint;
#[doc = "< I2C write data"]
pub const i2c_rw_t_I2C_MASTER_WRITE: i2c_rw_t = 0;
#[doc = "< I2C read data"]
pub const i2c_rw_t_I2C_MASTER_READ: i2c_rw_t = 1;
pub type i2c_rw_t = c_types::c_uint;
#[doc = "< I2C restart command"]
pub const i2c_opmode_t_I2C_CMD_RESTART: i2c_opmode_t = 0;
#[doc = "< I2C write command"]
pub const i2c_opmode_t_I2C_CMD_WRITE: i2c_opmode_t = 1;
#[doc = "< I2C read command"]
pub const i2c_opmode_t_I2C_CMD_READ: i2c_opmode_t = 2;
#[doc = "< I2C stop command"]
pub const i2c_opmode_t_I2C_CMD_STOP: i2c_opmode_t = 3;
pub type i2c_opmode_t = c_types::c_uint;
#[doc = "< I2C port 0"]
pub const i2c_port_t_I2C_NUM_0: i2c_port_t = 0;
pub const i2c_port_t_I2C_NUM_MAX: i2c_port_t = 1;
pub type i2c_port_t = c_types::c_uint;
#[doc = "< I2C ack for each byte read"]
pub const i2c_ack_type_t_I2C_MASTER_ACK: i2c_ack_type_t = 0;
#[doc = "< I2C nack for each byte read"]
pub const i2c_ack_type_t_I2C_MASTER_NACK: i2c_ack_type_t = 1;
#[doc = "< I2C nack for the last byte"]
pub const i2c_ack_type_t_I2C_MASTER_LAST_NACK: i2c_ack_type_t = 2;
pub const i2c_ack_type_t_I2C_MASTER_ACK_MAX: i2c_ack_type_t = 3;
pub type i2c_ack_type_t = c_types::c_uint;
#[doc = " @brief I2C initialization parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_config_t {
    #[doc = "< I2C mode"]
    pub mode: i2c_mode_t,
    #[doc = "< GPIO number for I2C sda signal"]
    pub sda_io_num: gpio_num_t,
    #[doc = "< Internal GPIO pull mode for I2C sda signal"]
    pub sda_pullup_en: gpio_pullup_t,
    #[doc = "< GPIO number for I2C scl signal"]
    pub scl_io_num: gpio_num_t,
    #[doc = "< Internal GPIO pull mode for I2C scl signal"]
    pub scl_pullup_en: gpio_pullup_t,
    #[doc = "< Clock Stretch time, depending on CPU frequency"]
    pub clk_stretch_tick: u32,
}
pub type i2c_cmd_handle_t = *mut c_types::c_void;
extern "C" {
    #[doc = " @brief I2C driver install"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param mode I2C mode( master or slave )"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Driver install error"]
    pub fn i2c_driver_install(i2c_num: i2c_port_t, mode: i2c_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C driver delete"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_driver_delete(i2c_num: i2c_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C parameter initialization"]
    #[doc = ""]
    #[doc = " @note It must be used after calling i2c_driver_install"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param i2c_conf pointer to I2C parameter settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_param_config(i2c_num: i2c_port_t, i2c_conf: *const i2c_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure GPIO signal for I2C sck and sda"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param sda_io_num GPIO number for I2C sda signal"]
    #[doc = " @param scl_io_num GPIO number for I2C scl signal"]
    #[doc = " @param sda_pullup_en Whether to enable the internal pullup for sda pin"]
    #[doc = " @param scl_pullup_en Whether to enable the internal pullup for scl pin"]
    #[doc = " @param mode I2C mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_set_pin(
        i2c_num: i2c_port_t,
        sda_io_num: c_types::c_int,
        scl_io_num: c_types::c_int,
        sda_pullup_en: gpio_pullup_t,
        scl_pullup_en: gpio_pullup_t,
        mode: i2c_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create and init I2C command link"]
    #[doc = "        @note"]
    #[doc = "        Before we build I2C command link, we need to call i2c_cmd_link_create() to create"]
    #[doc = "        a command link."]
    #[doc = "        After we finish sending the commands, we need to call i2c_cmd_link_delete() to"]
    #[doc = "        release and return the resources."]
    #[doc = ""]
    #[doc = " @return i2c command link handler"]
    pub fn i2c_cmd_link_create() -> i2c_cmd_handle_t;
}
extern "C" {
    #[doc = " @brief Free I2C command link"]
    #[doc = "        @note"]
    #[doc = "        Before we build I2C command link, we need to call i2c_cmd_link_create() to create"]
    #[doc = "        a command link."]
    #[doc = "        After we finish sending the commands, we need to call i2c_cmd_link_delete() to"]
    #[doc = "        release and return the resources."]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C command handle"]
    pub fn i2c_cmd_link_delete(cmd_handle: i2c_cmd_handle_t);
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to generate a start signal"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_start(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to write one byte to I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data I2C one byte command to write to bus"]
    #[doc = " @param ack_en enable ack check for master"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_write_byte(cmd_handle: i2c_cmd_handle_t, data: u8, ack_en: bool)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to write buffer to I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data data to send"]
    #[doc = " @param data_len data length"]
    #[doc = " @param ack_en enable ack check for master"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_write(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        data_len: size_t,
        ack_en: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to read one byte from I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data pointer accept the data byte"]
    #[doc = " @param ack ack value for read command"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_read_byte(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to read data from I2C bus"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = " @param data data buffer to accept the data from bus"]
    #[doc = " @param data_len read data length"]
    #[doc = " @param ack ack value for read command"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_read(
        cmd_handle: i2c_cmd_handle_t,
        data: *mut u8,
        data_len: size_t,
        ack: i2c_ack_type_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Queue command for I2C master to generate a stop signal"]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = "        Call i2c_master_cmd_begin() to send all queued commands"]
    #[doc = ""]
    #[doc = " @param cmd_handle I2C cmd link"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2c_master_stop(cmd_handle: i2c_cmd_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief I2C master send queued commands."]
    #[doc = "        This function will trigger sending all queued commands."]
    #[doc = "        The task will be blocked until all the commands have been sent out."]
    #[doc = "        The I2C APIs are not thread-safe, if you want to use one I2C port in different tasks,"]
    #[doc = "        you need to take care of the multi-thread issue."]
    #[doc = "        @note"]
    #[doc = "        Only call this function in I2C master mode"]
    #[doc = ""]
    #[doc = " @param i2c_num I2C port number"]
    #[doc = " @param cmd_handle I2C command handler"]
    #[doc = " @param ticks_to_wait maximum wait ticks."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Sending command error, slave doesn't ACK the transfer."]
    #[doc = "     - ESP_ERR_INVALID_STATE I2C driver not installed or not in master mode."]
    #[doc = "     - ESP_ERR_TIMEOUT Operation timeout because the bus is busy."]
    pub fn i2c_master_cmd_begin(
        i2c_num: i2c_port_t,
        cmd_handle: i2c_cmd_handle_t,
        ticks_to_wait: c_types::c_ulong,
    ) -> esp_err_t;
}
#[doc = "< I2S bits per sample: 8-bits"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_8BIT: i2s_bits_per_sample_t = 8;
#[doc = "< I2S bits per sample: 16-bits"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_16BIT: i2s_bits_per_sample_t = 16;
#[doc = "< I2S bits per sample: 24-bits"]
pub const i2s_bits_per_sample_t_I2S_BITS_PER_SAMPLE_24BIT: i2s_bits_per_sample_t = 24;
#[doc = " @brief I2S bit width per sample."]
pub type i2s_bits_per_sample_t = c_types::c_uint;
#[doc = "< I2S 1 channel (mono)"]
pub const i2s_channel_t_I2S_CHANNEL_MONO: i2s_channel_t = 1;
#[doc = "< I2S 2 channel (stereo)"]
pub const i2s_channel_t_I2S_CHANNEL_STEREO: i2s_channel_t = 2;
#[doc = " @brief I2S channel."]
pub type i2s_channel_t = c_types::c_uint;
#[doc = "< I2S communication format I2S"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S: i2s_comm_format_t = 1;
#[doc = "< I2S format MSB"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S_MSB: i2s_comm_format_t = 2;
#[doc = "< I2S format LSB"]
pub const i2s_comm_format_t_I2S_COMM_FORMAT_I2S_LSB: i2s_comm_format_t = 4;
#[doc = " @brief I2S communication standard format"]
pub type i2s_comm_format_t = c_types::c_uint;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_RIGHT_LEFT: i2s_channel_fmt_t = 0;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ALL_RIGHT: i2s_channel_fmt_t = 1;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ALL_LEFT: i2s_channel_fmt_t = 2;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ONLY_RIGHT: i2s_channel_fmt_t = 3;
pub const i2s_channel_fmt_t_I2S_CHANNEL_FMT_ONLY_LEFT: i2s_channel_fmt_t = 4;
#[doc = " @brief I2S channel format type"]
pub type i2s_channel_fmt_t = c_types::c_uint;
#[doc = "< I2S 0"]
pub const i2s_port_t_I2S_NUM_0: i2s_port_t = 0;
pub const i2s_port_t_I2S_NUM_MAX: i2s_port_t = 1;
#[doc = " @brief I2S Peripheral, 0"]
pub type i2s_port_t = c_types::c_uint;
pub const i2s_mode_t_I2S_MODE_MASTER: i2s_mode_t = 1;
pub const i2s_mode_t_I2S_MODE_SLAVE: i2s_mode_t = 2;
pub const i2s_mode_t_I2S_MODE_TX: i2s_mode_t = 4;
pub const i2s_mode_t_I2S_MODE_RX: i2s_mode_t = 8;
#[doc = " @brief I2S Mode, defaut is I2S_MODE_MASTER | I2S_MODE_TX"]
pub type i2s_mode_t = c_types::c_uint;
#[doc = " @brief I2S configuration parameters for i2s_param_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_config_t {
    #[doc = "< I2S work mode"]
    pub mode: i2s_mode_t,
    #[doc = "< I2S sample rate"]
    pub sample_rate: c_types::c_int,
    #[doc = "< I2S bits per sample"]
    pub bits_per_sample: i2s_bits_per_sample_t,
    #[doc = "< I2S channel format"]
    pub channel_format: i2s_channel_fmt_t,
    #[doc = "< I2S communication format"]
    pub communication_format: i2s_comm_format_t,
    #[doc = "< I2S DMA Buffer Count"]
    pub dma_buf_count: c_types::c_int,
    #[doc = "< I2S DMA Buffer Length"]
    pub dma_buf_len: c_types::c_int,
    #[doc = "< I2S auto clear tx descriptor if there is underflow condition (helps in avoiding noise in case of data unavailability)"]
    pub tx_desc_auto_clear: bool,
}
pub const i2s_event_type_t_I2S_EVENT_DMA_ERROR: i2s_event_type_t = 0;
#[doc = "< I2S DMA finish sent 1 buffer"]
pub const i2s_event_type_t_I2S_EVENT_TX_DONE: i2s_event_type_t = 1;
#[doc = "< I2S DMA finish received 1 buffer"]
pub const i2s_event_type_t_I2S_EVENT_RX_DONE: i2s_event_type_t = 2;
#[doc = "< I2S event max index"]
pub const i2s_event_type_t_I2S_EVENT_MAX: i2s_event_type_t = 3;
#[doc = " @brief I2S event types"]
pub type i2s_event_type_t = c_types::c_uint;
#[doc = " @brief Event structure used in I2S event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_event_t {
    #[doc = "< I2S event type"]
    pub type_: i2s_event_type_t,
    #[doc = "< I2S data size for I2S_DATA event"]
    pub size: size_t,
}
#[doc = " @brief I2S pin enable for i2s_set_pin"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2s_pin_config_t {
    #[doc = "< BCK out pin"]
    pub bck_o_en: c_types::c_int,
    #[doc = "< WS out pin"]
    pub ws_o_en: c_types::c_int,
    #[doc = "< BCK in pin"]
    pub bck_i_en: c_types::c_int,
    #[doc = "< WS in pin"]
    pub ws_i_en: c_types::c_int,
    #[doc = "< DATA out pin"]
    pub data_out_en: c_types::c_int,
    #[doc = "< DATA in pin"]
    pub data_in_en: c_types::c_int,
}
extern "C" {
    #[doc = " @brief Set I2S pin number"]
    #[doc = ""]
    #[doc = " @param   i2s_num     I2S_NUM_0"]
    #[doc = " @param   pin         I2S Pin structure"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL            IO error"]
    pub fn i2s_set_pin(i2s_num: i2s_port_t, pin: *const i2s_pin_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install and start I2S driver."]
    #[doc = ""]
    #[doc = " @note  This function must be called before any I2S driver read/write operations."]
    #[doc = ""]
    #[doc = " @param i2s_num         I2S_NUM_0"]
    #[doc = " @param i2s_config      I2S configurations - see i2s_config_t struct"]
    #[doc = " @param queue_size      I2S event queue size/depth."]
    #[doc = " @param i2s_queue       I2S event queue handle, if set NULL, driver will not use an event queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_driver_install(
        i2s_num: i2s_port_t,
        i2s_config: *const i2s_config_t,
        queue_size: c_types::c_int,
        i2s_queue: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall I2S driver."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_driver_uninstall(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to I2S DMA transmit buffer."]
    #[doc = ""]
    #[doc = " @note many ticks pass without space becoming available in the DMA"]
    #[doc = "       transmit buffer, then the function will return (note that if the"]
    #[doc = "       data is written to the DMA buffer in pieces, the overall operation"]
    #[doc = "       may still take longer than this timeout.) Pass portMAX_DELAY for no"]
    #[doc = "       timeout."]
    #[doc = ""]
    #[doc = " @param i2s_num             I2S_NUM_0"]
    #[doc = " @param src                 Source address to write from"]
    #[doc = " @param size                Size of data in bytes"]
    #[doc = " @param[out] bytes_written  Number of bytes written, if timeout, the result will be less than the size passed in."]
    #[doc = " @param ticks_to_wait       TX buffer wait timeout in RTOS ticks. If this"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK               Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn i2s_write(
        i2s_num: i2s_port_t,
        src: *const c_types::c_void,
        size: size_t,
        bytes_written: *mut size_t,
        ticks_to_wait: c_types::c_ulong,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to I2S DMA transmit buffer while expanding the number of bits per sample. For example, expanding 16-bit PCM to 32-bit PCM."]
    #[doc = ""]
    #[doc = " @note many ticks pass without space becoming available in the DMA"]
    #[doc = "       transmit buffer, then the function will return (note that if the"]
    #[doc = "       data is written to the DMA buffer in pieces, the overall operation"]
    #[doc = "       may still take longer than this timeout.) Pass portMAX_DELAY for no"]
    #[doc = "       timeout."]
    #[doc = "       Format of the data in source buffer is determined by the I2S"]
    #[doc = "       configuration (see i2s_config_t)."]
    #[doc = ""]
    #[doc = " @param i2s_num             I2S_NUM_0"]
    #[doc = " @param src                 Source address to write from"]
    #[doc = " @param size                Size of data in bytes"]
    #[doc = " @param src_bits            Source audio bit"]
    #[doc = " @param aim_bits            Bit wanted, no more than 32, and must be greater than src_bits"]
    #[doc = " @param[out] bytes_written  Number of bytes written, if timeout, the result will be less than the size passed in."]
    #[doc = " @param ticks_to_wait       TX buffer wait timeout in RTOS ticks. If this"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_write_expand(
        i2s_num: i2s_port_t,
        src: *const c_types::c_void,
        size: size_t,
        src_bits: size_t,
        aim_bits: size_t,
        bytes_written: *mut size_t,
        ticks_to_wait: c_types::c_ulong,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read data from I2S DMA receive buffer"]
    #[doc = ""]
    #[doc = " @note If the built-in ADC mode is enabled, we should call i2s_adc_start and i2s_adc_stop around the whole reading process,"]
    #[doc = "       to prevent the data getting corrupted."]
    #[doc = ""]
    #[doc = " @param i2s_num         I2S_NUM_0"]
    #[doc = " @param dest            Destination address to read into"]
    #[doc = " @param size            Size of data in bytes"]
    #[doc = " @param[out] bytes_read Number of bytes read, if timeout, bytes read will be less than the size passed in."]
    #[doc = " @param ticks_to_wait   RX buffer wait timeout in RTOS ticks. If this many ticks pass without bytes becoming available in the DMA receive buffer, then the function will return (note that if data is read from the DMA buffer in pieces, the overall operation may still take longer than this timeout.) Pass portMAX_DELAY for no timeout."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK               Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn i2s_read(
        i2s_num: i2s_port_t,
        dest: *mut c_types::c_void,
        size: size_t,
        bytes_read: *mut size_t,
        ticks_to_wait: c_types::c_ulong,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set sample rate used for I2S RX and TX."]
    #[doc = ""]
    #[doc = " @note The bit clock rate is determined by the sample rate and i2s_config_t configuration parameters (number of channels, bits_per_sample)."]
    #[doc = "       `bit_clock = rate * (number of channels) * bits_per_sample`"]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0"]
    #[doc = " @param rate I2S sample rate (ex: 8000, 44100...)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_sample_rates(i2s_num: i2s_port_t, rate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop I2S driver"]
    #[doc = ""]
    #[doc = " @note Disables I2S TX/RX, until i2s_start() is called."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_stop(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start I2S driver"]
    #[doc = ""]
    #[doc = " @note It is not necessary to call this function after i2s_driver_install() (it is started automatically), however it is necessary to call it after i2s_stop()."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_start(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Zero the contents of the TX DMA buffer."]
    #[doc = ""]
    #[doc = " @note Pushes zero-byte samples into the TX DMA buffer, until it is full."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn i2s_zero_dma_buffer(i2s_num: i2s_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set clock & bit width used for I2S RX and TX."]
    #[doc = ""]
    #[doc = " @note Similar to i2s_set_sample_rates(), but also sets bit width."]
    #[doc = ""]
    #[doc = " @param i2s_num  I2S_NUM_0"]
    #[doc = " @param rate I2S sample rate (ex: 8000, 44100...)"]
    #[doc = " @param bits I2S bit width (I2S_BITS_PER_SAMPLE_16BIT, I2S_BITS_PER_SAMPLE_24BIT)"]
    #[doc = " @param ch I2S channel, (I2S_CHANNEL_MONO, I2S_CHANNEL_STEREO)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_NO_MEM      Out of memory"]
    pub fn i2s_set_clk(
        i2s_num: i2s_port_t,
        rate: u32,
        bits: i2s_bits_per_sample_t,
        ch: i2s_channel_t,
    ) -> esp_err_t;
}
#[doc = " @brief ir rx initialization parameter structure type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_rx_config_t {
    pub io_num: u32,
    pub buf_len: u32,
}
#[doc = " @brief ir rx nec data union type definition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ir_rx_nec_data_t {
    pub __bindgen_anon_1: ir_rx_nec_data_t__bindgen_ty_1,
    #[doc = "< union fill"]
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ir_rx_nec_data_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl ir_rx_nec_data_t__bindgen_ty_1 {
    #[inline]
    pub fn addr1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_addr1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn addr2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_addr2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cmd1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cmd2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr1: u32,
        addr2: u32,
        cmd1: u32,
        cmd2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let addr1: u32 = unsafe { ::core::mem::transmute(addr1) };
            addr1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let addr2: u32 = unsafe { ::core::mem::transmute(addr2) };
            addr2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let cmd1: u32 = unsafe { ::core::mem::transmute(cmd1) };
            cmd1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let cmd2: u32 = unsafe { ::core::mem::transmute(cmd2) };
            cmd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Disable the ir rx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL ir rx has not been initialized yet"]
    pub fn ir_rx_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the ir rx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL ir rx has not been initialized yet"]
    pub fn ir_rx_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Receive infrared data"]
    #[doc = ""]
    #[doc = " @param data Pointer to the rx data buffer"]
    #[doc = " @param len Length of ir_rx_data, range: 0 < len < (uint16_t)"]
    #[doc = " @param timeout_ticks freertos timeout ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - -1 error"]
    #[doc = "     - length The actual length of data received"]
    pub fn ir_rx_recv_data(
        data: *mut ir_rx_nec_data_t,
        len: size_t,
        timeout_ticks: u32,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Deinit the ir rx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL ir rx has not been initialized yet"]
    pub fn ir_rx_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the ir rx"]
    #[doc = ""]
    #[doc = " @param config Pointer to deliver initialize configuration parameter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM malloc fail"]
    #[doc = "     - ESP_FAIL ir rx has been initialized"]
    pub fn ir_rx_init(config: *mut ir_rx_config_t) -> esp_err_t;
}
pub const ir_tx_timer_t_IR_TX_WDEV_TIMER: ir_tx_timer_t = 0;
pub const ir_tx_timer_t_IR_TX_HW_TIMER: ir_tx_timer_t = 1;
pub type ir_tx_timer_t = c_types::c_uint;
#[doc = " @brief ir tx initialization parameter structure type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ir_tx_config_t {
    pub io_num: u32,
    pub freq: u32,
    pub timer: ir_tx_timer_t,
}
#[doc = " @brief ir tx data union type definition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ir_tx_nec_data_t {
    pub __bindgen_anon_1: ir_tx_nec_data_t__bindgen_ty_1,
    #[doc = "< union fill"]
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ir_tx_nec_data_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl ir_tx_nec_data_t__bindgen_ty_1 {
    #[inline]
    pub fn addr1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_addr1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn addr2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_addr2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cmd1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cmd2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cmd2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        addr1: u32,
        addr2: u32,
        cmd1: u32,
        cmd2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let addr1: u32 = unsafe { ::core::mem::transmute(addr1) };
            addr1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let addr2: u32 = unsafe { ::core::mem::transmute(addr2) };
            addr2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let cmd1: u32 = unsafe { ::core::mem::transmute(cmd1) };
            cmd1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let cmd2: u32 = unsafe { ::core::mem::transmute(cmd2) };
            cmd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Send ir data"]
    #[doc = ""]
    #[doc = " @note If multiple data are identical, repeat signals will be used."]
    #[doc = " Infrared data consumes more than 100 ms per transmission, so note the timeout_ticks parameter"]
    #[doc = ""]
    #[doc = " @param data Pointer to the tx data buffer"]
    #[doc = " @param len Length of ir_tx_data, range: 0 < len < (uint16_t)"]
    #[doc = " @param timeout_ticks freertos timeout ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - -1 error"]
    #[doc = "     - length The actual length of data sent"]
    pub fn ir_tx_send_data(
        data: *mut ir_tx_nec_data_t,
        len: size_t,
        timeout_ticks: u32,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Deinit the ir tx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL ir tx has not been initialized yet"]
    pub fn ir_tx_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the ir tx"]
    #[doc = ""]
    #[doc = " @note WDEV timer will be more accurate, but PWM will not work."]
    #[doc = ""]
    #[doc = " @param config Pointer to deliver initialize configuration parameter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM malloc fail"]
    #[doc = "     - ESP_FAIL ir tx has been initialized"]
    pub fn ir_tx_init(config: *mut ir_tx_config_t) -> esp_err_t;
}
#[doc = "< LEDC high speed speed_mode"]
pub const ledc_mode_t_LEDC_HIGH_SPEED_MODE: ledc_mode_t = 0;
#[doc = "< LEDC low speed speed_mode"]
pub const ledc_mode_t_LEDC_LOW_SPEED_MODE: ledc_mode_t = 1;
#[doc = "< LEDC speed limit"]
pub const ledc_mode_t_LEDC_SPEED_MODE_MAX: ledc_mode_t = 2;
pub type ledc_mode_t = c_types::c_uint;
#[doc = "< Disable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_DISABLE: ledc_intr_type_t = 0;
#[doc = "< Enable LEDC interrupt"]
pub const ledc_intr_type_t_LEDC_INTR_FADE_END: ledc_intr_type_t = 1;
pub type ledc_intr_type_t = c_types::c_uint;
#[doc = "< LEDC timer 0"]
pub const ledc_timer_t_LEDC_TIMER_0: ledc_timer_t = 0;
#[doc = "< LEDC timer 1"]
pub const ledc_timer_t_LEDC_TIMER_1: ledc_timer_t = 1;
#[doc = "< LEDC timer 2"]
pub const ledc_timer_t_LEDC_TIMER_2: ledc_timer_t = 2;
#[doc = "< LEDC timer 3"]
pub const ledc_timer_t_LEDC_TIMER_3: ledc_timer_t = 3;
pub const ledc_timer_t_LEDC_TIMER_MAX: ledc_timer_t = 4;
pub type ledc_timer_t = c_types::c_uint;
#[doc = "< LEDC channel 0"]
pub const ledc_channel_t_LEDC_CHANNEL_0: ledc_channel_t = 0;
#[doc = "< LEDC channel 1"]
pub const ledc_channel_t_LEDC_CHANNEL_1: ledc_channel_t = 1;
#[doc = "< LEDC channel 2"]
pub const ledc_channel_t_LEDC_CHANNEL_2: ledc_channel_t = 2;
#[doc = "< LEDC channel 3"]
pub const ledc_channel_t_LEDC_CHANNEL_3: ledc_channel_t = 3;
#[doc = "< LEDC channel 4"]
pub const ledc_channel_t_LEDC_CHANNEL_4: ledc_channel_t = 4;
#[doc = "< LEDC channel 5"]
pub const ledc_channel_t_LEDC_CHANNEL_5: ledc_channel_t = 5;
#[doc = "< LEDC channel 6"]
pub const ledc_channel_t_LEDC_CHANNEL_6: ledc_channel_t = 6;
#[doc = "< LEDC channel 7"]
pub const ledc_channel_t_LEDC_CHANNEL_7: ledc_channel_t = 7;
pub const ledc_channel_t_LEDC_CHANNEL_MAX: ledc_channel_t = 8;
pub type ledc_channel_t = c_types::c_uint;
#[doc = "< LEDC PWM duty resolution of  1 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_1_BIT: ledc_timer_bit_t = 1;
#[doc = "< LEDC PWM duty resolution of  2 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_2_BIT: ledc_timer_bit_t = 2;
#[doc = "< LEDC PWM duty resolution of  3 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_3_BIT: ledc_timer_bit_t = 3;
#[doc = "< LEDC PWM duty resolution of  4 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_4_BIT: ledc_timer_bit_t = 4;
#[doc = "< LEDC PWM duty resolution of  5 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_5_BIT: ledc_timer_bit_t = 5;
#[doc = "< LEDC PWM duty resolution of  6 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_6_BIT: ledc_timer_bit_t = 6;
#[doc = "< LEDC PWM duty resolution of  7 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_7_BIT: ledc_timer_bit_t = 7;
#[doc = "< LEDC PWM duty resolution of  8 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_8_BIT: ledc_timer_bit_t = 8;
#[doc = "< LEDC PWM duty resolution of  9 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_9_BIT: ledc_timer_bit_t = 9;
#[doc = "< LEDC PWM duty resolution of 10 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_10_BIT: ledc_timer_bit_t = 10;
#[doc = "< LEDC PWM duty resolution of 11 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_11_BIT: ledc_timer_bit_t = 11;
#[doc = "< LEDC PWM duty resolution of 12 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_12_BIT: ledc_timer_bit_t = 12;
#[doc = "< LEDC PWM duty resolution of 13 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_13_BIT: ledc_timer_bit_t = 13;
#[doc = "< LEDC PWM duty resolution of 14 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_14_BIT: ledc_timer_bit_t = 14;
#[doc = "< LEDC PWM duty resolution of 15 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_15_BIT: ledc_timer_bit_t = 15;
#[doc = "< LEDC PWM duty resolution of 16 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_16_BIT: ledc_timer_bit_t = 16;
#[doc = "< LEDC PWM duty resolution of 17 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_17_BIT: ledc_timer_bit_t = 17;
#[doc = "< LEDC PWM duty resolution of 18 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_18_BIT: ledc_timer_bit_t = 18;
#[doc = "< LEDC PWM duty resolution of 19 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_19_BIT: ledc_timer_bit_t = 19;
#[doc = "< LEDC PWM duty resolution of 20 bits"]
pub const ledc_timer_bit_t_LEDC_TIMER_20_BIT: ledc_timer_bit_t = 20;
pub const ledc_timer_bit_t_LEDC_TIMER_BIT_MAX: ledc_timer_bit_t = 21;
pub type ledc_timer_bit_t = c_types::c_uint;
#[doc = "< LEDC fade function will return immediately"]
pub const ledc_fade_mode_t_LEDC_FADE_NO_WAIT: ledc_fade_mode_t = 0;
#[doc = "< LEDC fade function will block until fading to the target duty"]
pub const ledc_fade_mode_t_LEDC_FADE_WAIT_DONE: ledc_fade_mode_t = 1;
pub const ledc_fade_mode_t_LEDC_FADE_MAX: ledc_fade_mode_t = 2;
pub type ledc_fade_mode_t = c_types::c_uint;
#[doc = " @brief Configuration parameters of LEDC Timer timer for ledc_timer_config function"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ledc_timer_config_t {
    #[doc = "< LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    pub __bindgen_anon_1: ledc_timer_config_t__bindgen_ty_1,
    #[doc = "< The timer source of channel (0 - 3)"]
    pub timer_num: ledc_timer_t,
    #[doc = "< LEDC timer frequency (100Hz ~ 1KHz)"]
    pub freq_hz: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ledc_timer_config_t__bindgen_ty_1 {
    #[doc = "< LEDC channel duty resolution"]
    pub duty_resolution: ledc_timer_bit_t,
    #[doc = "< Deprecated in ESP-IDF 3.0. This is an alias to 'duty_resolution' for backward compatibility with ESP-IDF 2.1"]
    pub bit_num: ledc_timer_bit_t,
    _bindgen_union_align: u32,
}
#[doc = " @brief Configuration parameters of LEDC channel for ledc_channel_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ledc_channel_config_t {
    #[doc = "< the LEDC output gpio_num, if you want to use gpio16, gpio_num = 16"]
    pub gpio_num: c_types::c_int,
    #[doc = "< Invalid parameter, compatible with esp32 API. Configure interrupt, LEDC speed speed_mode, high-speed mode or low-speed mode"]
    pub speed_mode: ledc_mode_t,
    #[doc = "< LEDC channel (0 - 7)"]
    pub channel: ledc_channel_t,
    #[doc = "< Invalid parameter, compatible with esp32 API. Configure interrupt,Fade interrupt enable  or Fade interrupt disable"]
    pub intr_type: ledc_intr_type_t,
    #[doc = "< Invalid parameter, compatible with esp32 API. Select the timer source of channel (0 - 3)"]
    pub timer_sel: ledc_timer_t,
    #[doc = "< LEDC channel duty, the range of duty setting is [0, (2**duty_resolution)]"]
    pub duty: u32,
    #[doc = "< Invalid parameter, compatible with esp32 API.LEDC channel hpoint value, the max value is 0xfffff"]
    pub hpoint: c_types::c_int,
}
extern "C" {
    #[doc = " @brief  set ledc duty"]
    #[doc = ""]
    #[doc = " @param  speed_mode    unnecessary parameters, just for code unity"]
    #[doc = " @param  ledc_channel  ledc channel num"]
    #[doc = " @param  ledc_duty     set the ledc duty you want"]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "      - ESP_OK              Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_set_duty(
        speed_mode: ledc_mode_t,
        ledc_channel: ledc_channel_t,
        ledc_duty: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  update ledc duty"]
    #[doc = ""]
    #[doc = " @param  speed_mode     unnecessary parameters, just for code unity"]
    #[doc = " @param  ledc_channel   ledc channel num"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK              Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL            IO error"]
    pub fn ledc_update_duty(speed_mode: ledc_mode_t, ledc_channel: ledc_channel_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  set ledc duty by fade"]
    #[doc = ""]
    #[doc = " @param  speed_mode       unnecessary parameters, just for code unity"]
    #[doc = " @param  ledc_channel     ledc channel num"]
    #[doc = " @param  ledc_duty        set ledc duty"]
    #[doc = " @param  ledc_fade_time   set ledc fade time"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK               Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG  Parameter error"]
    pub fn ledc_set_fade_with_time(
        speed_mode: ledc_mode_t,
        ledc_channel: ledc_channel_t,
        ledc_duty: u32,
        ledc_fade_time: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  start change ledc duty by fade"]
    #[doc = " @param  speed_mode       unnecessary parameters, just for code unity"]
    #[doc = " @param  ledc_channel     ledc channel num"]
    #[doc = " @param  fade_mode        set fade mode, for example set LEDC_FADE_NO_WAIT  means LEDC fade function will return immediately"]
    #[doc = " set LEDC_FADE_WAIT_DONE means LEDC fade function will block until fading to the target duty"]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "    - ESP_OK              Success"]
    #[doc = "    - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "    - ESP_FAIL            IO error"]
    pub fn ledc_fade_start(
        speed_mode: ledc_mode_t,
        ledc_channel: ledc_channel_t,
        fade_mode: ledc_fade_mode_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC channel configuration"]
    #[doc = "        Configure LEDC channel with the given channel/output gpio_num/interrupt/source timer/frequency(Hz)/LEDC duty resolution"]
    #[doc = ""]
    #[doc = " @param ledc_conf Pointer of LEDC channel configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_channel_config(ledc_conf: *const ledc_channel_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC timer configuration"]
    #[doc = "        Configure LEDC timer with the given source timer/frequency(Hz)/duty_resolution"]
    #[doc = ""]
    #[doc = " @param  timer_conf Pointer of LEDC timer configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_timer_config(timer_conf: *const ledc_timer_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install LEDC fade function. This function will occupy interrupt of LEDC module."]
    #[doc = " @param intr_alloc_flags unnecessary parameters, just for code unity, maybe will be used later"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Fade function already installed."]
    pub fn ledc_fade_func_install(intr_alloc_flags: c_types::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall LEDC fade function."]
    #[doc = ""]
    pub fn ledc_fade_func_uninstall() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief LEDC stop."]
    #[doc = "        Disable LEDC output, and set idle level"]
    #[doc = ""]
    #[doc = " @param  speed_mode Select the LEDC speed_mode, high-speed mode and low-speed mode"]
    #[doc = " @param  channel LEDC channel (0-7), select from ledc_channel_t"]
    #[doc = " @param  idle_level Set output idle level after LEDC stops."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn ledc_stop(
        speed_mode: ledc_mode_t,
        channel: ledc_channel_t,
        idle_level: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " it is an empty function"]
    pub fn periph_module_enable(none: c_types::c_int) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief  PWM function initialization, including GPIO, frequency and duty cycle."]
    #[doc = ""]
    #[doc = " @param  period PWM period, unit: us."]
    #[doc = "         e.g. For 1KHz PWM, period is 1000 us. Do not set the period below 20us."]
    #[doc = " @param  duties duty cycle of each channels."]
    #[doc = " @param  channel_num PWM channel number, maximum is 8"]
    #[doc = " @param  pin_num GPIO number of PWM channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL Init error"]
    pub fn pwm_init(
        period: u32,
        duties: *mut u32,
        channel_num: u8,
        pin_num: *const u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  PWM function uninstall"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Init error"]
    pub fn pwm_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set the duty cycle of a PWM channel."]
    #[doc = "          Set the time that high level or low(if you invert the output of this channel)"]
    #[doc = "          signal will last, the duty cycle cannot exceed the period."]
    #[doc = ""]
    #[doc = " @note    After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param   channel_num PWM channel number"]
    #[doc = "          the channel_num cannot exceed the value initialized by pwm_init."]
    #[doc = " @param   duty duty cycle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_set_duty(channel_num: u8, duty: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get the duty cycle of a PWM channel."]
    #[doc = ""]
    #[doc = " @param   channel_num PWM channel number"]
    #[doc = "          the channel_num cannot exceed the value initialized by pwm_init."]
    #[doc = " @param  duty_p pointer saves the address of the specified channel duty cycle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_get_duty(channel_num: u8, duty_p: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set PWM period, unit: us."]
    #[doc = ""]
    #[doc = " @note After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param   period PWM period, unit: us"]
    #[doc = "          For example, for 1KHz PWM, period is 1000. Do not set the period below 20us."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_set_period(period: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get PWM period, unit: us."]
    #[doc = ""]
    #[doc = " @param   period_p pointer saves the address of the period"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_get_period(period_p: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Starts PWM."]
    #[doc = ""]
    #[doc = " @note    This function needs to be called after PWM configuration is changed."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop all PWM channel."]
    #[doc = "         Stop PWM and set the output of each channel to the specified level."]
    #[doc = "         Calling pwm_start can re-start PWM output."]
    #[doc = ""]
    #[doc = " @param  stop_level_mask Out put level after PWM is stoped"]
    #[doc = "         e.g. We initialize 8 channels, if stop_level_mask = 0x0f,"]
    #[doc = "         channel 0,1,2 and 3 will output high level, and channel 4,5,6 and 7 will output low level."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_stop(stop_level_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set the duty cycle of all channels."]
    #[doc = ""]
    #[doc = " @note   After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param  duties An array that store the duty cycle of each channel,"]
    #[doc = "         the array elements number needs to be the same as the number of channels."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_set_duties(duties: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set the phase of a PWM channel."]
    #[doc = ""]
    #[doc = " @note    After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param   channel_num PWM channel number"]
    #[doc = "          the channel_num cannot exceed the value initialized by pwm_init."]
    #[doc = " @param   phase The phase of this PWM channel, the phase range is (-180 ~ 180)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_set_phase(channel_num: u8, phase: i16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set the phase of all channels."]
    #[doc = ""]
    #[doc = " @note    After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param   phases An array that store the phase of each channel,"]
    #[doc = "          the array elements number needs to be the same as the number of channels."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_set_phases(phases: *mut i16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Get the phase of a PWM channel."]
    #[doc = ""]
    #[doc = " @param   channel_num PWM channel number"]
    #[doc = "          the channel_num cannot exceed the value initialized by pwm_init."]
    #[doc = " @param  phase_p pointer saves the address of the specified channel phase"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_get_phase(channel_num: u8, phase_p: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Set PWM period and duty of each PWM channel."]
    #[doc = ""]
    #[doc = " @note    After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param   period PWM period, unit: us"]
    #[doc = "          For example, for 1KHz PWM, period is 1000."]
    #[doc = " @param   duties An array that store the duty cycle of each channel,"]
    #[doc = "          the array elements number needs to be the same as the number of channels."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_set_period_duties(period: u32, duties: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set the inverting output PWM channel."]
    #[doc = ""]
    #[doc = " @note   After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param  channel_mask The channel bitmask that used to invert the output"]
    #[doc = "         e.g. We initialize 8 channels, if channel_mask = 0x0f, channels 0, 1, 2 and 3 will invert the output."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_set_channel_invert(channel_mask: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Clear the inverting output PWM channel."]
    #[doc = "         This function only works for the PWM channel that is already in the inverted output states."]
    #[doc = ""]
    #[doc = " @note   After set configuration, pwm_start needs to be called to take effect."]
    #[doc = ""]
    #[doc = " @param  channel_mask The channel bitmask that need to clear"]
    #[doc = "         e.g. The outputs of channels 0, 1, 2 and 3 are already in inverted state. If channel_mask = 0x07,"]
    #[doc = "         the output of channel 0, 1, and 2 will return to normal, the channel 3 will keep inverting output."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn pwm_clear_channel_invert(channel_mask: u16) -> esp_err_t;
}
#[doc = "!< 80 MHz"]
pub const rtc_cpu_freq_t_RTC_CPU_FREQ_80M: rtc_cpu_freq_t = 0;
#[doc = "!< 160 MHz"]
pub const rtc_cpu_freq_t_RTC_CPU_FREQ_160M: rtc_cpu_freq_t = 1;
#[doc = " @brief CPU frequency values"]
pub type rtc_cpu_freq_t = c_types::c_uint;
extern "C" {
    #[doc = " @brief Open RF hardware"]
    pub fn phy_open_rf();
}
extern "C" {
    #[doc = " @brief Close RF hardware"]
    pub fn phy_close_rf();
}
extern "C" {
    #[doc = " @brief Initialize RTC hardware"]
    pub fn rtc_init_clk(init_param: *mut u8);
}
extern "C" {
    #[doc = " @brief Initialize light sleep hardware"]
    pub fn rtc_lightsleep_init();
}
extern "C" {
    #[doc = " @brief Configure CPU sleep mode"]
    pub fn pm_set_sleep_mode(mode: u32);
}
extern "C" {
    #[doc = " @brief Initialize hardware when CPU wakes up from light sleep"]
    pub fn rtc_wakeup_init();
}
extern "C" {
    #[doc = " @brief Get the currently used CPU frequency configuration"]
    #[doc = ""]
    #[doc = " @return CPU frequency"]
    pub fn rtc_clk_cpu_freq_get() -> rtc_cpu_freq_t;
}
extern "C" {
    #[doc = " @brief Switch CPU frequency"]
    #[doc = ""]
    #[doc = " This function sets CPU frequency according to the given configuration"]
    #[doc = " structure. It enables PLLs, if necessary."]
    #[doc = ""]
    #[doc = " @note This function in not intended to be called by applications in FreeRTOS"]
    #[doc = " environment. This is because it does not adjust various timers based on the"]
    #[doc = " new CPU frequency."]
    #[doc = ""]
    #[doc = " @param cpu_freq  CPU frequency"]
    pub fn rtc_clk_cpu_freq_set(cpu_freq: rtc_cpu_freq_t);
}
extern "C" {
    #[doc = " @brief Enter light sleep mode"]
    #[doc = ""]
    #[doc = " @note  CPU wakeup has 2672 ms time cost, so the real sleeping time is to_sleep_time_in_us - 2672"]
    #[doc = ""]
    #[doc = " @param wakeup_opt  bit mask wake up reasons to enable (RTC_xxx_TRIG_EN flags"]
    #[doc = "                    combined with OR)"]
    #[doc = " @param reject_opt  bit mask of sleep reject reasons:"]
    #[doc = "                      - RTC_CNTL_GPIO_REJECT_EN"]
    #[doc = "                      - RTC_CNTL_SDIO_REJECT_EN"]
    #[doc = "                    These flags are used to prevent entering sleep when e.g."]
    #[doc = "                    an external host is communicating via SDIO slave"]
    #[doc = " @return non-zero if sleep was rejected by hardware"]
    pub fn rtc_light_sleep_start(wakeup_opt: u32, reject_opt: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Convert time interval from microseconds to RTC_CLK cycles"]
    #[doc = ""]
    #[doc = " @param time_in_us  Time interval in microseconds"]
    #[doc = " @param period      Period of clock in microseconds (as returned by esp_clk_cal_get)"]
    #[doc = ""]
    #[doc = " @return number of clock cycles"]
    pub fn rtc_us_to_clk(time_in_us: u32, period: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Convert time interval from RTC_CLK to microseconds"]
    #[doc = ""]
    #[doc = " @param rtc_cycles  Time interval in RTC_CLK cycles"]
    #[doc = " @param period      Period of clock in microseconds (as returned by esp_clk_cal_get)"]
    #[doc = ""]
    #[doc = " @return time interval in microseconds"]
    pub fn rtc_clk_to_us(rtc_cycles: u32, period: u32) -> u32;
}
extern "C" {
    #[doc = " @brief Get the calibration value of RTC clock"]
    #[doc = ""]
    #[doc = " @return the calibration value"]
    pub fn pm_rtc_clock_cali_proc() -> u32;
}
extern "C" {
    #[doc = " @brief Configure   CPU sleep time by RTC clock ticks"]
    #[doc = ""]
    #[doc = " @param rtc_cycles  Time interval in RTC_CLK cycles"]
    pub fn pm_set_sleep_cycles(rtc_cycles: u32);
}
extern "C" {
    #[doc = " @brief Get current value of RTC counter"]
    #[doc = ""]
    #[doc = " @return current value of RTC counter"]
    pub fn rtc_time_get() -> u32;
}
pub type spi_event_callback_t =
    ::core::option::Option<unsafe extern "C" fn(event: c_types::c_int, arg: *mut c_types::c_void)>;
pub const spi_host_t_CSPI_HOST: spi_host_t = 0;
pub const spi_host_t_HSPI_HOST: spi_host_t = 1;
#[doc = " @brief SPI peripheral enumeration"]
#[doc = ""]
#[doc = " @note ESP8266 has two hardware SPI, CSPI and HSPI. Currently, HSPI can be used arbitrarily."]
pub type spi_host_t = c_types::c_uint;
pub const spi_clk_div_t_SPI_2MHz_DIV: spi_clk_div_t = 40;
pub const spi_clk_div_t_SPI_4MHz_DIV: spi_clk_div_t = 20;
pub const spi_clk_div_t_SPI_5MHz_DIV: spi_clk_div_t = 16;
pub const spi_clk_div_t_SPI_8MHz_DIV: spi_clk_div_t = 10;
pub const spi_clk_div_t_SPI_10MHz_DIV: spi_clk_div_t = 8;
pub const spi_clk_div_t_SPI_16MHz_DIV: spi_clk_div_t = 5;
pub const spi_clk_div_t_SPI_20MHz_DIV: spi_clk_div_t = 4;
pub const spi_clk_div_t_SPI_40MHz_DIV: spi_clk_div_t = 2;
pub const spi_clk_div_t_SPI_80MHz_DIV: spi_clk_div_t = 1;
#[doc = " @brief SPI clock division factor enumeration"]
pub type spi_clk_div_t = c_types::c_uint;
pub const spi_mode_t_SPI_MASTER_MODE: spi_mode_t = 0;
pub const spi_mode_t_SPI_SLAVE_MODE: spi_mode_t = 1;
#[doc = " @brief SPI working mode enumeration"]
pub type spi_mode_t = c_types::c_uint;
#[doc = " @brief SPI interrupt enable union type definition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_intr_enable_t {
    pub __bindgen_anon_1: spi_intr_enable_t__bindgen_ty_1,
    #[doc = "< union fill"]
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_intr_enable_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_intr_enable_t__bindgen_ty_1 {
    #[inline]
    pub fn read_buffer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_buffer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_buffer(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write_buffer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trans_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trans_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_buffer: u32,
        write_buffer: u32,
        read_status: u32,
        write_status: u32,
        trans_done: u32,
        reserved5: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read_buffer: u32 = unsafe { ::core::mem::transmute(read_buffer) };
            read_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let write_buffer: u32 = unsafe { ::core::mem::transmute(write_buffer) };
            write_buffer as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let read_status: u32 = unsafe { ::core::mem::transmute(read_status) };
            read_status as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write_status: u32 = unsafe { ::core::mem::transmute(write_status) };
            write_status as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let trans_done: u32 = unsafe { ::core::mem::transmute(trans_done) };
            trans_done as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved5: u32 = unsafe { ::core::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief SPI bus interface parameter union type definition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_interface_t {
    pub __bindgen_anon_1: spi_interface_t__bindgen_ty_1,
    #[doc = "< union fill"]
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_interface_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl spi_interface_t__bindgen_ty_1 {
    #[inline]
    pub fn cpol(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpol(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpha(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpha(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_tx_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bit_tx_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_rx_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bit_rx_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn byte_tx_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_byte_tx_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn byte_rx_order(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_byte_rx_order(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mosi_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mosi_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn miso_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_miso_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cs_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cs_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cpol: u32,
        cpha: u32,
        bit_tx_order: u32,
        bit_rx_order: u32,
        byte_tx_order: u32,
        byte_rx_order: u32,
        mosi_en: u32,
        miso_en: u32,
        cs_en: u32,
        reserved9: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cpol: u32 = unsafe { ::core::mem::transmute(cpol) };
            cpol as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cpha: u32 = unsafe { ::core::mem::transmute(cpha) };
            cpha as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bit_tx_order: u32 = unsafe { ::core::mem::transmute(bit_tx_order) };
            bit_tx_order as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bit_rx_order: u32 = unsafe { ::core::mem::transmute(bit_rx_order) };
            bit_rx_order as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let byte_tx_order: u32 = unsafe { ::core::mem::transmute(byte_tx_order) };
            byte_tx_order as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let byte_rx_order: u32 = unsafe { ::core::mem::transmute(byte_rx_order) };
            byte_rx_order as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mosi_en: u32 = unsafe { ::core::mem::transmute(mosi_en) };
            mosi_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let miso_en: u32 = unsafe { ::core::mem::transmute(miso_en) };
            miso_en as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cs_en: u32 = unsafe { ::core::mem::transmute(cs_en) };
            cs_en as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let reserved9: u32 = unsafe { ::core::mem::transmute(reserved9) };
            reserved9 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief SPI transmission parameter structure type definition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_trans_t {
    #[doc = "< SPI transmission command"]
    pub cmd: *mut u16,
    #[doc = "< SPI transmission address"]
    pub addr: *mut u32,
    #[doc = "< SPI transmission MOSI buffer, in order to improve the transmission efficiency, it is recommended that the external incoming data is (uint32_t *) type data, do not use other type data."]
    pub mosi: *mut u32,
    #[doc = "< SPI transmission MISO buffer, in order to improve the transmission efficiency, it is recommended that the external incoming data is (uint32_t *) type data, do not use other type data."]
    pub miso: *mut u32,
    #[doc = "< SPI transmission packet members' bits"]
    pub bits: spi_trans_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spi_trans_t__bindgen_ty_1 {
    pub __bindgen_anon_1: spi_trans_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< union fill"]
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spi_trans_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl spi_trans_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cmd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cmd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn mosi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mosi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn miso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_miso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cmd: u32,
        addr: u32,
        mosi: u32,
        miso: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let cmd: u32 = unsafe { ::core::mem::transmute(cmd) };
            cmd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 7u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mosi: u32 = unsafe { ::core::mem::transmute(mosi) };
            mosi as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let miso: u32 = unsafe { ::core::mem::transmute(miso) };
            miso as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief SPI initialization parameter structure type definition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spi_config_t {
    #[doc = "< SPI bus interface"]
    pub interface: spi_interface_t,
    #[doc = "< check if enable SPI interrupt"]
    pub intr_enable: spi_intr_enable_t,
    #[doc = "< SPI interrupt event callback"]
    pub event_cb: spi_event_callback_t,
    #[doc = "< SPI mode"]
    pub mode: spi_mode_t,
    #[doc = "< SPI clock divider"]
    pub clk_div: spi_clk_div_t,
}
extern "C" {
    #[doc = " @brief Get the SPI clock division factor"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param clk_div Pointer to accept clock division factor"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_get_clk_div(host: spi_host_t, clk_div: *mut spi_clk_div_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get SPI Interrupt Enable"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param intr_enable Pointer to accept interrupt enable"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_get_intr_enable(host: spi_host_t, intr_enable: *mut spi_intr_enable_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get SPI working mode"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param mode Pointer to accept working mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_get_mode(host: spi_host_t, mode: *mut spi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get SPI bus interface configuration"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param interface Pointer to accept bus interface configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_get_interface(host: spi_host_t, interface: *mut spi_interface_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the SPI event callback function"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param event_cb Pointer to accept event callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_get_event_callback(
        host: spi_host_t,
        event_cb: *mut spi_event_callback_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the SPI clock division factor"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param clk_div Pointer to deliver clock division factor"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_set_clk_div(host: spi_host_t, clk_div: *mut spi_clk_div_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set SPI interrupt enable"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param intr_enable Pointer to deliver interrupt enable"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_set_intr_enable(host: spi_host_t, intr_enable: *mut spi_intr_enable_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the SPI mode of operation"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param mode Pointer to deliver working mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_set_mode(host: spi_host_t, mode: *mut spi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get SPI dummy bitlen"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param bitlen Pointer to accept dummy bitlen"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_get_dummy(host: spi_host_t, bitlen: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set SPI dummy bitlen"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param bitlen Pointer to deliver dummy bitlen"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_set_dummy(host: spi_host_t, bitlen: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set SPI bus interface configuration"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param interface Pointer to deliver bus interface configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_set_interface(host: spi_host_t, interface: *mut spi_interface_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the SPI event callback function"]
    #[doc = ""]
    #[doc = " @note  This event_cb will be called from an ISR. So there is a stack"]
    #[doc = "        size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = "        limit is smaller compared to a global SPI interrupt handler due"]
    #[doc = "        to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param event_cb Pointer to deliver event callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_set_event_callback(
        host: spi_host_t,
        event_cb: *mut spi_event_callback_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get SPI slave wr_status register"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param status Pointer to accept wr_status register"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_slave_get_status(host: spi_host_t, status: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set SPI slave rd_status register"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param status Pointer to deliver rd_status register"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_slave_set_status(host: spi_host_t, status: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief SPI data transfer function"]
    #[doc = ""]
    #[doc = " @note If the bit of the corresponding phase in the transmission parameter is 0, its data will not work."]
    #[doc = "       For example: trans.bits.cmd = 0, cmd will not be transmitted"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param trans Pointer to transmission parameter structure"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_trans(host: spi_host_t, trans: *mut spi_trans_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinit the spi"]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL spi has not been initialized yet"]
    pub fn spi_deinit(host: spi_host_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the spi"]
    #[doc = ""]
    #[doc = " @note SPI0 has been used by FLASH and cannot be used by the user temporarily."]
    #[doc = ""]
    #[doc = " @param host SPI peripheral number"]
    #[doc = "     - CSPI_HOST SPI0"]
    #[doc = "     - HSPI_HOST SPI1"]
    #[doc = ""]
    #[doc = " @param config Pointer to deliver initialize configuration parameter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM malloc fail"]
    #[doc = "     - ESP_FAIL spi has been initialized"]
    pub fn spi_init(host: spi_host_t, config: *mut spi_config_t) -> esp_err_t;
}
#[doc = "< No log output"]
pub const esp_log_level_t_ESP_LOG_NONE: esp_log_level_t = 0;
#[doc = "< Critical errors, software module can not recover on its own"]
pub const esp_log_level_t_ESP_LOG_ERROR: esp_log_level_t = 1;
#[doc = "< Error conditions from which recovery measures have been taken"]
pub const esp_log_level_t_ESP_LOG_WARN: esp_log_level_t = 2;
#[doc = "< Information messages which describe normal flow of events"]
pub const esp_log_level_t_ESP_LOG_INFO: esp_log_level_t = 3;
#[doc = "< Extra information which is not necessary for normal use (values, pointers, sizes, etc)."]
pub const esp_log_level_t_ESP_LOG_DEBUG: esp_log_level_t = 4;
#[doc = "< Bigger chunks of debugging information, or frequent messages which can potentially flood the output."]
pub const esp_log_level_t_ESP_LOG_VERBOSE: esp_log_level_t = 5;
pub const esp_log_level_t_ESP_LOG_MAX: esp_log_level_t = 6;
#[doc = " @brief Log level"]
#[doc = ""]
pub type esp_log_level_t = c_types::c_uint;
pub type putchar_like_t =
    ::core::option::Option<unsafe extern "C" fn(ch: c_types::c_int) -> c_types::c_int>;
extern "C" {
    #[doc = " @brief Set function used to output log entries"]
    #[doc = ""]
    #[doc = " By default, log output goes to UART0. This function can be used to redirect log"]
    #[doc = " output to some other destination, such as file or network. Returns the original"]
    #[doc = " log handler, which may be necessary to return output to the previous destination."]
    #[doc = ""]
    #[doc = " @param func new Function used for output. Must have same signature as putchar."]
    #[doc = ""]
    #[doc = " @return func old Function used for output."]
    pub fn esp_log_set_putchar(func: putchar_like_t) -> putchar_like_t;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output"]
    #[doc = ""]
    #[doc = " This function is used in expansion of ESP_LOGx macros."]
    #[doc = " In the 2nd stage bootloader, and at early application startup stage"]
    #[doc = " this function uses CPU cycle counter as time source. Later when"]
    #[doc = " FreeRTOS scheduler start running, it switches to FreeRTOS tick count."]
    #[doc = ""]
    #[doc = " For now, we ignore millisecond counter overflow."]
    #[doc = ""]
    #[doc = " @return timestamp, in milliseconds"]
    pub fn esp_log_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output"]
    #[doc = ""]
    #[doc = " This function uses HW cycle counter and does not depend on OS,"]
    #[doc = " so it can be safely used after application crash."]
    #[doc = ""]
    #[doc = " @return timestamp, in milliseconds"]
    pub fn esp_log_early_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Write message into the log"]
    #[doc = ""]
    #[doc = " This function is not intended to be used directly. Instead, use one of"]
    #[doc = " ESP_LOGE, ESP_LOGW, ESP_LOGI, ESP_LOGD, ESP_LOGV macros."]
    #[doc = ""]
    #[doc = " This function or these macros should not be used from an interrupt."]
    pub fn esp_log_write(
        level: esp_log_level_t,
        tag: *const c_types::c_char,
        format: *const c_types::c_char,
        ...
    );
}
extern "C" {
    #[doc = " @brief Write message into the log at system startup or critical state"]
    #[doc = ""]
    #[doc = " This function is not intended to be used directly. Instead, use one of"]
    #[doc = " ESP_EARLY_LOGE, ESP_EARLY_LOGW, ESP_LEARLY_OGI, ESP_EARLY_LOGD, ESP_EARLY_LOGV macros."]
    #[doc = ""]
    #[doc = " This function or these macros can be used from an interrupt or NMI exception."]
    pub fn esp_early_log_write(
        level: esp_log_level_t,
        tag: *const c_types::c_char,
        format: *const c_types::c_char,
        ...
    );
}
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()"]
#[doc = " returns an QueueHandle_t variable that can then be used as a parameter to"]
#[doc = " xQueueSend(), xQueueReceive(), etc."]
pub type QueueHandle_t = *mut c_types::c_void;
#[doc = " Type by which queue sets are referenced.  For example, a call to"]
#[doc = " xQueueCreateSet() returns an xQueueSet variable that can then be used as a"]
#[doc = " parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc."]
pub type QueueSetHandle_t = *mut c_types::c_void;
#[doc = " Queue sets can contain both queues and semaphores, so the"]
#[doc = " QueueSetMemberHandle_t is defined as a type to be used where a parameter or"]
#[doc = " return value can be either an QueueHandle_t or an SemaphoreHandle_t."]
pub type QueueSetMemberHandle_t = *mut c_types::c_void;
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "BaseType_t xQueueGenericSend("]
    #[doc = "QueueHandle_t xQueue,"]
    #[doc = "const void * pvItemToQueue,"]
    #[doc = "TickType_t xTicksToWait"]
    #[doc = "BaseType_t xCopyPosition"]
    #[doc = ");"]
    #[doc = " </pre>"]
    #[doc = ""]
    #[doc = " It is preferred that the macros xQueueSend(), xQueueSendToFront() and"]
    #[doc = " xQueueSendToBack() are used in place of calling this function directly."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  The item is queued by copy, not by reference."]
    #[doc = " This function must not be called from an interrupt service routine."]
    #[doc = " See xQueueSendFromISR () for an alternative which may be used in an ISR."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for space to become available on the queue, should it already"]
    #[doc = " be full.  The call will return immediately if this is set to 0 and the"]
    #[doc = " queue is full.  The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "struct AMessage"]
    #[doc = "{"]
    #[doc = "char ucMessageID;"]
    #[doc = "char ucData[ 20 ];"]
    #[doc = "} xMessage;"]
    #[doc = ""]
    #[doc = "uint32_t ulVar = 10UL;"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "QueueHandle_t xQueue1, xQueue2;"]
    #[doc = "struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );"]
    #[doc = ""]
    #[doc = "xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( xQueue1 != 0 )"]
    #[doc = "{"]
    #[doc = "if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if( xQueue2 != 0 )"]
    #[doc = "{"]
    #[doc = "pxMessage = & xMessage;"]
    #[doc = "xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueueSend xQueueSend"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: c_types::c_ulong,
        xCopyPosition: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "BaseType_t xQueuePeek("]
    #[doc = "QueueHandle_t xQueue,"]
    #[doc = "void * const pvBuffer,"]
    #[doc = "TickType_t xTicksToWait"]
    #[doc = ");</pre>"]
    #[doc = ""]
    #[doc = " Receive an item from a queue without removing the item from the queue."]
    #[doc = " The item is received by copy so a buffer of adequate size must be"]
    #[doc = " provided.  The number of bytes copied into the buffer was defined when"]
    #[doc = " the queue was created."]
    #[doc = ""]
    #[doc = " Successfully received items remain on the queue so will be returned again"]
    #[doc = " by the next call, or a call to xQueueReceive()."]
    #[doc = ""]
    #[doc = " This macro must not be used in an interrupt service routine.  See"]
    #[doc = " xQueuePeekFromISR() for an alternative that can be called from an interrupt"]
    #[doc = " service routine."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for an item to receive should the queue be empty at the time"]
    #[doc = " of the call.\t The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = " xQueuePeek() will return immediately if xTicksToWait is 0 and the queue"]
    #[doc = " is empty."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "struct AMessage"]
    #[doc = "{"]
    #[doc = "char ucMessageID;"]
    #[doc = "char ucData[ 20 ];"]
    #[doc = "} xMessage;"]
    #[doc = ""]
    #[doc = "QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = "if( xQueue == 0 )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "pxMessage = & xMessage;"]
    #[doc = "xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vADifferentTask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "struct AMessage *pxRxedMessage;"]
    #[doc = ""]
    #[doc = "if( xQueue != 0 )"]
    #[doc = "{"]
    #[doc = "if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueuePeek xQueuePeek"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: c_types::c_ulong,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "BaseType_t xQueuePeekFromISR("]
    #[doc = "QueueHandle_t xQueue,"]
    #[doc = "void *pvBuffer,"]
    #[doc = ");</pre>"]
    #[doc = ""]
    #[doc = " A version of xQueuePeek() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Receive an item from a queue without removing the item from the queue."]
    #[doc = " The item is received by copy so a buffer of adequate size must be"]
    #[doc = " provided.  The number of bytes copied into the buffer was defined when"]
    #[doc = " the queue was created."]
    #[doc = ""]
    #[doc = " Successfully received items remain on the queue so will be returned again"]
    #[doc = " by the next call, or a call to xQueueReceive()."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " \\defgroup xQueuePeekFromISR xQueuePeekFromISR"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "BaseType_t xQueueReceive("]
    #[doc = "QueueHandle_t xQueue,"]
    #[doc = "void *pvBuffer,"]
    #[doc = "TickType_t xTicksToWait"]
    #[doc = ");</pre>"]
    #[doc = ""]
    #[doc = " Receive an item from a queue.  The item is received by copy so a buffer of"]
    #[doc = " adequate size must be provided.  The number of bytes copied into the buffer"]
    #[doc = " was defined when the queue was created."]
    #[doc = ""]
    #[doc = " Successfully received items are removed from the queue."]
    #[doc = ""]
    #[doc = " This function must not be used in an interrupt service routine.  See"]
    #[doc = " xQueueReceiveFromISR for an alternative that can."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for an item to receive should the queue be empty at the time"]
    #[doc = " of the call.\t xQueueReceive() will return immediately if xTicksToWait"]
    #[doc = " is zero and the queue is empty.  The time is defined in tick periods so the"]
    #[doc = " constant portTICK_PERIOD_MS should be used to convert to real time if this is"]
    #[doc = " required."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "struct AMessage"]
    #[doc = "{"]
    #[doc = "char ucMessageID;"]
    #[doc = "char ucData[ 20 ];"]
    #[doc = "} xMessage;"]
    #[doc = ""]
    #[doc = "QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = "if( xQueue == 0 )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "pxMessage = & xMessage;"]
    #[doc = "xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vADifferentTask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "struct AMessage *pxRxedMessage;"]
    #[doc = ""]
    #[doc = "if( xQueue != 0 )"]
    #[doc = "{"]
    #[doc = "if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueueReceive xQueueReceive"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: c_types::c_ulong,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>"]
    #[doc = ""]
    #[doc = " Return the number of messages stored in a queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of messages available in the queue."]
    #[doc = ""]
    #[doc = " \\defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> c_types::c_ulong;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>"]
    #[doc = ""]
    #[doc = " Return the number of free spaces available in a queue.  This is equal to the"]
    #[doc = " number of items that can be sent to the queue before the queue becomes full"]
    #[doc = " if no items are removed."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of spaces available in the queue."]
    #[doc = ""]
    #[doc = " \\defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> c_types::c_ulong;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>"]
    #[doc = ""]
    #[doc = " Delete a queue - freeing all the memory allocated for storing of items"]
    #[doc = " placed on the queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue to be deleted."]
    #[doc = ""]
    #[doc = " \\defgroup vQueueDelete vQueueDelete"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "BaseType_t xQueueGenericSendFromISR("]
    #[doc = "QueueHandle_t\t\txQueue,"]
    #[doc = "const\tvoid\t*pvItemToQueue,"]
    #[doc = "BaseType_t\t*pxHigherPriorityTaskWoken,"]
    #[doc = "BaseType_t\txCopyPosition"]
    #[doc = ");"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " It is preferred that the macros xQueueSendFromISR(),"]
    #[doc = " xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place"]
    #[doc = " of calling this function directly.  xQueueGiveFromISR() is an"]
    #[doc = " equivalent for use by semaphores that don't actually copy any data."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " Items are queued by copy not reference so it is preferable to only"]
    #[doc = " queue small items, especially when called from an ISR.  In most cases"]
    #[doc = " it would be preferable to store a pointer to the item being queued."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task"]
    #[doc = " to unblock, and the unblocked task has a priority higher than the currently"]
    #[doc = " running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then"]
    #[doc = " a context switch should be requested before the interrupt is exited."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the data was successfully sent to the queue, otherwise"]
    #[doc = " errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage for buffered IO (where the ISR can obtain more than one value"]
    #[doc = " per call):"]
    #[doc = "<pre>"]
    #[doc = "void vBufferISR( void )"]
    #[doc = "{"]
    #[doc = "char cIn;"]
    #[doc = "BaseType_t xHigherPriorityTaskWokenByPost;"]
    #[doc = ""]
    #[doc = "xHigherPriorityTaskWokenByPost = pdFALSE;"]
    #[doc = ""]
    #[doc = "do"]
    #[doc = "{"]
    #[doc = "cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );"]
    #[doc = ""]
    #[doc = "xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );"]
    #[doc = ""]
    #[doc = "} while( portINPUT_BYTE( BUFFER_COUNT ) );"]
    #[doc = ""]
    #[doc = "if( xHigherPriorityTaskWokenByPost )"]
    #[doc = "{"]
    #[doc = "taskYIELD_YIELD_FROM_ISR();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " \\defgroup xQueueSendFromISR xQueueSendFromISR"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        pxHigherPriorityTaskWoken: *mut c_types::c_long,
        xCopyPosition: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    #[doc = " queue. h"]
    #[doc = " <pre>"]
    #[doc = "BaseType_t xQueueReceiveFromISR("]
    #[doc = "QueueHandle_t\txQueue,"]
    #[doc = "void\t*pvBuffer,"]
    #[doc = "BaseType_t *pxTaskWoken"]
    #[doc = ");"]
    #[doc = " </pre>"]
    #[doc = ""]
    #[doc = " Receive an item from a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param pxTaskWoken A task may be blocked waiting for space to become"]
    #[doc = " available on the queue.  If xQueueReceiveFromISR causes such a task to"]
    #[doc = " unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will"]
    #[doc = " remain unchanged."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = ""]
    #[doc = "QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "void vAFunction( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "char cValueToPost;"]
    #[doc = "const TickType_t xTicksToWait = ( TickType_t )0xff;"]
    #[doc = ""]
    #[doc = "xQueue = xQueueCreate( 10, sizeof( char ) );"]
    #[doc = "if( xQueue == 0 )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "cValueToPost = 'a';"]
    #[doc = "xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = "cValueToPost = 'b';"]
    #[doc = "xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "cValueToPost = 'c';"]
    #[doc = "xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vISR_Routine( void )"]
    #[doc = "{"]
    #[doc = "BaseType_t xTaskWokenByReceive = pdFALSE;"]
    #[doc = "char cRxedChar;"]
    #[doc = ""]
    #[doc = "while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )"]
    #[doc = "{"]
    #[doc = "vOutputCharacter( cRxedChar );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "if( cTaskWokenByPost != ( char ) pdFALSE;"]
    #[doc = "{"]
    #[doc = "taskYIELD ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xQueueReceiveFromISR xQueueReceiveFromISR"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        pxHigherPriorityTaskWoken: *mut c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> c_types::c_long;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> c_types::c_ulong;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        xCoRoutinePreviouslyWoken: c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        pxTaskWoken: *mut c_types::c_long,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const c_types::c_void,
        xTicksToWait: c_types::c_ulong,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut c_types::c_void,
        xTicksToWait: c_types::c_ulong,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: c_types::c_ulong,
        uxInitialCount: c_types::c_ulong,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: c_types::c_ulong,
        uxInitialCount: c_types::c_ulong,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueSemaphoreTake(
        xQueue: QueueHandle_t,
        xTicksToWait: c_types::c_ulong,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> *mut c_types::c_void;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(
        xMutex: QueueHandle_t,
        xTicksToWait: c_types::c_ulong,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(pxMutex: QueueHandle_t) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: c_types::c_ulong,
        uxItemSize: c_types::c_ulong,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateSet(uxEventQueueLength: c_types::c_ulong) -> QueueSetHandle_t;
}
extern "C" {
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> c_types::c_long;
}
extern "C" {
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: c_types::c_ulong,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: c_types::c_ulong,
        xWaitIndefinitely: c_types::c_long,
    );
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: c_types::c_long)
        -> c_types::c_long;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: c_types::c_ulong);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> c_types::c_ulong;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
#[doc = "< mode: regular UART mode"]
pub const uart_mode_t_UART_MODE_UART: uart_mode_t = 0;
#[doc = " @brief UART mode selection"]
pub type uart_mode_t = c_types::c_uint;
#[doc = "< word length: 5bits"]
pub const uart_word_length_t_UART_DATA_5_BITS: uart_word_length_t = 0;
#[doc = "< word length: 6bits"]
pub const uart_word_length_t_UART_DATA_6_BITS: uart_word_length_t = 1;
#[doc = "< word length: 7bits"]
pub const uart_word_length_t_UART_DATA_7_BITS: uart_word_length_t = 2;
#[doc = "< word length: 8bits"]
pub const uart_word_length_t_UART_DATA_8_BITS: uart_word_length_t = 3;
pub const uart_word_length_t_UART_DATA_BITS_MAX: uart_word_length_t = 4;
#[doc = " @brief UART word length constants"]
pub type uart_word_length_t = c_types::c_uint;
#[doc = "< stop bit: 1bit"]
pub const uart_stop_bits_t_UART_STOP_BITS_1: uart_stop_bits_t = 1;
#[doc = "< stop bit: 1.5bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_1_5: uart_stop_bits_t = 2;
#[doc = "< stop bit: 2bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_2: uart_stop_bits_t = 3;
pub const uart_stop_bits_t_UART_STOP_BITS_MAX: uart_stop_bits_t = 4;
#[doc = " @brief UART stop bits number"]
pub type uart_stop_bits_t = c_types::c_uint;
pub const uart_port_t_UART_NUM_0: uart_port_t = 0;
pub const uart_port_t_UART_NUM_1: uart_port_t = 1;
pub const uart_port_t_UART_NUM_MAX: uart_port_t = 2;
#[doc = " @brief UART peripheral number"]
pub type uart_port_t = c_types::c_uint;
#[doc = "< Disable UART parity"]
pub const uart_parity_t_UART_PARITY_DISABLE: uart_parity_t = 0;
#[doc = "< Enable UART even parity"]
pub const uart_parity_t_UART_PARITY_EVEN: uart_parity_t = 2;
#[doc = "< Enable UART odd parity"]
pub const uart_parity_t_UART_PARITY_ODD: uart_parity_t = 3;
#[doc = " @brief UART parity constants"]
pub type uart_parity_t = c_types::c_uint;
#[doc = "< disable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_DISABLE: uart_hw_flowcontrol_t = 0;
#[doc = "< enable RX hardware flow control (rts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_RTS: uart_hw_flowcontrol_t = 1;
#[doc = "< enable TX hardware flow control (cts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS: uart_hw_flowcontrol_t = 2;
#[doc = "< enable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS_RTS: uart_hw_flowcontrol_t = 3;
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_MAX: uart_hw_flowcontrol_t = 4;
#[doc = " @brief UART hardware flow control modes"]
pub type uart_hw_flowcontrol_t = c_types::c_uint;
#[doc = " @brief UART configuration parameters for uart_param_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_config_t {
    #[doc = "< UART baud rate"]
    pub baud_rate: c_types::c_int,
    #[doc = "< UART byte size"]
    pub data_bits: uart_word_length_t,
    #[doc = "< UART parity mode"]
    pub parity: uart_parity_t,
    #[doc = "< UART stop bits"]
    pub stop_bits: uart_stop_bits_t,
    #[doc = "< UART HW flow control mode (cts/rts)"]
    pub flow_ctrl: uart_hw_flowcontrol_t,
    #[doc = "< UART HW RTS threshold"]
    pub rx_flow_ctrl_thresh: u8,
}
#[doc = " @brief UART interrupt configuration parameters for uart_intr_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_intr_config_t {
    #[doc = "< UART interrupt enable mask, choose from UART_XXXX_INT_ENA_M under UART_INT_ENA_REG(i), connect with bit-or operator"]
    pub intr_enable_mask: u32,
    #[doc = "< UART timeout interrupt threshold (unit: time of sending one byte)"]
    pub rx_timeout_thresh: u8,
    #[doc = "< UART TX empty interrupt threshold."]
    pub txfifo_empty_intr_thresh: u8,
    #[doc = "< UART RX full interrupt threshold."]
    pub rxfifo_full_thresh: u8,
}
#[doc = "< UART data event"]
pub const uart_event_type_t_UART_DATA: uart_event_type_t = 0;
#[doc = "< UART RX buffer full event"]
pub const uart_event_type_t_UART_BUFFER_FULL: uart_event_type_t = 1;
#[doc = "< UART FIFO overflow event"]
pub const uart_event_type_t_UART_FIFO_OVF: uart_event_type_t = 2;
#[doc = "< UART RX frame error event"]
pub const uart_event_type_t_UART_FRAME_ERR: uart_event_type_t = 3;
#[doc = "< UART RX parity event"]
pub const uart_event_type_t_UART_PARITY_ERR: uart_event_type_t = 4;
#[doc = "< UART event max index"]
pub const uart_event_type_t_UART_EVENT_MAX: uart_event_type_t = 5;
#[doc = " @brief UART event types used in the ring buffer"]
pub type uart_event_type_t = c_types::c_uint;
#[doc = " @brief Event structure used in UART event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_event_t {
    #[doc = "< UART event type"]
    pub type_: uart_event_type_t,
    #[doc = "< UART data size for UART_DATA event"]
    pub size: size_t,
}
extern "C" {
    #[doc = " @brief Set UART data bits."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param data_bit Uart data bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_word_length(uart_num: uart_port_t, data_bit: uart_word_length_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART data bits."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param data_bit Pointer to accept value of UART data bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_word_length(
        uart_num: uart_port_t,
        data_bit: *mut uart_word_length_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART stop bits."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number"]
    #[doc = " @param stop_bits Uart stop bits"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_stop_bits(uart_num: uart_port_t, stop_bits: uart_stop_bits_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART stop bits."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param stop_bits Pointer to accept value of UART stop bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_stop_bits(uart_num: uart_port_t, stop_bits: *mut uart_stop_bits_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART parity mode."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param parity_mode The enum of uart parity configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_parity(uart_num: uart_port_t, parity_mode: uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART parity mode."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number"]
    #[doc = " @param parity_mode Pointer to accept value of UART parity mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_parity(uart_num: uart_port_t, parity_mode: *mut uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART baud rate."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number"]
    #[doc = " @param baudrate UART baud rate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_baudrate(uart_num: uart_port_t, baudrate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART baud rate."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param baudrate Pointer to accept value of Uart baud rate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_baudrate(uart_num: uart_port_t, baudrate: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART line inverse mode"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0"]
    #[doc = " @param inverse_mask Choose the wires that need to be inverted."]
    #[doc = "        Inverse_mask should be chosen from"]
    #[doc = "        UART_INVERSE_RXD / UART_INVERSE_TXD / UART_INVERSE_RTS / UART_INVERSE_CTS,"]
    #[doc = "        combined with OR operation."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_line_inverse(uart_num: uart_port_t, inverse_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure Hardware flow control."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param flow_ctrl Hardware flow control mode."]
    #[doc = " @param rx_thresh Threshold of Hardware flow control."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: uart_hw_flowcontrol_t,
        rx_thresh: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get hardware flow control mode"]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param flow_ctrl Option for different flow control mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success, result will be put in (*flow_ctrl)"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: *mut uart_hw_flowcontrol_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  UART0 swap."]
    #[doc = "         Use MTCK as UART0 RX, MTDO as UART0 TX, so ROM log will not output from"]
    #[doc = "         this new UART0. We also need to use MTDO (U0RTS) and MTCK (U0CTS) as UART0 in hardware."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    pub fn uart_enable_swap() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable UART0 swap."]
    #[doc = "         Use the original UART0, not MTCK and MTDO."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    pub fn uart_disable_swap() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear uart interrupts status."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param mask Uart interrupt bits mask."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_clear_intr_status(uart_num: uart_port_t, mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART interrupt enable"]
    #[doc = ""]
    #[doc = " @param uart_num     Uart port number"]
    #[doc = " @param enable_mask  Bit mask of the enable bits."]
    #[doc = "                     The bit mask should be composed from the fields of register UART_INT_ENA_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_enable_intr_mask(uart_num: uart_port_t, enable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt enable bits"]
    #[doc = ""]
    #[doc = " @param uart_num      Uart port number"]
    #[doc = " @param disable_mask  Bit mask of the disable bits."]
    #[doc = "                      The bit mask should be composed from the fields of register UART_INT_ENA_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_disable_intr_mask(uart_num: uart_port_t, disable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_enable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_disable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_disable_tx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0"]
    #[doc = " @param enable  1: enable; 0: disable"]
    #[doc = " @param thresh  Threshold of TX interrupt, 0 ~ UART_FIFO_LEN"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_enable_tx_intr(
        uart_num: uart_port_t,
        enable: c_types::c_int,
        thresh: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register UART interrupt handler (ISR)."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0"]
    #[doc = " @param fn  Interrupt handler function."]
    #[doc = " @param arg parameter for handler function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_isr_register(
        uart_num: uart_port_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut c_types::c_void)>,
        arg: *mut c_types::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Config Common parameters of serial ports."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param uart_conf Uart config parameters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_param_config(uart_num: uart_port_t, uart_conf: *mut uart_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Config types of uarts."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param uart_intr_conf Uart interrupt config parameters."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_intr_config(
        uart_num: uart_port_t,
        uart_intr_conf: *mut uart_intr_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install UART driver."]
    #[doc = ""]
    #[doc = " @note  Rx_buffer_size should be greater than UART_FIFO_LEN. Tx_buffer_size should be either zero or greater than UART_FIFO_LEN."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param rx_buffer_size UART RX ring buffer size."]
    #[doc = " @param tx_buffer_size UART TX ring buffer size."]
    #[doc = "        If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out."]
    #[doc = " @param queue_size UART event queue size/depth."]
    #[doc = " @param uart_queue UART event queue handle (out param). On success, a new queue handle is written here to provide"]
    #[doc = "        access to UART events. If set to NULL, driver will not use an event queue."]
    #[doc = " @param no_use Invalid parameters, just to fit some modules."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_driver_install(
        uart_num: uart_port_t,
        rx_buffer_size: c_types::c_int,
        tx_buffer_size: c_types::c_int,
        queue_size: c_types::c_int,
        uart_queue: *mut QueueHandle_t,
        no_use: c_types::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall UART driver."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_driver_delete(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Waiting for the last byte of data to be sent"]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param ticks_to_wait Timeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_wait_tx_done(uart_num: uart_port_t, ticks_to_wait: c_types::c_ulong) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length."]
    #[doc = ""]
    #[doc = " This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full."]
    #[doc = " @note This function should only be used when UART TX buffer is not enabled."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param buffer data buffer address"]
    #[doc = " @param len    data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1)  Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_tx_chars(
        uart_num: uart_port_t,
        buffer: *const c_types::c_char,
        len: u32,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,"]
    #[doc = ""]
    #[doc = " If the UART driver's parameter 'tx_buffer_size' is set to zero:"]
    #[doc = " This function will not return until all the data have been sent out, or at least pushed into TX FIFO."]
    #[doc = ""]
    #[doc = " Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,"]
    #[doc = " UART ISR will then move data from the ring buffer to TX FIFO gradually."]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param src   data buffer address"]
    #[doc = " @param size  data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes(
        uart_num: uart_port_t,
        src: *const c_types::c_char,
        size: size_t,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief UART read bytes from UART buffer"]
    #[doc = ""]
    #[doc = " @param uart_num Uart port number."]
    #[doc = " @param buf     pointer to the buffer."]
    #[doc = " @param length  data length"]
    #[doc = " @param ticks_to_wait sTimeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Error"]
    #[doc = "     - OTHERS (>=0) The number of bytes read from UART FIFO"]
    pub fn uart_read_bytes(
        uart_num: uart_port_t,
        buf: *mut u8,
        length: u32,
        ticks_to_wait: c_types::c_ulong,
    ) -> c_types::c_int;
}
extern "C" {
    #[doc = " @brief Alias of uart_flush_input."]
    #[doc = "        UART ring buffer flush. This will discard all data in the UART RX buffer."]
    #[doc = " @note  Instead of waiting the data sent out, this function will clear UART rx buffer."]
    #[doc = "        In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART port number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_flush(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear input buffer, discard all the data is in the ring-buffer."]
    #[doc = " @note  In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART port number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_flush_input(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART get RX ring buffer cached data length"]
    #[doc = ""]
    #[doc = " @param   uart_num UART port number."]
    #[doc = " @param   size Pointer of size_t to accept cached data length"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_buffered_data_len(uart_num: uart_port_t, size: *mut size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set threshold timeout for TOUT feature"]
    #[doc = ""]
    #[doc = " @param uart_num     Uart number to configure"]
    #[doc = " @param tout_thresh  This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126."]
    #[doc = "        tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate."]
    #[doc = "        If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0,"]
    #[doc = "        the TOUT feature is disabled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_rx_timeout(uart_num: uart_port_t, tout_thresh: u8) -> esp_err_t;
}
pub const uart_select_notif_t_UART_SELECT_READ_NOTIF: uart_select_notif_t = 0;
pub const uart_select_notif_t_UART_SELECT_WRITE_NOTIF: uart_select_notif_t = 1;
pub const uart_select_notif_t_UART_SELECT_ERROR_NOTIF: uart_select_notif_t = 2;
pub type uart_select_notif_t = c_types::c_uint;
pub type uart_select_notif_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        uart_num: uart_port_t,
        uart_select_notif: uart_select_notif_t,
        task_woken: *mut c_types::c_long,
    ),
>;
extern "C" {
    #[doc = " @brief Set notification callback function for select() events"]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @param uart_select_notif_callback callback function"]
    pub fn uart_set_select_notif_callback(
        uart_num: uart_port_t,
        uart_select_notif_callback: uart_select_notif_callback_t,
    );
}
extern "C" {
    #[doc = " @brief Get mutex guarding select() notifications"]
    pub fn uart_get_selectlock() -> *mut c_types::c_void;
}
pub type __builtin_va_list = __va_list_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub __va_stk: *mut c_types::c_int,
    pub __va_reg: *mut c_types::c_int,
    pub __va_ndx: c_types::c_int,
}
